(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.testing = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 */

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if ("production" !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
},{"./emptyFunction":8}],2:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],3:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],4:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":3}],5:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;
},{"./isTextNode":18}],6:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? "production" !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? "production" !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? "production" !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? "production" !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
},{"./invariant":16}],7:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
},{"./ExecutionEnvironment":2,"./createArrayFromMixed":6,"./getMarkupWrap":12,"./invariant":16}],8:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],9:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyObject = {};

if ("production" !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
},{}],10:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],11:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],12:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? "production" !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
},{"./ExecutionEnvironment":2,"./invariant":16}],13:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],14:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],15:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":14}],16:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if ("production" !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
},{}],17:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],18:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":17}],19:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],20:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":2}],21:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance = require('./performance');

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;
},{"./performance":20}],22:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],23:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
},{"./emptyFunction":8}],24:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],25:[function(require,module,exports){
'use strict';

module.exports = require('./lib/ReactDOM');

},{"./lib/ReactDOM":55}],26:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;
},{}],27:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var focusNode = require('fbjs/lib/focusNode');

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;
},{"./ReactDOMComponentTree":58,"fbjs/lib/focusNode":10}],28:[function(require,module,exports){
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventPropagators":44,"./FallbackCompositionState":45,"./SyntheticCompositionEvent":109,"./SyntheticInputEvent":113,"fbjs/lib/ExecutionEnvironment":2}],29:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],30:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInstrumentation = require('./ReactInstrumentation');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if ("production" !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "production" !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "production" !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    "production" !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    "production" !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if ("production" !== 'production') {
        warnValidStyle(styleName, styleValue, component);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if ("production" !== 'production') {
        warnValidStyle(styleName, styles[styleName], component);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
},{"./CSSProperty":29,"./ReactInstrumentation":87,"./dangerousStyleValue":126,"fbjs/lib/ExecutionEnvironment":2,"fbjs/lib/camelizeStyleName":4,"fbjs/lib/hyphenateStyleName":15,"fbjs/lib/memoizeStringOnly":19,"fbjs/lib/warning":23}],31:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PooledClass = require('./PooledClass');

var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */


  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */


  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? "production" !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */


  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
},{"./PooledClass":49,"./reactProdInvariant":145,"fbjs/lib/invariant":16}],32:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}
function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  // IE10+ fire input events to often, such when a placeholder
  // changes or when an input with a placeholder is focused.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
}

/**
 * (For IE <=11) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For IE <=11) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  if (activeElement.attachEvent) {
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.addEventListener('propertychange', handlePropertyChange, false);
  }
}

/**
 * (For IE <=11) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;

  if (activeElement.detachEvent) {
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
  }

  activeElement = null;
  activeElementInst = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For IE <=11) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetInstForInputEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput') {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return targetInst;
  }
}

function handleEventsForInputEventIE(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9-11, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventIE(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementInst;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return targetInst;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventPluginHub":41,"./EventPropagators":44,"./ReactDOMComponentTree":58,"./ReactUpdates":102,"./SyntheticEvent":111,"./getEventTarget":134,"./isEventSupported":142,"./isTextInputElement":143,"fbjs/lib/ExecutionEnvironment":2}],33:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMLazyTree = require('./DOMLazyTree');
var Danger = require('./Danger');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if ("production" !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    if ("production" !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: { toIndex: update.toIndex, content: update.content.toString() }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
},{"./DOMLazyTree":34,"./Danger":38,"./ReactDOMComponentTree":58,"./ReactInstrumentation":87,"./createMicrosoftUnsafeLocalFunction":125,"./setInnerHTML":147,"./setTextContent":148}],34:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMNamespaces = require('./DOMNamespaces');
var setInnerHTML = require('./setInnerHTML');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setTextContent = require('./setTextContent');

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;
},{"./DOMNamespaces":35,"./createMicrosoftUnsafeLocalFunction":125,"./setInnerHTML":147,"./setTextContent":148}],35:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;
},{}],36:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? "production" !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? "production" !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

      if ("production" !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if ("production" !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: "production" !== 'production' ? { autofocus: 'autoFocus' } : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],37:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  "production" !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if ("production" !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if ("production" !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }

};

module.exports = DOMPropertyOperations;
},{"./DOMProperty":36,"./ReactDOMComponentTree":58,"./ReactInstrumentation":87,"./quoteAttributeValueForBrowser":144,"fbjs/lib/warning":23}],38:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');

var Danger = {

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
    !markup ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }

};

module.exports = Danger;
},{"./DOMLazyTree":34,"./reactProdInvariant":145,"fbjs/lib/ExecutionEnvironment":2,"fbjs/lib/createNodesFromMarkup":7,"fbjs/lib/emptyFunction":8,"fbjs/lib/invariant":16}],39:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;
},{}],40:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventPropagators":44,"./ReactDOMComponentTree":58,"./SyntheticMouseEvent":115}],41:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? "production" !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? "production" !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
},{"./EventPluginRegistry":42,"./EventPluginUtils":43,"./ReactErrorUtils":78,"./accumulateInto":122,"./forEachAccumulated":130,"./reactProdInvariant":145,"fbjs/lib/invariant":16}],42:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if ("production" !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: "production" !== 'production' ? {} : null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if ("production" !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }

};

module.exports = EventPluginRegistry;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],43:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
if ("production" !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    "production" !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? "production" !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
},{"./ReactErrorUtils":78,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23}],44:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var warning = require('fbjs/lib/warning');

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
},{"./EventPluginHub":41,"./EventPluginUtils":43,"./accumulateInto":122,"./forEachAccumulated":130,"fbjs/lib/warning":23}],45:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./PooledClass":49,"./getTextContentAccessor":139,"object-assign":24}],46:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {}
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":36}],47:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;
},{}],48:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var React = require('react/lib/React');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: React.PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        "production" !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
},{"./ReactPropTypesSecret":95,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"react/lib/React":154}],49:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? "production" !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],50:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ViewportMetrics = require('./ViewportMetrics');

var getVendorPrefixedEventName = require('./getVendorPrefixedEventName');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;
},{"./EventPluginRegistry":42,"./ReactEventEmitterMixin":79,"./ViewportMetrics":121,"./getVendorPrefixedEventName":140,"./isEventSupported":142,"object-assign":24}],51:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if ("production" !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    }
    if (!keyUnique) {
      "production" !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
  ) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    if ("production" !== 'production') {
      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
  ) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }

};

module.exports = ReactChildReconciler;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":47,"./ReactReconciler":97,"./instantiateReactComponent":141,"./shouldUpdateReactComponent":149,"./traverseAllChildren":150,"_process":213,"fbjs/lib/warning":23,"react/lib/ReactComponentTreeHook":158}],52:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

};

module.exports = ReactComponentBrowserEnvironment;
},{"./DOMChildrenOperations":33,"./ReactDOMIDOperations":62}],53:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? "production" !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],54:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var React = require('react/lib/React');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactErrorUtils = require('./ReactErrorUtils');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactNodeTypes = require('./ReactNodeTypes');
var ReactReconciler = require('./ReactReconciler');

if ("production" !== 'production') {
  var checkReactTypeSpec = require('./checkReactTypeSpec');
}

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shallowEqual = require('fbjs/lib/shallowEqual');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    "production" !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    if ("production" !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? "production" !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    if ("production" !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        "production" !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      "production" !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if ("production" !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      "production" !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "production" !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if ("production" !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    if ("production" !== 'production') {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      if ("production" !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    if ("production" !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    if ("production" !== 'production') {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    if ("production" !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if ("production" !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if ("production" !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if ("production" !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {
    if ("production" !== 'production') {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? "production" !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if ("production" !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if ("production" !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    if ("production" !== 'production') {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      if ("production" !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    if ("production" !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }

    if ("production" !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if ("production" !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? "production" !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? "production" !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if ("production" !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      "production" !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

module.exports = ReactCompositeComponent;
},{"./ReactComponentEnvironment":53,"./ReactErrorUtils":78,"./ReactInstanceMap":86,"./ReactInstrumentation":87,"./ReactNodeTypes":92,"./ReactReconciler":97,"./checkReactTypeSpec":124,"./reactProdInvariant":145,"./shouldUpdateReactComponent":149,"fbjs/lib/emptyObject":9,"fbjs/lib/invariant":16,"fbjs/lib/shallowEqual":22,"fbjs/lib/warning":23,"object-assign":24,"react/lib/React":154,"react/lib/ReactCurrentOwner":159}],55:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactMount = require('./ReactMount');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if ("production" !== 'production') {
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    "production" !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    "production" !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        "production" !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

if ("production" !== 'production') {
  var ReactInstrumentation = require('./ReactInstrumentation');
  var ReactDOMUnknownPropertyHook = require('./ReactDOMUnknownPropertyHook');
  var ReactDOMNullInputValuePropHook = require('./ReactDOMNullInputValuePropHook');
  var ReactDOMInvalidARIAHook = require('./ReactDOMInvalidARIAHook');

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

module.exports = ReactDOM;
},{"./ReactDOMComponentTree":58,"./ReactDOMInvalidARIAHook":64,"./ReactDOMNullInputValuePropHook":65,"./ReactDOMUnknownPropertyHook":72,"./ReactDefaultInjection":75,"./ReactInstrumentation":87,"./ReactMount":90,"./ReactReconciler":97,"./ReactUpdates":102,"./ReactVersion":103,"./findDOMNode":128,"./getHostComponentFromComposite":135,"./renderSubtreeIntoContainer":146,"fbjs/lib/ExecutionEnvironment":2,"fbjs/lib/warning":23}],56:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* global hasOwnProperty:true */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMLazyTree = require('./DOMLazyTree');
var DOMNamespaces = require('./DOMNamespaces');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMultiChild = require('./ReactMultiChild');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');

var emptyFunction = require('fbjs/lib/emptyFunction');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var shallowEqual = require('fbjs/lib/shallowEqual');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  "production" !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? "production" !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? "production" !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
  }
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    "production" !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    "production" !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? "production" !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if ("production" !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    "production" !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;
if ("production" !== 'production') {
  setAndValidateContentChildDev = function (content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? "production" !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? "production" !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? "production" !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if ("production" !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if ("production" !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if ("production" !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if ("production" !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      // TODO: Validate that text is allowed as a child of this node
      if (contentToUse != null) {
        // Avoid setting textContent when the text is empty. In IE11 setting
        // textContent on a text area will cause the placeholder to not
        // show within the textarea until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        if (contentToUse !== '') {
          if ("production" !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if ("production" !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if ("production" !== 'production') {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if ("production" !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? "production" !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    if ("production" !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }

};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
},{"./AutoFocusUtils":27,"./CSSPropertyOperations":30,"./DOMLazyTree":34,"./DOMNamespaces":35,"./DOMProperty":36,"./DOMPropertyOperations":37,"./EventPluginHub":41,"./EventPluginRegistry":42,"./ReactBrowserEventEmitter":50,"./ReactDOMComponentFlags":57,"./ReactDOMComponentTree":58,"./ReactDOMInput":63,"./ReactDOMOption":66,"./ReactDOMSelect":67,"./ReactDOMTextarea":70,"./ReactInstrumentation":87,"./ReactMultiChild":91,"./ReactServerRenderingTransaction":99,"./escapeTextContentForBrowser":127,"./isEventSupported":142,"./reactProdInvariant":145,"./validateDOMNesting":151,"fbjs/lib/emptyFunction":8,"fbjs/lib/invariant":16,"fbjs/lib/shallowEqual":22,"fbjs/lib/warning":23,"object-assign":24}],57:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;
},{}],58:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');

var invariant = require('fbjs/lib/invariant');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Check if a given node should be cached.
 */
function shouldPrecacheNode(node, nodeID) {
  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
}

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    !false ? "production" !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? "production" !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
},{"./DOMProperty":36,"./ReactDOMComponentFlags":57,"./reactProdInvariant":145,"fbjs/lib/invariant":16}],59:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var validateDOMNesting = require('./validateDOMNesting');

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if ("production" !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
},{"./validateDOMNesting":151}],60:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;
},{"./DOMLazyTree":34,"./ReactDOMComponentTree":58,"object-assign":24}],61:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;
},{}],62:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;
},{"./DOMChildrenOperations":33,"./ReactDOMComponentTree":58}],63:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMPropertyOperations = require('./DOMPropertyOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        "production" !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        "production" !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        "production" !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        "production" !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };

    if ("production" !== 'production') {
      inst._wrapperState.controlled = isControlled(props);
    }
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if ("production" !== 'production') {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        "production" !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        "production" !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {

      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? "production" !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
},{"./DOMPropertyOperations":37,"./LinkedValueUtils":48,"./ReactDOMComponentTree":58,"./ReactUpdates":102,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"object-assign":24}],64:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty(tagName, name, debugID) {
  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      "production" !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    "production" !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (invalidProps.length > 1) {
    "production" !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
}

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook = {
  onBeforeMountComponent: function (debugID, element) {
    if ("production" !== 'production') {
      handleElement(debugID, element);
    }
  },
  onBeforeUpdateComponent: function (debugID, element) {
    if ("production" !== 'production') {
      handleElement(debugID, element);
    }
  }
};

module.exports = ReactDOMInvalidARIAHook;
},{"./DOMProperty":36,"fbjs/lib/warning":23,"react/lib/ReactComponentTreeHook":158}],65:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

var didWarnValueNull = false;

function handleElement(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    "production" !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMNullInputValuePropHook;
},{"fbjs/lib/warning":23,"react/lib/ReactComponentTreeHook":158}],66:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var React = require('react/lib/React');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMSelect = require('./ReactDOMSelect');

var warning = require('fbjs/lib/warning');
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      "production" !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }

};

module.exports = ReactDOMOption;
},{"./ReactDOMComponentTree":58,"./ReactDOMSelect":67,"fbjs/lib/warning":23,"object-assign":24,"react/lib/React":154}],67:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    "production" !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      "production" !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else if (!props.multiple && isArray) {
      "production" !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function (inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      "production" !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
},{"./LinkedValueUtils":48,"./ReactDOMComponentTree":58,"./ReactUpdates":102,"fbjs/lib/warning":23,"object-assign":24}],68:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./getNodeForCharacterOffset":138,"./getTextContentAccessor":139,"fbjs/lib/ExecutionEnvironment":2}],69:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    if ("production" !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? "production" !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }

});

module.exports = ReactDOMTextComponent;
},{"./DOMChildrenOperations":33,"./DOMLazyTree":34,"./ReactDOMComponentTree":58,"./escapeTextContentForBrowser":127,"./reactProdInvariant":145,"./validateDOMNesting":151,"fbjs/lib/invariant":16,"object-assign":24}],70:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        "production" !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        "production" !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        if ("production" !== 'production') {
          "production" !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
        }
        !(defaultValue == null) ? "production" !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? "production" !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === inst._wrapperState.initialValue) {
      node.value = textContent;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
},{"./LinkedValueUtils":48,"./ReactDOMComponentTree":58,"./ReactUpdates":102,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"object-assign":24}],71:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? "production" !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],72:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

if ("production" !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function (tagName, name, debugID) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      "production" !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else if (registrationName != null) {
      "production" !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function (debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    "production" !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (unknownProps.length > 1) {
    "production" !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMUnknownPropertyHook;
},{"./DOMProperty":36,"./EventPluginRegistry":42,"fbjs/lib/warning":23,"react/lib/ReactComponentTreeHook":158}],73:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactInvalidSetStateWarningHook = require('./ReactInvalidSetStateWarningHook');
var ReactHostOperationHistoryHook = require('./ReactHostOperationHistoryHook');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var performanceNow = require('fbjs/lib/performanceNow');
var warning = require('fbjs/lib/warning');

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    "production" !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var parentID = ReactComponentTreeHook.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook.getDisplayName(id),
      text: ReactComponentTreeHook.getText(id),
      updateCount: ReactComponentTreeHook.getUpdateCount(id),
      childIDs: ReactComponentTreeHook.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    "production" !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    "production" !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    "production" !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure =
// $FlowFixMe https://github.com/facebook/flow/issues/2345
typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  performance.clearMeasures(measurementName);
}

var ReactDebugTool = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }

    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }

    isProfiling = false;
    resetMeasurements();
    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool.beginProfiling();
}

module.exports = ReactDebugTool;
},{"./ReactHostOperationHistoryHook":83,"./ReactInvalidSetStateWarningHook":88,"fbjs/lib/ExecutionEnvironment":2,"fbjs/lib/performanceNow":21,"fbjs/lib/warning":23,"react/lib/ReactComponentTreeHook":158}],74:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./ReactUpdates":102,"./Transaction":120,"fbjs/lib/emptyFunction":8,"object-assign":24}],75:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ARIADOMPropertyConfig = require('./ARIADOMPropertyConfig');
var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMEmptyComponent = require('./ReactDOMEmptyComponent');
var ReactDOMTreeTraversal = require('./ReactDOMTreeTraversal');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');
var SelectEventPlugin = require('./SelectEventPlugin');
var SimpleEventPlugin = require('./SimpleEventPlugin');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};
},{"./ARIADOMPropertyConfig":26,"./BeforeInputEventPlugin":28,"./ChangeEventPlugin":32,"./DefaultEventPluginOrder":39,"./EnterLeaveEventPlugin":40,"./HTMLDOMPropertyConfig":46,"./ReactComponentBrowserEnvironment":52,"./ReactDOMComponent":56,"./ReactDOMComponentTree":58,"./ReactDOMEmptyComponent":60,"./ReactDOMTextComponent":69,"./ReactDOMTreeTraversal":71,"./ReactDefaultBatchingStrategy":74,"./ReactEventListener":80,"./ReactInjection":84,"./ReactReconcileTransaction":96,"./SVGDOMPropertyConfig":104,"./SelectEventPlugin":105,"./SimpleEventPlugin":106}],76:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;
},{}],77:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{}],78:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if ("production" !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      // $FlowFixMe https://github.com/facebook/flow/issues/2336
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
},{}],79:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":41}],80:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./PooledClass":49,"./ReactDOMComponentTree":58,"./ReactUpdates":102,"./getEventTarget":134,"fbjs/lib/EventListener":1,"fbjs/lib/ExecutionEnvironment":2,"fbjs/lib/getUnboundedScrollPosition":13,"object-assign":24}],81:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;
},{}],82:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var genericComponentClass = null;
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? "production" !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],83:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var history = [];

var ReactHostOperationHistoryHook = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

module.exports = ReactHostOperationHistoryHook;
},{}],84:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactHostComponent = require('./ReactHostComponent');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":36,"./EventPluginHub":41,"./EventPluginUtils":43,"./ReactBrowserEventEmitter":50,"./ReactComponentEnvironment":53,"./ReactEmptyComponent":77,"./ReactHostComponent":82,"./ReactUpdates":102}],85:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":68,"fbjs/lib/containsNode":5,"fbjs/lib/focusNode":10,"fbjs/lib/getActiveElement":11}],86:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],87:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

if ("production" !== 'production') {
  var ReactDebugTool = require('./ReactDebugTool');
  debugTool = ReactDebugTool;
}

module.exports = { debugTool: debugTool };
},{"./ReactDebugTool":73}],88:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var warning = require('fbjs/lib/warning');

if ("production" !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    "production" !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningHook = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningHook;
},{"fbjs/lib/warning":23}],89:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":123}],90:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var DOMProperty = require('./DOMProperty');
var React = require('react/lib/React');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMContainerInfo = require('./ReactDOMContainerInfo');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }
  ReactReconciler.unmountComponent(instance, safely);
  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if ("production" !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? "production" !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? "production" !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    "production" !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            "production" !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if ("production" !== 'production') {
        "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if ("production" !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

        if ("production" !== 'production') {
          "production" !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if ("production" !== 'production') {
      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

module.exports = ReactMount;
},{"./DOMLazyTree":34,"./DOMProperty":36,"./ReactBrowserEventEmitter":50,"./ReactDOMComponentTree":58,"./ReactDOMContainerInfo":59,"./ReactDOMFeatureFlags":61,"./ReactFeatureFlags":81,"./ReactInstanceMap":86,"./ReactInstrumentation":87,"./ReactMarkupChecksum":89,"./ReactReconciler":97,"./ReactUpdateQueue":101,"./ReactUpdates":102,"./instantiateReactComponent":141,"./reactProdInvariant":145,"./setInnerHTML":147,"./shouldUpdateReactComponent":149,"fbjs/lib/emptyObject":9,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"react/lib/React":154,"react/lib/ReactCurrentOwner":159}],91:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var emptyFunction = require('fbjs/lib/emptyFunction');
var flattenChildren = require('./flattenChildren');
var invariant = require('fbjs/lib/invariant');

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if ("production" !== 'production') {
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if ("production" !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if ("production" !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if ("production" !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if ("production" !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if ("production" !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};

module.exports = ReactMultiChild;
},{"./ReactChildReconciler":51,"./ReactComponentEnvironment":53,"./ReactInstanceMap":86,"./ReactInstrumentation":87,"./ReactReconciler":97,"./flattenChildren":129,"./reactProdInvariant":145,"fbjs/lib/emptyFunction":8,"fbjs/lib/invariant":16,"react/lib/ReactCurrentOwner":159}],92:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var React = require('react/lib/React');

var invariant = require('fbjs/lib/invariant');

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
    !false ? "production" !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
  }
};

module.exports = ReactNodeTypes;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16,"react/lib/React":154}],93:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],94:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactPropTypeLocationNames = {};

if ("production" !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
},{}],95:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;
},{}],96:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactInputSelection = require('./ReactInputSelection');
var ReactInstrumentation = require('./ReactInstrumentation');
var Transaction = require('./Transaction');
var ReactUpdateQueue = require('./ReactUpdateQueue');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

if ("production" !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":31,"./PooledClass":49,"./ReactBrowserEventEmitter":50,"./ReactInputSelection":85,"./ReactInstrumentation":87,"./ReactUpdateQueue":101,"./Transaction":120,"object-assign":24}],97:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactRef = require('./ReactRef');
var ReactInstrumentation = require('./ReactInstrumentation');

var warning = require('fbjs/lib/warning');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
  ) {
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      "production" !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }

};

module.exports = ReactReconciler;
},{"./ReactInstrumentation":87,"./ReactRef":98,"fbjs/lib/warning":23}],98:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":93}],99:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');
var Transaction = require('./Transaction');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactServerUpdateQueue = require('./ReactServerUpdateQueue');

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

if ("production" !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./PooledClass":49,"./ReactInstrumentation":87,"./ReactServerUpdateQueue":100,"./Transaction":120,"object-assign":24}],100:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactUpdateQueue = require('./ReactUpdateQueue');

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {
  if ("production" !== 'production') {
    var constructor = publicInstance.constructor;
    "production" !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */


  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
},{"./ReactUpdateQueue":101,"fbjs/lib/warning":23}],101:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if ("production" !== 'production') {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      "production" !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }

  if ("production" !== 'production') {
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if ("production" !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onSetState();
      "production" !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? "production" !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }

};

module.exports = ReactUpdateQueue;
},{"./ReactInstanceMap":86,"./ReactInstrumentation":87,"./ReactUpdates":102,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"react/lib/ReactCurrentOwner":159}],102:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? "production" !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? "production" !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
},{"./CallbackQueue":31,"./PooledClass":49,"./ReactFeatureFlags":81,"./ReactReconciler":97,"./Transaction":120,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"object-assign":24}],103:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

module.exports = '15.4.2';
},{}],104:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;
},{}],105:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var shallowEqual = require('fbjs/lib/shallowEqual');

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventPropagators":44,"./ReactDOMComponentTree":58,"./ReactInputSelection":85,"./SyntheticEvent":111,"./isTextInputElement":143,"fbjs/lib/ExecutionEnvironment":2,"fbjs/lib/getActiveElement":11,"fbjs/lib/shallowEqual":22}],106:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticAnimationEvent = require('./SyntheticAnimationEvent');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticTransitionEvent = require('./SyntheticTransitionEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? "production" !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }

};

module.exports = SimpleEventPlugin;
},{"./EventPropagators":44,"./ReactDOMComponentTree":58,"./SyntheticAnimationEvent":107,"./SyntheticClipboardEvent":108,"./SyntheticDragEvent":110,"./SyntheticEvent":111,"./SyntheticFocusEvent":112,"./SyntheticKeyboardEvent":114,"./SyntheticMouseEvent":115,"./SyntheticTouchEvent":116,"./SyntheticTransitionEvent":117,"./SyntheticUIEvent":118,"./SyntheticWheelEvent":119,"./getEventCharCode":131,"./reactProdInvariant":145,"fbjs/lib/EventListener":1,"fbjs/lib/emptyFunction":8,"fbjs/lib/invariant":16}],107:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;
},{"./SyntheticEvent":111}],108:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":111}],109:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":111}],110:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":115}],111:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if ("production" !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if ("production" !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      // eslint-disable-line valid-typeof
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // eslint-disable-line valid-typeof
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if ("production" !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if ("production" !== 'production') {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }

});

SyntheticEvent.Interface = EventInterface;

if ("production" !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              "production" !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    "production" !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
},{"./PooledClass":49,"fbjs/lib/emptyFunction":8,"fbjs/lib/warning":23,"object-assign":24}],112:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":118}],113:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":111}],114:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":118,"./getEventCharCode":131,"./getEventKey":132,"./getEventModifierState":133}],115:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":118,"./ViewportMetrics":121,"./getEventModifierState":133}],116:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":118,"./getEventModifierState":133}],117:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;
},{"./SyntheticEvent":111}],118:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":111,"./getEventTarget":134}],119:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":115}],120:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],121:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],122:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? "production" !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
},{"./reactProdInvariant":145,"fbjs/lib/invariant":16}],123:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],124:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? "production" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      "production" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if ("production" !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        "production" !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
}).call(this,require('_process'))

},{"./ReactPropTypeLocationNames":94,"./ReactPropTypesSecret":95,"./reactProdInvariant":145,"_process":213,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"react/lib/ReactComponentTreeHook":158}],125:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */

'use strict';

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;
},{}],126:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var warning = require('fbjs/lib/warning');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if ("production" !== 'production') {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          "production" !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":29,"fbjs/lib/warning":23}],127:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

'use strict';

// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html


/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;
},{}],128:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstanceMap = require('./ReactInstanceMap');

var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if ("production" !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
    !false ? "production" !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
  } else {
    !false ? "production" !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}

module.exports = findDOMNode;
},{"./ReactDOMComponentTree":58,"./ReactInstanceMap":86,"./getHostComponentFromComposite":135,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"react/lib/ReactCurrentOwner":159}],129:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var KeyEscapeUtils = require('./KeyEscapeUtils');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if ("production" !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
      }
      if (!keyUnique) {
        "production" !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  if ("production" !== 'production') {
    traverseAllChildren(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":47,"./traverseAllChildren":150,"_process":213,"fbjs/lib/warning":23,"react/lib/ReactComponentTreeHook":158}],130:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;
},{}],131:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],132:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":131}],133:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],134:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],135:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactNodeTypes = require('./ReactNodeTypes');

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;
},{"./ReactNodeTypes":92}],136:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],137:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;
},{}],138:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],139:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"fbjs/lib/ExecutionEnvironment":2}],140:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;
},{"fbjs/lib/ExecutionEnvironment":2}],141:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactHostComponent = require('./ReactHostComponent');

var getNextDebugID = require('./getNextDebugID');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};
_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if ("production" !== 'production') {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
      }
      info += getDeclarationErrorAddendum(element._owner);
      !false ? "production" !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
    !false ? "production" !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
  }

  if ("production" !== 'production') {
    "production" !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if ("production" !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if ("production" !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
},{"./ReactCompositeComponent":54,"./ReactEmptyComponent":77,"./ReactHostComponent":82,"./getNextDebugID":137,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"object-assign":24}],142:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"fbjs/lib/ExecutionEnvironment":2}],143:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;
},{}],144:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":127}],145:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */
'use strict';

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;
},{}],146:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":90}],147:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var DOMNamespaces = require('./DOMNamespaces');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;
},{"./DOMNamespaces":35,"./createMicrosoftUnsafeLocalFunction":125,"fbjs/lib/ExecutionEnvironment":2}],148:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./escapeTextContentForBrowser":127,"./setInnerHTML":147,"fbjs/lib/ExecutionEnvironment":2}],149:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;
},{}],150:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ("production" !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if ("production" !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? "production" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":47,"./ReactElementSymbol":76,"./getIteratorFn":136,"./reactProdInvariant":145,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"react/lib/ReactCurrentOwner":159}],151:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

if ("production" !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      "production" !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
      } else {
        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
},{"fbjs/lib/emptyFunction":8,"fbjs/lib/warning":23,"object-assign":24}],152:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47}],153:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"./reactProdInvariant":174,"dup":49,"fbjs/lib/invariant":16}],154:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactPureComponent = require('./ReactPureComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var onlyChild = require('./onlyChild');
var warning = require('fbjs/lib/warning');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if ("production" !== 'production') {
  var ReactElementValidator = require('./ReactElementValidator');
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if ("production" !== 'production') {
  var warned = false;
  __spread = function () {
    "production" !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

module.exports = React;
},{"./ReactChildren":155,"./ReactClass":156,"./ReactComponent":157,"./ReactDOMFactories":160,"./ReactElement":161,"./ReactElementValidator":163,"./ReactPropTypes":166,"./ReactPureComponent":168,"./ReactVersion":169,"./onlyChild":173,"fbjs/lib/warning":23,"object-assign":24}],155:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":153,"./ReactElement":161,"./traverseAllChildren":175,"fbjs/lib/emptyFunction":8}],156:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if ("production" !== 'production') {
      validateTypeDef(Constructor, childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if ("production" !== 'production') {
      validateTypeDef(Constructor, contextTypes, 'context');
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if ("production" !== 'production') {
      validateTypeDef(Constructor, propTypes, 'prop');
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      "production" !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? "production" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? "production" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if ("production" !== 'production') {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      "production" !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }

    return;
  }

  !(typeof spec !== 'function') ? "production" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? "production" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? "production" !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ("production" !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? "production" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? "production" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? "production" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? "production" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if ("production" !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        "production" !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        "production" !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if ("production" !== 'production') {
        "production" !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if ("production" !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "production" !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if ("production" !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? "production" !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      "production" !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
},{"./ReactComponent":157,"./ReactElement":161,"./ReactNoopUpdateQueue":164,"./ReactPropTypeLocationNames":165,"./reactProdInvariant":174,"fbjs/lib/emptyObject":9,"fbjs/lib/invariant":16,"fbjs/lib/warning":23,"object-assign":24}],157:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? "production" !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if ("production" !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          "production" !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
},{"./ReactNoopUpdateQueue":164,"./canDefineProperty":170,"./reactProdInvariant":174,"fbjs/lib/emptyObject":9,"fbjs/lib/invariant":16,"fbjs/lib/warning":23}],158:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  "production" !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? "production" !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? "production" !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? "production" !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? "production" !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? "production" !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? "production" !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

module.exports = ReactComponentTreeHook;
},{"./ReactCurrentOwner":159,"./reactProdInvariant":174,"fbjs/lib/invariant":16,"fbjs/lib/warning":23}],159:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],160:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactElement = require('./ReactElement');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if ("production" !== 'production') {
  var ReactElementValidator = require('./ReactElementValidator');
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
},{"./ReactElement":161,"./ReactElementValidator":163}],161:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var warning = require('fbjs/lib/warning');
var canDefineProperty = require('./canDefineProperty');
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if ("production" !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if ("production" !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      "production" !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      "production" !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if ("production" !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if ("production" !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if ("production" !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
},{"./ReactCurrentOwner":159,"./ReactElementSymbol":162,"./canDefineProperty":170,"fbjs/lib/warning":23,"object-assign":24}],162:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],163:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactComponentTreeHook = require('./ReactComponentTreeHook');
var ReactElement = require('./ReactElement');

var checkReactTypeSpec = require('./checkReactTypeSpec');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  "production" !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    "production" !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
        info += getDeclarationErrorAddendum();
        "production" !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if ("production" !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            "production" !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
},{"./ReactComponentTreeHook":158,"./ReactCurrentOwner":159,"./ReactElement":161,"./canDefineProperty":170,"./checkReactTypeSpec":171,"./getIteratorFn":172,"fbjs/lib/warning":23}],164:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {
  if ("production" !== 'production') {
    var constructor = publicInstance.constructor;
    "production" !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
},{"fbjs/lib/warning":23}],165:[function(require,module,exports){
arguments[4][94][0].apply(exports,arguments)
},{"dup":94}],166:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),
  symbol: createPrimitiveTypeChecker('symbol'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
/*eslint-disable no-self-compare*/
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/*eslint-enable no-self-compare*/

/**
 * We use an Error-like object for backward compatibility as people may call
 * PropTypes directly and inspect their output. However we don't use real
 * Errors anymore. We don't inspect their stack anyway, and creating them
 * is prohibitively expensive if they are created too often, such as what
 * happens in oneOfType() for any type before the one that matched.
 */
function PropTypeError(message) {
  this.message = message;
  this.stack = '';
}
// Make `instanceof Error` still work for returned errors.
PropTypeError.prototype = Error.prototype;

function createChainableTypeChecker(validate) {
  if ("production" !== 'production') {
    var manualPropTypeCallCache = {};
  }
  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if ("production" !== 'production') {
      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
        var cacheKey = componentName + ':' + propName;
        if (!manualPropTypeCallCache[cacheKey]) {
          "production" !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
          manualPropTypeCallCache[cacheKey] = true;
        }
      }
    }
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        if (props[propName] === null) {
          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
        }
        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName, secret) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!ReactElement.isValidElement(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

function isSymbol(propType, propValue) {
  // Native Symbol.
  if (propType === 'symbol') {
    return true;
  }

  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
  if (propValue['@@toStringTag'] === 'Symbol') {
    return true;
  }

  // Fallback for non-spec compliant Symbols which are polyfilled.
  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    return true;
  }

  return false;
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  if (isSymbol(propType, propValue)) {
    return 'symbol';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
},{"./ReactElement":161,"./ReactPropTypeLocationNames":165,"./ReactPropTypesSecret":167,"./getIteratorFn":172,"fbjs/lib/emptyFunction":8,"fbjs/lib/warning":23}],167:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"dup":95}],168:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;
},{"./ReactComponent":157,"./ReactNoopUpdateQueue":164,"fbjs/lib/emptyObject":9,"object-assign":24}],169:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"dup":103}],170:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var canDefineProperty = false;
if ("production" !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
},{}],171:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('./ReactComponentTreeHook');
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? "production" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      "production" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if ("production" !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require('./ReactComponentTreeHook');
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        "production" !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
}).call(this,require('_process'))

},{"./ReactComponentTreeHook":158,"./ReactPropTypeLocationNames":165,"./ReactPropTypesSecret":167,"./reactProdInvariant":174,"_process":213,"fbjs/lib/invariant":16,"fbjs/lib/warning":23}],172:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"dup":136}],173:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? "production" !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
},{"./ReactElement":161,"./reactProdInvariant":174,"fbjs/lib/invariant":16}],174:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"dup":145}],175:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ("production" !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if ("production" !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? "production" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":152,"./ReactCurrentOwner":159,"./ReactElementSymbol":162,"./getIteratorFn":172,"./reactProdInvariant":174,"fbjs/lib/invariant":16,"fbjs/lib/warning":23}],176:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":154}],177:[function(require,module,exports){
/*!
 * XRegExp.build 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2012-2016 MIT License
 * Inspired by Lea Verou's RegExp.create <lea.verou.me>
 */

module.exports = function(XRegExp) {
    'use strict';

    var REGEX_DATA = 'xregexp';
    var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g;
    var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g');

    /**
     * Strips a leading `^` and trailing unescaped `$`, if both are present.
     *
     * @param {String} pattern Pattern to process.
     * @returns {String} Pattern with edge anchors removed.
     */
    function deanchor(pattern) {
        // Allow any number of empty noncapturing groups before/after anchors, because regexes
        // built/generated by XRegExp sometimes include them
        var leadingAnchor = /^(?:\(\?:\))*\^/,
            trailingAnchor = /\$(?:\(\?:\))*$/;

        if (
            leadingAnchor.test(pattern) &&
            trailingAnchor.test(pattern) &&
            // Ensure that the trailing `$` isn't escaped
            trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))
        ) {
            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
        }

        return pattern;
    }

    /**
     * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
     *
     * @param {String|RegExp} value Value to convert.
     * @returns {RegExp} XRegExp object with XRegExp syntax applied.
     */
    function asXRegExp(value) {
        return XRegExp.isRegExp(value) ?
            (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?
                // Don't recompile, to preserve capture names
                value :
                // Recompile as XRegExp
                XRegExp(value.source)
            ) :
            // Compile string as XRegExp
            XRegExp(value);
    }

    /**
     * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in
     * the outer pattern and provided subpatterns are automatically renumbered to work correctly.
     * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.
     *
     * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
     *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
     *   character classes.
     * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
     *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
     * @param {String} [flags] Any combination of XRegExp flags.
     * @returns {RegExp} Regex with interpolated subpatterns.
     * @example
     *
     * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
     *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
     *     h12: /1[0-2]|0?[1-9]/,
     *     h24: /2[0-3]|[01][0-9]/
     *   }, 'x'),
     *   minutes: /^[0-5][0-9]$/
     * });
     * time.test('10:59'); // -> true
     * XRegExp.exec('10:59', time).minutes; // -> '59'
     */
    XRegExp.build = function(pattern, subs, flags) {
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
            data = {},
            numCaps = 0, // 'Caps' is short for captures
            numPriorCaps,
            numOuterCaps = 0,
            outerCapsMap = [0],
            outerCapNames,
            sub,
            p;

        // Add flags within a leading mode modifier to the overall pattern's flags
        if (inlineFlags) {
            flags = flags || '';
            inlineFlags[1].replace(/./g, function(flag) {
                // Don't add duplicates
                flags += (flags.indexOf(flag) > -1 ? '' : flag);
            });
        }

        for (p in subs) {
            if (subs.hasOwnProperty(p)) {
                // Passing to XRegExp enables extended syntax and ensures independent validity,
                // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
                // subpatterns provided as native regexes, it dies on octals and adds the property
                // used to hold extended regex instance data, for simplicity
                sub = asXRegExp(subs[p]);
                data[p] = {
                    // Deanchoring allows embedding independently useful anchored regexes. If you
                    // really need to keep your anchors, double them (i.e., `^^...$$`)
                    pattern: deanchor(sub.source),
                    names: sub[REGEX_DATA].captureNames || []
                };
            }
        }

        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
        // helps keep this simple. Named captures will be put back
        pattern = asXRegExp(pattern);
        outerCapNames = pattern[REGEX_DATA].captureNames || [];
        pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {
            var subName = $1 || $2,
                capName,
                intro,
                localCapIndex;
            // Named subpattern
            if (subName) {
                if (!data.hasOwnProperty(subName)) {
                    throw new ReferenceError('Undefined property ' + $0);
                }
                // Named subpattern was wrapped in a capturing group
                if ($1) {
                    capName = outerCapNames[numOuterCaps];
                    outerCapsMap[++numOuterCaps] = ++numCaps;
                    // If it's a named group, preserve the name. Otherwise, use the subpattern name
                    // as the capture name
                    intro = '(?<' + (capName || subName) + '>';
                } else {
                    intro = '(?:';
                }
                numPriorCaps = numCaps;
                return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                    // Capturing group
                    if (paren) {
                        capName = data[subName].names[numCaps - numPriorCaps];
                        ++numCaps;
                        // If the current capture has a name, preserve the name
                        if (capName) {
                            return '(?<' + capName + '>';
                        }
                    // Backreference
                    } else if (backref) {
                        localCapIndex = +backref - 1;
                        // Rewrite the backreference
                        return data[subName].names[localCapIndex] ?
                            // Need to preserve the backreference name in case using flag `n`
                            '\\k<' + data[subName].names[localCapIndex] + '>' :
                            '\\' + (+backref + numPriorCaps);
                    }
                    return match;
                }) + ')';
            }
            // Capturing group
            if ($3) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If the current capture has a name, preserve the name
                if (capName) {
                    return '(?<' + capName + '>';
                }
            // Backreference
            } else if ($4) {
                localCapIndex = +$4 - 1;
                // Rewrite the backreference
                return outerCapNames[localCapIndex] ?
                    // Need to preserve the backreference name in case using flag `n`
                    '\\k<' + outerCapNames[localCapIndex] + '>' :
                    '\\' + outerCapsMap[+$4];
            }
            return $0;
        });

        return XRegExp(pattern, flags);
    };

};

},{}],178:[function(require,module,exports){
/*!
 * XRegExp.matchRecursive 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2009-2016 MIT License
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Returns a match detail object composed of the provided values.
     */
    function row(name, value, start, end) {
        return {
            name: name,
            value: value,
            start: start,
            end: end
        };
    }

    /**
     * Returns an array of match strings between outermost left and right delimiters, or an array of
     * objects with detailed match parts and position data. An error is thrown if delimiters are
     * unbalanced within the data.
     *
     * @param {String} str String to search.
     * @param {String} left Left delimiter as an XRegExp pattern.
     * @param {String} right Right delimiter as an XRegExp pattern.
     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
     * @returns {Array} Array of matches, or an empty array.
     * @example
     *
     * // Basic usage
     * var str = '(t((e))s)t()(ing)';
     * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
     * // -> ['t((e))s', '', 'ing']
     *
     * // Extended information mode with valueNames
     * str = 'Here is <div> <div>an</div></div> example';
     * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
     *   valueNames: ['between', 'left', 'match', 'right']
     * });
     * // -> [
     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
     * // {name: 'right',   value: '</div>',         start: 27, end: 33},
     * // {name: 'between', value: ' example',       start: 33, end: 41}
     * // ]
     *
     * // Omitting unneeded parts with null valueNames, and using escapeChar
     * str = '...{1}.\\{{function(x,y){return {y:x}}}';
     * XRegExp.matchRecursive(str, '{', '}', 'g', {
     *   valueNames: ['literal', null, 'value', null],
     *   escapeChar: '\\'
     * });
     * // -> [
     * // {name: 'literal', value: '...',  start: 0, end: 3},
     * // {name: 'value',   value: '1',    start: 4, end: 5},
     * // {name: 'literal', value: '.\\{', start: 6, end: 9},
     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}
     * // ]
     *
     * // Sticky mode via flag y
     * str = '<1><<<2>>><3>4<5>';
     * XRegExp.matchRecursive(str, '<', '>', 'gy');
     * // -> ['1', '<<2>>', '3']
     */
    XRegExp.matchRecursive = function(str, left, right, flags, options) {
        flags = flags || '';
        options = options || {};
        var global = flags.indexOf('g') > -1,
            sticky = flags.indexOf('y') > -1,
            // Flag `y` is controlled internally
            basicFlags = flags.replace(/y/g, ''),
            escapeChar = options.escapeChar,
            vN = options.valueNames,
            output = [],
            openTokens = 0,
            delimStart = 0,
            delimEnd = 0,
            lastOuterEnd = 0,
            outerStart,
            innerStart,
            leftMatch,
            rightMatch,
            esc;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);

        if (escapeChar) {
            if (escapeChar.length > 1) {
                throw new Error('Cannot use more than one escape character');
            }
            escapeChar = XRegExp.escape(escapeChar);
            // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`
            esc = new RegExp(
                '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                    XRegExp.union([left, right]).source +
                    ')[^' + escapeChar + '])+)+',
                // Flags `gy` not needed here
                flags.replace(/[^imu]+/g, '')
            );
        }

        while (true) {
            // If using an escape character, advance to the delimiter's next starting position,
            // skipping any escaped characters in between
            if (escapeChar) {
                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
            }
            leftMatch = XRegExp.exec(str, left, delimEnd);
            rightMatch = XRegExp.exec(str, right, delimEnd);
            // Keep the leftmost match only
            if (leftMatch && rightMatch) {
                if (leftMatch.index <= rightMatch.index) {
                    rightMatch = null;
                } else {
                    leftMatch = null;
                }
            }
            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
            // LM | RM | OT | Result
            // 1  | 0  | 1  | loop
            // 1  | 0  | 0  | loop
            // 0  | 1  | 1  | loop
            // 0  | 1  | 0  | throw
            // 0  | 0  | 1  | throw
            // 0  | 0  | 0  | break
            // The paths above don't include the sticky mode special case. The loop ends after the
            // first completed match if not `global`.
            if (leftMatch || rightMatch) {
                delimStart = (leftMatch || rightMatch).index;
                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
            } else if (!openTokens) {
                break;
            }
            if (sticky && !openTokens && delimStart > lastOuterEnd) {
                break;
            }
            if (leftMatch) {
                if (!openTokens) {
                    outerStart = delimStart;
                    innerStart = delimEnd;
                }
                ++openTokens;
            } else if (rightMatch && openTokens) {
                if (!--openTokens) {
                    if (vN) {
                        if (vN[0] && outerStart > lastOuterEnd) {
                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                        }
                        if (vN[1]) {
                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                        }
                        if (vN[2]) {
                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                        }
                        if (vN[3]) {
                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                        }
                    } else {
                        output.push(str.slice(innerStart, delimStart));
                    }
                    lastOuterEnd = delimEnd;
                    if (!global) {
                        break;
                    }
                }
            } else {
                throw new Error('Unbalanced delimiter found in string');
            }
            // If the delimiter matched an empty string, avoid an infinite loop
            if (delimStart === delimEnd) {
                ++delimEnd;
            }
        }

        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }

        return output;
    };

};

},{}],179:[function(require,module,exports){
/*!
 * XRegExp Unicode Base 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2008-2016 MIT License
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds base support for Unicode matching:
     * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
     *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the
     *   braces for token names that are a single letter (e.g. `\pL` or `PL`).
     * - Adds flag A (astral), which enables 21-bit Unicode support.
     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
     *
     * Unicode Base relies on externally provided Unicode character data. Official addons are
     * available to provide data for Unicode categories, scripts, blocks, and properties.
     *
     * @requires XRegExp
     */

    // ==--------------------------==
    // Private stuff
    // ==--------------------------==

    // Storage for Unicode data
    var unicode = {};

    // Reuse utils
    var dec = XRegExp._dec;
    var hex = XRegExp._hex;
    var pad4 = XRegExp._pad4;

    // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
    function normalize(name) {
        return name.replace(/[- _]+/g, '').toLowerCase();
    }

    // Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
    function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ?
            dec(esc[1]) :
            chr.charCodeAt(chr.charAt(0) === '\\' ? 1 : 0);
    }

    // Inverts a list of ordered BMP characters and ranges
    function invertBmp(range) {
        var output = '';
        var lastEnd = -1;
        XRegExp.forEach(
            range,
            /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/,
            function(m) {
                var start = charCode(m[1]);
                if (start > (lastEnd + 1)) {
                    output += '\\u' + pad4(hex(lastEnd + 1));
                    if (start > (lastEnd + 2)) {
                        output += '-\\u' + pad4(hex(start - 1));
                    }
                }
                lastEnd = charCode(m[2] || m[1]);
            }
        );
        if (lastEnd < 0xFFFF) {
            output += '\\u' + pad4(hex(lastEnd + 1));
            if (lastEnd < 0xFFFE) {
                output += '-\\uFFFF';
            }
        }
        return output;
    }

    // Generates an inverted BMP range on first use
    function cacheInvertedBmp(slug) {
        var prop = 'b!';
        return unicode[slug][prop] || (
            unicode[slug][prop] = invertBmp(unicode[slug].bmp)
        );
    }

    // Combines and optionally negates BMP and astral data
    function buildAstral(slug, isNegated) {
        var item = unicode[slug],
            combined = '';
        if (item.bmp && !item.isBmpLast) {
            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');
        }
        if (item.astral) {
            combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';
        }
        // Astral Unicode tokens always match a code point, never a code unit
        return isNegated ?
            '(?:(?!' + combined + ')(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))' :
            '(?:' + combined + ')';
    }

    // Builds a complete astral pattern on first use
    function cacheAstral(slug, isNegated) {
        var prop = isNegated ? 'a!' : 'a=';
        return unicode[slug][prop] || (
            unicode[slug][prop] = buildAstral(slug, isNegated)
        );
    }

    // ==--------------------------==
    // Core functionality
    // ==--------------------------==

    /*
     * Add Unicode token syntax: \p{..}, \P{..}, \p{^..}. Also add astral mode (flag A).
     */
    XRegExp.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags) {
            var ERR_DOUBLE_NEG = 'Invalid double negation ',
                ERR_UNKNOWN_NAME = 'Unknown Unicode token ',
                ERR_UNKNOWN_REF = 'Unicode token missing data ',
                ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ',
                ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes',
                // Negated via \P{..} or \p{^..}
                isNegated = match[1] === 'P' || !!match[2],
                // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
                isAstralMode = flags.indexOf('A') > -1,
                // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`
                slug = normalize(match[4] || match[3]),
                // Token data object
                item = unicode[slug];

            if (match[1] === 'P' && match[2]) {
                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
            }
            if (!unicode.hasOwnProperty(slug)) {
                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
            }

            // Switch to the negated form of the referenced Unicode token
            if (item.inverseOf) {
                slug = normalize(item.inverseOf);
                if (!unicode.hasOwnProperty(slug)) {
                    throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);
                }
                item = unicode[slug];
                isNegated = !isNegated;
            }

            if (!(item.bmp || isAstralMode)) {
                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
            }
            if (isAstralMode) {
                if (scope === 'class') {
                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
                }

                return cacheAstral(slug, isNegated);
            }

            return scope === 'class' ?
                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :
                (isNegated ? '[^' : '[') + item.bmp + ']';
        },
        {
            scope: 'all',
            optionalFlags: 'A',
            leadChar: '\\'
        }
    );

    /**
     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
     *
     * @param {Array} data Objects with named character ranges. Each object may have properties
     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are
     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If
     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,
     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are
     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and
     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan
     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and
     *   `astral` data should be a combination of literal characters and `\xHH` or `\uHHHH` escape
     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be
     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
     *   character classes and alternation, and should use surrogate pairs to represent astral code
     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
     *   defined as the exact inverse of another token.
     * @example
     *
     * // Basic use
     * XRegExp.addUnicodeData([{
     *   name: 'XDigit',
     *   alias: 'Hexadecimal',
     *   bmp: '0-9A-Fa-f'
     * }]);
     * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
     */
    XRegExp.addUnicodeData = function(data) {
        var ERR_NO_NAME = 'Unicode token requires name',
            ERR_NO_DATA = 'Unicode token has no character data ',
            item,
            i;

        for (i = 0; i < data.length; ++i) {
            item = data[i];
            if (!item.name) {
                throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
                throw new Error(ERR_NO_DATA + item.name);
            }
            unicode[normalize(item.name)] = item;
            if (item.alias) {
                unicode[normalize(item.alias)] = item;
            }
        }

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        XRegExp.cache.flush('patterns');
    };

};

},{}],180:[function(require,module,exports){
/*!
 * XRegExp Unicode Blocks 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g.,
     * `\p{InBasicLatin}`. Token names are case insensitive, and any spaces, hyphens, and
     * underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
    }

    XRegExp.addUnicodeData([
        {
            name: 'InAegean_Numbers',
            astral: '\uD800[\uDD00-\uDD3F]'
        },
        {
            name: 'InAhom',
            astral: '\uD805[\uDF00-\uDF3F]'
        },
        {
            name: 'InAlchemical_Symbols',
            astral: '\uD83D[\uDF00-\uDF7F]'
        },
        {
            name: 'InAlphabetic_Presentation_Forms',
            bmp: '\uFB00-\uFB4F'
        },
        {
            name: 'InAnatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE7F]'
        },
        {
            name: 'InAncient_Greek_Musical_Notation',
            astral: '\uD834[\uDE00-\uDE4F]'
        },
        {
            name: 'InAncient_Greek_Numbers',
            astral: '\uD800[\uDD40-\uDD8F]'
        },
        {
            name: 'InAncient_Symbols',
            astral: '\uD800[\uDD90-\uDDCF]'
        },
        {
            name: 'InArabic',
            bmp: '\u0600-\u06FF'
        },
        {
            name: 'InArabic_Extended_A',
            bmp: '\u08A0-\u08FF'
        },
        {
            name: 'InArabic_Mathematical_Alphabetic_Symbols',
            astral: '\uD83B[\uDE00-\uDEFF]'
        },
        {
            name: 'InArabic_Presentation_Forms_A',
            bmp: '\uFB50-\uFDFF'
        },
        {
            name: 'InArabic_Presentation_Forms_B',
            bmp: '\uFE70-\uFEFF'
        },
        {
            name: 'InArabic_Supplement',
            bmp: '\u0750-\u077F'
        },
        {
            name: 'InArmenian',
            bmp: '\u0530-\u058F'
        },
        {
            name: 'InArrows',
            bmp: '\u2190-\u21FF'
        },
        {
            name: 'InAvestan',
            astral: '\uD802[\uDF00-\uDF3F]'
        },
        {
            name: 'InBalinese',
            bmp: '\u1B00-\u1B7F'
        },
        {
            name: 'InBamum',
            bmp: '\uA6A0-\uA6FF'
        },
        {
            name: 'InBamum_Supplement',
            astral: '\uD81A[\uDC00-\uDE3F]'
        },
        {
            name: 'InBasic_Latin',
            bmp: '\0-\x7F'
        },
        {
            name: 'InBassa_Vah',
            astral: '\uD81A[\uDED0-\uDEFF]'
        },
        {
            name: 'InBatak',
            bmp: '\u1BC0-\u1BFF'
        },
        {
            name: 'InBengali',
            bmp: '\u0980-\u09FF'
        },
        {
            name: 'InBlock_Elements',
            bmp: '\u2580-\u259F'
        },
        {
            name: 'InBopomofo',
            bmp: '\u3100-\u312F'
        },
        {
            name: 'InBopomofo_Extended',
            bmp: '\u31A0-\u31BF'
        },
        {
            name: 'InBox_Drawing',
            bmp: '\u2500-\u257F'
        },
        {
            name: 'InBrahmi',
            astral: '\uD804[\uDC00-\uDC7F]'
        },
        {
            name: 'InBraille_Patterns',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'InBuginese',
            bmp: '\u1A00-\u1A1F'
        },
        {
            name: 'InBuhid',
            bmp: '\u1740-\u175F'
        },
        {
            name: 'InByzantine_Musical_Symbols',
            astral: '\uD834[\uDC00-\uDCFF]'
        },
        {
            name: 'InCJK_Compatibility',
            bmp: '\u3300-\u33FF'
        },
        {
            name: 'InCJK_Compatibility_Forms',
            bmp: '\uFE30-\uFE4F'
        },
        {
            name: 'InCJK_Compatibility_Ideographs',
            bmp: '\uF900-\uFAFF'
        },
        {
            name: 'InCJK_Compatibility_Ideographs_Supplement',
            astral: '\uD87E[\uDC00-\uDE1F]'
        },
        {
            name: 'InCJK_Radicals_Supplement',
            bmp: '\u2E80-\u2EFF'
        },
        {
            name: 'InCJK_Strokes',
            bmp: '\u31C0-\u31EF'
        },
        {
            name: 'InCJK_Symbols_and_Punctuation',
            bmp: '\u3000-\u303F'
        },
        {
            name: 'InCJK_Unified_Ideographs',
            bmp: '\u4E00-\u9FFF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_A',
            bmp: '\u3400-\u4DBF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_B',
            astral: '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_C',
            astral: '\uD86D[\uDC00-\uDF3F]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD869[\uDF00-\uDFFF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_D',
            astral: '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_E',
            astral: '[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD86E[\uDC20-\uDFFF]'
        },
        {
            name: 'InCarian',
            astral: '\uD800[\uDEA0-\uDEDF]'
        },
        {
            name: 'InCaucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD6F]'
        },
        {
            name: 'InChakma',
            astral: '\uD804[\uDD00-\uDD4F]'
        },
        {
            name: 'InCham',
            bmp: '\uAA00-\uAA5F'
        },
        {
            name: 'InCherokee',
            bmp: '\u13A0-\u13FF'
        },
        {
            name: 'InCherokee_Supplement',
            bmp: '\uAB70-\uABBF'
        },
        {
            name: 'InCombining_Diacritical_Marks',
            bmp: '\u0300-\u036F'
        },
        {
            name: 'InCombining_Diacritical_Marks_Extended',
            bmp: '\u1AB0-\u1AFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_Supplement',
            bmp: '\u1DC0-\u1DFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_for_Symbols',
            bmp: '\u20D0-\u20FF'
        },
        {
            name: 'InCombining_Half_Marks',
            bmp: '\uFE20-\uFE2F'
        },
        {
            name: 'InCommon_Indic_Number_Forms',
            bmp: '\uA830-\uA83F'
        },
        {
            name: 'InControl_Pictures',
            bmp: '\u2400-\u243F'
        },
        {
            name: 'InCoptic',
            bmp: '\u2C80-\u2CFF'
        },
        {
            name: 'InCoptic_Epact_Numbers',
            astral: '\uD800[\uDEE0-\uDEFF]'
        },
        {
            name: 'InCounting_Rod_Numerals',
            astral: '\uD834[\uDF60-\uDF7F]'
        },
        {
            name: 'InCuneiform',
            astral: '\uD808[\uDC00-\uDFFF]'
        },
        {
            name: 'InCuneiform_Numbers_and_Punctuation',
            astral: '\uD809[\uDC00-\uDC7F]'
        },
        {
            name: 'InCurrency_Symbols',
            bmp: '\u20A0-\u20CF'
        },
        {
            name: 'InCypriot_Syllabary',
            astral: '\uD802[\uDC00-\uDC3F]'
        },
        {
            name: 'InCyrillic',
            bmp: '\u0400-\u04FF'
        },
        {
            name: 'InCyrillic_Extended_A',
            bmp: '\u2DE0-\u2DFF'
        },
        {
            name: 'InCyrillic_Extended_B',
            bmp: '\uA640-\uA69F'
        },
        {
            name: 'InCyrillic_Supplement',
            bmp: '\u0500-\u052F'
        },
        {
            name: 'InDeseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'InDevanagari',
            bmp: '\u0900-\u097F'
        },
        {
            name: 'InDevanagari_Extended',
            bmp: '\uA8E0-\uA8FF'
        },
        {
            name: 'InDingbats',
            bmp: '\u2700-\u27BF'
        },
        {
            name: 'InDomino_Tiles',
            astral: '\uD83C[\uDC30-\uDC9F]'
        },
        {
            name: 'InDuployan',
            astral: '\uD82F[\uDC00-\uDC9F]'
        },
        {
            name: 'InEarly_Dynastic_Cuneiform',
            astral: '\uD809[\uDC80-\uDD4F]'
        },
        {
            name: 'InEgyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
        },
        {
            name: 'InElbasan',
            astral: '\uD801[\uDD00-\uDD2F]'
        },
        {
            name: 'InEmoticons',
            astral: '\uD83D[\uDE00-\uDE4F]'
        },
        {
            name: 'InEnclosed_Alphanumeric_Supplement',
            astral: '\uD83C[\uDD00-\uDDFF]'
        },
        {
            name: 'InEnclosed_Alphanumerics',
            bmp: '\u2460-\u24FF'
        },
        {
            name: 'InEnclosed_CJK_Letters_and_Months',
            bmp: '\u3200-\u32FF'
        },
        {
            name: 'InEnclosed_Ideographic_Supplement',
            astral: '\uD83C[\uDE00-\uDEFF]'
        },
        {
            name: 'InEthiopic',
            bmp: '\u1200-\u137F'
        },
        {
            name: 'InEthiopic_Extended',
            bmp: '\u2D80-\u2DDF'
        },
        {
            name: 'InEthiopic_Extended_A',
            bmp: '\uAB00-\uAB2F'
        },
        {
            name: 'InEthiopic_Supplement',
            bmp: '\u1380-\u139F'
        },
        {
            name: 'InGeneral_Punctuation',
            bmp: '\u2000-\u206F'
        },
        {
            name: 'InGeometric_Shapes',
            bmp: '\u25A0-\u25FF'
        },
        {
            name: 'InGeometric_Shapes_Extended',
            astral: '\uD83D[\uDF80-\uDFFF]'
        },
        {
            name: 'InGeorgian',
            bmp: '\u10A0-\u10FF'
        },
        {
            name: 'InGeorgian_Supplement',
            bmp: '\u2D00-\u2D2F'
        },
        {
            name: 'InGlagolitic',
            bmp: '\u2C00-\u2C5F'
        },
        {
            name: 'InGothic',
            astral: '\uD800[\uDF30-\uDF4F]'
        },
        {
            name: 'InGrantha',
            astral: '\uD804[\uDF00-\uDF7F]'
        },
        {
            name: 'InGreek_Extended',
            bmp: '\u1F00-\u1FFF'
        },
        {
            name: 'InGreek_and_Coptic',
            bmp: '\u0370-\u03FF'
        },
        {
            name: 'InGujarati',
            bmp: '\u0A80-\u0AFF'
        },
        {
            name: 'InGurmukhi',
            bmp: '\u0A00-\u0A7F'
        },
        {
            name: 'InHalfwidth_and_Fullwidth_Forms',
            bmp: '\uFF00-\uFFEF'
        },
        {
            name: 'InHangul_Compatibility_Jamo',
            bmp: '\u3130-\u318F'
        },
        {
            name: 'InHangul_Jamo',
            bmp: '\u1100-\u11FF'
        },
        {
            name: 'InHangul_Jamo_Extended_A',
            bmp: '\uA960-\uA97F'
        },
        {
            name: 'InHangul_Jamo_Extended_B',
            bmp: '\uD7B0-\uD7FF'
        },
        {
            name: 'InHangul_Syllables',
            bmp: '\uAC00-\uD7AF'
        },
        {
            name: 'InHanunoo',
            bmp: '\u1720-\u173F'
        },
        {
            name: 'InHatran',
            astral: '\uD802[\uDCE0-\uDCFF]'
        },
        {
            name: 'InHebrew',
            bmp: '\u0590-\u05FF'
        },
        {
            name: 'InHigh_Private_Use_Surrogates',
            bmp: '\uDB80-\uDBFF'
        },
        {
            name: 'InHigh_Surrogates',
            bmp: '\uD800-\uDB7F'
        },
        {
            name: 'InHiragana',
            bmp: '\u3040-\u309F'
        },
        {
            name: 'InIPA_Extensions',
            bmp: '\u0250-\u02AF'
        },
        {
            name: 'InIdeographic_Description_Characters',
            bmp: '\u2FF0-\u2FFF'
        },
        {
            name: 'InImperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC5F]'
        },
        {
            name: 'InInscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF7F]'
        },
        {
            name: 'InInscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF5F]'
        },
        {
            name: 'InJavanese',
            bmp: '\uA980-\uA9DF'
        },
        {
            name: 'InKaithi',
            astral: '\uD804[\uDC80-\uDCCF]'
        },
        {
            name: 'InKana_Supplement',
            astral: '\uD82C[\uDC00-\uDCFF]'
        },
        {
            name: 'InKanbun',
            bmp: '\u3190-\u319F'
        },
        {
            name: 'InKangxi_Radicals',
            bmp: '\u2F00-\u2FDF'
        },
        {
            name: 'InKannada',
            bmp: '\u0C80-\u0CFF'
        },
        {
            name: 'InKatakana',
            bmp: '\u30A0-\u30FF'
        },
        {
            name: 'InKatakana_Phonetic_Extensions',
            bmp: '\u31F0-\u31FF'
        },
        {
            name: 'InKayah_Li',
            bmp: '\uA900-\uA92F'
        },
        {
            name: 'InKharoshthi',
            astral: '\uD802[\uDE00-\uDE5F]'
        },
        {
            name: 'InKhmer',
            bmp: '\u1780-\u17FF'
        },
        {
            name: 'InKhmer_Symbols',
            bmp: '\u19E0-\u19FF'
        },
        {
            name: 'InKhojki',
            astral: '\uD804[\uDE00-\uDE4F]'
        },
        {
            name: 'InKhudawadi',
            astral: '\uD804[\uDEB0-\uDEFF]'
        },
        {
            name: 'InLao',
            bmp: '\u0E80-\u0EFF'
        },
        {
            name: 'InLatin_Extended_Additional',
            bmp: '\u1E00-\u1EFF'
        },
        {
            name: 'InLatin_Extended_A',
            bmp: '\u0100-\u017F'
        },
        {
            name: 'InLatin_Extended_B',
            bmp: '\u0180-\u024F'
        },
        {
            name: 'InLatin_Extended_C',
            bmp: '\u2C60-\u2C7F'
        },
        {
            name: 'InLatin_Extended_D',
            bmp: '\uA720-\uA7FF'
        },
        {
            name: 'InLatin_Extended_E',
            bmp: '\uAB30-\uAB6F'
        },
        {
            name: 'InLatin_1_Supplement',
            bmp: '\x80-\xFF'
        },
        {
            name: 'InLepcha',
            bmp: '\u1C00-\u1C4F'
        },
        {
            name: 'InLetterlike_Symbols',
            bmp: '\u2100-\u214F'
        },
        {
            name: 'InLimbu',
            bmp: '\u1900-\u194F'
        },
        {
            name: 'InLinear_A',
            astral: '\uD801[\uDE00-\uDF7F]'
        },
        {
            name: 'InLinear_B_Ideograms',
            astral: '\uD800[\uDC80-\uDCFF]'
        },
        {
            name: 'InLinear_B_Syllabary',
            astral: '\uD800[\uDC00-\uDC7F]'
        },
        {
            name: 'InLisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'InLow_Surrogates',
            bmp: '\uDC00-\uDFFF'
        },
        {
            name: 'InLycian',
            astral: '\uD800[\uDE80-\uDE9F]'
        },
        {
            name: 'InLydian',
            astral: '\uD802[\uDD20-\uDD3F]'
        },
        {
            name: 'InMahajani',
            astral: '\uD804[\uDD50-\uDD7F]'
        },
        {
            name: 'InMahjong_Tiles',
            astral: '\uD83C[\uDC00-\uDC2F]'
        },
        {
            name: 'InMalayalam',
            bmp: '\u0D00-\u0D7F'
        },
        {
            name: 'InMandaic',
            bmp: '\u0840-\u085F'
        },
        {
            name: 'InManichaean',
            astral: '\uD802[\uDEC0-\uDEFF]'
        },
        {
            name: 'InMathematical_Alphanumeric_Symbols',
            astral: '\uD835[\uDC00-\uDFFF]'
        },
        {
            name: 'InMathematical_Operators',
            bmp: '\u2200-\u22FF'
        },
        {
            name: 'InMeetei_Mayek',
            bmp: '\uABC0-\uABFF'
        },
        {
            name: 'InMeetei_Mayek_Extensions',
            bmp: '\uAAE0-\uAAFF'
        },
        {
            name: 'InMende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCDF]'
        },
        {
            name: 'InMeroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDFF]'
        },
        {
            name: 'InMeroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'InMiao',
            astral: '\uD81B[\uDF00-\uDF9F]'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_A',
            bmp: '\u27C0-\u27EF'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_B',
            bmp: '\u2980-\u29FF'
        },
        {
            name: 'InMiscellaneous_Symbols',
            bmp: '\u2600-\u26FF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Arrows',
            bmp: '\u2B00-\u2BFF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Pictographs',
            astral: '\uD83D[\uDC00-\uDDFF]|\uD83C[\uDF00-\uDFFF]'
        },
        {
            name: 'InMiscellaneous_Technical',
            bmp: '\u2300-\u23FF'
        },
        {
            name: 'InModi',
            astral: '\uD805[\uDE00-\uDE5F]'
        },
        {
            name: 'InModifier_Tone_Letters',
            bmp: '\uA700-\uA71F'
        },
        {
            name: 'InMongolian',
            bmp: '\u1800-\u18AF'
        },
        {
            name: 'InMro',
            astral: '\uD81A[\uDE40-\uDE6F]'
        },
        {
            name: 'InMultani',
            astral: '\uD804[\uDE80-\uDEAF]'
        },
        {
            name: 'InMusical_Symbols',
            astral: '\uD834[\uDD00-\uDDFF]'
        },
        {
            name: 'InMyanmar',
            bmp: '\u1000-\u109F'
        },
        {
            name: 'InMyanmar_Extended_A',
            bmp: '\uAA60-\uAA7F'
        },
        {
            name: 'InMyanmar_Extended_B',
            bmp: '\uA9E0-\uA9FF'
        },
        {
            name: 'InNKo',
            bmp: '\u07C0-\u07FF'
        },
        {
            name: 'InNabataean',
            astral: '\uD802[\uDC80-\uDCAF]'
        },
        {
            name: 'InNew_Tai_Lue',
            bmp: '\u1980-\u19DF'
        },
        {
            name: 'InNumber_Forms',
            bmp: '\u2150-\u218F'
        },
        {
            name: 'InOgham',
            bmp: '\u1680-\u169F'
        },
        {
            name: 'InOl_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'InOld_Hungarian',
            astral: '\uD803[\uDC80-\uDCFF]'
        },
        {
            name: 'InOld_Italic',
            astral: '\uD800[\uDF00-\uDF2F]'
        },
        {
            name: 'InOld_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'InOld_Permic',
            astral: '\uD800[\uDF50-\uDF7F]'
        },
        {
            name: 'InOld_Persian',
            astral: '\uD800[\uDFA0-\uDFDF]'
        },
        {
            name: 'InOld_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'InOld_Turkic',
            astral: '\uD803[\uDC00-\uDC4F]'
        },
        {
            name: 'InOptical_Character_Recognition',
            bmp: '\u2440-\u245F'
        },
        {
            name: 'InOriya',
            bmp: '\u0B00-\u0B7F'
        },
        {
            name: 'InOrnamental_Dingbats',
            astral: '\uD83D[\uDE50-\uDE7F]'
        },
        {
            name: 'InOsmanya',
            astral: '\uD801[\uDC80-\uDCAF]'
        },
        {
            name: 'InPahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF8F]'
        },
        {
            name: 'InPalmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'InPau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEFF]'
        },
        {
            name: 'InPhags_pa',
            bmp: '\uA840-\uA87F'
        },
        {
            name: 'InPhaistos_Disc',
            astral: '\uD800[\uDDD0-\uDDFF]'
        },
        {
            name: 'InPhoenician',
            astral: '\uD802[\uDD00-\uDD1F]'
        },
        {
            name: 'InPhonetic_Extensions',
            bmp: '\u1D00-\u1D7F'
        },
        {
            name: 'InPhonetic_Extensions_Supplement',
            bmp: '\u1D80-\u1DBF'
        },
        {
            name: 'InPlaying_Cards',
            astral: '\uD83C[\uDCA0-\uDCFF]'
        },
        {
            name: 'InPrivate_Use_Area',
            bmp: '\uE000-\uF8FF'
        },
        {
            name: 'InPsalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDFAF]'
        },
        {
            name: 'InRejang',
            bmp: '\uA930-\uA95F'
        },
        {
            name: 'InRumi_Numeral_Symbols',
            astral: '\uD803[\uDE60-\uDE7F]'
        },
        {
            name: 'InRunic',
            bmp: '\u16A0-\u16FF'
        },
        {
            name: 'InSamaritan',
            bmp: '\u0800-\u083F'
        },
        {
            name: 'InSaurashtra',
            bmp: '\uA880-\uA8DF'
        },
        {
            name: 'InSharada',
            astral: '\uD804[\uDD80-\uDDDF]'
        },
        {
            name: 'InShavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'InShorthand_Format_Controls',
            astral: '\uD82F[\uDCA0-\uDCAF]'
        },
        {
            name: 'InSiddham',
            astral: '\uD805[\uDD80-\uDDFF]'
        },
        {
            name: 'InSinhala',
            bmp: '\u0D80-\u0DFF'
        },
        {
            name: 'InSinhala_Archaic_Numbers',
            astral: '\uD804[\uDDE0-\uDDFF]'
        },
        {
            name: 'InSmall_Form_Variants',
            bmp: '\uFE50-\uFE6F'
        },
        {
            name: 'InSora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCFF]'
        },
        {
            name: 'InSpacing_Modifier_Letters',
            bmp: '\u02B0-\u02FF'
        },
        {
            name: 'InSpecials',
            bmp: '\uFFF0-\uFFFF'
        },
        {
            name: 'InSundanese',
            bmp: '\u1B80-\u1BBF'
        },
        {
            name: 'InSundanese_Supplement',
            bmp: '\u1CC0-\u1CCF'
        },
        {
            name: 'InSuperscripts_and_Subscripts',
            bmp: '\u2070-\u209F'
        },
        {
            name: 'InSupplemental_Arrows_A',
            bmp: '\u27F0-\u27FF'
        },
        {
            name: 'InSupplemental_Arrows_B',
            bmp: '\u2900-\u297F'
        },
        {
            name: 'InSupplemental_Arrows_C',
            astral: '\uD83E[\uDC00-\uDCFF]'
        },
        {
            name: 'InSupplemental_Mathematical_Operators',
            bmp: '\u2A00-\u2AFF'
        },
        {
            name: 'InSupplemental_Punctuation',
            bmp: '\u2E00-\u2E7F'
        },
        {
            name: 'InSupplemental_Symbols_and_Pictographs',
            astral: '\uD83E[\uDD00-\uDDFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_A',
            astral: '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_B',
            astral: '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSutton_SignWriting',
            astral: '\uD836[\uDC00-\uDEAF]'
        },
        {
            name: 'InSyloti_Nagri',
            bmp: '\uA800-\uA82F'
        },
        {
            name: 'InSyriac',
            bmp: '\u0700-\u074F'
        },
        {
            name: 'InTagalog',
            bmp: '\u1700-\u171F'
        },
        {
            name: 'InTagbanwa',
            bmp: '\u1760-\u177F'
        },
        {
            name: 'InTags',
            astral: '\uDB40[\uDC00-\uDC7F]'
        },
        {
            name: 'InTai_Le',
            bmp: '\u1950-\u197F'
        },
        {
            name: 'InTai_Tham',
            bmp: '\u1A20-\u1AAF'
        },
        {
            name: 'InTai_Viet',
            bmp: '\uAA80-\uAADF'
        },
        {
            name: 'InTai_Xuan_Jing_Symbols',
            astral: '\uD834[\uDF00-\uDF5F]'
        },
        {
            name: 'InTakri',
            astral: '\uD805[\uDE80-\uDECF]'
        },
        {
            name: 'InTamil',
            bmp: '\u0B80-\u0BFF'
        },
        {
            name: 'InTelugu',
            bmp: '\u0C00-\u0C7F'
        },
        {
            name: 'InThaana',
            bmp: '\u0780-\u07BF'
        },
        {
            name: 'InThai',
            bmp: '\u0E00-\u0E7F'
        },
        {
            name: 'InTibetan',
            bmp: '\u0F00-\u0FFF'
        },
        {
            name: 'InTifinagh',
            bmp: '\u2D30-\u2D7F'
        },
        {
            name: 'InTirhuta',
            astral: '\uD805[\uDC80-\uDCDF]'
        },
        {
            name: 'InTransport_and_Map_Symbols',
            astral: '\uD83D[\uDE80-\uDEFF]'
        },
        {
            name: 'InUgaritic',
            astral: '\uD800[\uDF80-\uDF9F]'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics',
            bmp: '\u1400-\u167F'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
            bmp: '\u18B0-\u18FF'
        },
        {
            name: 'InVai',
            bmp: '\uA500-\uA63F'
        },
        {
            name: 'InVariation_Selectors',
            bmp: '\uFE00-\uFE0F'
        },
        {
            name: 'InVariation_Selectors_Supplement',
            astral: '\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'InVedic_Extensions',
            bmp: '\u1CD0-\u1CFF'
        },
        {
            name: 'InVertical_Forms',
            bmp: '\uFE10-\uFE1F'
        },
        {
            name: 'InWarang_Citi',
            astral: '\uD806[\uDCA0-\uDCFF]'
        },
        {
            name: 'InYi_Radicals',
            bmp: '\uA490-\uA4CF'
        },
        {
            name: 'InYi_Syllables',
            bmp: '\uA000-\uA48F'
        },
        {
            name: 'InYijing_Hexagram_Symbols',
            bmp: '\u4DC0-\u4DFF'
        }
    ]);

};

},{}],181:[function(require,module,exports){
/*!
 * XRegExp Unicode Categories 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
     * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token
     * names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
    }

    XRegExp.addUnicodeData([
        {
            name: 'C',
            alias: 'Other',
            isBmpLast: true,
            bmp: '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
            astral: '\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Cc',
            alias: 'Control',
            bmp: '\0-\x1F\x7F-\x9F'
        },
        {
            name: 'Cf',
            alias: 'Format',
            bmp: '\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
            astral: '\uDB40[\uDC01\uDC20-\uDC7F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uD804\uDCBD'
        },
        {
            name: 'Cn',
            alias: 'Unassigned',
            bmp: '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
            astral: '\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Co',
            alias: 'Private_Use',
            bmp: '\uE000-\uF8FF',
            astral: '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
        },
        {
            name: 'Cs',
            alias: 'Surrogate',
            bmp: '\uD800-\uDFFF'
        },
        {
            name: 'L',
            alias: 'Letter',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Ll',
            alias: 'Lowercase_Letter',
            bmp: 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Lm',
            alias: 'Modifier_Letter',
            bmp: '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
            astral: '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F]'
        },
        {
            name: 'Lo',
            alias: 'Other_Letter',
            bmp: '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD83A[\uDC00-\uDCC4]|\uD803[\uDC00-\uDC48]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Lt',
            alias: 'Titlecase_Letter',
            bmp: '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
        },
        {
            name: 'Lu',
            alias: 'Uppercase_Letter',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD801[\uDC00-\uDC27]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]'
        },
        {
            name: 'M',
            alias: 'Mark',
            bmp: '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Mc',
            alias: 'Spacing_Mark',
            bmp: '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
            astral: '\uD834[\uDD65\uDD66\uDD6D-\uDD72]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD81B[\uDF51-\uDF7E]'
        },
        {
            name: 'Me',
            alias: 'Enclosing_Mark',
            bmp: '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
        },
        {
            name: 'Mn',
            alias: 'Nonspacing_Mark',
            bmp: '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'N',
            alias: 'Number',
            bmp: '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD806[\uDCE0-\uDCF2]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD834[\uDF60-\uDF71]|\uD83C[\uDD00-\uDD0C]|\uD809[\uDC00-\uDC6E]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]'
        },
        {
            name: 'Nd',
            alias: 'Decimal_Number',
            bmp: '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD801[\uDCA0-\uDCA9]|\uD835[\uDFCE-\uDFFF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]'
        },
        {
            name: 'Nl',
            alias: 'Letter_Number',
            bmp: '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
            astral: '\uD809[\uDC00-\uDC6E]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]'
        },
        {
            name: 'No',
            alias: 'Other_Number',
            bmp: '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D70-\u0D75\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
            astral: '\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD83C[\uDD00-\uDD0C]|\uD806[\uDCEA-\uDCF2]|\uD83A[\uDCC7-\uDCCF]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDF3A\uDF3B]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]'
        },
        {
            name: 'P',
            alias: 'Punctuation',
            bmp: '\x21-\x23\x25-\\x2A\x2C-\x2F\x3A\x3B\\x3F\x40\\x5B-\\x5D\x5F\\x7B\x7D\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Pc',
            alias: 'Connector_Punctuation',
            bmp: '\x5F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
        },
        {
            name: 'Pd',
            alias: 'Dash_Punctuation',
            bmp: '\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
        },
        {
            name: 'Pe',
            alias: 'Close_Punctuation',
            bmp: '\\x29\\x5D\x7D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
        },
        {
            name: 'Pf',
            alias: 'Final_Punctuation',
            bmp: '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
        },
        {
            name: 'Pi',
            alias: 'Initial_Punctuation',
            bmp: '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
        },
        {
            name: 'Po',
            alias: 'Other_Punctuation',
            bmp: '\x21-\x23\x25-\x27\\x2A\x2C\\x2E\x2F\x3A\x3B\\x3F\x40\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Ps',
            alias: 'Open_Punctuation',
            bmp: '\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
        },
        {
            name: 'S',
            alias: 'Symbol',
            bmp: '\\x24\\x2B\x3C-\x3E\\x5E\x60\\x7C\x7E\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD83B[\uDEF0\uDEF1]'
        },
        {
            name: 'Sc',
            alias: 'Currency_Symbol',
            bmp: '\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6'
        },
        {
            name: 'Sk',
            alias: 'Modifier_Symbol',
            bmp: '\\x5E\x60\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
            astral: '\uD83C[\uDFFB-\uDFFF]'
        },
        {
            name: 'Sm',
            alias: 'Math_Symbol',
            bmp: '\\x2B\x3C-\x3E\\x7C\x7E\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
            astral: '\uD83B[\uDEF0\uDEF1]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]'
        },
        {
            name: 'So',
            alias: 'Other_Symbol',
            bmp: '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]'
        },
        {
            name: 'Z',
            alias: 'Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        },
        {
            name: 'Zl',
            alias: 'Line_Separator',
            bmp: '\u2028'
        },
        {
            name: 'Zp',
            alias: 'Paragraph_Separator',
            bmp: '\u2029'
        },
        {
            name: 'Zs',
            alias: 'Space_Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
        }
    ]);

};

},{}],182:[function(require,module,exports){
/*!
 * XRegExp Unicode Properties 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2012-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
     * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from
     * UAX #44 <http://unicode.org/reports/tr44/>:
     *
     * - Alphabetic
     *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm +
     *   Lo + Nl + Other_Alphabetic.
     *
     * - Default_Ignorable_Code_Point
     *   For programmatic determination of default ignorable code points. New characters that should
     *   be ignored in rendering (unless explicitly supported) will be assigned in these ranges,
     *   permitting programs to correctly handle the default rendering of such characters when not
     *   otherwise supported.
     *
     * - Lowercase
     *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
     *
     * - Noncharacter_Code_Point
     *   Code points permanently reserved for internal use.
     *
     * - Uppercase
     *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
     *
     * - White_Space
     *   Spaces, separator characters and other control characters which should be treated by
     *   programming languages as "white space" for the purpose of parsing elements.
     *
     * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS
     * #18 RL1.2 additionally requires support for Unicode scripts and general categories. These are
     * included in XRegExp's Unicode Categories and Unicode Scripts addons.
     *
     * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
    }

    var unicodeData = [
        {
            name: 'ASCII',
            bmp: '\0-\x7F'
        },
        {
            name: 'Alphabetic',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD805[\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD811[\uDC00-\uDE46]|\uD82C[\uDC00\uDC01]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Any',
            isBmpLast: true,
            bmp: '\0-\uFFFF',
            astral: '[\uD800-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'Default_Ignorable_Code_Point',
            bmp: '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
            astral: '[\uDB40-\uDB43][\uDC00-\uDFFF]|\uD834[\uDD73-\uDD7A]|\uD82F[\uDCA0-\uDCA3]'
        },
        {
            name: 'Lowercase',
            bmp: 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Noncharacter_Code_Point',
            bmp: '\uFDD0-\uFDEF\uFFFE\uFFFF',
            astral: '[\uDB3F\uDB7F\uDBBF\uDBFF\uD83F\uD87F\uD8BF\uDAFF\uD97F\uD9BF\uD9FF\uDA3F\uD8FF\uDABF\uDA7F\uD93F][\uDFFE\uDFFF]'
        },
        {
            name: 'Uppercase',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD801[\uDC00-\uDC27]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
        },
        {
            name: 'White_Space',
            bmp: '\x09-\x0D\x20\x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        }
    ];

    // Add non-generated data
    unicodeData.push({
        name: 'Assigned',
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: 'Cn'
    });

    XRegExp.addUnicodeData(unicodeData);

};

},{}],183:[function(require,module,exports){
/*!
 * XRegExp Unicode Scripts 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive,
     * and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
    }

    XRegExp.addUnicodeData([
        {
            name: 'Ahom',
            astral: '\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]'
        },
        {
            name: 'Anatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE46]'
        },
        {
            name: 'Arabic',
            bmp: '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
            astral: '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
        },
        {
            name: 'Armenian',
            bmp: '\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17'
        },
        {
            name: 'Avestan',
            astral: '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
        },
        {
            name: 'Balinese',
            bmp: '\u1B00-\u1B4B\u1B50-\u1B7C'
        },
        {
            name: 'Bamum',
            bmp: '\uA6A0-\uA6F7',
            astral: '\uD81A[\uDC00-\uDE38]'
        },
        {
            name: 'Bassa_Vah',
            astral: '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
        },
        {
            name: 'Batak',
            bmp: '\u1BC0-\u1BF3\u1BFC-\u1BFF'
        },
        {
            name: 'Bengali',
            bmp: '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB'
        },
        {
            name: 'Bopomofo',
            bmp: '\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA'
        },
        {
            name: 'Brahmi',
            astral: '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
        },
        {
            name: 'Braille',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'Buginese',
            bmp: '\u1A00-\u1A1B\u1A1E\u1A1F'
        },
        {
            name: 'Buhid',
            bmp: '\u1740-\u1753'
        },
        {
            name: 'Canadian_Aboriginal',
            bmp: '\u1400-\u167F\u18B0-\u18F5'
        },
        {
            name: 'Carian',
            astral: '\uD800[\uDEA0-\uDED0]'
        },
        {
            name: 'Caucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD63\uDD6F]'
        },
        {
            name: 'Chakma',
            astral: '\uD804[\uDD00-\uDD34\uDD36-\uDD43]'
        },
        {
            name: 'Cham',
            bmp: '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
        },
        {
            name: 'Cherokee',
            bmp: '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
        },
        {
            name: 'Common',
            bmp: '\0-\x40\\x5B-\x60\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FA\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E42\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD82F[\uDCA0-\uDCA3]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uDB40[\uDC01\uDC20-\uDC7F]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]'
        },
        {
            name: 'Coptic',
            bmp: '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
        },
        {
            name: 'Cuneiform',
            astral: '\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]|\uD808[\uDC00-\uDF99]'
        },
        {
            name: 'Cypriot',
            astral: '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
        },
        {
            name: 'Cyrillic',
            bmp: '\u0400-\u0484\u0487-\u052F\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
        },
        {
            name: 'Deseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'Devanagari',
            bmp: '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD'
        },
        {
            name: 'Duployan',
            astral: '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
        },
        {
            name: 'Egyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
        },
        {
            name: 'Elbasan',
            astral: '\uD801[\uDD00-\uDD27]'
        },
        {
            name: 'Ethiopic',
            bmp: '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
        },
        {
            name: 'Georgian',
            bmp: '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D'
        },
        {
            name: 'Glagolitic',
            bmp: '\u2C00-\u2C2E\u2C30-\u2C5E'
        },
        {
            name: 'Gothic',
            astral: '\uD800[\uDF30-\uDF4A]'
        },
        {
            name: 'Grantha',
            astral: '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
        },
        {
            name: 'Greek',
            bmp: '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
            astral: '\uD800[\uDD40-\uDD8C\uDDA0]|\uD834[\uDE00-\uDE45]'
        },
        {
            name: 'Gujarati',
            bmp: '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9'
        },
        {
            name: 'Gurmukhi',
            bmp: '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75'
        },
        {
            name: 'Han',
            bmp: '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD87E[\uDC00-\uDE1D]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Hangul',
            bmp: '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
        },
        {
            name: 'Hanunoo',
            bmp: '\u1720-\u1734'
        },
        {
            name: 'Hatran',
            astral: '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
        },
        {
            name: 'Hebrew',
            bmp: '\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
        },
        {
            name: 'Hiragana',
            bmp: '\u3041-\u3096\u309D-\u309F',
            astral: '\uD82C\uDC01|\uD83C\uDE00'
        },
        {
            name: 'Imperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
        },
        {
            name: 'Inherited',
            bmp: '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
            astral: '\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uD800[\uDDFD\uDEE0]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Inscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
        },
        {
            name: 'Inscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
        },
        {
            name: 'Javanese',
            bmp: '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
        },
        {
            name: 'Kaithi',
            astral: '\uD804[\uDC80-\uDCC1]'
        },
        {
            name: 'Kannada',
            bmp: '\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
        },
        {
            name: 'Katakana',
            bmp: '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
            astral: '\uD82C\uDC00'
        },
        {
            name: 'Kayah_Li',
            bmp: '\uA900-\uA92D\uA92F'
        },
        {
            name: 'Kharoshthi',
            astral: '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]'
        },
        {
            name: 'Khmer',
            bmp: '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
        },
        {
            name: 'Khojki',
            astral: '\uD804[\uDE00-\uDE11\uDE13-\uDE3D]'
        },
        {
            name: 'Khudawadi',
            astral: '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
        },
        {
            name: 'Lao',
            bmp: '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
        },
        {
            name: 'Latin',
            bmp: 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
        },
        {
            name: 'Lepcha',
            bmp: '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
        },
        {
            name: 'Limbu',
            bmp: '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
        },
        {
            name: 'Linear_A',
            astral: '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
        },
        {
            name: 'Linear_B',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
        },
        {
            name: 'Lisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'Lycian',
            astral: '\uD800[\uDE80-\uDE9C]'
        },
        {
            name: 'Lydian',
            astral: '\uD802[\uDD20-\uDD39\uDD3F]'
        },
        {
            name: 'Mahajani',
            astral: '\uD804[\uDD50-\uDD76]'
        },
        {
            name: 'Malayalam',
            bmp: '\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D75\u0D79-\u0D7F'
        },
        {
            name: 'Mandaic',
            bmp: '\u0840-\u085B\u085E'
        },
        {
            name: 'Manichaean',
            astral: '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
        },
        {
            name: 'Meetei_Mayek',
            bmp: '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
        },
        {
            name: 'Mende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
        },
        {
            name: 'Meroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
        },
        {
            name: 'Meroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'Miao',
            astral: '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
        },
        {
            name: 'Modi',
            astral: '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
        },
        {
            name: 'Mongolian',
            bmp: '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA'
        },
        {
            name: 'Mro',
            astral: '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
        },
        {
            name: 'Multani',
            astral: '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
        },
        {
            name: 'Myanmar',
            bmp: '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
        },
        {
            name: 'Nabataean',
            astral: '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
        },
        {
            name: 'New_Tai_Lue',
            bmp: '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
        },
        {
            name: 'Nko',
            bmp: '\u07C0-\u07FA'
        },
        {
            name: 'Ogham',
            bmp: '\u1680-\u169C'
        },
        {
            name: 'Ol_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'Old_Hungarian',
            astral: '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
        },
        {
            name: 'Old_Italic',
            astral: '\uD800[\uDF00-\uDF23]'
        },
        {
            name: 'Old_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'Old_Permic',
            astral: '\uD800[\uDF50-\uDF7A]'
        },
        {
            name: 'Old_Persian',
            astral: '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
        },
        {
            name: 'Old_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'Old_Turkic',
            astral: '\uD803[\uDC00-\uDC48]'
        },
        {
            name: 'Oriya',
            bmp: '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
        },
        {
            name: 'Osmanya',
            astral: '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
        },
        {
            name: 'Pahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
        },
        {
            name: 'Palmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'Pau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEF8]'
        },
        {
            name: 'Phags_Pa',
            bmp: '\uA840-\uA877'
        },
        {
            name: 'Phoenician',
            astral: '\uD802[\uDD00-\uDD1B\uDD1F]'
        },
        {
            name: 'Psalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
        },
        {
            name: 'Rejang',
            bmp: '\uA930-\uA953\uA95F'
        },
        {
            name: 'Runic',
            bmp: '\u16A0-\u16EA\u16EE-\u16F8'
        },
        {
            name: 'Samaritan',
            bmp: '\u0800-\u082D\u0830-\u083E'
        },
        {
            name: 'Saurashtra',
            bmp: '\uA880-\uA8C4\uA8CE-\uA8D9'
        },
        {
            name: 'Sharada',
            astral: '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
        },
        {
            name: 'Shavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'Siddham',
            astral: '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
        },
        {
            name: 'SignWriting',
            astral: '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
        },
        {
            name: 'Sinhala',
            bmp: '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
            astral: '\uD804[\uDDE1-\uDDF4]'
        },
        {
            name: 'Sora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
        },
        {
            name: 'Sundanese',
            bmp: '\u1B80-\u1BBF\u1CC0-\u1CC7'
        },
        {
            name: 'Syloti_Nagri',
            bmp: '\uA800-\uA82B'
        },
        {
            name: 'Syriac',
            bmp: '\u0700-\u070D\u070F-\u074A\u074D-\u074F'
        },
        {
            name: 'Tagalog',
            bmp: '\u1700-\u170C\u170E-\u1714'
        },
        {
            name: 'Tagbanwa',
            bmp: '\u1760-\u176C\u176E-\u1770\u1772\u1773'
        },
        {
            name: 'Tai_Le',
            bmp: '\u1950-\u196D\u1970-\u1974'
        },
        {
            name: 'Tai_Tham',
            bmp: '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
        },
        {
            name: 'Tai_Viet',
            bmp: '\uAA80-\uAAC2\uAADB-\uAADF'
        },
        {
            name: 'Takri',
            astral: '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
        },
        {
            name: 'Tamil',
            bmp: '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
        },
        {
            name: 'Telugu',
            bmp: '\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
        },
        {
            name: 'Thaana',
            bmp: '\u0780-\u07B1'
        },
        {
            name: 'Thai',
            bmp: '\u0E01-\u0E3A\u0E40-\u0E5B'
        },
        {
            name: 'Tibetan',
            bmp: '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
        },
        {
            name: 'Tifinagh',
            bmp: '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
        },
        {
            name: 'Tirhuta',
            astral: '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
        },
        {
            name: 'Ugaritic',
            astral: '\uD800[\uDF80-\uDF9D\uDF9F]'
        },
        {
            name: 'Vai',
            bmp: '\uA500-\uA62B'
        },
        {
            name: 'Warang_Citi',
            astral: '\uD806[\uDCA0-\uDCF2\uDCFF]'
        },
        {
            name: 'Yi',
            bmp: '\uA000-\uA48C\uA490-\uA4C6'
        }
    ]);

};

},{}],184:[function(require,module,exports){
var XRegExp = require('./xregexp');

require('./addons/build')(XRegExp);
require('./addons/matchrecursive')(XRegExp);
require('./addons/unicode-base')(XRegExp);
require('./addons/unicode-blocks')(XRegExp);
require('./addons/unicode-categories')(XRegExp);
require('./addons/unicode-properties')(XRegExp);
require('./addons/unicode-scripts')(XRegExp);

module.exports = XRegExp;

},{"./addons/build":177,"./addons/matchrecursive":178,"./addons/unicode-base":179,"./addons/unicode-blocks":180,"./addons/unicode-categories":181,"./addons/unicode-properties":182,"./addons/unicode-scripts":183,"./xregexp":185}],185:[function(require,module,exports){
/*!
 * XRegExp 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2007-2016 MIT License
 */

'use strict';

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */

// ==--------------------------==
// Private stuff
// ==--------------------------==

// Property name used for extended regex instance data
var REGEX_DATA = 'xregexp';
// Optional features that can be installed and uninstalled
var features = {
    astral: false,
    natives: false
};
// Native methods to use and restore ('native' is an ES3 reserved keyword)
var nativ = {
    exec: RegExp.prototype.exec,
    test: RegExp.prototype.test,
    match: String.prototype.match,
    replace: String.prototype.replace,
    split: String.prototype.split
};
// Storage for fixed/extended native methods
var fixed = {};
// Storage for regexes cached by `XRegExp.cache`
var regexCache = {};
// Storage for pattern details cached by the `XRegExp` constructor
var patternCache = {};
// Storage for regex syntax tokens added internally or by `XRegExp.addToken`
var tokens = [];
// Token scopes
var defaultScope = 'default';
var classScope = 'class';
// Regexes that match native regex syntax, including octals
var nativeTokens = {
    // Any native multicharacter token in default scope, or any single character
    'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
    // Any native multicharacter token in character class scope, or any single character
    'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
};
// Any backreference or dollar-prefixed character in replacement strings
var replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g;
// Check for correct `exec` handling of nonparticipating capturing groups
var correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;
// Check for ES6 `flags` prop support
var hasFlagsProp = /x/.flags !== undefined;
// Shortcut to `Object.prototype.toString`
var toString = {}.toString;

function hasNativeFlag(flag) {
    // Can't check based on the presense of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    if (isSupported && flag === 'y') {
        // Work around Safari 9.1.1 bug
        return new RegExp('aa|.', 'y').test('b');
    }
    return isSupported;
}
// Check for ES6 `u` flag support
var hasNativeU = hasNativeFlag('u');
// Check for ES6 `y` flag support
var hasNativeY = hasNativeFlag('y');
// Tracker for known flags, including addon flags
var registeredFlags = {
    g: true,
    i: true,
    m: true,
    u: hasNativeU,
    y: hasNativeY
};

/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Augmented regex.
 */
function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
    var p;

    regex[REGEX_DATA] = {
        captureNames: captureNames
    };

    if (isInternalOnly) {
        return regex;
    }

    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
    if (regex.__proto__) {
        regex.__proto__ = XRegExp.prototype;
    } else {
        for (p in XRegExp.prototype) {
            // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
            // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
            // extensions exist on `regex.prototype` anyway
            regex[p] = XRegExp.prototype[p];
        }
    }

    regex[REGEX_DATA].source = xSource;
    // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
    regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;

    return regex;
}

/**
 * Removes any duplicate characters from the provided string.
 *
 * @param {String} str String to remove duplicate characters from.
 * @returns {String} String with any duplicate characters removed.
 */
function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}

/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`addG` {Boolean} Add flag g while copying the regex.
 *   <li>`addY` {Boolean} Add flag y while copying the regex.
 *   <li>`removeG` {Boolean} Remove flag g while copying the regex.
 *   <li>`removeY` {Boolean} Remove flag y while copying the regex.
 *   <li>`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */
function copyRegex(regex, options) {
    if (!XRegExp.isRegExp(regex)) {
        throw new TypeError('Type RegExp expected');
    }

    var xData = regex[REGEX_DATA] || {},
        flags = getNativeFlags(regex),
        flagsToAdd = '',
        flagsToRemove = '',
        xregexpSource = null,
        xregexpFlags = null;

    options = options || {};

    if (options.removeG) {flagsToRemove += 'g';}
    if (options.removeY) {flagsToRemove += 'y';}
    if (flagsToRemove) {
        flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');
    }

    if (options.addG) {flagsToAdd += 'g';}
    if (options.addY) {flagsToAdd += 'y';}
    if (flagsToAdd) {
        flags = clipDuplicates(flags + flagsToAdd);
    }

    if (!options.isInternalOnly) {
        if (xData.source !== undefined) {
            xregexpSource = xData.source;
        }
        // null or undefined; don't want to add to `flags` if the previous value was null, since
        // that indicates we're not tracking original precompilation flags
        if (xData.flags != null) {
            // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never
            // removed for non-internal regexes, so don't need to handle it
            xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
        }
    }

    // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid
    // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and
    // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the
    // translation to native regex syntax
    regex = augment(
        new RegExp(regex.source, flags),
        hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,
        xregexpSource,
        xregexpFlags,
        options.isInternalOnly
    );

    return regex;
}

/**
 * Converts hexadecimal to decimal.
 *
 * @param {String} hex
 * @returns {Number}
 */
function dec(hex) {
    return parseInt(hex, 16);
}

/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @param {RegExp} regex Regex to check.
 * @returns {String} Native flags in use.
 */
function getNativeFlags(regex) {
    return hasFlagsProp ?
        regex.flags :
        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
        // with an empty string) allows this to continue working predictably when
        // `XRegExp.proptotype.toString` is overriden
        nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
}

/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @param {RegExp} regex Regex to check.
 * @returns {Boolean} Whether the regex uses named capture.
 */
function hasNamedCapture(regex) {
    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
}

/**
 * Converts decimal to hexadecimal.
 *
 * @param {Number|String} dec
 * @returns {String}
 */
function hex(dec) {
    return parseInt(dec, 10).toString(16);
}

/**
 * Returns the first index at which a given value can be found in an array.
 *
 * @param {Array} array Array to search.
 * @param {*} value Value to locate in the array.
 * @returns {Number} Zero-based index at which the item is found, or -1.
 */
function indexOf(array, value) {
    var len = array.length, i;

    for (i = 0; i < len; ++i) {
        if (array[i] === value) {
            return i;
        }
    }

    return -1;
}

/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {Boolean} Whether the object matches the type.
 */
function isType(value, type) {
    return toString.call(value) === '[object ' + type + ']';
}

/**
 * Checks whether the next nonignorable token after the specified position is a quantifier.
 *
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @returns {Boolean} Whether the next token is a quantifier.
 */
function isQuantifierNext(pattern, pos, flags) {
    return nativ.test.call(
        flags.indexOf('x') > -1 ?
            // Ignore any leading whitespace, line comments, and inline comments
            /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ :
            // Ignore any leading inline comments
            /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/,
        pattern.slice(pos)
    );
}

/**
 * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.
 *
 * @param {String} str
 * @returns {String}
 */
function pad4(str) {
    while (str.length < 4) {
        str = '0' + str;
    }
    return str;
}

/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {Object} Object with properties `pattern` and `flags`.
 */
function prepareFlags(pattern, flags) {
    var i;

    // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
    if (clipDuplicates(flags) !== flags) {
        throw new SyntaxError('Invalid duplicate regex flag ' + flags);
    }

    // Strip and apply a leading mode modifier with any combination of flags except g or y
    pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
        if (nativ.test.call(/[gy]/, $1)) {
            throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
        }
        // Allow duplicate flags within the mode modifier
        flags = clipDuplicates(flags + $1);
        return '';
    });

    // Throw on unknown native or nonnative flags
    for (i = 0; i < flags.length; ++i) {
        if (!registeredFlags[flags.charAt(i)]) {
            throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));
        }
    }

    return {
        pattern: pattern,
        flags: flags
    };
}

/**
 * Prepares an options object from the given value.
 *
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */
function prepareOptions(value) {
    var options = {};

    if (isType(value, 'String')) {
        XRegExp.forEach(value, /[^\s,]+/, function(match) {
            options[match] = true;
        });

        return options;
    }

    return value;
}

/**
 * Registers a flag so it doesn't throw an 'unknown flag' error.
 *
 * @param {String} flag Single-character flag to register.
 */
function registerFlag(flag) {
    if (!/^[\w$]$/.test(flag)) {
        throw new Error('Flag must be a single character A-Za-z0-9_$');
    }

    registeredFlags[flag] = true;
}

/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: 'default' or 'class'.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */
function runTokens(pattern, flags, pos, scope, context) {
    var i = tokens.length,
        leadChar = pattern.charAt(pos),
        result = null,
        match,
        t;

    // Run in reverse insertion order
    while (i--) {
        t = tokens[i];
        if (
            (t.leadChar && t.leadChar !== leadChar) ||
            (t.scope !== scope && t.scope !== 'all') ||
            (t.flag && flags.indexOf(t.flag) === -1)
        ) {
            continue;
        }

        match = XRegExp.exec(pattern, t.regex, pos, 'sticky');
        if (match) {
            result = {
                matchLength: match[0].length,
                output: t.handler.call(context, match, scope, flags),
                reparse: t.reparse
            };
            // Finished with token tests
            break;
        }
    }

    return result;
}

/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setAstral(on) {
    features.astral = on;
}

/**
 * Enables or disables native method overrides.
 *
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setNatives(on) {
    RegExp.prototype.exec = (on ? fixed : nativ).exec;
    RegExp.prototype.test = (on ? fixed : nativ).test;
    String.prototype.match = (on ? fixed : nativ).match;
    String.prototype.replace = (on ? fixed : nativ).replace;
    String.prototype.split = (on ? fixed : nativ).split;

    features.natives = on;
}

/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */
function toObject(value) {
    // null or undefined
    if (value == null) {
        throw new TypeError('Cannot convert null or undefined to object');
    }

    return value;
}

// ==--------------------------==
// Constructor
// ==--------------------------==

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     <li>`g` - global
 *     <li>`i` - ignore case
 *     <li>`m` - multiline anchors
 *     <li>`u` - unicode (ES6)
 *     <li>`y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     <li>`n` - explicit capture
 *     <li>`s` - dot matches all (aka singleline)
 *     <li>`x` - free-spacing and line comments (aka extended)
 *     <li>`A` - astral (requires the Unicode Base addon)
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \n\
 *          (?<month> [0-9]{2} ) -?  # month \n\
 *          (?<day>   [0-9]{2} )     # day   ', 'x');
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */
function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError('Cannot supply flags when copying a RegExp');
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? '' : String(pattern);
    flags = flags === undefined ? '' : String(flags);

    if (XRegExp.isInstalled('astral') && flags.indexOf('A') === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += 'A';
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = '';
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp's tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos < appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result && result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result && result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                output += token;
                pos += token.length;
                if (token === '[' && scope === defaultScope) {
                    scope = classScope;
                } else if (token === ']' && scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}

// Add `RegExp.prototype` to the prototype chain
XRegExp.prototype = new RegExp();

// ==--------------------------==
// Public properties
// ==--------------------------==

/**
 * The XRegExp version number as a string containing three dot-separated parts. For example,
 * '2.0.0-beta-3'.
 *
 * @static
 * @type String
 */
XRegExp.version = '3.1.1';

// ==--------------------------==
// Public methods
// ==--------------------------==

// Intentionally undocumented; used in tests and addons
XRegExp._hasNativeFlag = hasNativeFlag;
XRegExp._dec = dec;
XRegExp._hex = hex;
XRegExp._pad4 = pad4;

/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The regex scope where the match was found: 'default' or 'class'.
 *   <li>The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
 *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
 *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an 'unknown flag' error when any of the flags are used.
 *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   <li>`leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn't change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token's performance
 *     since the token can be skipped at any positions where this character doesn't appear.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   function() {return '\\x07';},
 *   {scope: 'all'}
 * );
 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
 * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of
 * // character classes only)
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   function(match) {return match[1] + (match[2] ? '' : '?');},
 *   {flag: 'U'}
 * );
 * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
 * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
 */
XRegExp.addToken = function(regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags, i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i < optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
};

/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
};

// Intentionally undocumented; used in tests
XRegExp.cache.flush = function(cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
};

/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any point within a regex that uses any flags.
 *
 * @param {String} str String to escape.
 * @returns {String} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape('Escaped? <.>');
 * // -> 'Escaped\?\ <\.>'
 */
XRegExp.escape = function(str) {
    return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named backreference properties are included on the match array.
 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
 * must start at the specified position only. The `lastIndex` property of the provided regex is not
 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named backreference properties, or `null`.
 * @example
 *
 * // Basic use, with named backreference
 * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
 * match.hex; // -> '2620'
 *
 * // With pos and sticky, in a loop
 * var pos = 2, result = [], match;
 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -> ['2', '3', '4']
 */
XRegExp.exec = function(str, regex, pos, sticky) {
    var cacheKey = 'g',
        addY = false,
        match,
        r2;

    addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));
    if (addY) {
        cacheKey += 'y';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    r2.lastIndex = pos = pos || 0;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    if (sticky && match && match.index !== pos) {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
};

/**
 * Executes a provided function once per regex match. Searches always start at the beginning of the
 * string and continue until the end, regardless of the state of the regex's `global` property and
 * initial `lastIndex`.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The zero-based match index.
 *   <li>The string being traversed.
 *   <li>The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * var evens = [];
 * XRegExp.forEach('1a2345', /\d/, function(match, i) {
 *   if (i % 2) evens.push(+match[0]);
 * });
 * // evens -> [2, 4]
 */
XRegExp.forEach = function(str, regex, callback) {
    var pos = 0,
        i = -1,
        match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
};

/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -> true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
 * Installs optional features according to the specified options. Can be undone using
 * `XRegExp.uninstall`.
 *
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // DEPRECATED: Overrides native regex methods with fixed/extended versions
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.install('astral natives');
 */
XRegExp.install = function(options) {
    options = prepareOptions(options);

    if (!features.astral && options.astral) {
        setAstral(true);
    }

    if (!features.natives && options.natives) {
        setNatives(true);
    }
};

/**
 * Checks whether an individual optional feature is installed.
 *
 * @param {String} feature Name of the feature to check. One of:
 *   <li>`astral`
 *   <li>`natives`
 * @returns {Boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled('astral');
 */
XRegExp.isInstalled = function(feature) {
    return !!(features[feature]);
};

/**
 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @param {*} value Object to check.
 * @returns {Boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp('string'); // -> false
 * XRegExp.isRegExp(/regex/i); // -> true
 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
 */
XRegExp.isRegExp = function(value) {
    return toString.call(value) === '[object RegExp]';
    //return isType(value, 'RegExp');
};

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is 'all'.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match('abc', /\w/); // -> 'a'
 * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
 * XRegExp.match('abc', /x/g, 'one'); // -> null
 *
 * // Match all
 * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /x/, 'all'); // -> []
 */
XRegExp.match = function(str, regex, scope) {
    var global = (regex.global && scope !== 'one') || scope === 'all',
        cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',
        result,
        r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === 'one' && result) ?
                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result && result[0]);
};

/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and or objects with
 * `regex` and `backref` properties. When a backreference is specified, the named or numbered
 * backreference is passed forward to the next regex or returned.
 *
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within <b> tags
 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
 *   XRegExp('(?is)<b>.*?</b>'),
 *   /\d+/
 * ]);
 * // -> ['2', '4', '56']
 *
 * // Passing forward and returning specific backreferences
 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
 *         <a href="http://www.google.com/">Google</a>';
 * XRegExp.matchChain(html, [
 *   {regex: /<a href="([^"]+)">/i, backref: 1},
 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
 * ]);
 * // -> ['xregexp.com', 'www.google.com']
 */
XRegExp.matchChain = function(str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i < values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
};

/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement
 * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared
 * to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     <li>$$ - Inserts a literal $ character.
 *     <li>$&, $0 - Inserts the matched substring.
 *     <li>$` - Inserts the string that precedes the matched substring (left context).
 *     <li>$' - Inserts the string that follows the matched substring (right context).
 *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
 *       backreference n/nn.
 *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as
 *       properties of this first argument.
 *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
 *     <li>The zero-based index of the match within the total search string.
 *     <li>The total string being searched.
 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
 *   explicitly specified and using a regex with flag g, `scope` is 'all'.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
 * XRegExp.replace('John Smith', name, '${last}, ${first}');
 * // -> 'Smith, John'
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace('John Smith', name, function(match) {
 *   return match.last + ', ' + match.first;
 * });
 * // -> 'Smith, John'
 *
 * // String search, with replace-all
 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
 * // -> 'XRegExp builds XRegExps'
 */
XRegExp.replace = function(str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search),
        global = (search.global && scope !== 'one') || scope === 'all',
        cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY',
        s2 = search,
        result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex && search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
};

/**
 * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an
 * array of replacement details. Later replacements operate on the output of earlier replacements.
 * Replacement details are accepted as an array with a regex or string to search for, the
 * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `${name}`.
 *
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp('(?<name>a)'), 'z${name}'],
 *   [/b/gi, 'y'],
 *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
 *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
 *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
 *   [/f/g, function($0) {
 *     return $0.toUpperCase();
 *   }]
 * ]);
 */
XRegExp.replaceEach = function(str, replacements) {
    var i, r;

    for (i = 0; i < replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
};

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split('a b c', ' ');
 * // -> ['a', 'b', 'c']
 *
 * // With limit
 * XRegExp.split('a b c', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', '..']
 */
XRegExp.split = function(str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
};

/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test('abc', /c/); // -> true
 *
 * // With pos and sticky
 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
 * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true
 */
XRegExp.test = function(str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
};

/**
 * Uninstalls optional features according to the specified options. All optional features start out
 * uninstalled, so this is used to undo the actions of `XRegExp.install`.
 *
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons
 *   astral: true,
 *
 *   // DEPRECATED: Restores native regex methods
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall('astral natives');
 */
XRegExp.uninstall = function(options) {
    options = prepareOptions(options);

    if (features.astral && options.astral) {
        setAstral(false);
    }

    if (features.natives && options.natives) {
        setNatives(false);
    }
};

/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
 */
XRegExp.union = function(patterns, flags) {
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?<' + name + '>';
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') && patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g;
    var output = [];
    var pattern;
    for (var i = 0; i < patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    return XRegExp(output.join('|'), flags);
};

// ==--------------------------==
// Fixed/extended native methods
// ==--------------------------==

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
 * override the native method. Use via `XRegExp.exec` without overriding natives.
 *
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */
fixed.exec = function(str) {
    var origLastIndex = this.lastIndex,
        match = nativ.exec.apply(this, arguments),
        name,
        r2,
        i;

    if (match) {
        // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing
        // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9
        // in standards mode follows the spec.
        if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
            r2 = copyRegex(this, {
                removeG: true,
                isInternalOnly: true
            });
            // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
            // matching due to characters outside the match
            nativ.replace.call(String(str).slice(match.index), r2, function() {
                var len = arguments.length, i;
                // Skip index 0 and the last 2
                for (i = 1; i < len - 2; ++i) {
                    if (arguments[i] === undefined) {
                        match[i] = undefined;
                    }
                }
            });
        }

        // Attach named capture properties
        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
            // Skip index 0
            for (i = 1; i < match.length; ++i) {
                name = this[REGEX_DATA].captureNames[i - 1];
                if (name) {
                    match[name] = match[i];
                }
            }
        }

        // Fix browsers that increment `lastIndex` after zero-length matches
        if (this.global && !match[0].length && (this.lastIndex > match.index)) {
            this.lastIndex = match.index;
        }
    }

    if (!this.global) {
        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
        this.lastIndex = origLastIndex;
    }

    return match;
};

/**
 * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
 * uses this to override the native method.
 *
 * @param {String} str String to search.
 * @returns {Boolean} Whether the regex matched the provided value.
 */
fixed.test = function(str) {
    // Do this the easy way :-)
    return !!fixed.exec.call(this, str);
};

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
 * override the native method.
 *
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */
fixed.match = function(regex) {
    var result;

    if (!XRegExp.isRegExp(regex)) {
        // Use the native `RegExp` rather than `XRegExp`
        regex = new RegExp(regex);
    } else if (regex.global) {
        result = nativ.match.apply(this, arguments);
        // Fixes IE bug
        regex.lastIndex = 0;

        return result;
    }

    return fixed.exec.call(regex, toObject(this));
};

/**
 * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
 * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser
 * bugs in replacement text syntax when performing a replacement using a nonregex search value, and
 * the value of a replacement regex's `lastIndex` property during replacement iterations and upon
 * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note
 * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via
 * `XRegExp.replace` without overriding natives.
 *
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {String} New string with one or all matches replaced.
 */
fixed.replace = function(search, replacement) {
    var isRegex = XRegExp.isRegExp(search),
        origLastIndex,
        captureNames,
        result;

    if (isRegex) {
        if (search[REGEX_DATA]) {
            captureNames = search[REGEX_DATA].captureNames;
        }
        // Only needed if `search` is nonglobal
        origLastIndex = search.lastIndex;
    } else {
        search += ''; // Type-convert
    }

    // Don't use `typeof`; some older browsers return 'function' for regex objects
    if (isType(replacement, 'Function')) {
        // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
        // functions isn't type-converted to a string
        result = nativ.replace.call(String(this), search, function() {
            var args = arguments, i;
            if (captureNames) {
                // Change the `arguments[0]` string primitive to a `String` object that can store
                // properties. This really does need to use `String` as a constructor
                args[0] = new String(args[0]);
                // Store named backreferences on the first argument
                for (i = 0; i < captureNames.length; ++i) {
                    if (captureNames[i]) {
                        args[0][captureNames[i]] = args[i + 1];
                    }
                }
            }
            // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari
            // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
            if (isRegex && search.global) {
                search.lastIndex = args[args.length - 2] + args[0].length;
            }
            // ES6 specs the context for replacement functions as `undefined`
            return replacement.apply(undefined, args);
        });
    } else {
        // Ensure that the last value of `args` will be a string when given nonstring `this`,
        // while still throwing on null or undefined context
        result = nativ.replace.call(this == null ? this : String(this), search, function() {
            // Keep this function's `arguments` available through closure
            var args = arguments;
            return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {
                var n;
                // Named or numbered backreference with curly braces
                if ($1) {
                    // XRegExp behavior for `${n}`:
                    // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the
                    //    entire match. Any number of leading zeros may be used.
                    // 2. Backreference to named capture `n`, if it exists and is not an integer
                    //    overridden by numbered capture. In practice, this does not overlap with
                    //    numbered capture since XRegExp does not allow named capture to use a bare
                    //    integer as the name.
                    // 3. If the name or number does not refer to an existing capturing group, it's
                    //    an error.
                    n = +$1; // Type-convert; drop leading zeros
                    if (n <= args.length - 3) {
                        return args[n] || '';
                    }
                    // Groups with the same name is an error, else would need `lastIndexOf`
                    n = captureNames ? indexOf(captureNames, $1) : -1;
                    if (n < 0) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[n + 1] || '';
                }
                // Else, special variable or numbered backreference without curly braces
                if ($2 === '$') { // $$
                    return '$';
                }
                if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00
                    return args[0];
                }
                if ($2 === '`') { // $` (left context)
                    return args[args.length - 1].slice(0, args[args.length - 2]);
                }
                if ($2 === "'") { // $' (right context)
                    return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                }
                // Else, numbered backreference without curly braces
                $2 = +$2; // Type-convert; drop leading zero
                // XRegExp behavior for `$n` and `$nn`:
                // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.
                // - `$1` is an error if no capturing groups.
                // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.
                // - `$01` is `$1` if at least one capturing group, else it's an error.
                // - `$0` (not followed by 1-9) and `$00` are the entire match.
                // Native behavior, for comparison:
                // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                // - `$1` is a literal `$1` if no capturing groups.
                // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                // - `$0` is a literal `$0`.
                if (!isNaN($2)) {
                    if ($2 > args.length - 3) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[$2] || '';
                }
                // `$` followed by an unsupported char is an error, unlike native JS
                throw new SyntaxError('Invalid token ' + $0);
            });
        });
    }

    if (isRegex) {
        if (search.global) {
            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
            search.lastIndex = 0;
        } else {
            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
            search.lastIndex = origLastIndex;
        }
    }

    return result;
};

/**
 * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
 * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
 *
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 */
fixed.split = function(separator, limit) {
    if (!XRegExp.isRegExp(separator)) {
        // Browsers handle nonregex split correctly, so use the faster native method
        return nativ.split.apply(this, arguments);
    }

    var str = String(this),
        output = [],
        origLastIndex = separator.lastIndex,
        lastLastIndex = 0,
        lastLength;

    // Values for `limit`, per the spec:
    // If undefined: pow(2,32) - 1
    // If 0, Infinity, or NaN: 0
    // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
    // If negative number: pow(2,32) - floor(abs(limit))
    // If other: Type-convert, then use the above rules
    // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless
    // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
    limit = (limit === undefined ? -1 : limit) >>> 0;

    XRegExp.forEach(str, separator, function(match) {
        // This condition is not the same as `if (match[0].length)`
        if ((match.index + match[0].length) > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = match.index + lastLength;
        }
    });

    if (lastLastIndex === str.length) {
        if (!nativ.test.call(separator, '') || lastLength) {
            output.push('');
        }
    } else {
        output.push(str.slice(lastLastIndex));
    }

    separator.lastIndex = origLastIndex;
    return output.length > limit ? output.slice(0, limit) : output;
};

// ==--------------------------==
// Built-in syntax/flag tokens
// ==--------------------------==

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */
XRegExp.addToken(
    /\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/,
    function(match, scope) {
        // \B is allowed in default scope only
        if (match[1] === 'B' && scope === defaultScope) {
            return match[0];
        }
        throw new SyntaxError('Invalid escape ' + match[0]);
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */
XRegExp.addToken(
    /\\u{([\dA-Fa-f]+)}/,
    function(match, scope, flags) {
        var code = dec(match[1]);
        if (code > 0x10FFFF) {
            throw new SyntaxError('Invalid Unicode code point ' + match[0]);
        }
        if (code <= 0xFFFF) {
            // Converting to \uNNNN avoids needing to escape the literal character and keep it
            // separate from preceding tokens
            return '\\u' + pad4(hex(code));
        }
        // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
        if (hasNativeU && flags.indexOf('u') > -1) {
            return match[0];
        }
        throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
 * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
 * character class endings can't be determined.
 */
XRegExp.addToken(
    /\[(\^?)]/,
    function(match) {
        // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
        // (?!) should work like \b\B, but is unreliable in some versions of Firefox
        return match[1] ? '[\\s\\S]' : '\\b\\B';
    },
    {leadChar: '['}
);

/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */
XRegExp.addToken(
    /\(\?#[^)]*\)/,
    function(match, scope, flags) {
        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.
        // inadvertedly changing `\1(?#)1` to `\11`.
        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
            '' : '(?:)';
    },
    {leadChar: '('}
);

/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */
XRegExp.addToken(
    /\s+|#[^\n]*\n?/,
    function(match, scope, flags) {
        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.
        // inadvertedly changing `\1 1` to `\11`.
        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
            '' : '(?:)';
    },
    {flag: 'x'}
);

/*
 * Dot, in dotall mode (aka singleline mode, flag s) only.
 */
XRegExp.addToken(
    /\./,
    function() {
        return '[\\s\\S]';
    },
    {
        flag: 's',
        leadChar: '.'
    }
);

/*
 * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
 * and $ only. Also allows numbered backreferences as `\k<n>`.
 */
XRegExp.addToken(
    /\\k<([\w$]+)>/,
    function(match) {
        // Groups with the same name is an error, else would need `lastIndexOf`
        var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1],
            endIndex = match.index + match[0].length;
        if (!index || index > this.captureNames.length) {
            throw new SyntaxError('Backreference to undefined group ' + match[0]);
        }
        // Keep backreferences separate from subsequent literal numbers. This avoids e.g.
        // inadvertedly changing `(?<n>)\k<n>1` to `()\11`.
        return '\\' + index + (
            endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?
                '' : '(?:)'
        );
    },
    {leadChar: '\\'}
);

/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
 */
XRegExp.addToken(
    /\\(\d+)/,
    function(match, scope) {
        if (
            !(
                scope === defaultScope &&
                /^[1-9]/.test(match[1]) &&
                +match[1] <= this.captureNames.length
            ) &&
            match[1] !== '0'
        ) {
            throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +
                match[0]);
        }
        return match[0];
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
 * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
 * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */
XRegExp.addToken(
    /\(\?P?<([\w$]+)>/,
    function(match) {
        // Disallow bare integers as names because named backreferences are added to match arrays
        // and therefore numeric properties may lead to incorrect lookups
        if (!isNaN(match[1])) {
            throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
        }
        if (match[1] === 'length' || match[1] === '__proto__') {
            throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
        }
        if (indexOf(this.captureNames, match[1]) > -1) {
            throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
        }
        this.captureNames.push(match[1]);
        this.hasNamedCapture = true;
        return '(';
    },
    {leadChar: '('}
);

/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds explicit capture mode (flag n).
 */
XRegExp.addToken(
    /\((?!\?)/,
    function(match, scope, flags) {
        if (flags.indexOf('n') > -1) {
            return '(?:';
        }
        this.captureNames.push(null);
        return '(';
    },
    {
        optionalFlags: 'n',
        leadChar: '('
    }
);

module.exports = XRegExp;

},{}],186:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _theme = require('source/util/theme');

var _theme2 = _interopRequireDefault(_theme);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-button": {
        display: ['-webkit-inline-flex', 'inline-flex'],
        color: _theme2.default.button.text.color,
        padding: '0.7em 0.5em',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative',
        userSelect: 'none',
        borderRadius: 3,
        borderWidth: 0,
        overflow: 'hidden',
        marginLeft: 5,
        marginRight: 5
    },
    "doric-button:after": {
        content: '""',
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        transition: 'background-color 250ms linear'
    },
    "doric-button[pressed]:after": {
        backgroundColor: 'rgba(0, 0, 0, 0.25)',
        transition: 'none'
    },

    "doric-button[disabled]": {
        boxShadow: 'none'
    },
    "doric-button[raised]": {
        boxShadow: _theme2.default.general.boxShadow
    }
});
var Button = function Button(props) {
    var _props$text = props.text,
        text = _props$text === undefined ? null : _props$text,
        children = props.children,
        _props$className = props.className,
        className = _props$className === undefined ? "" : _props$className,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['text', 'children', 'className']);


    return _react2.default.createElement(
        _CustomEvents2.default,
        (0, _extends3.default)({ component: 'doric-button' }, passThrough, { 'class': className }),
        text,
        children
    );
};

exports.default = Button;

},{"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/component/CustomEvents":190,"source/util/app":203,"source/util/theme":211}],187:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _theme = require('source/util/theme');

var _theme2 = _interopRequireDefault(_theme);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-card": {
        display: 'block',
        boxShadow: _theme2.default.general.boxShadow,
        margin: 5,
        borderRadius: 3,
        overflow: 'hidden',
        backgroundColor: 'white'
    },
    "doric-card .content": {
        padding: 5
    },
    "doric-card .title": {
        position: 'relative',
        overflow: 'hidden',
        WebkitFontSmoothing: 'antialiased',
        fontWeight: 900,
        fontSize: 18,
        padding: 5,
        borderBottom: '1px solid lightgray'
    },
    "doric-card .actions": {
        padding: 5,
        borderTop: '1px solid lightgray'
    }
});
var Card = function Card(props) {
    var children = props.children,
        _props$title = props.title,
        title = _props$title === undefined ? null : _props$title,
        _props$actions = props.actions,
        actions = _props$actions === undefined ? null : _props$actions,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['children', 'title', 'actions']);

    var titleElement = null;
    var actionElement = null;

    if (title !== null) {
        titleElement = _react2.default.createElement(
            'div',
            { className: 'title' },
            title
        );
    }
    if (actions !== null) {
        actionElement = _react2.default.createElement(
            'div',
            { className: 'actions' },
            actions
        );
    }

    return _react2.default.createElement(
        'doric-card',
        passThrough,
        titleElement,
        _react2.default.createElement(
            'div',
            { className: 'content' },
            children
        ),
        actionElement
    );
};

exports.default = Card;

},{"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/util/app":203,"source/util/theme":211}],188:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _stylesheet = require('source/util/stylesheet');

var _ContentAligners = require('source/component/ContentAligners');

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

var _Icon = require('source/component/Icon');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-checkbox": {
        position: 'relative',
        display: 'block',
        userSelect: 'none'
    },
    "doric-checkbox[disabled='true']": {
        color: 'gray',
        opacity: 0.6
    },
    "doric-checkbox:after": {
        content: "''",
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        transition: _consts2.default.css.backgroundTransition
    },
    "doric-checkbox[pressed]:not([disabled='true']):after": {
        backgroundColor: _stylesheet.CSS.rgba(0, 0, 0, 0.25),
        transition: 'none'
    },
    "doric-checkbox doric-icon": {
        transition: 'color 250ms linear'
    },
    "doric-checkbox[checked='true']:not([disabled='true']) doric-icon": {
        color: _consts2.default.theme.bluish
    }
});
var Checkbox = function Checkbox(props) {
    var _ref;

    var _props$checked = props.checked,
        checked = _props$checked === undefined ? false : _props$checked,
        children = props.children,
        label = props.label,
        _props$onChange = props.onChange,
        onChange = _props$onChange === undefined ? warningFunc("Checkbox has no onChange function") : _props$onChange,
        _props$onIcon = props.onIcon,
        onIcon = _props$onIcon === undefined ? "ion-android-checkbox" : _props$onIcon,
        _props$offIcon = props.offIcon,
        offIcon = _props$offIcon === undefined ? "ion-android-checkbox-outline-blank" : _props$offIcon,
        _props$side = props.side,
        side = _props$side === undefined ? 'left' : _props$side,
        _props$className = props.className,
        className = _props$className === undefined ? "" : _props$className,
        _props$style = props.style,
        style = _props$style === undefined ? {} : _props$style,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['checked', 'children', 'label', 'onChange', 'onIcon', 'offIcon', 'side', 'className', 'style']);

    var change = function change() {
        if (props.disabled !== true) {
            onChange(checked === false);
        }
    };
    var iconName = checked === true ? onIcon : offIcon;
    var padding = (0, _defineProperty3.default)({
        padding: 5
    }, 'padding' + side.charAt(0).toUpperCase() + side.slice(1), 30);

    return _react2.default.createElement(
        _CustomEvents2.default,
        (0, _extends3.default)({ component: 'doric-checkbox', 'class': className, onTap: change }, passThrough, { style: (0, _extends3.default)({}, style, padding), checked: checked }),
        _react2.default.createElement(
            _ContentAligners.CenterContent,
            { 'data-no-press': true, style: (_ref = {}, (0, _defineProperty3.default)(_ref, side, 0), (0, _defineProperty3.default)(_ref, 'top', 0), (0, _defineProperty3.default)(_ref, 'position', 'absolute'), _ref), width: 30, height: '100%' },
            _react2.default.createElement(_Icon.Icon, { icon: iconName, 'data-no-press': true, style: { fontSize: 26 } })
        ),
        label,
        children
    );
};

exports.default = Checkbox;

},{"babel-runtime/helpers/defineProperty":232,"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/component/ContentAligners":189,"source/component/CustomEvents":190,"source/component/Icon":192,"source/util/app":203,"source/util/consts":205,"source/util/stylesheet":210}],189:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlignContent = exports.CenterContent = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-center-content": {
        display: ['-webkit-inline-flex', 'inline-flex'],
        alignItems: 'center',
        justifyContent: 'center'
    },
    "doric-align-content": {
        display: ['-webkit-inline-flex', 'inline-flex']
    },
    "doric-center-content.block, doric-align-content.block": {
        display: ['-webkit-flex', 'flex']
    }
});
var CenterContent = function CenterContent(_ref) {
    var width = _ref.width,
        height = _ref.height,
        _ref$className = _ref.className,
        className = _ref$className === undefined ? "" : _ref$className,
        block = _ref.block,
        _ref$style = _ref.style,
        style = _ref$style === undefined ? {} : _ref$style,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['width', 'height', 'className', 'block', 'style']);
    return _react2.default.createElement('doric-center-content', (0, _extends3.default)({ 'class': ((block ? "block" : "") + ' ' + className).trim() }, passThrough, { style: (0, _extends3.default)({}, style, { width: width, height: height }) }));
};
var AlignContent = function AlignContent(_ref2) {
    var width = _ref2.width,
        height = _ref2.height,
        _ref2$className = _ref2.className,
        className = _ref2$className === undefined ? "" : _ref2$className,
        block = _ref2.block,
        _ref2$horizontal = _ref2.horizontal,
        horizontal = _ref2$horizontal === undefined ? "center" : _ref2$horizontal,
        _ref2$vertical = _ref2.vertical,
        vertical = _ref2$vertical === undefined ? "center" : _ref2$vertical,
        _ref2$style = _ref2.style,
        style = _ref2$style === undefined ? {} : _ref2$style,
        passThrough = (0, _objectWithoutProperties3.default)(_ref2, ['width', 'height', 'className', 'block', 'horizontal', 'vertical', 'style']);
    return _react2.default.createElement('doric-align-content', (0, _extends3.default)({
        'class': ((block ? "block" : "") + ' ' + className).trim()
    }, passThrough, {
        style: (0, _extends3.default)({}, style, {
            width: width,
            height: height,
            WebkitAlignItems: vertical,
            WebkitJustifyContent: horizontal,
            alignItems: vertical,
            justifyContent: horizontal
        }) }));
};

exports.CenterContent = CenterContent;
exports.AlignContent = AlignContent;

},{"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/util/app":203}],190:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var traverse = function traverse(node, evt, handlers) {
    var triggers = [];
    var current = node;
    var cont = true;

    evt.stopPropagation();
    evt.stopPropagation = function () {
        return cont = false;
    };
    while (cont == true && current !== document.body && current !== null && current !== undefined) {
        if (handlers.has(current.dataset.synthId) === true) {
            handlers.get(current.dataset.synthId)(evt);
        }
        current = current.parentNode;
    }
};
var handlers = {};
var nextID = 0;
var genID = function genID() {
    nextID += 1;
    return nextID.toString();
};
var registerHandler = function registerHandler(type, id, handler) {
    if (handlers[type] === undefined) {
        window.addEventListener(type, function (evt) {
            return traverse(evt.target, evt, handlers[evt.type.toLowerCase()]);
        }, true);
        handlers[type] = new _map2.default();
    }
    handlers[type].set(id, handler);
};
var unregisterHandlers = function unregisterHandlers(id) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)((0, _values2.default)(handlers)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var mapping = _step.value;

            mapping.delete(id);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};
window.showHandlers = function () {
    return cblog(handlers);
};

var nativeEvents = new _set2.default(['onCut', 'onCopy', 'onPaste', 'onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onFocus', 'onBlur', 'onChange', 'onInput', 'onSubmit', 'onClick', 'onContextMenu', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onSelect', 'onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart', 'onScroll', 'onWheel', 'onAbort', 'onCanPlay', 'onCanPlayThrough', 'onDurationChange', 'onEmptied', 'onEncrypted', 'onEnded', 'onError', 'onLoadedData', 'onLoadedMetadata', 'onLoadStart', 'onPause', 'onPlay', 'onPlaying', 'onProgress', 'onRateChange', 'onSeeked', 'onSeeking', 'onStalled', 'onSuspend', 'onTimeUpdate', 'onVolumeChange', 'onWaiting', 'onAnimationStart', 'onAnimationEnd', 'onAnimationIteration', 'onTransitionEnd']);

var CustomEvents = function (_React$Component) {
    (0, _inherits3.default)(CustomEvents, _React$Component);

    function CustomEvents(props) {
        (0, _classCallCheck3.default)(this, CustomEvents);

        var _this = (0, _possibleConstructorReturn3.default)(this, (CustomEvents.__proto__ || (0, _getPrototypeOf2.default)(CustomEvents)).call(this, props));

        _initialiseProps.call(_this);

        _this.id = genID();
        return _this;
    }

    return CustomEvents;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.updateCallbacks = function () {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(_this2.props)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var key = _step2.value;

                if (key.slice(0, 2) === 'on' && nativeEvents.has(key) === false) {
                    registerHandler(key.slice(2).toLowerCase(), _this2.id, _this2.props[key]);
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    };

    this.componentDidMount = function () {
        _this2.updateCallbacks();
        if (_reactDom2.default.findDOMNode(_this2).dataset.synthId === undefined) {
            console.warn(_this2.props.component.name + ' must pass the data-synth-id prop into the DOM elements rendered');
        }
    };

    this.componentDidUpdate = function () {
        unregisterHandlers(_this2.id);
        _this2.updateCallbacks();
    };

    this.componentWillUnmount = function () {
        unregisterHandlers(_this2.id);
    };

    this.render = function () {
        if ((_this2.props.component || null) === null) {
            throw new Error("component must be passed into CustomEvents");
        }
        var Component = _this2.props.component;
        var props = (0, _keys2.default)(_this2.props).reduce(function (p, key) {
            if (key !== 'component' && key.slice(0, 2) !== 'on' || nativeEvents.has(key) === true) {
                p[key] = _this2.props[key];
            }
            return p;
        }, {});
        return _react2.default.createElement(Component, (0, _extends3.default)({ 'data-synth-id': _this2.id }, props));
    };
};

exports.default = CustomEvents;

},{"babel-runtime/core-js/get-iterator":215,"babel-runtime/core-js/map":217,"babel-runtime/core-js/object/get-prototype-of":223,"babel-runtime/core-js/object/keys":224,"babel-runtime/core-js/object/values":226,"babel-runtime/core-js/set":228,"babel-runtime/helpers/classCallCheck":231,"babel-runtime/helpers/extends":233,"babel-runtime/helpers/inherits":234,"babel-runtime/helpers/possibleConstructorReturn":236,"react":176,"react-dom":25}],191:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-grid": {
        display: 'block',
        overflow: 'auto'
    },
    "doric-grid-item": {
        display: 'inline-block',
        margin: 0,
        padding: 0,
        borderWidth: 0,
        borderStyle: 'solid',
        borderColor: 'transparent',
        overflow: 'hidden',
        position: 'relative',
        top: 0,
        left: 0,
        float: 'left'
    }
});

var Grid = function Grid(props) {
    var _props$cellSpacing = props.cellSpacing,
        cellSpacing = _props$cellSpacing === undefined ? [0, 0] : _props$cellSpacing,
        _props$cellHeight = props.cellHeight,
        cellHeight = _props$cellHeight === undefined ? 30 : _props$cellHeight,
        _props$colCount = props.colCount,
        colCount = _props$colCount === undefined ? 12 : _props$colCount,
        _props$style = props.style,
        style = _props$style === undefined ? {} : _props$style;

    var _ref = typeof cellSpacing === 'number' ? [cellSpacing, cellSpacing] : cellSpacing,
        _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        cellSpacingH = _ref2[0],
        cellSpacingV = _ref2[1];

    var gridStyle = (0, _extends3.default)({}, style, {
        paddingLeft: cellSpacingH,
        paddingTop: cellSpacingV
    });
    var baseItemStyle = {
        borderWidth: cellSpacingV + 'px ' + cellSpacingH + 'px'
    };
    var children = props.children;


    if (cellHeight !== null) {
        baseItemStyle.height = cellHeight + cellSpacingV * 2;
    }

    children = _react2.default.Children.toArray(children);
    children = children.map(function (child) {
        var _child$props = child.props,
            _child$props$colSpan = _child$props.colSpan,
            colSpan = _child$props$colSpan === undefined ? 1 : _child$props$colSpan,
            childProps = (0, _objectWithoutProperties3.default)(_child$props, ['colSpan']);

        var width = 'calc(' + colSpan * 100 / colCount + '% + ' + cellSpacingH + 'px)';
        var marginLeft = -cellSpacingH;
        var marginTop = -cellSpacingV;
        return _react2.default.createElement(
            'doric-grid-item',
            { style: (0, _extends3.default)({}, baseItemStyle, { width: width, marginTop: marginTop, marginLeft: marginLeft }) },
            _react2.default.createElement(child.type, childProps)
        );
    });

    return _react2.default.createElement(
        'doric-grid',
        { style: gridStyle },
        children
    );
};

exports.default = Grid;

},{"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"babel-runtime/helpers/slicedToArray":237,"react":176,"source/util/app":203}],192:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IconButton = exports.Icon = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _icons = require('source/util/icons');

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-icon": {
        display: 'inline',
        fontSize: 18,
        fontFamily: "Ionic"
    }
});
var Icon = function Icon(_ref) {
    var icon = _ref.icon,
        className = _ref.className,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['icon', 'className']);
    return _react2.default.createElement(
        'doric-icon',
        (0, _extends3.default)({}, passThrough, { 'class': className }),
        _icons2.default[icon]
    );
};
var IconButton = function IconButton(_ref2) {
    var icon = _ref2.icon,
        _ref2$text = _ref2.text,
        text = _ref2$text === undefined ? "" : _ref2$text,
        children = _ref2.children,
        props = (0, _objectWithoutProperties3.default)(_ref2, ['icon', 'text', 'children']);
    return _react2.default.createElement(
        Button,
        (0, _extends3.default)({}, props, { text: _react2.default.createElement(Icon, { icon: icon }) }),
        text,
        children
    );
};

exports.Icon = Icon;
exports.IconButton = IconButton;

},{"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/util/app":203,"source/util/icons":209}],193:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-image": {
        display: 'inline-block',
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center center'
    }
});
var Image = function Image(_ref) {
    var source = _ref.source,
        _ref$cover = _ref.cover,
        cover = _ref$cover === undefined ? false : _ref$cover,
        _ref$contain = _ref.contain,
        contain = _ref$contain === undefined ? false : _ref$contain,
        _ref$width = _ref.width,
        width = _ref$width === undefined ? null : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? null : _ref$height,
        _ref$style = _ref.style,
        style = _ref$style === undefined ? {} : _ref$style,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['source', 'cover', 'contain', 'width', 'height', 'style']);

    var bgSize = 'contain';

    if (cover === true && contain === false) {
        bgSize = 'cover';
    }

    return _react2.default.createElement('doric-image', (0, _extends3.default)({ style: (0, _extends3.default)({}, style, { backgroundImage: 'url("' + source + '")', width: width, height: height, backgroundSize: bgSize }) }, passThrough));
};

exports.default = Image;

},{"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/util/app":203}],194:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _doricInput;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-input": (_doricInput = {
        display: 'inline-block',
        position: 'relative',
        top: 0,
        left: 0
    }, (0, _defineProperty3.default)(_doricInput, 'display', 'block'), (0, _defineProperty3.default)(_doricInput, 'margin', 3), (0, _defineProperty3.default)(_doricInput, 'paddingTop', 22), (0, _defineProperty3.default)(_doricInput, 'backgroundColor', 'white'), _doricInput),
    "doric-input > input": {
        width: '100%',
        borderWidth: 0,
        padding: 5,
        borderBottom: '2px solid ' + _consts2.default.theme.grayBG,
        backgroundColor: 'transparent',
        position: 'relative',
        top: 0,
        left: 0,
        zIndex: "+1"
    },
    "doric-input > input:focus": {
        outline: 'none'
    },
    "doric-input > doric-input-label": {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: 22,
        transformOrigin: 'left top',
        transform: 'translate(0, 3px) scale(0.85)',
        transition: 'transform 150ms linear'
    },
    "doric-input > input:focus ~ doric-input-label:not([placeholder])": {
        color: '#435dec'
    },
    "doric-input > doric-input-label[placeholder]": {
        transform: 'translate(5px, 100%)',
        color: 'gray'
    },
    "doric-input > input + doric-input-flourish": {
        position: 'absolute',
        height: 2,
        backgroundColor: _consts2.default.theme.bluish,
        left: 0,
        right: 0,
        bottom: 0,
        transform: 'scaleX(0)',
        zIndex: "+2"
    },
    "doric-input > input:focus + doric-input-flourish": {
        transition: 'transform 100ms linear',
        transform: 'scaleX(1)'
    }
});

var TextInput = function (_React$Component) {
    (0, _inherits3.default)(TextInput, _React$Component);

    function TextInput(props) {
        (0, _classCallCheck3.default)(this, TextInput);

        var _this = (0, _possibleConstructorReturn3.default)(this, (TextInput.__proto__ || (0, _getPrototypeOf2.default)(TextInput)).call(this, props));

        _this.render = function () {
            var _this$props = _this.props,
                _this$props$value = _this$props.value,
                value = _this$props$value === undefined ? "" : _this$props$value,
                _this$props$type = _this$props.type,
                type = _this$props$type === undefined ? "text" : _this$props$type,
                _this$props$label = _this$props.label,
                label = _this$props$label === undefined ? null : _this$props$label;

            var labelProps = {
                placeholder: value === "" || value === null ? "" : null
            };
            var poc = _this.props.onChange || function () {};
            var onChange = function onChange(evt) {
                return poc(evt.target.value, evt);
            };

            return _react2.default.createElement(
                _CustomEvents2.default,
                { component: 'doric-input', onTap: function onTap() {
                        return _this.refs.textInput.focus();
                    } },
                _react2.default.createElement('input', (0, _extends3.default)({ type: type, onChange: onChange, value: value }, { ref: 'textInput' })),
                _react2.default.createElement('doric-input-flourish', null),
                _react2.default.createElement(
                    'doric-input-label',
                    labelProps,
                    label
                )
            );
        };

        return _this;
    }

    return TextInput;
}(_react2.default.Component);

var Input = {
    Text: function Text(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'text' }));
    },
    Password: function Password(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'password' }));
    },
    Search: function Search(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'search' }));
    },
    URL: function URL(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'url' }));
    },
    Email: function Email(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'email' }));
    },
    Number: function Number(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'number' }));
    }
};

exports.default = Input;

},{"babel-runtime/core-js/object/get-prototype-of":223,"babel-runtime/helpers/classCallCheck":231,"babel-runtime/helpers/defineProperty":232,"babel-runtime/helpers/extends":233,"babel-runtime/helpers/inherits":234,"babel-runtime/helpers/possibleConstructorReturn":236,"react":176,"source/component/CustomEvents":190,"source/util/app":203,"source/util/consts":205}],195:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-pinboard": {
        display: 'inline-block',
        position: 'relative',
        overflow: 'auto'
    },
    "doric-pin": {
        position: 'absolute'
    }
});
var Pinboard = function Pinboard(_ref) {
    var _ref$style = _ref.style,
        style = _ref$style === undefined ? {} : _ref$style,
        _ref$width = _ref.width,
        width = _ref$width === undefined ? "100%" : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? "100%" : _ref$height,
        _ref$className = _ref.className,
        className = _ref$className === undefined ? "" : _ref$className,
        children = _ref.children,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['style', 'width', 'height', 'className', 'children']);

    children = _react2.default.Children.toArray(children);

    children = children.map(function (child, index) {
        var _child$props = child.props,
            pinStyle = _child$props.pinStyle,
            childProps = (0, _objectWithoutProperties3.default)(_child$props, ['pinStyle']);

        var actualChild = _react2.default.createElement(child.type, childProps);
        return _react2.default.createElement(
            'doric-pin',
            { key: index, style: pinStyle },
            actualChild
        );
    });

    return _react2.default.createElement(
        'doric-pinboard',
        { 'class': className, style: (0, _extends3.default)({}, style, { width: width, height: height }) },
        children
    );
};

exports.default = Pinboard;

},{"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/util/app":203}],196:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-progress": {
        display: 'block',
        height: 10,
        backgroundColor: "#e0e0e0",
        marginTop: 10,
        marginBottom: 10,
        marginLeft: 5,
        marginRight: 5,
        position: 'relative'
    },
    "doric-progress-bar": {
        height: '100%',
        width: '100%',
        position: 'absolute',
        transformOrigin: 'left center',
        transition: 'transform 200ms ease-out'
    },
    "doric-progress-bar.primary": {
        backgroundColor: '#4285f4'
    },
    "doric-progress-bar.secondary": {
        backgroundColor: '#b3cefb'
    }
});
var Progress = function Progress(_ref) {
    var progress = _ref.progress,
        _ref$secondaryProgres = _ref.secondaryProgress,
        secondaryProgress = _ref$secondaryProgres === undefined ? null : _ref$secondaryProgres,
        className = _ref.className,
        children = _ref.children,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['progress', 'secondaryProgress', 'className', 'children']);

    var scale = 'scaleX(' + progress + ')';
    var secondaryProgressBar = null;

    if (secondaryProgress !== null) {
        var scale2 = 'scaleX(' + secondaryProgress + ')';
        secondaryProgressBar = _react2.default.createElement('doric-progress-bar', { 'class': 'secondary', style: { WebkitTransform: scale2, transform: scale2 } });
    }

    return _react2.default.createElement(
        'doric-progress',
        (0, _extends3.default)({ 'class': className }, passThrough),
        secondaryProgressBar,
        _react2.default.createElement('doric-progress-bar', { 'class': 'primary', style: { WebkitTransform: scale, transform: scale } })
    );
};

exports.default = Progress;

},{"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/util/app":203}],197:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var find = Array.prototype.find;
_app2.default.addStyles({
    "doric-slider": {
        display: 'block',
        position: 'relative',
        top: 0,
        left: 0,
        height: 30
    },
    "doric-slider-track": {
        position: 'absolute',
        top: 13,
        left: 12,
        right: 12,
        height: 4,
        backgroundColor: _consts2.default.theme.grayBG,
        overflow: 'visible'
    },
    "doric-slider-track-fill": {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        backgroundColor: _consts2.default.theme.bluish,
        transformOrigin: 'left center'
    },
    "doric-slider-thumb": {
        position: 'absolute',
        top: 2,
        width: '100%',
        height: 0,
        overflow: 'visible'
    },
    "doric-slider-track-circle": {
        display: 'block',
        width: 20,
        height: 20,
        borderRadius: 15,
        backgroundColor: _consts2.default.theme.bluish,
        boxShadow: '1px 1px 1px rgba(0, 0, 0, 0.25)',
        transform: 'translate(-50%, -50%)'
    },
    "doric-slider-value": {
        position: 'absolute',
        width: 30,
        height: 20,
        fontSize: 10,
        textAlign: 'center',
        lineHeight: '20px',
        top: -35,
        left: -15,
        display: 'none',
        borderRadius: 3,
        overflow: 'hidden',
        backgroundColor: _consts2.default.theme.bluish,
        color: 'white',
        zIndex: '+1000'
    },
    "doric-slider-thumb[pressed] > doric-slider-value": {
        display: 'block'
    }
});
var clampNormal = function clampNormal(value) {
    return Math.min(1, Math.max(0, value));
};

var Slider = function (_React$Component) {
    (0, _inherits3.default)(Slider, _React$Component);

    function Slider(props) {
        (0, _classCallCheck3.default)(this, Slider);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Slider.__proto__ || (0, _getPrototypeOf2.default)(Slider)).call(this, props));

        _this.touchStart = function (evt) {
            if (_this.touchID !== null) {
                return;
            }

            var _evt$changedTouches = (0, _slicedToArray3.default)(evt.changedTouches, 1),
                touch = _evt$changedTouches[0];

            var track = _this.refs.track.getBoundingClientRect();
            var thumb = _this.refs.thumb.getBoundingClientRect();
            _this.range = track.width;
            _this.startPos = track.left;
            _this.startValue = thumb.left - track.left;
            _this.touchStartPos = touch.clientX;
            _this.touchID = touch.identifier;
        };

        _this.touchMove = function (evt) {
            var _context;

            var touch = (_context = evt.changedTouches, find).call(_context, function (touch) {
                return touch.identifier === _this.touchID;
            });
            if (touch === undefined) {
                return;
            }

            var _this$props = _this.props,
                _this$props$min = _this$props.min,
                min = _this$props$min === undefined ? 0 : _this$props$min,
                _this$props$max = _this$props.max,
                max = _this$props$max === undefined ? 10 : _this$props$max,
                _this$props$step = _this$props.step,
                step = _this$props$step === undefined ? 1 : _this$props$step,
                _this$props$onChange = _this$props.onChange,
                onChange = _this$props$onChange === undefined ? function () {} : _this$props$onChange,
                value = _this$props.value;

            var offset = touch.clientX - _this.touchStartPos;
            var pos = _this.startValue + offset;

            var range = max - min;
            var newValue = range * clampNormal(pos / _this.range) + min;

            newValue = Math.round(newValue / step) * step;

            if (newValue !== value) {
                onChange(newValue);
            }
        };

        _this.componentDidMount = function () {
            _this.refs.thumb.addEventListener('touchmove', function (evt) {
                evt.preventDefault();
            }, { passive: false, capture: true });
        };

        _this.render = function () {
            var _this$props2 = _this.props,
                _this$props2$min = _this$props2.min,
                min = _this$props2$min === undefined ? 0 : _this$props2$min,
                _this$props2$max = _this$props2.max,
                max = _this$props2$max === undefined ? 10 : _this$props2$max,
                value = _this$props2.value,
                color = _this$props2.color,
                _this$props2$displayF = _this$props2.displayFunc,
                displayFunc = _this$props2$displayF === undefined ? function (i) {
                return i;
            } : _this$props2$displayF;

            var pos = (value - min) / (max - min);
            var thumbStyle = {
                left: pos * 100 + '%'
            };
            var fillStyle = {
                transform: 'scaleX(' + pos + ')',
                backgroundColor: color
            };

            var events = {
                onTouchStart: _this.touchStart,
                onTouchMove: _this.touchMove,
                onTouchEnd: function onTouchEnd() {
                    return _this.touchID = null;
                }
            };
            var thumb = _react2.default.createElement('doric-slider-track-circle', { 'data-no-press': true, style: { backgroundColor: color } });
            var valueDisplay = _react2.default.createElement(
                'doric-slider-value',
                { style: { backgroundColor: color } },
                displayFunc(value)
            );

            return _react2.default.createElement(
                'doric-slider',
                null,
                _react2.default.createElement(
                    'doric-slider-track',
                    { ref: 'track' },
                    _react2.default.createElement('doric-slider-track-fill', { style: fillStyle }),
                    _react2.default.createElement(
                        'doric-slider-thumb',
                        (0, _extends3.default)({ ref: 'thumb', style: thumbStyle }, events),
                        thumb,
                        valueDisplay
                    )
                )
            );
        };

        _this.touchID = null;
        return _this;
    }

    return Slider;
}(_react2.default.Component);

exports.default = Slider;

},{"babel-runtime/core-js/object/get-prototype-of":223,"babel-runtime/helpers/classCallCheck":231,"babel-runtime/helpers/extends":233,"babel-runtime/helpers/inherits":234,"babel-runtime/helpers/possibleConstructorReturn":236,"babel-runtime/helpers/slicedToArray":237,"react":176,"source/component/CustomEvents":190,"source/util/app":203,"source/util/consts":205}],198:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _ContentAligners = require('source/component/ContentAligners');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "@keyframes spinner-rotate": {
        from: {
            transform: 'rotate(0)'
        },
        to: {
            transform: 'rotate(360deg)'
        }
    },
    "div.spinner": {
        position: 'relative'
    },
    "div.spinner .hex": {
        width: 22,
        height: 38,
        position: 'absolute',
        left: -11,
        top: -19
    },
    "div.spinner > div": {
        animationName: 'spinner-rotate',
        animationTimingFunction: 'ease-in-out',
        animationIterationCount: 'infinite',
        animationDuration: '2000ms'
    },
    "div.spinner > .outer": {
        animationDirection: 'reverse'
    },
    "div.spinner > .inner > .hex": {
        backgroundColor: 'white'
    },
    "div.spinner > .outer > .hex": {
        backgroundColor: _consts2.default.theme.bluish
    }
});
var Spinner = function Spinner() {
    return _react2.default.createElement(
        'doric-spinner',
        null,
        _react2.default.createElement(
            _ContentAligners.CenterContent,
            { width: 45, height: 45 },
            _react2.default.createElement(
                'div',
                { className: 'spinner' },
                _react2.default.createElement(
                    'div',
                    { className: 'outer' },
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(30deg)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(90deg)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(150deg)" } })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'inner' },
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(30deg) scale(0.5)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(90deg) scale(0.5)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(150deg) scale(0.5)" } })
                )
            )
        )
    );
};

exports.default = Spinner;

},{"react":176,"source/component/ContentAligners":189,"source/util/app":203,"source/util/consts":205}],199:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _stylesheet = require('source/util/stylesheet');

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

var _ContentAligners = require('source/component/ContentAligners');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-toggle": {
        display: 'block',
        position: 'relative',
        userSelect: 'none'
    },
    "doric-toggle[disabled='true']": {
        color: 'gray',
        opacity: 0.6
    },
    "doric-toggle:after": {
        content: "''",
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        transition: _consts2.default.css.backgroundTransition
    },
    "doric-toggle[pressed]:not([disabled='true']):after": {
        backgroundColor: _stylesheet.CSS.rgba(0, 0, 0, 0.25),
        transition: 'none'
    },
    "doric-toggle-switch": {
        width: 36,
        height: 14,
        borderRadius: 7,
        backgroundColor: _consts2.default.theme.grayBG,
        position: 'relative',
        transition: 'background-color 50ms linear'
    },
    "doric-toggle:not([disabled='true']) doric-toggle-switch[on='true']": {
        backgroundColor: '#b3cefb'
    },
    "doric-toggle-switch:after": {
        content: "''",
        boxShadow: '2px 2px 2px rgba(0, 0, 0, 0.25)',
        position: 'absolute',
        top: -3,
        left: -1,
        width: 20,
        height: 20,
        borderRadius: 11,
        backgroundColor: 'gray',
        transition: 'transform 50ms linear, background-color 50ms linear'
    },
    "doric-toggle-switch[on='true']:after": {
        transform: 'translateX(18px)'
    },
    "doric-toggle:not([disabled='true']) doric-toggle-switch[on='true']:after": {
        backgroundColor: _consts2.default.theme.bluish
    }
});
var Toggle = function Toggle(props) {
    var _ref;

    var _props$on = props.on,
        on = _props$on === undefined ? false : _props$on,
        label = props.label,
        children = props.children,
        _props$side = props.side,
        side = _props$side === undefined ? 'left' : _props$side,
        _props$style = props.style,
        style = _props$style === undefined ? {} : _props$style,
        _props$className = props.className,
        className = _props$className === undefined ? "" : _props$className,
        _props$onChange = props.onChange,
        onChange = _props$onChange === undefined ? warningFunc("Toggle has no change function") : _props$onChange,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['on', 'label', 'children', 'side', 'style', 'className', 'onChange']);

    var change = function change() {
        if (props.disabled !== true) {
            onChange(on === false);
        }
    };
    var padding = (0, _defineProperty3.default)({
        padding: 5
    }, 'padding' + side.charAt(0).toUpperCase() + side.slice(1), 45);

    return _react2.default.createElement(
        _CustomEvents2.default,
        (0, _extends3.default)({ component: 'doric-toggle', on: on, style: (0, _extends3.default)({}, style, padding), onTap: change, 'class': className }, passThrough),
        _react2.default.createElement(
            _ContentAligners.CenterContent,
            { 'data-no-press': true, style: (_ref = {}, (0, _defineProperty3.default)(_ref, side, 0), (0, _defineProperty3.default)(_ref, 'top', 0), (0, _defineProperty3.default)(_ref, 'position', 'absolute'), _ref), width: 45, height: '100%' },
            _react2.default.createElement('doric-toggle-switch', { on: on, 'data-no-press': true })
        ),
        label,
        children
    );
};

exports.default = Toggle;

},{"babel-runtime/helpers/defineProperty":232,"babel-runtime/helpers/extends":233,"babel-runtime/helpers/objectWithoutProperties":235,"react":176,"source/component/ContentAligners":189,"source/component/CustomEvents":190,"source/util/app":203,"source/util/consts":205,"source/util/stylesheet":210}],200:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,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u8LuSsJP+OywsMPCDgs7LOywsMPCDgs7LIIv+OyysMvCLgu7LOyyCL7gC77gV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+HX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfh1+HX4dfh1+HX4dfh1+HX4dfh1+HX4dfh1+E3eU+T9zR5T5P3NHlPk/c0eU+T9zTHvIfv0eR7tPgeLb5Hi+/R4nu0+B4t+C34Lfgt+C34Lfgt+C34Lfgt+C34bfht+G34bfht+G34bfht+G34bfht+G04bTgdOB04HTgdOB04HTgd3t/hvR3e2+XzXT7f5fNdPt/lc11+ry6f7/L9e/wePT7X43M9/l6Pf7ce/259/n6fv9fn9+vz79CH14fXH/O5f3mJ/xP/J55PPJ94PvF64u/E34m/E38n/k78nfg78Xfi78Tfib8TbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW1mHX4ffgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+E34TfhN+E34SPbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W3i28S3iW8T3ya+TXyb+DbxbeLbxLeJbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W224bfht+Hj4cTDiYcTDyceTjyceDjxcHbg4+PswMfLiZezA78DvwO/A78DvwsfjyceTzyeeDy78Lvw8Xri9cTr2YXfhd+Fj++zC78LH/9nD34PPj1IepA9+D34Pfg9+PQie/DpRtKN7MHvwe/BpyfZh9+H34dPZ5LOJJ1JOpN0JrlbkrsluVuS/uSY/nC3JHeLuFvE3SLuFnG3iLtFdEt0S9wt4m4Rd4vomeiZ6Jm4W8TdIvom7hZxt4i7RXRPdE90T3RPdE90T3RPdE90T3RPdE/cLeJuEXeLuFvE3SLuFnG3iLtF3C3ibhF3i7hbxN0i7hZxt4i7Rdwt4m4Rd4u4W8TdIu4WcbeIu0XcLeJuEXeLuFvE3SLuFnG3iLtF3C2i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/+rX/wHuf9d/AAAAAAAB//8AAnjaY2BgYGQAgjO2i86D6AvLjCdB6SkAS/0G9AA=";

},{}],201:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,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";

},{}],202:[function(require,module,exports){
'use strict';

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _icons = require('source/util/icons');

var _icons2 = _interopRequireDefault(_icons);

var _utils = require('source/util/utils');

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

require('source/util/chrono');

require('source/util/gesture');

require('source/util/deviceready');

var _theme = require('source/util/theme');

var _theme2 = _interopRequireDefault(_theme);

var _Button = require('source/component/Button');

var _Button2 = _interopRequireDefault(_Button);

var _Card = require('source/component/Card');

var _Card2 = _interopRequireDefault(_Card);

var _ContentAligners = require('source/component/ContentAligners');

var _Checkbox = require('source/component/Checkbox');

var _Checkbox2 = _interopRequireDefault(_Checkbox);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

var _Grid = require('source/component/Grid');

var _Grid2 = _interopRequireDefault(_Grid);

var _Icon = require('source/component/Icon');

var _Image = require('source/component/Image');

var _Image2 = _interopRequireDefault(_Image);

var _Input = require('source/component/Input');

var _Input2 = _interopRequireDefault(_Input);

var _Pinboard = require('source/component/Pinboard');

var _Pinboard2 = _interopRequireDefault(_Pinboard);

var _Progress = require('source/component/Progress');

var _Progress2 = _interopRequireDefault(_Progress);

var _Slider = require('source/component/Slider');

var _Slider2 = _interopRequireDefault(_Slider);

var _Spinner = require('source/component/Spinner');

var _Spinner2 = _interopRequireDefault(_Spinner);

var _Toggle = require('source/component/Toggle');

var _Toggle2 = _interopRequireDefault(_Toggle);

var _stylesheet = require('source/util/stylesheet');

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.Doric = {
    Button: _Button2.default,
    Card: _Card2.default,
    CenterContent: _ContentAligners.CenterContent,
    AlignContent: _ContentAligners.AlignContent,
    Checkbox: _Checkbox2.default,
    CustomEvents: _CustomEvents2.default,
    Grid: _Grid2.default,
    Icon: _Icon.Icon,
    IconButton: _Icon.IconButton,
    Image: _Image2.default,
    Input: _Input2.default,
    Pinboard: _Pinboard2.default,
    Progress: _Progress2.default,
    Slider: _Slider2.default,
    Spinner: _Spinner2.default,
    Toggle: _Toggle2.default
};
window.React = _react2.default;
window.DoricUtil = {
    CSS: _stylesheet.CSS,
    warningFunc: _utils.warningFunc
};

Math.rand = function (a) {
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (b === null) {
        b = a;
        a = 0;
    }
    return Math.floor(Math.random() * (b - a + 1)) + a;
};

window.cblog = console.log.bind(console);
window.cberr = console.error.bind(console);

},{"react":176,"react-dom":25,"source/component/Button":186,"source/component/Card":187,"source/component/Checkbox":188,"source/component/ContentAligners":189,"source/component/CustomEvents":190,"source/component/Grid":191,"source/component/Icon":192,"source/component/Image":193,"source/component/Input":194,"source/component/Pinboard":195,"source/component/Progress":196,"source/component/Slider":197,"source/component/Spinner":198,"source/component/Toggle":199,"source/util/app":203,"source/util/chrono":204,"source/util/consts":205,"source/util/deviceready":206,"source/util/gesture":208,"source/util/icons":209,"source/util/stylesheet":210,"source/util/theme":211,"source/util/utils":212}],203:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _stylesheet = require('source/util/stylesheet');

var _robotoLightWoff = require('source/data-uri/roboto-light.woff.source');

var _robotoLightWoff2 = _interopRequireDefault(_robotoLightWoff);

var _ioniconsWoff = require('source/data-uri/ionicons.woff.source');

var _ioniconsWoff2 = _interopRequireDefault(_ioniconsWoff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var head = document.querySelector("head");
var roboto = document.createElement("style");
var appStyle = document.createElement("style");
var fonts = new _set2.default();

var componentStyleSheet = (0, _stylesheet.createStyleSheet)();
var initCalled = false;

roboto.setAttribute("data-name", "doric-core-style");
head.appendChild(roboto);

appStyle.setAttribute("data-name", "doric-app-style");
head.appendChild(appStyle);

window.App = {
    render: function render(content) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
            var wrapper;
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            wrapper = _react2.default.createElement(
                                'div',
                                { style: { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', overflow: 'hidden' } },
                                content
                            );

                            if (!(initCalled === false)) {
                                _context.next = 6;
                                break;
                            }

                            _context.next = 4;
                            return deviceReady;

                        case 4:
                            componentStyleSheet.__init(roboto);
                            initCalled = true;

                        case 6:
                            _reactDom2.default.render(wrapper, document.body);
                            App.styleSheet.__init(appStyle);
                            App.styleSheet = (0, _stylesheet.createStyleSheet)();

                        case 9:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, _this);
        }))();
    },
    addFont: function addFont(name, def) {
        if (fonts.has(name) === true) {
            return;
        }
        var elem = document.createElement("style");

        fonts.add(name);
        elem.dataset.fontName = name;
        elem.innerHTML = (0, _stylesheet.genCSS)({ "@font-face": def });

        head.appendChild(elem);
    },

    styleSheet: (0, _stylesheet.createStyleSheet)()
};

componentStyleSheet.addStyles({
    "*": {
        boxSizing: 'border-box'
    },
    "html, body": {
        width: '100%',
        height: '100%',
        padding: 0,
        margin: 0
    },
    body: {
        fontFamily: "Roboto",
        backgroundColor: '#f5f5f5'
    }
});
App.addFont('roboto', {
    fontFamily: '"Roboto"',
    src: 'url("' + _robotoLightWoff2.default + '") format("woff")',
    fontWeight: "normal",
    fontStyle: "normal"
});
App.addFont('ionic', {
    fontFamily: '"Ionic"',
    src: 'url("' + _ioniconsWoff2.default + '") format("woff")',
    fontWeight: "normal",
    fontStyle: "normal"
});

exports.default = componentStyleSheet;

},{"babel-runtime/core-js/set":228,"babel-runtime/helpers/asyncToGenerator":230,"babel-runtime/regenerator":240,"react":176,"react-dom":25,"source/data-uri/ionicons.woff.source":200,"source/data-uri/roboto-light.woff.source":201,"source/util/stylesheet":210}],204:[function(require,module,exports){
'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _xregexp = require('xregexp');

var _xregexp2 = _interopRequireDefault(_xregexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var chronoSpecial = {
    'yesterday': function yesterday(date) {
        date.setDate(date.getDate() - 1);
        return date;
    },
    '1 week ago': function weekAgo(date) {
        date.setDate(date.getDate() - 7);
        return date;
    }
};
var chronoUnitRegex = (0, _xregexp2.default)("(?<offset>(\\+|\\-)\\d+) (?<unit>\\w+)");
var unitFunction = {
    millisecond: function millisecond(date, milliseconds) {
        date.setMilliseconds(date.getMilliseconds() + milliseconds);
        return date;
    },
    second: function second(date, seconds) {
        date.setSeconds(date.getSeconds() + seconds);
        return date;
    },
    minute: function minute(date, minutes) {
        date.setMinutes(date.getMinutes() + minutes);
        return date;
    },
    hour: function hour(date, hours) {
        date.setHours(date.getHours() + hours);
        return date;
    },
    day: function day(date, days) {
        date.setDate(date.getDate() + days);
        return date;
    },
    week: function week(date, weeks) {
        date.setDate(date.getDate() + weeks * 7);
        return date;
    },
    month: function month(date, months) {
        var expected = date.getMonth() + months;
        date.setMonth(expected);
        if (date.getMonth() !== expected) {
            date.setDate(0);
        }
        return date;
    },
    year: function year(date, years) {
        date.setFullYear(date.getFullYear() + years);
        return date;
    },
    decade: function decade(date, decades) {
        date.setFullYear(date.getFullYear() + decades * 10);
        return date;
    }
};
var _startOf = {
    second: function second(date) {
        date.setMilliseconds(0);
    },
    minute: function minute(date) {
        _startOf.second(date);
        date.setSeconds(0);
    },
    hour: function hour(date) {
        _startOf.minute(date);
        date.setMinutes(0);
    },
    day: function day(date) {
        _startOf.hour(date);
        date.setHours(0);
    },
    week: function week(date) {
        _startOf.day(date);
        date.setDate(date.getDate() - date.getDay());
    },
    month: function month(date) {
        _startOf.day(date);
        date.setDate(1);
    },
    year: function year(date) {
        _startOf.month(date);
        date.setMonth(0);
    }
};
var _endOf = {
    second: function second(date) {
        date.setMilliseconds(999);
    },
    minute: function minute(date) {
        _endOf.second(date);
        date.setSeconds(59);
    },
    hour: function hour(date) {
        _endOf.minute(date);
        date.setMinutes(59);
    },
    day: function day(date) {
        _endOf.hour(date);
        date.setHours(23);
    },
    week: function week(date) {
        _endOf.day(date);
        date.setDate(date.getDate() + (6 - date.getDay()));
    },
    month: function month(date) {
        _endOf.day(date);
        date.setMonth(date.getMonth() + 1);
        date.setDate(0);
    },
    year: function year(date) {
        _endOf.month(date);
        date.setMonth(11);
    }
};
var unitConversion = {
    'millisecond': 'millisecond',
    'milliseconds': 'millisecond',
    'ms': 'millisecond',

    'second': 'second',
    'seconds': 'second',
    's': 'second',

    'minute': 'minute',
    'minutes': 'minute',
    'min': 'minute',

    'hour': 'hour',
    'hours': 'hour',
    'hr': 'hour',

    'day': 'day',
    'days': 'day',
    'ni': 'day',
    'hi': 'day',
    '': 'day',

    'week': 'week',
    'weeks': 'week',
    'shuu': 'week',
    '': 'week',
    '': 'week',

    'month': 'month',
    'months': 'month',

    'year': 'year',
    'years': 'year',

    'decade': 'decade',
    'decades': 'decade'
};
var chronoInfo = {
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var chronoFormat = {
    ms: {
        base: function base(date) {
            return date.getMilliseconds();
        },
        padded: function padded(date) {
            return ('00' + date.getMilliseconds()).slice(-3);
        }
    },
    second: {
        base: function base(date) {
            return date.getSeconds();
        },
        padded: function padded(date) {
            return ('0' + date.getSeconds()).slice(-2);
        }
    },
    minute: {
        base: function base(date) {
            return date.getMinutes();
        },
        padded: function padded(date) {
            return ('0' + date.getMinutes()).slice(-2);
        }
    },
    hour: {
        base: function base(date) {
            return date.getHours();
        },
        padded: function padded(date) {
            return ('0' + date.getHours()).slice(-2);
        },
        "12": function _(date) {
            var hour = date.getHours() % 12;
            if (hour === 0) {
                return 12;
            }
            return hour;
        },
        "12padded": function padded(date) {
            return ('0' + chronoFormat.hour['12'](date)).slice(-2);
        }
    },
    weekday: {
        base: function base(date) {
            return date.getDay();
        },
        short: function short(date) {
            return chronoInfo.days[date.getDay()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.days[date.getDay()];
        }
    },
    date: {
        base: function base(date) {
            return date.getDate();
        },
        padded: function padded(date) {
            return ('0' + date.getDate()).slice(-2);
        }
    },
    month: {
        base: function base(date) {
            return date.getMonth() + 1;
        },
        short: function short(date) {
            return chronoInfo.months[date.getDate()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.months[date.getDate()];
        }
    },
    year: {
        base: function base(date) {
            return date.getFullYear() % 100;
        },
        full: function full(date) {
            return date.getFullYear();
        }
    },
    tod: {
        base: function base(date) {
            return date.getHours() < 12 === true ? "AM" : "PM";
        }
    }
};
chronoFormat.day = chronoFormat.date;
var chronoCheckUnit = function chronoCheckUnit(unit) {
    if (unitConversion.hasOwnProperty(unit) === false) {
        throw new Error('Unrecognized unit: ' + unit);
    }
};

/* -AxelDoc-
module global {
    @function chrono {
        @desc Creates a new instance of {chrono}.
        @args {
            @arg dateTime [Date]
                This is some long description of the thing
                {year, month} destructuring?
                [title]year[title]
        }
        @return chrono

        @function diff {
            @desc A function that will calculate the amount of time to add to the first argument in order to get the second argument.
            @args {
                @arg startDate [chrono] The date to start from.
                @arg targetDate [chrono] The date to get to.
            }
            @return object
        }
        @function now {
            @desc Returns the current date as a chrono object.
            @args {}
            @return chrono
        }
        @function parse {
            @desc Parses a date string and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function parseMS {
            @desc Parses a date string generated by C# code and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function trigger {
            @desc Fires a function after a specified time.
            @args {
                @arg delay [number] The number of milliseconds to wait.
                @arg func [function] The function to call.
            }
            @return chronoTrigger
        }
    }

    object chrono {
        @prop dateObject {
            @desc Gets a copy of the internal Date object.
            @type Date
        }

        @prop unixTimestamp {
            @desc Gets the unix timestamp of the chrono object.
            @type number
        }

        @prop milliseconds {
            @desc Gets the milliseconds of the chrono object.
            @type number
        }
        @prop seconds {
            @desc Gets the seconds of the chrono object.
            @type number
        }
        @prop minutes {
            @desc Gets the minutes of the chrono object.
            @type number
        }
        @prop hours {
            @desc Gets the hours of the chrono object.
            @type number
        }
        @prop weekday {
            @desc Gets the weekday of the chrono object.
            @type number
        }
        @prop date {
            @desc Gets the date of the chrono object. This number is adjusted to the range (0-30) unlike the normal Date object.
            @type number
        }
        @prop months {
            @desc Gets the months of the chrono object.
            @type number
        }
        @prop year {
            @desc Gets the year of the chrono object.
            @type number
        }

        @function shift {
            @desc Shifts the date forward or backward in time.
            @args {
                @arg offset [Number] The amount of time to shift the date.
                @arg unit [String] The units to shift by. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year', 'decade'.
            }
            @args {
                @arg duration [object] An object that will shift the date.
            }
            @return chrono
        }
        @function startOf {
            @desc Moves the date to the start of the specified unit.
            @args {
                @arg unit [string] The unit to move to the start of. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year'.
            }
            @return chrono
        }
        @function format {
            @desc Formats the chrono object using the specified string.
            @args {
                @arg format [string] The string describing the format the date should be put into.
            }
            @return string
        }
    }

    object chronoTrigger {
        @prop status {
            @desc The status of the trigger.
            @type string
        }

        @function cancel {
            @desc Cancels the trigger if it hasn't fired yet.
        }
    }
}
*/
var chrono = function chrono() {
    var arg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var internalDate = function () {
        if (arg === null) {
            return new Date();
        }

        if (Date.prototype.isPrototypeOf(arg) === true || typeof arg === 'number') {
            return new Date(arg);
        }

        if (arg.__chrono === true) {
            return arg.dateObject;
        }

        if (typeof arg === 'string') {
            arg = arg.toLowerCase();
            if (chronoSpecial.hasOwnProperty(arg) === true) {
                return chronoSpecial[arg](new Date());
            }

            var match = _xregexp2.default.exec(arg, chronoUnitRegex);
            if (match !== null) {
                var offset = match.offset,
                    unit = match.unit;


                chronoCheckUnit(unit);

                return unitFunction[unitConversion[unit]](new Date(), parseInt(offset));
            }

            return new Date(arg);
        }

        var _arg = arg,
            _arg$year = _arg.year,
            year = _arg$year === undefined ? 1970 : _arg$year,
            _arg$month = _arg.month,
            month = _arg$month === undefined ? 0 : _arg$month,
            _arg$date = _arg.date,
            date = _arg$date === undefined ? 0 : _arg$date,
            _arg$hours = _arg.hours,
            hours = _arg$hours === undefined ? 0 : _arg$hours,
            _arg$minutes = _arg.minutes,
            minutes = _arg$minutes === undefined ? 0 : _arg$minutes,
            _arg$seconds = _arg.seconds,
            seconds = _arg$seconds === undefined ? 0 : _arg$seconds,
            _arg$milliseconds = _arg.milliseconds,
            milliseconds = _arg$milliseconds === undefined ? 0 : _arg$milliseconds;

        return new Date(year, month, date + 1, hours, minutes, seconds, milliseconds);
    }();

    return {
        __chrono: true,
        get dateObject() {
            return new Date(internalDate);
        },
        get unixTimestamp() {
            return internalDate.getTime();
        },

        get milliseconds() {
            return internalDate.getMilliseconds();
        },
        get seconds() {
            return internalDate.getSeconds();
        },
        get minutes() {
            return internalDate.getMinutes();
        },
        get hours() {
            return internalDate.getHours();
        },
        get weekday() {
            return internalDate.getDay();
        },
        get date() {
            return internalDate.getDate() - 1;
        },
        get month() {
            return internalDate.getMonth();
        },
        get year() {
            return internalDate.getFullYear();
        },

        set: function set(props) {
            var _props$year = props.year,
                year = _props$year === undefined ? internalDate.getFullYear() : _props$year,
                _props$month = props.month,
                month = _props$month === undefined ? internalDate.getMonth() : _props$month,
                _props$date = props.date,
                date = _props$date === undefined ? internalDate.getDate() - 1 : _props$date,
                _props$hours = props.hours,
                hours = _props$hours === undefined ? internalDate.getHours() : _props$hours,
                _props$minutes = props.minutes,
                minutes = _props$minutes === undefined ? internalDate.getMinutes() : _props$minutes,
                _props$seconds = props.seconds,
                seconds = _props$seconds === undefined ? internalDate.getSeconds() : _props$seconds,
                _props$milliseconds = props.milliseconds,
                milliseconds = _props$milliseconds === undefined ? internalDate.getMilliseconds() : _props$milliseconds;


            return chrono(new Date(year, month, date + 1, hours, minutes, seconds, milliseconds));
        },
        shift: function shift(offset, unit) {
            var newDate = void 0;
            newDate = new Date(internalDate);

            if ((typeof offset === 'undefined' ? 'undefined' : (0, _typeof3.default)(offset)) === 'object') {
                // if (offset.hasOwnProperty('__chrono_duration') && offset.__chrono_duration === true) {
                //     offset = offset.asObject();
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = (0, _getIterator3.default)((0, _entries2.default)(offset)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
                            _unit = _step$value[0],
                            value = _step$value[1];

                        chronoCheckUnit(_unit);
                        newDate = unitFunction[unitConversion[_unit]](newDate, value);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return chrono(newDate);
            } else {
                if (typeof offset === 'string') {
                    var match = _xregexp2.default.exec(offset, chronoUnitRegex);

                    offset = match.offset;
                    unit = match.unit;

                    chronoCheckUnit(unit);
                    offset = parseInt(offset);
                }

                return chrono(unitFunction[unitConversion[unit]](newDate, offset));
            }
        },
        startOf: function startOf(unit) {
            var adjustedDate = new Date(internalDate);

            _startOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        endOf: function endOf(unit) {
            var adjustedDate = new Date(internalDate);

            _endOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        format: function format() {
            var formatString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (formatString === null) {
                return internalDate.toString();
            }

            if (formatString === 'utc') {
                return internalDate.toUTCString();
            }
            if (formatString === 'locale') {
                return internalDate.toLocaleString();
            }

            return formatString.replace(/\{(\w+)(\/(\w+))?\}/g, function (full, prop, skip) {
                var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'base';
                return chronoFormat[prop][type](internalDate);
            });
        },
        toString: function toString() {
            return internalDate.toString();
        },
        toJSON: function toJSON() {
            // return internalDate.toJSON();
            return "{month}-{day}-{year/full} {hour/padded}:{minute/padded}:{second/padded}".replace(/\{(\w+)(\/(\w+))?\}/g, function (full, prop, skip) {
                var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'base';
                return chronoFormat[prop][type](internalDate);
            });
        }
    };
};
chrono.diff = function (first, second) {
    var internalDate = new Date(second.unixTimestamp - first.unixTimestamp);
    console.log(second.unixTimestamp - first.unixTimestamp);
    console.log(internalDate);

    return {
        milliseconds: internalDate.getMilliseconds(),
        seconds: internalDate.getSeconds(),
        minutes: internalDate.getMinutes(),
        hours: internalDate.getHours(),
        days: internalDate.getDate() - 1,
        months: internalDate.getMonth(),
        years: internalDate.getFullYear() - 1970
    };
};
chrono.now = function () {
    return chrono(Date.now());
};
chrono.parse = function (string) {
    return chrono(Date.parse(string));
};
chrono.parseMS = function (string) {
    return chrono(Date.parse(string.replace("T", " ")));
};
chrono.trigger = function (delay, func) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
    }

    var id = setTimeout(function () {
        status = 'fired';
        func.apply(undefined, args);
    }, delay);
    var status = void 0;

    status = 'waiting';

    return {
        cancel: function cancel() {
            status = 'cancelled';
            clearTimeout(id);
        },

        get status() {
            return status;
        }
    };
};
chrono.wait = function (wait) {
    return new _promise2.default(function (resolve) {
        return setTimeout(function () {
            return resolve(null);
        }, wait);
    });
};

window.chrono = chrono;
// export default chrono;

},{"babel-runtime/core-js/get-iterator":215,"babel-runtime/core-js/object/entries":221,"babel-runtime/core-js/promise":227,"babel-runtime/helpers/slicedToArray":237,"babel-runtime/helpers/typeof":239,"xregexp":184}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    theme: {
        bluish: '#4285f4',
        grayBG: "#d0d0d0"
    },
    css: {
        backgroundTransition: "background-color 250ms linear"
    }
};

},{}],206:[function(require,module,exports){
"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _env = require("source/util/env");

var _env2 = _interopRequireDefault(_env);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
    @type Promise
    @name deviceReady
    @desc a promise that resolves after the deviceready event has fired in codova.
        Useful for plugins that are written and included outside of Corinthian.
*/
if (window.deviceReady === undefined) {
    window.deviceReady = new _promise2.default(function (resolve) {
        if (_env2.default.app === true) {
            document.addEventListener("deviceready", function () {
                return resolve(true);
            });
        } else {
            resolve(true);
        }
    });
}

},{"babel-runtime/core-js/promise":227,"source/util/env":207}],207:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
    @type Object
    @name Environment
    @desc Contains information about the current environment.
    @property {Boolean} mobile
        True if the current page is on a mobile platform (mobile browser, cordova, etc.).
    @property {Boolean} app
        True if the current page is inside of cordova.
*/

var eventSupport = function () {
    var passive = false;
    var once = false;
    var evtChecker = {
        get passive() {
            passive = true;
            return true;
        },
        get once() {
            once = true;
            return true;
        }
    };
    window.addEventListener('load', null, evtChecker);
    return { passive: passive, once: once };
}();

exports.default = (0, _freeze2.default)({
    mobile: typeof orientation !== 'undefined' || navigator.userAgent.indexOf("Mobile") !== -1,
    app: typeof cordova !== 'undefined',
    events: eventSupport
});

},{"babel-runtime/core-js/object/freeze":222}],208:[function(require,module,exports){
'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _env = require('source/util/env');

var _env2 = _interopRequireDefault(_env);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var addEventListener = EventTarget.prototype.addEventListener;

EventTarget.prototype.addEventListener = function (type, listener) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (_env2.default.events.passive === false && (typeof opts === 'undefined' ? 'undefined' : (0, _typeof3.default)(opts)) === 'object') {
        opts = opts.capture || false;
    }
    if (_env2.default.events.passive === true && typeof opts === 'boolean') {
        opts = { capture: opts };
    }
    addEventListener.call(this, type, listener, opts);
    // console.log(`adding: ${type}, support: passive(${Env.events.passive}).once(${Env.events.once})`);
};

var forEach = Array.prototype.forEach;
var schedule = function schedule(time, func) {
    return setTimeout(func, time);
};

var findPressTarget = function findPressTarget(node) {
    while (node !== null && node !== undefined && node.getAttribute("data-no-press") !== null) {
        node = node.parentNode;
    }

    return node || document.body;
};
var touchData = function touchData(_ref, _ref2) {
    var x = _ref.pageX,
        y = _ref.pageY,
        id = _ref.identifier,
        target = _ref.target;
    var _ref2$mouseTriggered = _ref2.mouseTriggered,
        mouseTriggered = _ref2$mouseTriggered === undefined ? false : _ref2$mouseTriggered;
    var targetOverride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return (0, _freeze2.default)({
        position: (0, _freeze2.default)({
            x: x, y: y
        }),
        time: Date.now(),
        target: targetOverride || target,
        pressTarget: findPressTarget(targetOverride || target),
        id: id,
        mouseTriggered: mouseTriggered
    });
};

var polarVector = function polarVector(_ref3, _ref4) {
    var _ref3$position = _ref3.position,
        x1 = _ref3$position.x,
        y1 = _ref3$position.y;
    var _ref4$position = _ref4.position,
        x2 = _ref4$position.x,
        y2 = _ref4$position.y;

    var angle = void 0;
    var magnitude = void 0;

    angle = Math.atan2(y2 - y1, x2 - x1);
    angle *= 180 / Math.PI;
    angle = (angle + 450) % 360;

    magnitude = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

    return {
        angle: angle,
        magnitude: magnitude
    };
};

var angleDif = function angleDif(firstAngle, secondAngle) {
    var absDif = Math.abs(firstAngle - secondAngle) % 360;
    if (absDif > 180) {
        return 360 - absDif;
    }
    return absDif;
};

var createEvent = function createEvent(eventType) {
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var eventProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var event = void 0;

    event = document.createEvent("CustomEvent");
    event.initCustomEvent(eventType, true, true, detail);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(eventProps)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            event[key] = eventProps[key];
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return event;
};

var register = function register(type, createCallbacks) {
    var _createCallbacks = createCallbacks({ polarVector: polarVector, angleDif: angleDif }),
        _createCallbacks$star = _createCallbacks.start,
        start = _createCallbacks$star === undefined ? function () {} : _createCallbacks$star,
        _createCallbacks$move = _createCallbacks.move,
        move = _createCallbacks$move === undefined ? function () {} : _createCallbacks$move,
        _createCallbacks$end = _createCallbacks.end,
        end = _createCallbacks$end === undefined ? function () {} : _createCallbacks$end;

    registeredHandlers.push(type);
    registeredCallbacks[type] = { start: start, move: move, end: end };
    touchVars[type] = {};
};

var editableTagNames = ["input", "textarea", "select"];

var enabled = void 0;
var touchDataStart = void 0;
var touchDataLast = void 0;
var touchVars = void 0;
var registeredHandlers = void 0;
var registeredCallbacks = void 0;

enabled = true;
touchDataStart = {};
touchDataLast = {};
touchVars = {};
registeredHandlers = [];
registeredCallbacks = {};

window.addEventListener("touchstart", function (evt) {
    var changedTouches = evt.changedTouches;

    if (enabled === false) {
        return;
    }

    forEach.call(changedTouches, function (touch) {
        var data = touchData(touch, evt);

        touchDataStart[data.id] = data;
        touchDataLast[data.id] = data;

        data.pressTarget.setAttribute("pressed", "");

        registeredHandlers.forEach(function (handlerName) {
            var handler = registeredCallbacks[handlerName];

            touchVars[handlerName][data.id] = {};
            handler.start({ touch: data, vars: touchVars[handlerName][data.id] });
        });
    });
}, false);
window.addEventListener("touchmove", function (evt) {
    var changedTouches = evt.changedTouches;

    if (enabled === false) {
        return;
    }

    forEach.call(changedTouches, function (touch) {
        var data = touchData(touch, evt);
        var startTouch = touchDataStart[data.id];
        var lastPosition = touchDataLast[data.id];
        var overallVector = polarVector(data, startTouch);
        var difVector = polarVector(data, lastPosition);

        registeredHandlers.forEach(function (handlerName) {
            var handler = registeredCallbacks[handlerName];
            var vars = touchVars[handlerName][data.id];

            handler.move({ touch: data, vars: vars, overallVector: overallVector, difVector: difVector });
        });
    });
}, false);
window.addEventListener("touchend", function (evt) {
    var changedTouches = evt.changedTouches;

    if (enabled === false) {
        return;
    }

    forEach.call(changedTouches, function (touch) {
        var data = touchData(touch, evt);
        var startTouch = touchDataStart[data.id];
        var targetTagName = data.target.nodeName.toLowerCase();
        var overallVector = polarVector(data, startTouch);

        var somethingEditable = void 0;
        var currentNode = void 0;

        data.pressTarget.removeAttribute("pressed");

        somethingEditable = false;
        currentNode = data.target;
        while (true) {
            if (currentNode.getAttribute !== undefined && currentNode.getAttribute("contenteditable") === true) {
                somethingEditable = true;
                break;
            }

            currentNode = currentNode.parentNode;
            if (currentNode === document || currentNode === null) {
                break;
            }
        }

        // if (editableTagNames.indexOf(targetTagName) === -1 && somethingEditable === false && evt.cancelable === true) {
        if (evt.cancelable === true && editableTagNames.indexOf(targetTagName) === -1) {
            evt.preventDefault();
        }

        registeredHandlers.forEach(function (handlerName) {
            var handler = registeredCallbacks[handlerName];
            var vars = touchVars[handlerName][data.id];

            handler.end({ touch: data, vars: vars, startTouch: startTouch, overallVector: overallVector });
            touchVars[handlerName][touch.id] = null;
        });

        touchDataStart[touch.id] = null;
        touchDataLast[touch.id] = null;
    });
}, false);

(function () {
    if (_env2.default.mobile === true) {
        return;
    }
    var copyPropList = ['pageX', 'pageY', 'screenX', 'screenY', 'altKey', 'ctrlKey', 'shiftKey', 'metaKey', 'clientX', 'clientY', 'layerX', 'layerY', 'x', 'y'];
    var createTouch = function createTouch(evt, target) {
        return copyPropList.reduce(function (synthTouch, propertyName) {
            synthTouch[propertyName] = evt[propertyName];
            return synthTouch;
        }, { identifier: -1, target: target, sourceElement: target });
    };
    var createTouchList = function createTouchList(evt, target) {
        return {
            changedTouches: {
                0: createTouch(evt, target),
                length: 1
            }
        };
    };
    var currentElement = void 0;
    var mouseIsDown = void 0;

    currentElement = null;
    mouseIsDown = false;

    window.addEventListener("mousedown", function (evt) {
        if (evt.button !== 0) {
            return;
        }
        var event = createEvent("touchstart", null, (0, _extends3.default)({}, createTouchList(evt, evt.target), {
            mouseTriggered: true
        }));

        mouseIsDown = true;
        currentElement = evt.target;
        currentElement.dispatchEvent(event);
    });
    window.addEventListener("mousemove", function (evt) {
        if (mouseIsDown === false) {
            return;
        }
        var event = createEvent("touchmove", null, (0, _extends3.default)({}, createTouchList(evt, currentElement), {
            mouseTriggered: true
        }));

        if (evt.target.tagName.toLowerCase() !== 'input' || evt.target.type !== 'range') {
            evt.preventDefault();
        }
        currentElement.dispatchEvent(event);
    });
    window.addEventListener("mouseup", function (evt) {
        if (evt.button !== 0 || mouseIsDown === false) {
            return;
        }
        var event = createEvent("touchend", null, (0, _extends3.default)({}, createTouchList(evt, currentElement), {
            mouseTriggered: true
        }));

        mouseIsDown = false;
        currentElement.dispatchEvent(event);
        currentElement = null;
    });
})();

register("tap", function () {
    return {
        start: function start(_ref5) {
            var vars = _ref5.vars;

            vars.valid = true;
        },
        move: function move(_ref6) {
            var vars = _ref6.vars,
                overallVector = _ref6.overallVector;

            if (overallVector.magnitude > 20) {
                vars.valid = false;
            }
        },
        end: function end(_ref7) {
            var vars = _ref7.vars,
                startTouch = _ref7.startTouch,
                touch = _ref7.touch,
                overallVector = _ref7.overallVector;

            if (overallVector.magnitude > 20) {
                vars.valid = false;
            }
            if (vars.valid === true && touch.time - startTouch.time < 500) {
                if (startTouch.target !== document.activeElement && document.activeElement !== null && touch.mouseTriggered === false && 'blur' in document.activeElement) {
                    document.activeElement.blur();
                    startTouch.target.focus();
                }

                startTouch.target.dispatchEvent(createEvent("tap", null, { touch: touch }));
            }
        }
    };
});

register("hold", function () {
    var createCallbackForTouch = function createCallbackForTouch(touch) {
        return function () {
            timeouts[touch.id] = null;
            touch.target.dispatchEvent(createEvent("hold", null, { position: touch.position }));
        };
    };
    var timeouts = void 0;

    timeouts = {};
    return {
        start: function start(_ref8) {
            var touch = _ref8.touch;

            timeouts[touch.id] = schedule(1000, createCallbackForTouch(touch));
        },
        move: function move(_ref9) {
            var touch = _ref9.touch,
                overallVector = _ref9.overallVector;

            if (overallVector.magnitude > 20) {
                clearTimeout(timeouts[touch.id]);
                timeouts[touch.id] = null;
            }
        },
        end: function end(_ref10) {
            var touch = _ref10.touch;

            if (timeouts[touch.id] !== null) {
                clearTimeout(timeouts[touch.id]);
                timeouts[touch.id] = null;
            }
        }
    };
});

window.gesture = { register: register };

},{"babel-runtime/core-js/get-iterator":215,"babel-runtime/core-js/object/freeze":222,"babel-runtime/core-js/object/keys":224,"babel-runtime/helpers/extends":233,"babel-runtime/helpers/typeof":239,"source/util/env":207}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var c = String.fromCharCode;

var icons = {
  "ion-ionic": c(61771),
  "ion-arrow-up-a": c(61708),
  "ion-arrow-right-a": c(61705),
  "ion-arrow-down-a": c(61699),
  "ion-arrow-left-a": c(61702),
  "ion-arrow-up-b": c(61709),
  "ion-arrow-right-b": c(61706),
  "ion-arrow-down-b": c(61700),
  "ion-arrow-left-b": c(61703),
  "ion-arrow-up-c": c(61710),
  "ion-arrow-right-c": c(61707),
  "ion-arrow-down-c": c(61701),
  "ion-arrow-left-c": c(61704),
  "ion-arrow-return-right": c(62054),
  "ion-arrow-return-left": c(62053),
  "ion-arrow-swap": c(62056),
  "ion-arrow-shrink": c(62055),
  "ion-arrow-expand": c(62046),
  "ion-arrow-move": c(62051),
  "ion-arrow-resize": c(62052),
  "ion-chevron-up": c(61734),
  "ion-chevron-right": c(61733),
  "ion-chevron-down": c(61731),
  "ion-chevron-left": c(61732),
  "ion-navicon-round": c(61965),
  "ion-navicon": c(61966),
  "ion-drag": c(61744),
  "ion-log-in": c(62110),
  "ion-log-out": c(62111),
  "ion-checkmark-round": c(61729),
  "ion-checkmark": c(61730),
  "ion-checkmark-circled": c(61728),
  "ion-close-round": c(61737),
  "ion-close": c(61738),
  "ion-close-circled": c(61736),
  "ion-plus-round": c(61975),
  "ion-plus": c(61976),
  "ion-plus-circled": c(61974),
  "ion-minus-round": c(61960),
  "ion-minus": c(61961),
  "ion-minus-circled": c(61959),
  "ion-information": c(61770),
  "ion-information-circled": c(61769),
  "ion-help": c(61763),
  "ion-help-circled": c(61762),
  "ion-backspace-outline": c(62398),
  "ion-backspace": c(62399),
  "ion-help-buoy": c(62076),
  "ion-asterisk": c(62228),
  "ion-alert": c(61697),
  "ion-alert-circled": c(61696),
  "ion-refresh": c(61980),
  "ion-loop": c(61953),
  "ion-shuffle": c(61985),
  "ion-home": c(61764),
  "ion-search": c(61983),
  "ion-flag": c(62073),
  "ion-star": c(62030),
  "ion-heart": c(61761),
  "ion-heart-broken": c(62237),
  "ion-gear-a": c(61757),
  "ion-gear-b": c(61758),
  "ion-toggle-filled": c(62292),
  "ion-toggle": c(62293),
  "ion-settings": c(62125),
  "ion-wrench": c(62138),
  "ion-hammer": c(62075),
  "ion-edit": c(62143),
  "ion-trash-a": c(62034),
  "ion-trash-b": c(62035),
  "ion-document": c(61743),
  "ion-document-text": c(61742),
  "ion-clipboard": c(61735),
  "ion-scissors": c(62283),
  "ion-funnel": c(62235),
  "ion-bookmark": c(62059),
  "ion-email": c(61746),
  "ion-email-unread": c(62403),
  "ion-folder": c(61753),
  "ion-filing": c(61748),
  "ion-archive": c(61698),
  "ion-reply": c(61982),
  "ion-reply-all": c(61981),
  "ion-forward": c(61754),
  "ion-share": c(61984),
  "ion-paper-airplane": c(62147),
  "ion-link": c(61950),
  "ion-paperclip": c(61967),
  "ion-compose": c(61740),
  "ion-briefcase": c(62060),
  "ion-medkit": c(62114),
  "ion-at": c(61711),
  "ion-pound": c(61977),
  "ion-quote": c(62279),
  "ion-cloud": c(61739),
  "ion-upload": c(62037),
  "ion-more": c(61963),
  "ion-grid": c(61759),
  "ion-calendar": c(61719),
  "ion-clock": c(62062),
  "ion-compass": c(62067),
  "ion-pinpoint": c(62119),
  "ion-pin": c(62118),
  "ion-navigate": c(62115),
  "ion-location": c(61951),
  "ion-map": c(61955),
  "ion-lock-combination": c(62676),
  "ion-locked": c(61952),
  "ion-unlocked": c(62036),
  "ion-key": c(62102),
  "ion-arrow-graph-up-right": c(62050),
  "ion-arrow-graph-down-right": c(62048),
  "ion-arrow-graph-up-left": c(62049),
  "ion-arrow-graph-down-left": c(62047),
  "ion-stats-bars": c(62133),
  "ion-connection-bars": c(62068),
  "ion-pie-graph": c(62117),
  "ion-chatbubble": c(61726),
  "ion-chatbubble-working": c(61725),
  "ion-chatbubbles": c(61727),
  "ion-chatbox": c(61723),
  "ion-chatbox-working": c(61722),
  "ion-chatboxes": c(61724),
  "ion-person": c(61971),
  "ion-person-add": c(61969),
  "ion-person-stalker": c(61970),
  "ion-woman": c(62045),
  "ion-man": c(61954),
  "ion-female": c(62072),
  "ion-male": c(62113),
  "ion-transgender": c(62709),
  "ion-fork": c(62074),
  "ion-knife": c(62103),
  "ion-spoon": c(62132),
  "ion-soup-can-outline": c(62707),
  "ion-soup-can": c(62708),
  "ion-beer": c(62058),
  "ion-wineglass": c(62137),
  "ion-coffee": c(62066),
  "ion-icecream": c(62077),
  "ion-pizza": c(62120),
  "ion-power": c(62121),
  "ion-mouse": c(62272),
  "ion-battery-full": c(61715),
  "ion-battery-half": c(61716),
  "ion-battery-low": c(61717),
  "ion-battery-empty": c(61714),
  "ion-battery-charging": c(61713),
  "ion-wifi": c(62044),
  "ion-bluetooth": c(61718),
  "ion-calculator": c(62061),
  "ion-camera": c(61720),
  "ion-eye": c(61747),
  "ion-eye-disabled": c(62214),
  "ion-flash": c(61751),
  "ion-flash-off": c(61750),
  "ion-qr-scanner": c(62278),
  "ion-image": c(61767),
  "ion-images": c(61768),
  "ion-wand": c(62296),
  "ion-contrast": c(62069),
  "ion-aperture": c(62227),
  "ion-crop": c(62401),
  "ion-easel": c(62402),
  "ion-paintbrush": c(62677),
  "ion-paintbucket": c(62678),
  "ion-monitor": c(61962),
  "ion-laptop": c(61948),
  "ion-ipad": c(61945),
  "ion-iphone": c(61946),
  "ion-ipod": c(61947),
  "ion-printer": c(61978),
  "ion-usb": c(62136),
  "ion-outlet": c(62274),
  "ion-bug": c(62142),
  "ion-code": c(62065),
  "ion-code-working": c(62064),
  "ion-code-download": c(62063),
  "ion-fork-repo": c(62144),
  "ion-network": c(62273),
  "ion-pull-request": c(62277),
  "ion-merge": c(62271),
  "ion-xbox": c(62220),
  "ion-playstation": c(62218),
  "ion-steam": c(62219),
  "ion-closed-captioning": c(62231),
  "ion-videocamera": c(62038),
  "ion-film-marker": c(61749),
  "ion-disc": c(61741),
  "ion-headphone": c(61760),
  "ion-music-note": c(61964),
  "ion-radio-waves": c(62124),
  "ion-speakerphone": c(62130),
  "ion-mic-a": c(61956),
  "ion-mic-b": c(61957),
  "ion-mic-c": c(61958),
  "ion-volume-high": c(62039),
  "ion-volume-medium": c(62041),
  "ion-volume-low": c(62040),
  "ion-volume-mute": c(62042),
  "ion-levels": c(62104),
  "ion-play": c(61973),
  "ion-pause": c(61968),
  "ion-stop": c(62031),
  "ion-record": c(61979),
  "ion-skip-forward": c(61987),
  "ion-skip-backward": c(61986),
  "ion-eject": c(61745),
  "ion-bag": c(61712),
  "ion-card": c(61721),
  "ion-cash": c(62230),
  "ion-pricetag": c(62122),
  "ion-pricetags": c(62123),
  "ion-thumbsup": c(62033),
  "ion-thumbsdown": c(62032),
  "ion-happy-outline": c(62406),
  "ion-happy": c(62236),
  "ion-sad-outline": c(62679),
  "ion-sad": c(62282),
  "ion-bowtie": c(62400),
  "ion-tshirt-outline": c(62710),
  "ion-tshirt": c(62711),
  "ion-trophy": c(62294),
  "ion-podium": c(62276),
  "ion-ribbon-a": c(62280),
  "ion-ribbon-b": c(62281),
  "ion-university": c(62295),
  "ion-magnet": c(62112),
  "ion-beaker": c(62057),
  "ion-erlenmeyer-flask": c(62405),
  "ion-egg": c(62071),
  "ion-earth": c(62070),
  "ion-planet": c(62275),
  "ion-lightbulb": c(62105),
  "ion-cube": c(62232),
  "ion-leaf": c(61949),
  "ion-waterdrop": c(62043),
  "ion-flame": c(62234),
  "ion-fireball": c(62233),
  "ion-bonfire": c(62229),
  "ion-umbrella": c(62135),
  "ion-nuclear": c(62116),
  "ion-no-smoking": c(62146),
  "ion-thermometer": c(62134),
  "ion-speedometer": c(62131),
  "ion-model-s": c(62145),
  "ion-plane": c(61972),
  "ion-jet": c(62101),
  "ion-load-a": c(62106),
  "ion-load-b": c(62107),
  "ion-load-c": c(62108),
  "ion-load-d": c(62109),
  "ion-ios-ionic-outline": c(62542),
  "ion-ios-arrow-back": c(62415),
  "ion-ios-arrow-forward": c(62417),
  "ion-ios-arrow-up": c(62424),
  "ion-ios-arrow-right": c(62419),
  "ion-ios-arrow-down": c(62416),
  "ion-ios-arrow-left": c(62418),
  "ion-ios-arrow-thin-up": c(62423),
  "ion-ios-arrow-thin-right": c(62422),
  "ion-ios-arrow-thin-down": c(62420),
  "ion-ios-arrow-thin-left": c(62421),
  "ion-ios-circle-filled": c(62464),
  "ion-ios-circle-outline": c(62465),
  "ion-ios-checkmark-empty": c(62461),
  "ion-ios-checkmark-outline": c(62462),
  "ion-ios-checkmark": c(62463),
  "ion-ios-plus-empty": c(62601),
  "ion-ios-plus-outline": c(62602),
  "ion-ios-plus": c(62603),
  "ion-ios-close-empty": c(62468),
  "ion-ios-close-outline": c(62469),
  "ion-ios-close": c(62470),
  "ion-ios-minus-empty": c(62562),
  "ion-ios-minus-outline": c(62563),
  "ion-ios-minus": c(62564),
  "ion-ios-information-empty": c(62539),
  "ion-ios-information-outline": c(62540),
  "ion-ios-information": c(62541),
  "ion-ios-help-empty": c(62532),
  "ion-ios-help-outline": c(62533),
  "ion-ios-help": c(62534),
  "ion-ios-search": c(62629),
  "ion-ios-search-strong": c(62628),
  "ion-ios-star": c(62643),
  "ion-ios-star-half": c(62641),
  "ion-ios-star-outline": c(62642),
  "ion-ios-heart": c(62531),
  "ion-ios-heart-outline": c(62530),
  "ion-ios-more": c(62570),
  "ion-ios-more-outline": c(62569),
  "ion-ios-home": c(62536),
  "ion-ios-home-outline": c(62535),
  "ion-ios-cloud": c(62476),
  "ion-ios-cloud-outline": c(62473),
  "ion-ios-cloud-upload": c(62475),
  "ion-ios-cloud-upload-outline": c(62474),
  "ion-ios-cloud-download": c(62472),
  "ion-ios-cloud-download-outline": c(62471),
  "ion-ios-upload": c(62667),
  "ion-ios-upload-outline": c(62666),
  "ion-ios-download": c(62496),
  "ion-ios-download-outline": c(62495),
  "ion-ios-refresh": c(62620),
  "ion-ios-refresh-outline": c(62619),
  "ion-ios-refresh-empty": c(62618),
  "ion-ios-reload": c(62621),
  "ion-ios-loop-strong": c(62553),
  "ion-ios-loop": c(62554),
  "ion-ios-bookmarks": c(62442),
  "ion-ios-bookmarks-outline": c(62441),
  "ion-ios-book": c(62440),
  "ion-ios-book-outline": c(62439),
  "ion-ios-flag": c(62509),
  "ion-ios-flag-outline": c(62508),
  "ion-ios-glasses": c(62527),
  "ion-ios-glasses-outline": c(62526),
  "ion-ios-browsers": c(62448),
  "ion-ios-browsers-outline": c(62447),
  "ion-ios-at": c(62426),
  "ion-ios-at-outline": c(62425),
  "ion-ios-pricetag": c(62605),
  "ion-ios-pricetag-outline": c(62604),
  "ion-ios-pricetags": c(62607),
  "ion-ios-pricetags-outline": c(62606),
  "ion-ios-cart": c(62456),
  "ion-ios-cart-outline": c(62455),
  "ion-ios-chatboxes": c(62458),
  "ion-ios-chatboxes-outline": c(62457),
  "ion-ios-chatbubble": c(62460),
  "ion-ios-chatbubble-outline": c(62459),
  "ion-ios-cog": c(62482),
  "ion-ios-cog-outline": c(62481),
  "ion-ios-gear": c(62525),
  "ion-ios-gear-outline": c(62524),
  "ion-ios-settings": c(62631),
  "ion-ios-settings-strong": c(62630),
  "ion-ios-toggle": c(62659),
  "ion-ios-toggle-outline": c(62658),
  "ion-ios-analytics": c(62414),
  "ion-ios-analytics-outline": c(62413),
  "ion-ios-pie": c(62596),
  "ion-ios-pie-outline": c(62595),
  "ion-ios-pulse": c(62611),
  "ion-ios-pulse-strong": c(62610),
  "ion-ios-filing": c(62505),
  "ion-ios-filing-outline": c(62504),
  "ion-ios-box": c(62444),
  "ion-ios-box-outline": c(62443),
  "ion-ios-compose": c(62488),
  "ion-ios-compose-outline": c(62487),
  "ion-ios-trash": c(62661),
  "ion-ios-trash-outline": c(62660),
  "ion-ios-copy": c(62492),
  "ion-ios-copy-outline": c(62491),
  "ion-ios-email": c(62499),
  "ion-ios-email-outline": c(62498),
  "ion-ios-undo": c(62663),
  "ion-ios-undo-outline": c(62662),
  "ion-ios-redo": c(62617),
  "ion-ios-redo-outline": c(62616),
  "ion-ios-paperplane": c(62580),
  "ion-ios-paperplane-outline": c(62579),
  "ion-ios-folder": c(62517),
  "ion-ios-folder-outline": c(62516),
  "ion-ios-paper": c(62578),
  "ion-ios-paper-outline": c(62577),
  "ion-ios-list": c(62548),
  "ion-ios-list-outline": c(62547),
  "ion-ios-world": c(62675),
  "ion-ios-world-outline": c(62674),
  "ion-ios-alarm": c(62408),
  "ion-ios-alarm-outline": c(62407),
  "ion-ios-speedometer": c(62640),
  "ion-ios-speedometer-outline": c(62639),
  "ion-ios-stopwatch": c(62645),
  "ion-ios-stopwatch-outline": c(62644),
  "ion-ios-timer": c(62657),
  "ion-ios-timer-outline": c(62656),
  "ion-ios-clock": c(62467),
  "ion-ios-clock-outline": c(62466),
  "ion-ios-time": c(62655),
  "ion-ios-time-outline": c(62654),
  "ion-ios-calendar": c(62452),
  "ion-ios-calendar-outline": c(62451),
  "ion-ios-photos": c(62594),
  "ion-ios-photos-outline": c(62593),
  "ion-ios-albums": c(62410),
  "ion-ios-albums-outline": c(62409),
  "ion-ios-camera": c(62454),
  "ion-ios-camera-outline": c(62453),
  "ion-ios-reverse-camera": c(62623),
  "ion-ios-reverse-camera-outline": c(62622),
  "ion-ios-eye": c(62501),
  "ion-ios-eye-outline": c(62500),
  "ion-ios-bolt": c(62438),
  "ion-ios-bolt-outline": c(62437),
  "ion-ios-color-wand": c(62486),
  "ion-ios-color-wand-outline": c(62485),
  "ion-ios-color-filter": c(62484),
  "ion-ios-color-filter-outline": c(62483),
  "ion-ios-grid-view": c(62529),
  "ion-ios-grid-view-outline": c(62528),
  "ion-ios-crop-strong": c(62493),
  "ion-ios-crop": c(62494),
  "ion-ios-barcode": c(62428),
  "ion-ios-barcode-outline": c(62427),
  "ion-ios-briefcase": c(62446),
  "ion-ios-briefcase-outline": c(62445),
  "ion-ios-medkit": c(62558),
  "ion-ios-medkit-outline": c(62557),
  "ion-ios-medical": c(62556),
  "ion-ios-medical-outline": c(62555),
  "ion-ios-infinite": c(62538),
  "ion-ios-infinite-outline": c(62537),
  "ion-ios-calculator": c(62450),
  "ion-ios-calculator-outline": c(62449),
  "ion-ios-keypad": c(62544),
  "ion-ios-keypad-outline": c(62543),
  "ion-ios-telephone": c(62649),
  "ion-ios-telephone-outline": c(62648),
  "ion-ios-drag": c(62497),
  "ion-ios-location": c(62550),
  "ion-ios-location-outline": c(62549),
  "ion-ios-navigate": c(62574),
  "ion-ios-navigate-outline": c(62573),
  "ion-ios-locked": c(62552),
  "ion-ios-locked-outline": c(62551),
  "ion-ios-unlocked": c(62665),
  "ion-ios-unlocked-outline": c(62664),
  "ion-ios-monitor": c(62566),
  "ion-ios-monitor-outline": c(62565),
  "ion-ios-printer": c(62609),
  "ion-ios-printer-outline": c(62608),
  "ion-ios-game-controller-a": c(62521),
  "ion-ios-game-controller-a-outline": c(62520),
  "ion-ios-game-controller-b": c(62523),
  "ion-ios-game-controller-b-outline": c(62522),
  "ion-ios-americanfootball": c(62412),
  "ion-ios-americanfootball-outline": c(62411),
  "ion-ios-baseball": c(62430),
  "ion-ios-baseball-outline": c(62429),
  "ion-ios-basketball": c(62432),
  "ion-ios-basketball-outline": c(62431),
  "ion-ios-tennisball": c(62651),
  "ion-ios-tennisball-outline": c(62650),
  "ion-ios-football": c(62519),
  "ion-ios-football-outline": c(62518),
  "ion-ios-body": c(62436),
  "ion-ios-body-outline": c(62435),
  "ion-ios-person": c(62590),
  "ion-ios-person-outline": c(62589),
  "ion-ios-personadd": c(62592),
  "ion-ios-personadd-outline": c(62591),
  "ion-ios-people": c(62588),
  "ion-ios-people-outline": c(62587),
  "ion-ios-musical-notes": c(62572),
  "ion-ios-musical-note": c(62571),
  "ion-ios-bell": c(62434),
  "ion-ios-bell-outline": c(62433),
  "ion-ios-mic": c(62561),
  "ion-ios-mic-outline": c(62560),
  "ion-ios-mic-off": c(62559),
  "ion-ios-volume-high": c(62670),
  "ion-ios-volume-low": c(62671),
  "ion-ios-play": c(62600),
  "ion-ios-play-outline": c(62599),
  "ion-ios-pause": c(62584),
  "ion-ios-pause-outline": c(62583),
  "ion-ios-recording": c(62615),
  "ion-ios-recording-outline": c(62614),
  "ion-ios-fastforward": c(62503),
  "ion-ios-fastforward-outline": c(62502),
  "ion-ios-rewind": c(62625),
  "ion-ios-rewind-outline": c(62624),
  "ion-ios-skipbackward": c(62635),
  "ion-ios-skipbackward-outline": c(62634),
  "ion-ios-skipforward": c(62637),
  "ion-ios-skipforward-outline": c(62636),
  "ion-ios-shuffle-strong": c(62632),
  "ion-ios-shuffle": c(62633),
  "ion-ios-videocam": c(62669),
  "ion-ios-videocam-outline": c(62668),
  "ion-ios-film": c(62507),
  "ion-ios-film-outline": c(62506),
  "ion-ios-flask": c(62513),
  "ion-ios-flask-outline": c(62512),
  "ion-ios-lightbulb": c(62546),
  "ion-ios-lightbulb-outline": c(62545),
  "ion-ios-wineglass": c(62673),
  "ion-ios-wineglass-outline": c(62672),
  "ion-ios-pint": c(62598),
  "ion-ios-pint-outline": c(62597),
  "ion-ios-nutrition": c(62576),
  "ion-ios-nutrition-outline": c(62575),
  "ion-ios-flower": c(62515),
  "ion-ios-flower-outline": c(62514),
  "ion-ios-rose": c(62627),
  "ion-ios-rose-outline": c(62626),
  "ion-ios-paw": c(62586),
  "ion-ios-paw-outline": c(62585),
  "ion-ios-flame": c(62511),
  "ion-ios-flame-outline": c(62510),
  "ion-ios-sunny": c(62647),
  "ion-ios-sunny-outline": c(62646),
  "ion-ios-partlysunny": c(62582),
  "ion-ios-partlysunny-outline": c(62581),
  "ion-ios-cloudy": c(62480),
  "ion-ios-cloudy-outline": c(62479),
  "ion-ios-rainy": c(62613),
  "ion-ios-rainy-outline": c(62612),
  "ion-ios-thunderstorm": c(62653),
  "ion-ios-thunderstorm-outline": c(62652),
  "ion-ios-snowy": c(62638),
  "ion-ios-moon": c(62568),
  "ion-ios-moon-outline": c(62567),
  "ion-ios-cloudy-night": c(62478),
  "ion-ios-cloudy-night-outline": c(62477),
  "ion-android-arrow-up": c(62310),
  "ion-android-arrow-forward": c(62223),
  "ion-android-arrow-down": c(62301),
  "ion-android-arrow-back": c(62154),
  "ion-android-arrow-dropup": c(62309),
  "ion-android-arrow-dropup-circle": c(62308),
  "ion-android-arrow-dropright": c(62307),
  "ion-android-arrow-dropright-circle": c(62306),
  "ion-android-arrow-dropdown": c(62303),
  "ion-android-arrow-dropdown-circle": c(62302),
  "ion-android-arrow-dropleft": c(62305),
  "ion-android-arrow-dropleft-circle": c(62304),
  "ion-android-add": c(62151),
  "ion-android-add-circle": c(62297),
  "ion-android-remove": c(62196),
  "ion-android-remove-circle": c(62377),
  "ion-android-close": c(62167),
  "ion-android-cancel": c(62318),
  "ion-android-radio-button-off": c(62374),
  "ion-android-radio-button-on": c(62375),
  "ion-android-checkmark-circle": c(62325),
  "ion-android-checkbox-outline-blank": c(62322),
  "ion-android-checkbox-outline": c(62323),
  "ion-android-checkbox-blank": c(62321),
  "ion-android-checkbox": c(62324),
  "ion-android-done": c(62339),
  "ion-android-done-all": c(62338),
  "ion-android-menu": c(62356),
  "ion-android-more-horizontal": c(62358),
  "ion-android-more-vertical": c(62359),
  "ion-android-refresh": c(62376),
  "ion-android-sync": c(62385),
  "ion-android-wifi": c(62213),
  "ion-android-call": c(62162),
  "ion-android-apps": c(62300),
  "ion-android-settings": c(62199),
  "ion-android-options": c(62365),
  "ion-android-funnel": c(62347),
  "ion-android-search": c(62197),
  "ion-android-home": c(62351),
  "ion-android-cloud-outline": c(62329),
  "ion-android-cloud": c(62330),
  "ion-android-download": c(62173),
  "ion-android-upload": c(62390),
  "ion-android-cloud-done": c(62328),
  "ion-android-cloud-circle": c(62327),
  "ion-android-favorite-outline": c(62343),
  "ion-android-favorite": c(62344),
  "ion-android-star-outline": c(62382),
  "ion-android-star-half": c(62381),
  "ion-android-star": c(62204),
  "ion-android-calendar": c(62161),
  "ion-android-alarm-clock": c(62298),
  "ion-android-time": c(62387),
  "ion-android-stopwatch": c(62205),
  "ion-android-watch": c(62397),
  "ion-android-locate": c(62185),
  "ion-android-navigate": c(62360),
  "ion-android-pin": c(62371),
  "ion-android-compass": c(62332),
  "ion-android-map": c(62355),
  "ion-android-walk": c(62395),
  "ion-android-bicycle": c(62313),
  "ion-android-car": c(62319),
  "ion-android-bus": c(62317),
  "ion-android-subway": c(62383),
  "ion-android-train": c(62388),
  "ion-android-boat": c(62314),
  "ion-android-plane": c(62372),
  "ion-android-restaurant": c(62378),
  "ion-android-bar": c(62312),
  "ion-android-cart": c(62320),
  "ion-android-camera": c(62163),
  "ion-android-image": c(62180),
  "ion-android-film": c(62345),
  "ion-android-color-palette": c(62331),
  "ion-android-create": c(62334),
  "ion-android-mail": c(62187),
  "ion-android-drafts": c(62340),
  "ion-android-send": c(62198),
  "ion-android-archive": c(62153),
  "ion-android-delete": c(62335),
  "ion-android-attach": c(62311),
  "ion-android-share": c(62200),
  "ion-android-share-alt": c(62380),
  "ion-android-bookmark": c(62315),
  "ion-android-document": c(62337),
  "ion-android-clipboard": c(62326),
  "ion-android-list": c(62353),
  "ion-android-folder-open": c(62346),
  "ion-android-folder": c(62176),
  "ion-android-print": c(62373),
  "ion-android-open": c(62364),
  "ion-android-exit": c(62341),
  "ion-android-contract": c(62333),
  "ion-android-expand": c(62342),
  "ion-android-globe": c(62348),
  "ion-android-chat": c(62164),
  "ion-android-textsms": c(62386),
  "ion-android-hangout": c(62349),
  "ion-android-happy": c(62350),
  "ion-android-sad": c(62379),
  "ion-android-person": c(62368),
  "ion-android-people": c(62366),
  "ion-android-person-add": c(62367),
  "ion-android-contact": c(62168),
  "ion-android-contacts": c(62169),
  "ion-android-playstore": c(62192),
  "ion-android-lock": c(62354),
  "ion-android-unlock": c(62389),
  "ion-android-microphone": c(62188),
  "ion-android-microphone-off": c(62357),
  "ion-android-notifications-none": c(62361),
  "ion-android-notifications": c(62363),
  "ion-android-notifications-off": c(62362),
  "ion-android-volume-mute": c(62392),
  "ion-android-volume-down": c(62391),
  "ion-android-volume-up": c(62394),
  "ion-android-volume-off": c(62393),
  "ion-android-hand": c(62179),
  "ion-android-desktop": c(62336),
  "ion-android-laptop": c(62352),
  "ion-android-phone-portrait": c(62370),
  "ion-android-phone-landscape": c(62369),
  "ion-android-bulb": c(62316),
  "ion-android-sunny": c(62384),
  "ion-android-alert": c(62299),
  "ion-android-warning": c(62396),
  "ion-social-twitter": c(62019),
  "ion-social-twitter-outline": c(62018),
  "ion-social-facebook": c(62001),
  "ion-social-facebook-outline": c(62000),
  "ion-social-googleplus": c(62005),
  "ion-social-googleplus-outline": c(62004),
  "ion-social-google": c(62287),
  "ion-social-google-outline": c(62286),
  "ion-social-dribbble": c(61997),
  "ion-social-dribbble-outline": c(61996),
  "ion-social-octocat": c(62696),
  "ion-social-github": c(62003),
  "ion-social-github-outline": c(62002),
  "ion-social-instagram": c(62289),
  "ion-social-instagram-outline": c(62288),
  "ion-social-whatsapp": c(62704),
  "ion-social-whatsapp-outline": c(62703),
  "ion-social-snapchat": c(62700),
  "ion-social-snapchat-outline": c(62699),
  "ion-social-foursquare": c(62285),
  "ion-social-foursquare-outline": c(62284),
  "ion-social-pinterest": c(62129),
  "ion-social-pinterest-outline": c(62128),
  "ion-social-rss": c(62013),
  "ion-social-rss-outline": c(62012),
  "ion-social-tumblr": c(62017),
  "ion-social-tumblr-outline": c(62016),
  "ion-social-wordpress": c(62025),
  "ion-social-wordpress-outline": c(62024),
  "ion-social-reddit": c(62011),
  "ion-social-reddit-outline": c(62010),
  "ion-social-hackernews": c(62007),
  "ion-social-hackernews-outline": c(62006),
  "ion-social-designernews": c(61995),
  "ion-social-designernews-outline": c(61994),
  "ion-social-yahoo": c(62027),
  "ion-social-yahoo-outline": c(62026),
  "ion-social-buffer": c(61993),
  "ion-social-buffer-outline": c(61992),
  "ion-social-skype": c(62015),
  "ion-social-skype-outline": c(62014),
  "ion-social-linkedin": c(62009),
  "ion-social-linkedin-outline": c(62008),
  "ion-social-vimeo": c(62021),
  "ion-social-vimeo-outline": c(62020),
  "ion-social-twitch": c(62702),
  "ion-social-twitch-outline": c(62701),
  "ion-social-youtube": c(62029),
  "ion-social-youtube-outline": c(62028),
  "ion-social-dropbox": c(61999),
  "ion-social-dropbox-outline": c(61998),
  "ion-social-apple": c(61991),
  "ion-social-apple-outline": c(61990),
  "ion-social-android": c(61989),
  "ion-social-android-outline": c(61988),
  "ion-social-windows": c(62023),
  "ion-social-windows-outline": c(62022),
  "ion-social-html5": c(62691),
  "ion-social-html5-outline": c(62690),
  "ion-social-css3": c(62687),
  "ion-social-css3-outline": c(62686),
  "ion-social-javascript": c(62693),
  "ion-social-javascript-outline": c(62692),
  "ion-social-angular": c(62681),
  "ion-social-angular-outline": c(62680),
  "ion-social-nodejs": c(62695),
  "ion-social-sass": c(62698),
  "ion-social-python": c(62697),
  "ion-social-chrome": c(62683),
  "ion-social-chrome-outline": c(62682),
  "ion-social-codepen": c(62685),
  "ion-social-codepen-outline": c(62684),
  "ion-social-markdown": c(62694),
  "ion-social-tux": c(62149),
  "ion-social-freebsd-devil": c(62148),
  "ion-social-usd": c(62291),
  "ion-social-usd-outline": c(62290),
  "ion-social-bitcoin": c(62127),
  "ion-social-bitcoin-outline": c(62126),
  "ion-social-yen": c(62706),
  "ion-social-yen-outline": c(62705),
  "ion-social-euro": c(62689),
  "ion-social-euro-outline": c(62688)
};

exports.default = icons;

},{}],210:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CSS = exports.genCSS = exports.createStyleSheet = undefined;

var _freeze = require("babel-runtime/core-js/object/freeze");

var _freeze2 = _interopRequireDefault(_freeze);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = require("babel-runtime/helpers/defineProperty");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require("babel-runtime/core-js/object/entries");

var _entries2 = _interopRequireDefault(_entries);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cssNoMeasurement = new _set2.default(["animationIterationCount", "boxFlex", "boxFlexGroup", "boxOrdinalGroup", "columnCount", "fillOpacity", "flex", "flexGrow", "flexPositive", "flexShrink", "flexNegative", "flexOrder", "fontWeight", "lineClamp", "lineHeight", "opacity", "order", "orphans", "stopOpacity", "strokeDashoffset", "strokeOpacity", "strokeWidth", "tabSize", "widows", "zIndex", "zoom"]);
var cssPrefixNames = new _set2.default(['transform', 'transformOrigin', 'boxShadow', 'transition', 'animation', 'animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction', 'userSelect', 'justifyContent', 'alignItems', 'flexWrap']);
var cssPrefixes = ['-webkit-', '-moz-', '-ms-', '-o-', ''];

var getCSSValue = function getCSSValue(prop, value) {
    if (value === null) {
        return null;
    }
    if (typeof value === 'function') {
        value = value();
    }
    if (Array.isArray(value) === true) {
        return value.map(function (value) {
            return getCSSValue(prop, value)[0];
        });
    }
    if (typeof value === 'number' && cssNoMeasurement.has(prop) === false) {
        value += "px";
    }
    return [value];
};

var genCSS = function genCSS(defs) {
    var tabs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var space = '\t'.repeat(tabs);
    return (0, _entries2.default)(defs).reduce(function (css, _ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            selector = _ref2[0],
            cssProps = _ref2[1];

        var content = (0, _entries2.default)(cssProps).reduce(function (contentArray, _ref3) {
            var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
                propName = _ref4[0],
                propValue = _ref4[1];

            var lines = [];
            if (Array.isArray(propValue) === false && (typeof propValue === "undefined" ? "undefined" : (0, _typeof3.default)(propValue)) === 'object') {
                lines = [genCSS((0, _defineProperty3.default)({}, propName, propValue), tabs + 1)];
            } else {
                var value = getCSSValue(propName, propValue);
                var cssPropName = propName.replace(/[A-Z]/g, function (letter) {
                    return '-' + letter.toLowerCase();
                });

                if (cssPrefixNames.has(propName) === true) {
                    lines = cssPrefixes.map(function (prefix) {
                        return space + "\t" + prefix + cssPropName + ": " + value[0] + ";";
                    });
                } else {
                    lines = value.map(function (value) {
                        return space + "\t" + cssPropName + ": " + value + ";";
                    });
                }
            }

            return [].concat((0, _toConsumableArray3.default)(contentArray), (0, _toConsumableArray3.default)(lines));
        }, []).join('\n');
        if (selector.slice(0, 10) === "@keyframes") {
            css.push(space + "@-webkit-keyframes " + selector.slice(11) + " {\n" + content + "\n" + space + "}");
        }
        css.push("" + space + selector + " {\n" + content + "\n" + space + "}");
        return css;
    }, []).join('\n');
};
var createStyleSheet = function createStyleSheet() {
    var styles = {};
    return {
        addStyles: function addStyles(defs) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)((0, _entries2.default)(defs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
                        selector = _step$value[0],
                        def = _step$value[1];

                    styles[selector] = def;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        },
        __init: function __init(styleTag) {
            styleTag.innerHTML = genCSS(styles);
        }
    };
};

var CSS = (0, _freeze2.default)({
    rgba: function rgba(r, g, b, a) {
        return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
    },
    rgb: function rgb(r, g, b) {
        return CSS.rgba(r, g, b, 1);
    }
});

exports.createStyleSheet = createStyleSheet;
exports.genCSS = genCSS;
exports.CSS = CSS;

},{"babel-runtime/core-js/get-iterator":215,"babel-runtime/core-js/object/entries":221,"babel-runtime/core-js/object/freeze":222,"babel-runtime/core-js/set":228,"babel-runtime/helpers/defineProperty":232,"babel-runtime/helpers/slicedToArray":237,"babel-runtime/helpers/toConsumableArray":238,"babel-runtime/helpers/typeof":239}],211:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var theme = {
    general: {
        boxShadow: '0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2)'
    },
    button: {
        text: {
            color: 'black'
        }
    }
};

exports.default = theme;

},{}],212:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.warningFunc = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warningFunc = function warningFunc(errorMessage) {
    return function () {
        return console.warn(errorMessage);
    };
};

window.range = {
    array: function array(start) {
        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var f = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var arr = [];

        if (f === null) {
            if (typeof end === 'function') {
                f = end;
                end = null;
            } else {
                f = function f(i) {
                    return i;
                };
            }
        }
        if (end === null) {
            end = start;
            start = 0;
        }

        while (start < end) {
            arr.push(f(start));
            start += 1;
        }

        return arr;
    },
    gen: _regenerator2.default.mark(function gen(start) {
        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var f = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        return _regenerator2.default.wrap(function gen$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (f === null) {
                            if (typeof end === 'function') {
                                f = end;
                                end = null;
                            } else {
                                f = function f(i) {
                                    return i;
                                };
                            }
                        }
                        if (end === null) {
                            end = start;
                            start = 0;
                        }

                    case 2:
                        if (!(start < end)) {
                            _context.next = 8;
                            break;
                        }

                        _context.next = 5;
                        return f(start);

                    case 5:
                        start += 1;
                        _context.next = 2;
                        break;

                    case 8:
                    case 'end':
                        return _context.stop();
                }
            }
        }, gen, this);
    })
};

exports.warningFunc = warningFunc;

},{"babel-runtime/regenerator":240}],213:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],214:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":242}],215:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":243}],216:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":244}],217:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":245}],218:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":246}],219:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":247}],220:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":248}],221:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/entries"), __esModule: true };
},{"core-js/library/fn/object/entries":249}],222:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":250}],223:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":251}],224:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":252}],225:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":253}],226:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/values"), __esModule: true };
},{"core-js/library/fn/object/values":254}],227:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":255}],228:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":256}],229:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":257}],230:[function(require,module,exports){
"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      var callNext = step.bind(null, "next");
      var callThrow = step.bind(null, "throw");

      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          _promise2.default.resolve(value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };
};

exports.__esModule = true;
},{"babel-runtime/core-js/promise":227}],231:[function(require,module,exports){
"use strict";

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],232:[function(require,module,exports){
"use strict";

var _defineProperty = require("babel-runtime/core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":220}],233:[function(require,module,exports){
"use strict";

var _Object$assign = require("babel-runtime/core-js/object/assign")["default"];

exports["default"] = _Object$assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/assign":218}],234:[function(require,module,exports){
"use strict";

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":219,"babel-runtime/core-js/object/set-prototype-of":225}],235:[function(require,module,exports){
"use strict";

exports.default = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

exports.__esModule = true;
},{}],236:[function(require,module,exports){
"use strict";

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

exports.__esModule = true;
},{"babel-runtime/helpers/typeof":239}],237:[function(require,module,exports){
"use strict";

var _isIterable2 = require("babel-runtime/core-js/is-iterable");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/get-iterator":215,"babel-runtime/core-js/is-iterable":216}],238:[function(require,module,exports){
"use strict";

var _from = require("babel-runtime/core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/array/from":214}],239:[function(require,module,exports){
"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

exports["default"] = function (obj) {
  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
};

exports.__esModule = true;
},{"babel-runtime/core-js/symbol":229}],240:[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":241}],241:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (_Object$setPrototypeOf) {
      _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return _Promise.resolve(value.arg).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return _Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new _Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":213,"babel-runtime/core-js/object/create":219,"babel-runtime/core-js/object/set-prototype-of":225,"babel-runtime/core-js/promise":227,"babel-runtime/core-js/symbol":229}],242:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/$.core').Array.from;
},{"../../modules/$.core":266,"../../modules/es6.array.from":319,"../../modules/es6.string.iterator":330}],243:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":317,"../modules/es6.string.iterator":330,"../modules/web.dom.iterable":336}],244:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.is-iterable');
},{"../modules/core.is-iterable":318,"../modules/es6.string.iterator":330,"../modules/web.dom.iterable":336}],245:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
module.exports = require('../modules/$.core').Map;
},{"../modules/$.core":266,"../modules/es6.map":321,"../modules/es6.object.to-string":327,"../modules/es6.string.iterator":330,"../modules/es7.map.to-json":332,"../modules/web.dom.iterable":336}],246:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$.core').Object.assign;
},{"../../modules/$.core":266,"../../modules/es6.object.assign":322}],247:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":291}],248:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":291}],249:[function(require,module,exports){
require('../../modules/es7.object.entries');
module.exports = require('../../modules/$.core').Object.entries;
},{"../../modules/$.core":266,"../../modules/es7.object.entries":333}],250:[function(require,module,exports){
require('../../modules/es6.object.freeze');
module.exports = require('../../modules/$.core').Object.freeze;
},{"../../modules/$.core":266,"../../modules/es6.object.freeze":323}],251:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/$.core').Object.getPrototypeOf;
},{"../../modules/$.core":266,"../../modules/es6.object.get-prototype-of":324}],252:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/$.core').Object.keys;
},{"../../modules/$.core":266,"../../modules/es6.object.keys":325}],253:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":266,"../../modules/es6.object.set-prototype-of":326}],254:[function(require,module,exports){
require('../../modules/es7.object.values');
module.exports = require('../../modules/$.core').Object.values;
},{"../../modules/$.core":266,"../../modules/es7.object.values":334}],255:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
module.exports = require('../modules/$.core').Promise;
},{"../modules/$.core":266,"../modules/es6.object.to-string":327,"../modules/es6.promise":328,"../modules/es6.string.iterator":330,"../modules/web.dom.iterable":336}],256:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/$.core').Set;
},{"../modules/$.core":266,"../modules/es6.object.to-string":327,"../modules/es6.set":329,"../modules/es6.string.iterator":330,"../modules/es7.set.to-json":335,"../modules/web.dom.iterable":336}],257:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
module.exports = require('../../modules/$.core').Symbol;
},{"../../modules/$.core":266,"../../modules/es6.object.to-string":327,"../../modules/es6.symbol":331}],258:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],259:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],260:[function(require,module,exports){
var isObject = require('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":284}],261:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , TAG = require('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":262,"./$.wks":315}],262:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],263:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , hide         = require('./$.hide')
  , redefineAll  = require('./$.redefine-all')
  , ctx          = require('./$.ctx')
  , strictNew    = require('./$.strict-new')
  , defined      = require('./$.defined')
  , forOf        = require('./$.for-of')
  , $iterDefine  = require('./$.iter-define')
  , step         = require('./$.iter-step')
  , ID           = require('./$.uid')('id')
  , $has         = require('./$.has')
  , isObject     = require('./$.is-object')
  , setSpecies   = require('./$.set-species')
  , DESCRIPTORS  = require('./$.descriptors')
  , isExtensible = Object.isExtensible || isObject
  , SIZE         = DESCRIPTORS ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./$":291,"./$.ctx":267,"./$.defined":268,"./$.descriptors":269,"./$.for-of":274,"./$.has":277,"./$.hide":278,"./$.is-object":284,"./$.iter-define":287,"./$.iter-step":289,"./$.redefine-all":299,"./$.set-species":303,"./$.strict-new":307,"./$.uid":314}],264:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = require('./$.for-of')
  , classof = require('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":261,"./$.for-of":274}],265:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , global         = require('./$.global')
  , $export        = require('./$.export')
  , fails          = require('./$.fails')
  , hide           = require('./$.hide')
  , redefineAll    = require('./$.redefine-all')
  , forOf          = require('./$.for-of')
  , strictNew      = require('./$.strict-new')
  , isObject       = require('./$.is-object')
  , setToStringTag = require('./$.set-to-string-tag')
  , DESCRIPTORS    = require('./$.descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":291,"./$.descriptors":269,"./$.export":272,"./$.fails":273,"./$.for-of":274,"./$.global":276,"./$.hide":278,"./$.is-object":284,"./$.redefine-all":299,"./$.set-to-string-tag":304,"./$.strict-new":307}],266:[function(require,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],267:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":258}],268:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],269:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":273}],270:[function(require,module,exports){
var isObject = require('./$.is-object')
  , document = require('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":276,"./$.is-object":284}],271:[function(require,module,exports){
// all enumerable object keys, includes symbols
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":291}],272:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , ctx       = require('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":266,"./$.ctx":267,"./$.global":276}],273:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],274:[function(require,module,exports){
var ctx         = require('./$.ctx')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , anObject    = require('./$.an-object')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":260,"./$.ctx":267,"./$.is-array-iter":282,"./$.iter-call":285,"./$.to-length":312,"./core.get-iterator-method":316}],275:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./$.to-iobject')
  , getNames  = require('./$').getNames
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":291,"./$.to-iobject":311}],276:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],277:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],278:[function(require,module,exports){
var $          = require('./$')
  , createDesc = require('./$.property-desc');
module.exports = require('./$.descriptors') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":291,"./$.descriptors":269,"./$.property-desc":298}],279:[function(require,module,exports){
module.exports = require('./$.global').document && document.documentElement;
},{"./$.global":276}],280:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],281:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":262}],282:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./$.iterators')
  , ITERATOR   = require('./$.wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./$.iterators":290,"./$.wks":315}],283:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":262}],284:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],285:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":260}],286:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , descriptor     = require('./$.property-desc')
  , setToStringTag = require('./$.set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./$":291,"./$.hide":278,"./$.property-desc":298,"./$.set-to-string-tag":304,"./$.wks":315}],287:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./$.library')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , hide           = require('./$.hide')
  , has            = require('./$.has')
  , Iterators      = require('./$.iterators')
  , $iterCreate    = require('./$.iter-create')
  , setToStringTag = require('./$.set-to-string-tag')
  , getProto       = require('./$').getProto
  , ITERATOR       = require('./$.wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , methods, key;
  // Fix native
  if($native){
    var IteratorPrototype = getProto($default.call(new Base));
    // Set @@toStringTag to native iterators
    setToStringTag(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES  ? $default : getMethod(VALUES),
      keys:    IS_SET      ? $default : getMethod(KEYS),
      entries: !DEF_VALUES ? $default : getMethod('entries')
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./$":291,"./$.export":272,"./$.has":277,"./$.hide":278,"./$.iter-create":286,"./$.iterators":290,"./$.library":293,"./$.redefine":300,"./$.set-to-string-tag":304,"./$.wks":315}],288:[function(require,module,exports){
var ITERATOR     = require('./$.wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":315}],289:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],290:[function(require,module,exports){
module.exports = {};
},{}],291:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],292:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":291,"./$.to-iobject":311}],293:[function(require,module,exports){
module.exports = true;
},{}],294:[function(require,module,exports){
var global    = require('./$.global')
  , macrotask = require('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain, fn;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    fn     = head.fn;
    if(domain)domain.enter();
    fn(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// environments with maybe non-completely correct, but existent Promise
} else if(Promise && Promise.resolve){
  notify = function(){
    Promise.resolve().then(flush);
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":262,"./$.global":276,"./$.task":309}],295:[function(require,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = require('./$')
  , toObject = require('./$.to-object')
  , IObject  = require('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = require('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":291,"./$.fails":273,"./$.iobject":281,"./$.to-object":313}],296:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./$.export')
  , core    = require('./$.core')
  , fails   = require('./$.fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":266,"./$.export":272,"./$.fails":273}],297:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject')
  , isEnum    = $.isEnum;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./$":291,"./$.to-iobject":311}],298:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],299:[function(require,module,exports){
var redefine = require('./$.redefine');
module.exports = function(target, src){
  for(var key in src)redefine(target, key, src[key]);
  return target;
};
},{"./$.redefine":300}],300:[function(require,module,exports){
module.exports = require('./$.hide');
},{"./$.hide":278}],301:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],302:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = require('./$').getDesc
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":291,"./$.an-object":260,"./$.ctx":267,"./$.is-object":284}],303:[function(require,module,exports){
'use strict';
var core        = require('./$.core')
  , $           = require('./$')
  , DESCRIPTORS = require('./$.descriptors')
  , SPECIES     = require('./$.wks')('species');

module.exports = function(KEY){
  var C = core[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":291,"./$.core":266,"./$.descriptors":269,"./$.wks":315}],304:[function(require,module,exports){
var def = require('./$').setDesc
  , has = require('./$.has')
  , TAG = require('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":291,"./$.has":277,"./$.wks":315}],305:[function(require,module,exports){
var global = require('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":276}],306:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./$.an-object')
  , aFunction = require('./$.a-function')
  , SPECIES   = require('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":258,"./$.an-object":260,"./$.wks":315}],307:[function(require,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],308:[function(require,module,exports){
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":268,"./$.to-integer":310}],309:[function(require,module,exports){
var ctx                = require('./$.ctx')
  , invoke             = require('./$.invoke')
  , html               = require('./$.html')
  , cel                = require('./$.dom-create')
  , global             = require('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":262,"./$.ctx":267,"./$.dom-create":270,"./$.global":276,"./$.html":279,"./$.invoke":280}],310:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],311:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./$.iobject')
  , defined = require('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":268,"./$.iobject":281}],312:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":310}],313:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":268}],314:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],315:[function(require,module,exports){
var store  = require('./$.shared')('wks')
  , uid    = require('./$.uid')
  , Symbol = require('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
};
},{"./$.global":276,"./$.shared":305,"./$.uid":314}],316:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":261,"./$.core":266,"./$.iterators":290,"./$.wks":315}],317:[function(require,module,exports){
var anObject = require('./$.an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":260,"./$.core":266,"./core.get-iterator-method":316}],318:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};
},{"./$.classof":261,"./$.core":266,"./$.iterators":290,"./$.wks":315}],319:[function(require,module,exports){
'use strict';
var ctx         = require('./$.ctx')
  , $export     = require('./$.export')
  , toObject    = require('./$.to-object')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
$export($export.S + $export.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , $$      = arguments
      , $$len   = $$.length
      , mapfn   = $$len > 1 ? $$[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        result[index] = mapping ? mapfn(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});

},{"./$.ctx":267,"./$.export":272,"./$.is-array-iter":282,"./$.iter-call":285,"./$.iter-detect":288,"./$.to-length":312,"./$.to-object":313,"./core.get-iterator-method":316}],320:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./$.add-to-unscopables')
  , step             = require('./$.iter-step')
  , Iterators        = require('./$.iterators')
  , toIObject        = require('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./$.add-to-unscopables":259,"./$.iter-define":287,"./$.iter-step":289,"./$.iterators":290,"./$.to-iobject":311}],321:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":265,"./$.collection-strong":263}],322:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./$.export');

$export($export.S + $export.F, 'Object', {assign: require('./$.object-assign')});
},{"./$.export":272,"./$.object-assign":295}],323:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(it) : it;
  };
});
},{"./$.is-object":284,"./$.object-sap":296}],324:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('getPrototypeOf', function($getPrototypeOf){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./$.object-sap":296,"./$.to-object":313}],325:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":296,"./$.to-object":313}],326:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./$.export');
$export($export.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.export":272,"./$.set-proto":302}],327:[function(require,module,exports){

},{}],328:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , LIBRARY    = require('./$.library')
  , global     = require('./$.global')
  , ctx        = require('./$.ctx')
  , classof    = require('./$.classof')
  , $export    = require('./$.export')
  , isObject   = require('./$.is-object')
  , anObject   = require('./$.an-object')
  , aFunction  = require('./$.a-function')
  , strictNew  = require('./$.strict-new')
  , forOf      = require('./$.for-of')
  , setProto   = require('./$.set-proto').set
  , same       = require('./$.same-value')
  , SPECIES    = require('./$.wks')('species')
  , speciesConstructor = require('./$.species-constructor')
  , asap       = require('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var USE_NATIVE = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && require('./$.descriptors')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var PromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve),
  this.reject  = aFunction(reject)
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , result, then;
      try {
        if(handler){
          if(!ok)record.h = true;
          result = handler === true ? value : handler(value);
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise._d
    , chain  = record.a || record.c
    , i      = 0
    , reaction;
  if(record.h)return false;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(record.p === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = this._d = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.redefine-all')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction = new PromiseCapability(speciesConstructor(this, P))
        , promise  = reaction.promise
        , record   = this._d;
      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      record.c.push(reaction);
      if(record.a)record.a.push(reaction);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
require('./$.set-to-string-tag')(P, PROMISE);
require('./$.set-species')(PROMISE);
Wrapper = require('./$.core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = new PromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof P && sameConstructor(x.constructor, this))return x;
    var capability = new PromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject
      , values     = [];
    var abrupt = perform(function(){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        var alreadyCalled = false;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled = true;
          results[index] = value;
          --remaining || resolve(results);
        }, reject);
      });
      else resolve(results);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./$":291,"./$.a-function":258,"./$.an-object":260,"./$.classof":261,"./$.core":266,"./$.ctx":267,"./$.descriptors":269,"./$.export":272,"./$.for-of":274,"./$.global":276,"./$.is-object":284,"./$.iter-detect":288,"./$.library":293,"./$.microtask":294,"./$.redefine-all":299,"./$.same-value":301,"./$.set-proto":302,"./$.set-species":303,"./$.set-to-string-tag":304,"./$.species-constructor":306,"./$.strict-new":307,"./$.wks":315}],329:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":265,"./$.collection-strong":263}],330:[function(require,module,exports){
'use strict';
var $at  = require('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":287,"./$.string-at":308}],331:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = require('./$')
  , global         = require('./$.global')
  , has            = require('./$.has')
  , DESCRIPTORS    = require('./$.descriptors')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , $fails         = require('./$.fails')
  , shared         = require('./$.shared')
  , setToStringTag = require('./$.set-to-string-tag')
  , uid            = require('./$.uid')
  , wks            = require('./$.wks')
  , keyOf          = require('./$.keyof')
  , $names         = require('./$.get-names')
  , enumKeys       = require('./$.enum-keys')
  , isArray        = require('./$.is-array')
  , anObject       = require('./$.an-object')
  , toIObject      = require('./$.to-iobject')
  , createDesc     = require('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  redefine($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./$.library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$export($export.G + $export.W, {Symbol: $Symbol});

$export($export.S, 'Symbol', symbolStatics);

$export($export.S + $export.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./$":291,"./$.an-object":260,"./$.descriptors":269,"./$.enum-keys":271,"./$.export":272,"./$.fails":273,"./$.get-names":275,"./$.global":276,"./$.has":277,"./$.is-array":283,"./$.keyof":292,"./$.library":293,"./$.property-desc":298,"./$.redefine":300,"./$.set-to-string-tag":304,"./$.shared":305,"./$.to-iobject":311,"./$.uid":314,"./$.wks":315}],332:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Map', {toJSON: require('./$.collection-to-json')('Map')});
},{"./$.collection-to-json":264,"./$.export":272}],333:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $export  = require('./$.export')
  , $entries = require('./$.object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./$.export":272,"./$.object-to-array":297}],334:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $export = require('./$.export')
  , $values = require('./$.object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./$.export":272,"./$.object-to-array":297}],335:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":264,"./$.export":272}],336:[function(require,module,exports){
require('./es6.array.iterator');
var Iterators = require('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":290,"./es6.array.iterator":320}]},{},[202])(202)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0FSSUFET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0F1dG9Gb2N1c1V0aWxzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NTGF6eVRyZWUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01OYW1lc3BhY2VzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHkuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUG9vbGVkQ2xhc3MuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW5wdXQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUludmFsaWRBUklBSG9vay5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NT3B0aW9uLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TW91bnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0T3duZXIuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVmLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9UcmFuc2FjdGlvbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZmluZERPTU5vZGUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRLZXkuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldE5leHREZWJ1Z0lELmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3NldElubmVySFRNTC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMveHJlZ2V4cC9zcmMvYWRkb25zL2J1aWxkLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3hyZWdleHAvc3JjL2FkZG9ucy9tYXRjaHJlY3Vyc2l2ZS5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy9hZGRvbnMvdW5pY29kZS1iYXNlLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3hyZWdleHAvc3JjL2FkZG9ucy91bmljb2RlLWJsb2Nrcy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy9hZGRvbnMvdW5pY29kZS1jYXRlZ29yaWVzLmpzIiwiLi4vRG9yaWMvbm9kZV9tb2R1bGVzL3hyZWdleHAvc3JjL2FkZG9ucy91bmljb2RlLXByb3BlcnRpZXMuanMiLCIuLi9Eb3JpYy9ub2RlX21vZHVsZXMveHJlZ2V4cC9zcmMvYWRkb25zL3VuaWNvZGUtc2NyaXB0cy5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy9pbmRleC5qcyIsIi4uL0RvcmljL25vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy94cmVnZXhwLmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXGNvbXBvbmVudFxcQnV0dG9uLmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXGNvbXBvbmVudFxcQ2FyZC5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFxjb21wb25lbnRcXENoZWNrYm94LmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXGNvbXBvbmVudFxcQ29udGVudEFsaWduZXJzLmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXGNvbXBvbmVudFxcQ3VzdG9tRXZlbnRzLmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXGNvbXBvbmVudFxcR3JpZC5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFxjb21wb25lbnRcXEljb24uanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcY29tcG9uZW50XFxJbWFnZS5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFxjb21wb25lbnRcXElucHV0LmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXGNvbXBvbmVudFxcUGluYm9hcmQuanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcY29tcG9uZW50XFxQcm9ncmVzcy5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFxjb21wb25lbnRcXFNsaWRlci5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFxjb21wb25lbnRcXFNwaW5uZXIuanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcY29tcG9uZW50XFxUb2dnbGUuanMiLCIuLi9Eb3JpYy9zb3VyY2UvZGF0YS11cmkvaW9uaWNvbnMud29mZi5zb3VyY2UiLCIuLi9Eb3JpYy9zb3VyY2UvZGF0YS11cmkvcm9ib3RvLWxpZ2h0LndvZmYuc291cmNlIiwiLi5cXERvcmljXFxzb3VyY2VcXG1haW4uanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcdXRpbFxcYXBwLmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXHV0aWxcXGNocm9uby5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFx1dGlsXFxjb25zdHMuanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcdXRpbFxcZGV2aWNlcmVhZHkuanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcdXRpbFxcZW52LmpzIiwiLi5cXERvcmljXFxzb3VyY2VcXHV0aWxcXGdlc3R1cmUuanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcdXRpbFxcaWNvbnMuanMiLCIuLlxcRG9yaWNcXHNvdXJjZVxcdXRpbFxcc3R5bGVzaGVldC5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFx1dGlsXFx0aGVtZS5qcyIsIi4uXFxEb3JpY1xcc291cmNlXFx1dGlsXFx1dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2VudHJpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9mcmVlemUuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvcnVudGltZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZW50cmllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2ZyZWV6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3ZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hLWZ1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYW4tb2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY2xhc3NvZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24tc3Ryb25nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi10by1qc29uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jdHguanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWZpbmVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZGVzY3JpcHRvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kb20tY3JlYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZW51bS1rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZXhwb3J0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZmFpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mb3Itb2YuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5nZXQtbmFtZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5nbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oaWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaHRtbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmludm9rZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlvYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1hcnJheS1pdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1vYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWNhbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItZGVmaW5lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1kZXRlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLXN0ZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyYXRvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmtleW9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQubGlicmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm1pY3JvdGFzay5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm9iamVjdC1hc3NpZ24uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3Qtc2FwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQub2JqZWN0LXRvLWFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucHJvcGVydHktZGVzYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLWFsbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2FtZS12YWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1zcGVjaWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2V0LXRvLXN0cmluZy10YWcuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zaGFyZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaWN0LW5ldy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN0cmluZy1hdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRhc2suanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pbnRlZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8taW9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWxlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLW9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnVpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLndrcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3A0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDditCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0b0JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBOztBQ0ZBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTs7QUNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICogQHR5cGVjaGVja3NcclxuICovXHJcblxyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXHJcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cclxuICovXHJcbnZhciBFdmVudExpc3RlbmVyID0ge1xyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXHJcbiAgICovXHJcbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XHJcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cclxuICAgKi9cclxuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XHJcblxyXG4vKipcclxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxyXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XHJcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxyXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXHJcbiAqL1xyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XHJcblxyXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxyXG5cclxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcclxuXHJcbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxyXG5cclxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcclxuXHJcbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XHJcblxyXG4vKipcclxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcclxuICpcclxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcclxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcclxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcclxuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xyXG5cclxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XHJcblxyXG4vKipcclxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxyXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxyXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXHJcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxyXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcclxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcclxuICpcclxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xyXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XHJcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcclxuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcclxuXHJcbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcclxuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xyXG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcclxuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XHJcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XHJcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcclxuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cclxuICpcclxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xyXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxyXG4gKiBAcmV0dXJuIHthcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XHJcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XHJcblxyXG4gIC8vIFNvbWUgYnJvd3NlcnMgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3RcclxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cclxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG5cclxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gICEodHlwZW9mIG9iai5jYWxsZWUgIT09ICdmdW5jdGlvbicpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBjYW5cXCd0IGJlIGBhcmd1bWVudHNgLiBVc2UgcmVzdCBwYXJhbXMgJyArICcoZnVuY3Rpb24oLi4uYXJncykge30pIG9yIEFycmF5LmZyb20oKSBpbnN0ZWFkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcclxuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcclxuICAvLyBmYWxsYmFjay5cclxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcclxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxyXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xyXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcclxuICAgIHJldFtpaV0gPSBvYmpbaWldO1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vKipcclxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXHJcbiAqXHJcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcclxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcclxuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXHJcbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxyXG4gKlxyXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gb2JqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcclxuICByZXR1cm4gKFxyXG4gICAgLy8gbm90IG51bGwvZmFsc2VcclxuICAgICEhb2JqICYmIChcclxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXHJcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcclxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XHJcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcclxuICAgIC8vIG5vdCB3aW5kb3dcclxuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXHJcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXHJcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcclxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxyXG4gICAgLy8gYSByZWFsIGFycmF5XHJcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcclxuICAgIC8vIGFyZ3VtZW50c1xyXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XHJcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxyXG4gICAgJ2l0ZW0nIGluIG9iailcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cclxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxyXG4gKlxyXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XHJcbiAqXHJcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XHJcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xyXG4gKiAgICAgLi4uXHJcbiAqICAgfVxyXG4gKlxyXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxyXG4gKlxyXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XHJcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gb2JqXHJcbiAqIEByZXR1cm4ge2FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XHJcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XHJcbiAgICByZXR1cm4gW29ial07XHJcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgIHJldHVybiBvYmouc2xpY2UoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcclxudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXHJcbiAqL1xyXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xyXG5cclxuLyoqXHJcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxyXG4gKi9cclxudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxyXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cclxuICovXHJcbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xyXG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XHJcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxyXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXHJcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXHJcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cclxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXHJcbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xyXG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xyXG4gICEhIWR1bW15Tm9kZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XHJcblxyXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XHJcbiAgaWYgKHdyYXApIHtcclxuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XHJcblxyXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XHJcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcclxuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcclxuICB9XHJcblxyXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XHJcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XHJcbiAgICAhaGFuZGxlU2NyaXB0ID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG5vZGVzID0gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpO1xyXG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xyXG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlcztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gYXJnO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xyXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxyXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxyXG4gKi9cclxudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XHJcblxyXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XHJcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcclxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcclxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcclxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcclxuICByZXR1cm4gYXJnO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcclxuICovXHJcblxyXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xyXG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxyXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcclxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cclxuICB0cnkge1xyXG4gICAgbm9kZS5mb2N1cygpO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQHR5cGVjaGVja3NcclxuICovXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xyXG5cclxuLyoqXHJcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXHJcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXHJcbiAqXHJcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxyXG4gKiB5ZXQgZGVmaW5lZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSAvKj9ET01FbGVtZW50Ki97XHJcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxyXG4gKi9cclxudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcclxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxyXG4gKlxyXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXHJcbiAqL1xyXG5cclxudmFyIHNob3VsZFdyYXAgPSB7fTtcclxuXHJcbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcclxudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xyXG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XHJcblxyXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xyXG5cclxudmFyIG1hcmt1cFdyYXAgPSB7XHJcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcclxuXHJcbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxyXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcclxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXHJcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcclxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcclxuXHJcbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcclxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcclxuXHJcbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXHJcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxyXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcclxuICAndGZvb3QnOiB0YWJsZVdyYXAsXHJcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxyXG5cclxuICAndGQnOiB0cldyYXAsXHJcbiAgJ3RoJzogdHJXcmFwXHJcbn07XHJcblxyXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcclxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxyXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXHJcbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xyXG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xyXG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcclxuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cclxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xyXG4gICEhIWR1bW15Tm9kZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xyXG4gICAgbm9kZU5hbWUgPSAnKic7XHJcbiAgfVxyXG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcclxuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XHJcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcclxuICAgIH1cclxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xyXG4gIH1cclxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcclxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xyXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXHJcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XHJcbiAgaWYgKHNjcm9sbGFibGUgPT09IHdpbmRvdykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxyXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcclxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcclxuXHJcbi8qKlxyXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxyXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcclxuICpcclxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcclxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xyXG5cclxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcclxuXHJcbi8qKlxyXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXHJcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxyXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcclxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcclxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcclxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxyXG4gKlxyXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcclxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cclxuICpcclxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcclxuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXHJcbiAqIGV4cGVjdGluZy5cclxuICpcclxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcclxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxyXG4gKi9cclxuXHJcbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XHJcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xyXG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XHJcblxyXG4gIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICB2YXIgZXJyb3I7XHJcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xyXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xyXG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xyXG4gICAgICB9KSk7XHJcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcclxuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xyXG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtZW1vaXplU3RyaW5nT25seShjYWxsYmFjaykge1xyXG4gIHZhciBjYWNoZSA9IHt9O1xyXG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICBpZiAoIWNhY2hlLmhhc093blByb3BlcnR5KHN0cmluZykpIHtcclxuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xyXG4gIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciBwZXJmb3JtYW5jZTtcclxuXHJcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcclxuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcclxuXHJcbnZhciBwZXJmb3JtYW5jZU5vdztcclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xyXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XHJcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxyXG4gKi9cclxuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xyXG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XHJcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xyXG4gICAgcmV0dXJuIERhdGUubm93KCk7XHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdzsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqIFxyXG4gKi9cclxuXHJcbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuLyoqXHJcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXHJcbiAqL1xyXG5mdW5jdGlvbiBpcyh4LCB5KSB7XHJcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxyXG4gIGlmICh4ID09PSB5KSB7XHJcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcclxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXHJcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxyXG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXHJcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcclxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXHJcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcclxuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcclxuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcclxuXHJcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XHJcblxyXG4vKipcclxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXHJcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXHJcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxyXG4gKi9cclxuXHJcbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xyXG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxyXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xyXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgfSBjYXRjaCAoeCkge31cclxuICAgIH07XHJcblxyXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcclxuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KSgpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7IiwiLypcclxub2JqZWN0LWFzc2lnblxyXG4oYykgU2luZHJlIFNvcmh1c1xyXG5AbGljZW5zZSBNSVRcclxuKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxuXHJcbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xyXG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcclxuXHR0cnkge1xyXG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXHJcblxyXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxyXG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xyXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xyXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XHJcblx0XHR2YXIgdGVzdDIgPSB7fTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xyXG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XHJcblx0XHR9XHJcblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xyXG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XHJcblx0XHR9KTtcclxuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxyXG5cdFx0dmFyIHRlc3QzID0ge307XHJcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcclxuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcclxuXHRcdH0pO1xyXG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XHJcblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcclxuXHR2YXIgZnJvbTtcclxuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xyXG5cdHZhciBzeW1ib2xzO1xyXG5cclxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xyXG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xyXG5cclxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XHJcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcclxuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xyXG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XHJcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdG87XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3RET00nKTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFSSUFET01Qcm9wZXJ0eUNvbmZpZyA9IHtcclxuICBQcm9wZXJ0aWVzOiB7XHJcbiAgICAvLyBHbG9iYWwgU3RhdGVzIGFuZCBQcm9wZXJ0aWVzXHJcbiAgICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcclxuICAgICdhcmlhLWRldGFpbHMnOiAwLFxyXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxyXG4gICAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcclxuICAgICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxyXG4gICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcclxuICAgICdhcmlhLWxhYmVsJzogMCxcclxuICAgICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXHJcbiAgICAvLyBXaWRnZXQgQXR0cmlidXRlc1xyXG4gICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcclxuICAgICdhcmlhLWNoZWNrZWQnOiAwLFxyXG4gICAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxyXG4gICAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxyXG4gICAgJ2FyaWEtbGV2ZWwnOiAwLFxyXG4gICAgJ2FyaWEtbW9kYWwnOiAwLFxyXG4gICAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcclxuICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXHJcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXHJcbiAgICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXHJcbiAgICAnYXJpYS1wcmVzc2VkJzogMCxcclxuICAgICdhcmlhLXJlYWRvbmx5JzogMCxcclxuICAgICdhcmlhLXJlcXVpcmVkJzogMCxcclxuICAgICdhcmlhLXNlbGVjdGVkJzogMCxcclxuICAgICdhcmlhLXNvcnQnOiAwLFxyXG4gICAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxyXG4gICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxyXG4gICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxyXG4gICAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcclxuICAgIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcclxuICAgICdhcmlhLWF0b21pYyc6IDAsXHJcbiAgICAnYXJpYS1idXN5JzogMCxcclxuICAgICdhcmlhLWxpdmUnOiAwLFxyXG4gICAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxyXG4gICAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXHJcbiAgICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcclxuICAgICdhcmlhLWdyYWJiZWQnOiAwLFxyXG4gICAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcclxuICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxyXG4gICAgJ2FyaWEtY29sY291bnQnOiAwLFxyXG4gICAgJ2FyaWEtY29saW5kZXgnOiAwLFxyXG4gICAgJ2FyaWEtY29sc3Bhbic6IDAsXHJcbiAgICAnYXJpYS1jb250cm9scyc6IDAsXHJcbiAgICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXHJcbiAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxyXG4gICAgJ2FyaWEtZmxvd3RvJzogMCxcclxuICAgICdhcmlhLWxhYmVsbGVkYnknOiAwLFxyXG4gICAgJ2FyaWEtb3ducyc6IDAsXHJcbiAgICAnYXJpYS1wb3NpbnNldCc6IDAsXHJcbiAgICAnYXJpYS1yb3djb3VudCc6IDAsXHJcbiAgICAnYXJpYS1yb3dpbmRleCc6IDAsXHJcbiAgICAnYXJpYS1yb3dzcGFuJzogMCxcclxuICAgICdhcmlhLXNldHNpemUnOiAwXHJcbiAgfSxcclxuICBET01BdHRyaWJ1dGVOYW1lczoge30sXHJcbiAgRE9NUHJvcGVydHlOYW1lczoge31cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQVJJQURPTVByb3BlcnR5Q29uZmlnOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG5cclxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xyXG5cclxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xyXG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb2N1c05vZGUoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcykpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcclxudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcclxuXHJcbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXHJcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xyXG5cclxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcclxuXHJcbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xyXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XHJcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xyXG59XHJcblxyXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xyXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xyXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cclxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xyXG5cclxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcclxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xyXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXHJcbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcclxuXHJcbi8qKlxyXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxyXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XHJcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xyXG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xyXG59XHJcblxyXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xyXG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XHJcblxyXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXHJcbnZhciBldmVudFR5cGVzID0ge1xyXG4gIGJlZm9yZUlucHV0OiB7XHJcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xyXG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXHJcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXHJcbiAgICB9LFxyXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleVByZXNzJywgJ3RvcFRleHRJbnB1dCcsICd0b3BQYXN0ZSddXHJcbiAgfSxcclxuICBjb21wb3NpdGlvbkVuZDoge1xyXG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcclxuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxyXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xyXG4gICAgfSxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cclxuICB9LFxyXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcclxuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XHJcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxyXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXHJcbiAgICB9LFxyXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXHJcbiAgfSxcclxuICBjb21wb3NpdGlvblVwZGF0ZToge1xyXG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcclxuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxyXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xyXG4gICAgfSxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cclxuICB9XHJcbn07XHJcblxyXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXHJcbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XHJcblxyXG4vKipcclxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXHJcbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcclxuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcclxuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXHJcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXHJcbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxyXG4gKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcclxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xyXG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XHJcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XHJcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XHJcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xyXG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25VcGRhdGUnOlxyXG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcclxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xyXG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xyXG59XHJcblxyXG4vKipcclxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XHJcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcclxuICAgIGNhc2UgJ3RvcEtleVVwJzpcclxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXHJcbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XHJcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcclxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cclxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XHJcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XHJcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxyXG4gICAgY2FzZSAndG9wQmx1cic6XHJcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxyXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcclxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cclxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxyXG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xyXG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XHJcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcclxuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cclxudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XHJcblxyXG4vKipcclxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICB2YXIgZXZlbnRUeXBlO1xyXG4gIHZhciBmYWxsYmFja0RhdGE7XHJcblxyXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XHJcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xyXG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xyXG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XHJcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xyXG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcclxuICB9XHJcblxyXG4gIGlmICghZXZlbnRUeXBlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xyXG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXHJcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXHJcbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xyXG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XHJcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcclxuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcblxyXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcclxuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxyXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cclxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XHJcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XHJcbiAgcmV0dXJuIGV2ZW50O1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcclxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xyXG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxyXG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XHJcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcclxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxyXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XHJcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcclxuICAgICAgICogcGFnZS5cclxuICAgICAgICpcclxuICAgICAgICogVHJhY2tpbmcgYXQ6XHJcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcclxuICAgICAgICpcclxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxyXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXHJcbiAgICAgICAqL1xyXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcclxuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcclxuXHJcbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxyXG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cclxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcclxuXHJcbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXHJcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcclxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cclxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNoYXJzO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcclxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XHJcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXHJcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxyXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XHJcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxyXG4gIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcclxuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XHJcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XHJcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5yZWxlYXNlKGN1cnJlbnRDb21wb3NpdGlvbik7XHJcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XHJcbiAgICAgIHJldHVybiBjaGFycztcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcclxuICAgIGNhc2UgJ3RvcFBhc3RlJzpcclxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxyXG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxyXG4gICAgICAvKipcclxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXHJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XHJcbiAgICAgICAqXHJcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cclxuICAgICAgICpcclxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXHJcbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxyXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcclxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cclxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xyXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xyXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cclxuICAgICAgICovXHJcbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxyXG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXHJcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHZhciBjaGFycztcclxuXHJcbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XHJcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxyXG4gIC8vIGJlIGZpcmVkLlxyXG4gIGlmICghY2hhcnMpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuXHJcbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xyXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XHJcbiAgcmV0dXJuIGV2ZW50O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxyXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxyXG4gKlxyXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XHJcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXHJcbiAqXHJcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcclxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXHJcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxyXG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcclxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXHJcbiAqXHJcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXHJcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcclxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cclxuICovXHJcbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xyXG5cclxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxyXG5cclxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxyXG4gKi9cclxuXHJcbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xyXG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxyXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxyXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXHJcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcclxuICBib3hGbGV4OiB0cnVlLFxyXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcclxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXHJcbiAgY29sdW1uQ291bnQ6IHRydWUsXHJcbiAgZmxleDogdHJ1ZSxcclxuICBmbGV4R3JvdzogdHJ1ZSxcclxuICBmbGV4UG9zaXRpdmU6IHRydWUsXHJcbiAgZmxleFNocmluazogdHJ1ZSxcclxuICBmbGV4TmVnYXRpdmU6IHRydWUsXHJcbiAgZmxleE9yZGVyOiB0cnVlLFxyXG4gIGdyaWRSb3c6IHRydWUsXHJcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcclxuICBmb250V2VpZ2h0OiB0cnVlLFxyXG4gIGxpbmVDbGFtcDogdHJ1ZSxcclxuICBsaW5lSGVpZ2h0OiB0cnVlLFxyXG4gIG9wYWNpdHk6IHRydWUsXHJcbiAgb3JkZXI6IHRydWUsXHJcbiAgb3JwaGFuczogdHJ1ZSxcclxuICB0YWJTaXplOiB0cnVlLFxyXG4gIHdpZG93czogdHJ1ZSxcclxuICB6SW5kZXg6IHRydWUsXHJcbiAgem9vbTogdHJ1ZSxcclxuXHJcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xyXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxyXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcclxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcclxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXHJcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcclxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxyXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXHJcbiAgc3Ryb2tlV2lkdGg6IHRydWVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcclxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcclxuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xyXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXHJcbiAqL1xyXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xyXG5cclxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxyXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cclxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcclxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxyXG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcclxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXHJcbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cclxuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XHJcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXHJcbiAqL1xyXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xyXG4gIGJhY2tncm91bmQ6IHtcclxuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxyXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxyXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXHJcbiAgfSxcclxuICBiYWNrZ3JvdW5kUG9zaXRpb246IHtcclxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXHJcbiAgfSxcclxuICBib3JkZXI6IHtcclxuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxyXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXHJcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxyXG4gIH0sXHJcbiAgYm9yZGVyQm90dG9tOiB7XHJcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcclxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxyXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcclxuICB9LFxyXG4gIGJvcmRlckxlZnQ6IHtcclxuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcclxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcclxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxyXG4gIH0sXHJcbiAgYm9yZGVyUmlnaHQ6IHtcclxuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXHJcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxyXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxyXG4gIH0sXHJcbiAgYm9yZGVyVG9wOiB7XHJcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcclxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxyXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcclxuICB9LFxyXG4gIGZvbnQ6IHtcclxuICAgIGZvbnRTdHlsZTogdHJ1ZSxcclxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxyXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcclxuICAgIGZvbnRTaXplOiB0cnVlLFxyXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcclxuICAgIGZvbnRGYW1pbHk6IHRydWVcclxuICB9LFxyXG4gIG91dGxpbmU6IHtcclxuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcclxuICAgIG91dGxpbmVTdHlsZTogdHJ1ZSxcclxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBDU1NQcm9wZXJ0eSA9IHtcclxuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxyXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcclxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xyXG5cclxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcclxudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKCcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcclxudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xyXG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xyXG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcclxufSk7XHJcblxyXG52YXIgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSBmYWxzZTtcclxudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XHJcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcclxuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XHJcbiAgdHJ5IHtcclxuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cclxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xyXG4gIH1cclxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XHJcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XHJcbiAgfVxyXG59XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcclxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xyXG5cclxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cclxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XHJcblxyXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XHJcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XHJcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XHJcblxyXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xyXG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xyXG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xyXG4gIH07XHJcblxyXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XHJcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uJXMgJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lciksIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdm9pZCAwO1xyXG4gIH07XHJcblxyXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xyXG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xyXG4gIH07XHJcblxyXG4gIHZhciBjaGVja1JlbmRlck1lc3NhZ2UgPSBmdW5jdGlvbiAob3duZXIpIHtcclxuICAgIGlmIChvd25lcikge1xyXG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XHJcbiAgICovXHJcbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcclxuICAgIHZhciBvd25lcjtcclxuICAgIGlmIChjb21wb25lbnQpIHtcclxuICAgICAgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuICAgIH1cclxuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XHJcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcclxuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcclxuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcclxuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgb3duZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBvd25lcik7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cclxuICovXHJcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlcmlhbGl6ZXMgYSBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgZm9yIHVzZSBhcyBpbmxpbmUgc3R5bGVzOlxyXG4gICAqXHJcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXHJcbiAgICogICBcIndpZHRoOjIwMHB4O2hlaWdodDowO1wiXHJcbiAgICpcclxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxyXG4gICAqIFRoZSByZXN1bHQgc2hvdWxkIGJlIEhUTUwtZXNjYXBlZCBiZWZvcmUgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcclxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxyXG4gICAqL1xyXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcywgY29tcG9uZW50KSB7XHJcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xyXG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xyXG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xyXG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCkgKyAnOyc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xyXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xyXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxyXG4gICAqL1xyXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzLCBjb21wb25lbnQpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgIGluc3RhbmNlSUQ6IGNvbXBvbmVudC5fZGVidWdJRCxcclxuICAgICAgICB0eXBlOiAndXBkYXRlIHN0eWxlcycsXHJcbiAgICAgICAgcGF5bG9hZDogc3R5bGVzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XHJcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XHJcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XHJcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcgfHwgc3R5bGVOYW1lID09PSAnY3NzRmxvYXQnKSB7XHJcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVGbG9hdEFjY2Vzc29yO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnICYmIENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xyXG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcclxuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxyXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcclxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XHJcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXHJcbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXHJcbiAqXHJcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cclxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cclxuICpcclxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxyXG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcblxyXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBDYWxsYmFja1F1ZXVlKGFyZykge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbGxiYWNrUXVldWUpO1xyXG5cclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XHJcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XHJcbiAgICB0aGlzLl9hcmcgPSBhcmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcblxyXG5cclxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcclxuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcclxuICAgKiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3IgdXBkYXRlZC5cclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUubm90aWZ5QWxsID0gZnVuY3Rpb24gbm90aWZ5QWxsKCkge1xyXG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcclxuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xyXG4gICAgdmFyIGFyZyA9IHRoaXMuX2FyZztcclxuICAgIGlmIChjYWxsYmFja3MgJiYgY29udGV4dHMpIHtcclxuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogX3Byb2RJbnZhcmlhbnQoJzI0JykgOiB2b2lkIDA7XHJcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSwgYXJnKTtcclxuICAgICAgfVxyXG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcclxuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5jaGVja3BvaW50ID0gZnVuY3Rpb24gY2hlY2twb2ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3MgPyB0aGlzLl9jYWxsYmFja3MubGVuZ3RoIDogMDtcclxuICB9O1xyXG5cclxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5yb2xsYmFjayA9IGZ1bmN0aW9uIHJvbGxiYWNrKGxlbikge1xyXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jb250ZXh0cykge1xyXG4gICAgICB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID0gbGVuO1xyXG4gICAgICB0aGlzLl9jb250ZXh0cy5sZW5ndGggPSBsZW47XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XHJcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cclxuICAgKi9cclxuXHJcblxyXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5yZXNldCgpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBDYWxsYmFja1F1ZXVlO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XHJcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcclxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xyXG5cclxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xyXG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xyXG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcclxuXHJcbnZhciBldmVudFR5cGVzID0ge1xyXG4gIGNoYW5nZToge1xyXG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcclxuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcclxuICAgICAgY2FwdHVyZWQ6ICdvbkNoYW5nZUNhcHR1cmUnXHJcbiAgICB9LFxyXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRm9yIElFIHNoaW1zXHJcbiAqL1xyXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XHJcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XHJcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xyXG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XHJcblxyXG4vKipcclxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcclxufVxyXG5cclxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xyXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XHJcbiAgLy8gU2VlIGBoYW5kbGVDaGFuZ2VgIGNvbW1lbnQgYmVsb3dcclxuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xyXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xyXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XHJcblxyXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXHJcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxyXG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxyXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxyXG4gIC8vXHJcbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxyXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXHJcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcclxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXHJcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcclxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXHJcbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcclxuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcclxuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpIHtcclxuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xyXG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcclxuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcclxuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcclxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcclxuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcclxuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2hhbmdlJykge1xyXG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XHJcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEZvY3VzJykge1xyXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxyXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxyXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcclxuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpO1xyXG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcclxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcclxuICovXHJcbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcclxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xyXG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxyXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxyXG4gIC8vIElFMTArIGZpcmUgaW5wdXQgZXZlbnRzIHRvIG9mdGVuLCBzdWNoIHdoZW4gYSBwbGFjZWhvbGRlclxyXG4gIC8vIGNoYW5nZXMgb3Igd2hlbiBhbiBpbnB1dCB3aXRoIGEgcGxhY2Vob2xkZXIgaXMgZm9jdXNlZC5cclxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIChGb3IgSUUgPD0xMSkgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXHJcbiAqIHNldCBvbiB0aGUgYWN0aXZlIGVsZW1lbnQuXHJcbiAqL1xyXG52YXIgbmV3VmFsdWVQcm9wID0ge1xyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XHJcbiAgfSxcclxuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cclxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xyXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiAoRm9yIElFIDw9MTEpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XHJcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxyXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xyXG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XHJcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xyXG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcclxuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcclxuXHJcbiAgLy8gTm90IGd1YXJkZWQgaW4gYSBjYW5EZWZpbmVQcm9wZXJ0eSBjaGVjazogSUU4IHN1cHBvcnRzIGRlZmluZVByb3BlcnR5IG9ubHlcclxuICAvLyBvbiBET00gZWxlbWVudHNcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcclxuICBpZiAoYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCkge1xyXG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgYWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlLCBmYWxzZSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogKEZvciBJRSA8PTExKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcclxuICogaWYgYW55IGV4aXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xyXG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXHJcbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XHJcblxyXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XHJcbiAgICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xyXG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcclxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xyXG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogKEZvciBJRSA8PTExKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxyXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcclxuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XHJcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XHJcblxyXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xyXG59XHJcblxyXG4vKipcclxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XHJcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0Jykge1xyXG4gICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzIChpLmUuLCBub3QgSUU4IG9yIElFOSksIHRoZSBpbnB1dCBldmVudCBpcyBleGFjdGx5XHJcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcclxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XHJcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEZvY3VzJykge1xyXG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXHJcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcclxuICAgIC8vIGVxdWFsIHRvICd2YWx1ZSdcclxuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcclxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXHJcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXHJcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcclxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXHJcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xyXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcclxuICAgIC8vXHJcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXHJcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXHJcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xyXG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XHJcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xyXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEZvciBJRTggYW5kIElFOS5cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcclxuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcclxuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxyXG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXHJcbiAgICAvL1xyXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxyXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcclxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcclxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcclxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxyXG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cclxuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxyXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XHJcbiAgICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IGFjdGl2ZUVsZW1lbnQudmFsdWU7XHJcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SW5zdDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XHJcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXHJcbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcclxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxyXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xyXG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcclxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xyXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXHJcbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cclxuICpcclxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcclxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxyXG4gKiAtIHRleHRhcmVhXHJcbiAqIC0gc2VsZWN0XHJcbiAqL1xyXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XHJcblxyXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXHJcblxyXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XHJcblxyXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XHJcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcclxuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xyXG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xyXG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XHJcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUU7XHJcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcclxuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcclxuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xyXG4gICAgICBpZiAoaW5zdCkge1xyXG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XHJcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XHJcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcclxudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XHJcblxyXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xyXG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcclxudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xyXG5cclxuZnVuY3Rpb24gZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIG5vZGUpIHtcclxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRleHQgY29tcG9uZW50cywgd2hpY2ggcmV0dXJuIFtvcGVuLCBjbG9zZV0gY29tbWVudHNcclxuICAvLyBmcm9tIGdldEhvc3ROb2RlLlxyXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XHJcbiAgICBub2RlID0gbm9kZVsxXTtcclxuICB9XHJcbiAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRTaWJsaW5nIDogcGFyZW50Tm9kZS5maXJzdENoaWxkO1xyXG59XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cclxuICpcclxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cclxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBpbnNlcnRDaGlsZEF0ID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XHJcbiAgLy8gV2UgcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcclxuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXHJcbiAgLy8gd2UgYXJlIGNhcmVmdWwgdG8gdXNlIGBudWxsYC4pXHJcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGRUcmVlLCByZWZlcmVuY2VOb2RlKSB7XHJcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xyXG4gICAgbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlWzBdLCBjaGlsZE5vZGVbMV0sIHJlZmVyZW5jZU5vZGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XHJcbiAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBjaGlsZE5vZGVbMV07XHJcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVbMF07XHJcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xyXG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9zaW5nQ29tbWVudCk7XHJcbiAgfVxyXG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XHJcbiAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudDtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcclxuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSk7XHJcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBub2RlID0gbmV4dE5vZGU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcclxuICAgICAgLy8gVGhlIGNsb3NpbmcgY29tbWVudCBpcyByZW1vdmVkIGJ5IFJlYWN0TXVsdGlDaGlsZC5cclxuICAgICAgYnJlYWs7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XHJcbiAgdmFyIHBhcmVudE5vZGUgPSBvcGVuaW5nQ29tbWVudC5wYXJlbnROb2RlO1xyXG4gIHZhciBub2RlQWZ0ZXJDb21tZW50ID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XHJcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XHJcbiAgICAvLyBUaGVyZSBhcmUgbm8gdGV4dCBub2RlcyBiZXR3ZWVuIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGNvbW1lbnRzOyBpbnNlcnRcclxuICAgIC8vIGEgbmV3IG9uZSBpZiBzdHJpbmdUZXh0IGlzbid0IGVtcHR5LlxyXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcclxuICAgICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdUZXh0KSwgbm9kZUFmdGVyQ29tbWVudCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChzdHJpbmdUZXh0KSB7XHJcbiAgICAgIC8vIFNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBmaXJzdCBub2RlIGFmdGVyIHRoZSBvcGVuaW5nIGNvbW1lbnQsIGFuZFxyXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxyXG4gICAgICBzZXRUZXh0Q29udGVudChub2RlQWZ0ZXJDb21tZW50LCBzdHJpbmdUZXh0KTtcclxuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBub2RlQWZ0ZXJDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCxcclxuICAgICAgdHlwZTogJ3JlcGxhY2UgdGV4dCcsXHJcbiAgICAgIHBheWxvYWQ6IHN0cmluZ1RleHRcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwO1xyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xyXG4gICAgRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZENoaWxkLCBtYXJrdXApO1xyXG4gICAgaWYgKHByZXZJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcclxuICAgICAgICBpbnN0YW5jZUlEOiBwcmV2SW5zdGFuY2UuX2RlYnVnSUQsXHJcbiAgICAgICAgdHlwZTogJ3JlcGxhY2Ugd2l0aCcsXHJcbiAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobWFya3VwLm5vZGUpO1xyXG4gICAgICBpZiAobmV4dEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgICBpbnN0YW5jZUlEOiBuZXh0SW5zdGFuY2UuX2RlYnVnSUQsXHJcbiAgICAgICAgICB0eXBlOiAnbW91bnQnLFxyXG4gICAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cclxuICovXHJcbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XHJcblxyXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcclxuXHJcbiAgcmVwbGFjZURlbGltaXRlZFRleHQ6IHJlcGxhY2VEZWxpbWl0ZWRUZXh0LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcclxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHVwZGF0ZXMpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBwYXJlbnROb2RlRGVidWdJRCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHBhcmVudE5vZGUpLl9kZWJ1Z0lEO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICB2YXIgdXBkYXRlID0gdXBkYXRlc1trXTtcclxuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ0lOU0VSVF9NQVJLVVAnOlxyXG4gICAgICAgICAgaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50LCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXHJcbiAgICAgICAgICAgICAgdHlwZTogJ2luc2VydCBjaGlsZCcsXHJcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyB0b0luZGV4OiB1cGRhdGUudG9JbmRleCwgY29udGVudDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnTU9WRV9FWElTVElORyc6XHJcbiAgICAgICAgICBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlLCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXHJcbiAgICAgICAgICAgICAgdHlwZTogJ21vdmUgY2hpbGQnLFxyXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4LCB0b0luZGV4OiB1cGRhdGUudG9JbmRleCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnU0VUX01BUktVUCc6XHJcbiAgICAgICAgICBzZXRJbm5lckhUTUwocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXHJcbiAgICAgICAgICAgICAgdHlwZTogJ3JlcGxhY2UgY2hpbGRyZW4nLFxyXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdURVhUX0NPTlRFTlQnOlxyXG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXHJcbiAgICAgICAgICAgICAgdHlwZTogJ3JlcGxhY2UgdGV4dCcsXHJcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1JFTU9WRV9OT0RFJzpcclxuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSk7XHJcbiAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcclxuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcclxuICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlIGNoaWxkJyxcclxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcclxudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XHJcblxyXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xyXG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XHJcblxyXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xyXG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XHJcblxyXG4vKipcclxuICogSW4gSUUgKDgtMTEpIGFuZCBFZGdlLCBhcHBlbmRpbmcgbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBpcyBkcmFtYXRpY2FsbHlcclxuICogZmFzdGVyIHRoYW4gYXBwZW5kaW5nIGEgZnVsbCBzdWJ0cmVlLCBzbyB3ZSBlc3NlbnRpYWxseSBxdWV1ZSB1cCB0aGVcclxuICogLmFwcGVuZENoaWxkIGNhbGxzIGhlcmUgYW5kIGFwcGx5IHRoZW0gc28gZWFjaCBub2RlIGlzIGFkZGVkIHRvIGl0cyBwYXJlbnRcclxuICogYmVmb3JlIGFueSBjaGlsZHJlbiBhcmUgYWRkZWQuXHJcbiAqXHJcbiAqIEluIG90aGVyIGJyb3dzZXJzLCBkb2luZyBzbyBpcyBzbG93ZXIgb3IgbmV1dHJhbCBjb21wYXJlZCB0byB0aGUgb3RoZXIgb3JkZXJcclxuICogKGluIEZpcmVmb3gsIHR3aWNlIGFzIHNsb3cpIHNvIHdlIG9ubHkgZG8gdGhpcyBpbnZlcnNpb24gaW4gSUUuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3BpY3lqL2lubmVyaHRtbC12cy1jcmVhdGVlbGVtZW50LXZzLWNsb25lbm9kZS5cclxuICovXHJcbnZhciBlbmFibGVMYXp5ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgL1xcYkVkZ2VcXC9cXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSkge1xyXG4gIGlmICghZW5hYmxlTGF6eSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbm9kZSA9IHRyZWUubm9kZTtcclxuICB2YXIgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xyXG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaW5zZXJ0VHJlZUJlZm9yZShub2RlLCBjaGlsZHJlbltpXSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0cmVlLmh0bWwgIT0gbnVsbCkge1xyXG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIHRyZWUuaHRtbCk7XHJcbiAgfSBlbHNlIGlmICh0cmVlLnRleHQgIT0gbnVsbCkge1xyXG4gICAgc2V0VGV4dENvbnRlbnQobm9kZSwgdHJlZS50ZXh0KTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBpbnNlcnRUcmVlQmVmb3JlID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgdHJlZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZW4ndCBhY3R1YWxseSBwYXJ0IG9mIHRoZSBET00gYWZ0ZXIgaW5zZXJ0aW9uIHNvXHJcbiAgLy8gYXBwZW5kaW5nIGNoaWxkcmVuIHdvbid0IHVwZGF0ZSB0aGUgRE9NLiBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgZnJhZ21lbnRcclxuICAvLyBpcyBwcm9wZXJseSBwb3B1bGF0ZWQgZmlyc3QsIGJyZWFraW5nIG91dCBvZiBvdXIgbGF6eSBhcHByb2FjaCBmb3IganVzdFxyXG4gIC8vIHRoaXMgbGV2ZWwuIEFsc28sIHNvbWUgPG9iamVjdD4gcGx1Z2lucyAobGlrZSBGbGFzaCBQbGF5ZXIpIHdpbGwgcmVhZFxyXG4gIC8vIDxwYXJhbT4gbm9kZXMgaW1tZWRpYXRlbHkgdXBvbiBpbnNlcnRpb24gaW50byB0aGUgRE9NLCBzbyA8b2JqZWN0PlxyXG4gIC8vIG11c3QgYWxzbyBiZSBwb3B1bGF0ZWQgcHJpb3IgdG8gaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cclxuICBpZiAodHJlZS5ub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgfHwgdHJlZS5ub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSAmJiB0cmVlLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgJiYgKHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCB0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpKSB7XHJcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XHJcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGROb2RlLCBuZXdUcmVlKSB7XHJcbiAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdUcmVlLm5vZGUsIG9sZE5vZGUpO1xyXG4gIGluc2VydFRyZWVDaGlsZHJlbihuZXdUcmVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVldWVDaGlsZChwYXJlbnRUcmVlLCBjaGlsZFRyZWUpIHtcclxuICBpZiAoZW5hYmxlTGF6eSkge1xyXG4gICAgcGFyZW50VHJlZS5jaGlsZHJlbi5wdXNoKGNoaWxkVHJlZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHBhcmVudFRyZWUubm9kZS5hcHBlbmRDaGlsZChjaGlsZFRyZWUubm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBxdWV1ZUhUTUwodHJlZSwgaHRtbCkge1xyXG4gIGlmIChlbmFibGVMYXp5KSB7XHJcbiAgICB0cmVlLmh0bWwgPSBodG1sO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZXRJbm5lckhUTUwodHJlZS5ub2RlLCBodG1sKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXVlVGV4dCh0cmVlLCB0ZXh0KSB7XHJcbiAgaWYgKGVuYWJsZUxhenkpIHtcclxuICAgIHRyZWUudGV4dCA9IHRleHQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNldFRleHRDb250ZW50KHRyZWUubm9kZSwgdGV4dCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICByZXR1cm4gdGhpcy5ub2RlLm5vZGVOYW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBET01MYXp5VHJlZShub2RlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5vZGU6IG5vZGUsXHJcbiAgICBjaGlsZHJlbjogW10sXHJcbiAgICBodG1sOiBudWxsLFxyXG4gICAgdGV4dDogbnVsbCxcclxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xyXG4gIH07XHJcbn1cclxuXHJcbkRPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUgPSBpbnNlcnRUcmVlQmVmb3JlO1xyXG5ET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZSA9IHJlcGxhY2VDaGlsZFdpdGhUcmVlO1xyXG5ET01MYXp5VHJlZS5xdWV1ZUNoaWxkID0gcXVldWVDaGlsZDtcclxuRE9NTGF6eVRyZWUucXVldWVIVE1MID0gcXVldWVIVE1MO1xyXG5ET01MYXp5VHJlZS5xdWV1ZVRleHQgPSBxdWV1ZVRleHQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERPTUxhenlUcmVlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET01OYW1lc3BhY2VzID0ge1xyXG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcclxuICBtYXRobWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcclxuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NTmFtZXNwYWNlczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XHJcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xyXG59XHJcblxyXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XHJcbiAgLyoqXHJcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcclxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXHJcbiAgICovXHJcbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MSxcclxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg0LFxyXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXHJcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MTAgfCAweDgsXHJcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHgyMCxcclxuXHJcbiAgLyoqXHJcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XHJcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICpcclxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXHJcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXHJcbiAgICogYXR0cmlidXRlcyB3aGVyZSBpdCdzIGltcG9zc2libGUgdG8gZW51bWVyYXRlIGFsbCBvZiB0aGUgcG9zc2libGVcclxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXHJcbiAgICpcclxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXHJcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXHJcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cclxuICAgKlxyXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXHJcbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxyXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cclxuICAgKlxyXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cclxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxyXG4gICAqXHJcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxyXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXHJcbiAgICpcclxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcclxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxyXG4gICAqL1xyXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcclxuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcclxuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcclxuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcclxuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xyXG4gICAgdmFyIERPTVByb3BlcnR5TmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01Qcm9wZXJ0eU5hbWVzIHx8IHt9O1xyXG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcclxuXHJcbiAgICBpZiAoZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpIHtcclxuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcclxuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcclxuXHJcbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XHJcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcclxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXHJcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcclxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcclxuXHJcbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcclxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxyXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXHJcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxyXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcclxuICAgICAgfTtcclxuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc1MCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZF0gPSBwcm9wTmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xyXG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cclxudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XHJcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xyXG5cclxuLyoqXHJcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcclxuICpcclxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cclxuICogICB0cnVlXHJcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxyXG4gKiAgIHVuZGVmaW5lZFxyXG4gKlxyXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcclxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xyXG4gKi9cclxudmFyIERPTVByb3BlcnR5ID0ge1xyXG5cclxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXHJcbiAgUk9PVF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3Ryb290JyxcclxuXHJcbiAgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUixcclxuICBBVFRSSUJVVEVfTkFNRV9DSEFSOiBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ1xcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwJyxcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XHJcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxyXG4gICAqXHJcbiAgICogYXR0cmlidXRlTmFtZTpcclxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXHJcbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXHJcbiAgICogcHJvcGVydHlOYW1lOlxyXG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXHJcbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcclxuICAgKiBtdXRhdGlvbk1ldGhvZDpcclxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxyXG4gICAqIG11c3RVc2VQcm9wZXJ0eTpcclxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxyXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcclxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxyXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcclxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxyXG4gICAqICAgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cclxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcclxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXHJcbiAgICogICBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cclxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxyXG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxyXG4gICAqICAgUmVtb3ZlZCB3aGVuIHN0cmljdGx5IGVxdWFsIHRvIGZhbHNlOyBwcmVzZW50IHdpdGhvdXQgYSB2YWx1ZSB3aGVuXHJcbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXHJcbiAgICovXHJcbiAgcHJvcGVydGllczoge30sXHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sIHVzZWRcclxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cclxuICAgKlxyXG4gICAqIGF1dG9mb2N1cyBpcyBwcmVkZWZpbmVkLCBiZWNhdXNlIGFkZGluZyBpdCB0byB0aGUgcHJvcGVydHkgd2hpdGVsaXN0XHJcbiAgICogY2F1c2VzIHVuaW50ZW5kZWQgc2lkZSBlZmZlY3RzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZTogXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHsgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyB9IDogbnVsbCxcclxuXHJcbiAgLyoqXHJcbiAgICogQWxsIG9mIHRoZSBpc0N1c3RvbUF0dHJpYnV0ZSgpIGZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlbiBpbmplY3RlZC5cclxuICAgKi9cclxuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxyXG4gICAqIEBtZXRob2RcclxuICAgKi9cclxuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xyXG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XHJcblxyXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xyXG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xyXG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XHJcblxyXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcclxuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcclxuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XHJcbiAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXHJcbiAqL1xyXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXHJcbiAgICovXHJcbiAgY3JlYXRlTWFya3VwRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xyXG4gIH0sXHJcblxyXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcclxuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUgKyAnPVwiXCInO1xyXG4gIH0sXHJcblxyXG4gIHNldEF0dHJpYnV0ZUZvclJvb3Q6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FLCAnJyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cclxuICAgKi9cclxuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xyXG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xyXG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcclxuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XHJcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxyXG4gICAqL1xyXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgKi9cclxuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcclxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XHJcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XHJcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcclxuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XHJcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XHJcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxyXG4gICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cclxuICAgICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcclxuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXHJcbiAgICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxyXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcclxuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcclxuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XHJcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xyXG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxyXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgYXR0cmlidXRlJyxcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcclxuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBwYXlsb2FkID0ge307XHJcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXHJcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxyXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKi9cclxuICBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcclxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXHJcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxyXG4gICAgICAgIHBheWxvYWQ6IG5hbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKi9cclxuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xyXG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcclxuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcclxuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xyXG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcclxuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcclxuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XHJcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcclxuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXHJcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxyXG4gICAgICAgIHBheWxvYWQ6IG5hbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHlPcGVyYXRpb25zOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZSgnZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwJyk7XHJcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG52YXIgRGFuZ2VyID0ge1xyXG5cclxuICAvKipcclxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xyXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcclxuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzU2JykgOiB2b2lkIDA7XHJcbiAgICAhbWFya3VwID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogX3Byb2RJbnZhcmlhbnQoJzU3JykgOiB2b2lkIDA7XHJcbiAgICAhKG9sZENoaWxkLm5vZGVOYW1lICE9PSAnSFRNTCcpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSBhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IF9wcm9kSW52YXJpYW50KCc1OCcpIDogdm9pZCAwO1xyXG5cclxuICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xyXG4gICAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcclxuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIERPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZENoaWxkLCBtYXJrdXApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcclxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcclxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxyXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxyXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cclxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcclxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXHJcbiAqL1xyXG5cclxudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcclxuXHJcbnZhciBldmVudFR5cGVzID0ge1xyXG4gIG1vdXNlRW50ZXI6IHtcclxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxyXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXHJcbiAgfSxcclxuICBtb3VzZUxlYXZlOiB7XHJcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XHJcblxyXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXHJcblxyXG4gIC8qKlxyXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXHJcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxyXG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcclxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcclxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxyXG4gICAqL1xyXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XHJcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB3aW47XHJcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cclxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXHJcbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xyXG4gICAgICBpZiAoZG9jKSB7XHJcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2luID0gd2luZG93O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZyb207XHJcbiAgICB2YXIgdG87XHJcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XHJcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xyXG4gICAgICB2YXIgcmVsYXRlZCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50O1xyXG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cclxuICAgICAgZnJvbSA9IG51bGw7XHJcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcclxuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xyXG5cclxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XHJcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcclxuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XHJcblxyXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XHJcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XHJcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XHJcblxyXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XHJcblxyXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcclxudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcclxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XHJcblxyXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XHJcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xyXG4gKi9cclxudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXHJcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxyXG4gKi9cclxudmFyIGV2ZW50UXVldWUgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XHJcbiAgaWYgKGV2ZW50KSB7XHJcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcclxuXHJcbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XHJcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcclxufTtcclxudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcclxuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcclxufTtcclxuXHJcbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcclxuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXHJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xyXG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQobmFtZSwgdHlwZSwgcHJvcHMpIHtcclxuICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgIGNhc2UgJ29uQ2xpY2snOlxyXG4gICAgY2FzZSAnb25DbGlja0NhcHR1cmUnOlxyXG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XHJcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XHJcbiAgICBjYXNlICdvbk1vdXNlRG93bic6XHJcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxyXG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxyXG4gICAgY2FzZSAnb25Nb3VzZU1vdmVDYXB0dXJlJzpcclxuICAgIGNhc2UgJ29uTW91c2VVcCc6XHJcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcclxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXHJcbiAqXHJcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAqXHJcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XHJcbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cclxuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXHJcbiAqXHJcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XHJcbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXHJcbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XHJcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cclxuICpcclxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cclxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxyXG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxyXG4gKlxyXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cclxuICAgKi9cclxuICBpbmplY3Rpb246IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cclxuICAgICAqL1xyXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxyXG5cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxyXG4gICAqL1xyXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IF9wcm9kSW52YXJpYW50KCc5NCcsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XHJcblxyXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XHJcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcclxuICAgIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV0gPSBsaXN0ZW5lcjtcclxuXHJcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcclxuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XHJcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXHJcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxyXG4gICAqL1xyXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xyXG4gICAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcclxuICAgIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxyXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xyXG4gICAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QuX2N1cnJlbnRFbGVtZW50LnR5cGUsIGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xyXG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXHJcbiAgICovXHJcbiAgZGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XHJcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcclxuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xyXG4gICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcclxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cclxuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xyXG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcclxuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxyXG4gICAqL1xyXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcclxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xyXG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcclxuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcclxuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcclxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgIHZhciBldmVudHM7XHJcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXHJcbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XHJcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xyXG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuICAgICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XHJcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxyXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVucXVldWVFdmVudHM6IGZ1bmN0aW9uIChldmVudHMpIHtcclxuICAgIGlmIChldmVudHMpIHtcclxuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xyXG4gICAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxyXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxyXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcclxuICAgIGV2ZW50UXVldWUgPSBudWxsO1xyXG4gICAgaWYgKHNpbXVsYXRlZCkge1xyXG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcclxuICAgIH1cclxuICAgICEhZXZlbnRRdWV1ZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5NScpIDogdm9pZCAwO1xyXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXHJcbiAgICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcclxuICAgKi9cclxuICBfX3B1cmdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcclxuICB9LFxyXG5cclxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXHJcbiAqL1xyXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XHJcblxyXG4vKipcclxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXHJcbiAqL1xyXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XHJcbiAgaWYgKCFldmVudFBsdWdpbk9yZGVyKSB7XHJcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xyXG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xyXG4gICAgdmFyIHBsdWdpbkluZGV4ID0gZXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xyXG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xyXG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICAhcGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NycsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xyXG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcclxuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcclxuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcclxuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcclxuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OScsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XHJcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xyXG5cclxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcclxuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcclxuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xyXG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xyXG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcclxuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xyXG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcclxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XHJcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcclxuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xyXG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xyXG5cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XHJcblxyXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xyXG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXHJcbiAqXHJcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxyXG4gKi9cclxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxyXG4gICAqL1xyXG4gIHBsdWdpbnM6IFtdLFxyXG5cclxuICAvKipcclxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcclxuICAgKi9cclxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxyXG5cclxuICAvKipcclxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxyXG4gICAqL1xyXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcclxuICAgKi9cclxuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXHJcbiAgICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxyXG4gICAqIG9ubHkgaW4gX19ERVZfXy5cclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXHJcbiAgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIF9fREVWX19cclxuXHJcbiAgLyoqXHJcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xyXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xyXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XHJcbiAgICovXHJcbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xyXG4gICAgISFldmVudFBsdWdpbk9yZGVyID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XHJcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXHJcbiAgICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcclxuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXHJcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cclxuICAgKlxyXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cclxuICAgKi9cclxuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uIChpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XHJcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcclxuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XHJcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xyXG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcclxuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcclxuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XHJcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxyXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcclxuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XHJcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBwdWxsaW5nIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIG91dCBvZiBkaXNwYXRjaENvbmZpZyBoZWxwcyBGbG93IHNlZVxyXG4gICAgICAvLyB0aGF0IGl0IGlzIG5vdCB1bmRlZmluZWQuXHJcbiAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xyXG5cclxuICAgICAgZm9yICh2YXIgcGhhc2UgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcclxuICAgICAgICBpZiAoIXBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXV07XHJcbiAgICAgICAgaWYgKHBsdWdpbk1vZHVsZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHBsdWdpbk1vZHVsZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xyXG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XHJcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XHJcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xyXG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xyXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xyXG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xyXG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xyXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcclxuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcclxuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xyXG4gICAgICAgIGlmIChwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xyXG4gICAgICAgICAgZGVsZXRlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luUmVnaXN0cnk7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbi8qKlxyXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIC0gYENvbXBvbmVudFRyZWVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgaW5zdGFuY2VzXHJcbiAqICAgYW5kIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXHJcbiAqL1xyXG52YXIgQ29tcG9uZW50VHJlZTtcclxudmFyIFRyZWVUcmF2ZXJzYWw7XHJcbnZhciBpbmplY3Rpb24gPSB7XHJcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XHJcbiAgICBDb21wb25lbnRUcmVlID0gSW5qZWN0ZWQ7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlICYmIEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgaW5qZWN0VHJlZVRyYXZlcnNhbDogZnVuY3Rpb24gKEluamVjdGVkKSB7XHJcbiAgICBUcmVlVHJhdmVyc2FsID0gSW5qZWN0ZWQ7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5pc0FuY2VzdG9yICYmIEluamVjdGVkLmdldExvd2VzdENvbW1vbkFuY2VzdG9yLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0VHJlZVRyYXZlcnNhbCguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGlzQW5jZXN0b3Igb3IgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IuJykgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XHJcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlVXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoRW5kJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaENhbmNlbCc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcclxuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VNb3ZlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaE1vdmUnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XHJcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlRG93bicgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hTdGFydCc7XHJcbn1cclxuXHJcbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xyXG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xyXG5cclxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xyXG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcclxuXHJcbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcclxuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XHJcblxyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdm9pZCAwO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcclxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xyXG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XHJcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICBpZiAoc2ltdWxhdGVkKSB7XHJcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcclxuICB9XHJcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cclxuICovXHJcbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XHJcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xyXG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cclxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xyXG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XHJcbiAgfVxyXG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XHJcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcclxuICogYXQgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiByZXR1cm5pbmcgdHJ1ZSwgYW5kIHJldHVybnMgdGhhdCBpZC5cclxuICpcclxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXHJcbiAqIHRydWUsIG9yIG51bGwgaWYgbm8gbGlzdGVuZXIgcmV0dXJuZWQgdHJ1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XHJcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xyXG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cclxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlc1tpXSkpIHtcclxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXNbaV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XHJcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xyXG4gICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXM7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxyXG4gKi9cclxuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xyXG4gIHZhciByZXQgPSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCk7XHJcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcclxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxyXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxyXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxyXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxyXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxyXG4gKi9cclxuZnVuY3Rpb24gZXhlY3V0ZURpcmVjdERpc3BhdGNoKGV2ZW50KSB7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcclxuICB9XHJcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XHJcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XHJcbiAgISFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2V4ZWN1dGVEaXJlY3REaXNwYXRjaCguLi4pOiBJbnZhbGlkIGBldmVudGAuJykgOiBfcHJvZEludmFyaWFudCgnMTAzJykgOiB2b2lkIDA7XHJcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xyXG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCkgOiBudWxsO1xyXG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XHJcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcclxuICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XHJcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxyXG4gKi9cclxudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XHJcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxyXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxyXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXHJcblxyXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxyXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxyXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXHJcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcclxuXHJcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XHJcbiAgfSxcclxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcclxuICB9LFxyXG4gIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xyXG4gIH0sXHJcbiAgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcclxuICB9LFxyXG4gIGdldFBhcmVudEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XHJcbiAgfSxcclxuICB0cmF2ZXJzZVR3b1BoYXNlOiBmdW5jdGlvbiAodGFyZ2V0LCBmbiwgYXJnKSB7XHJcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XHJcbiAgfSxcclxuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XHJcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XHJcbiAgfSxcclxuXHJcbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlsczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XHJcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XHJcblxyXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XHJcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xyXG5cclxuLyoqXHJcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcclxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xyXG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XHJcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xyXG59XHJcblxyXG4vKipcclxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxyXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxyXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xyXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpIDogdm9pZCAwO1xyXG4gIH1cclxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcclxuICBpZiAobGlzdGVuZXIpIHtcclxuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xyXG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XHJcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxyXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXHJcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxyXG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cclxuICovXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcclxuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcclxuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xyXG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xyXG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcclxuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xyXG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxyXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxyXG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cclxuICovXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XHJcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcclxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcclxuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xyXG4gICAgaWYgKGxpc3RlbmVyKSB7XHJcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xyXG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxyXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxyXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxyXG4gKi9cclxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcclxuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xyXG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XHJcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xyXG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcclxuICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xyXG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XHJcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxyXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXHJcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxyXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxyXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXHJcbiAqIHNpbmdsZSBvbmUuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXHJcbiAqL1xyXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcclxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxyXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcclxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXHJcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9yczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcclxuXHJcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XHJcblxyXG4vKipcclxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxyXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxyXG4gKlxyXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXHJcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXHJcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXHJcbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcclxuICovXHJcbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XHJcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XHJcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XHJcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcclxufVxyXG5cclxuX2Fzc2lnbihGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLCB7XHJcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XHJcbiAgICB0aGlzLl9zdGFydFRleHQgPSBudWxsO1xyXG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldFRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXHJcbiAgICogdGV4dCBjb250ZW50IGFuZCB0aGUgY3VycmVudCBjb250ZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3RhcnQ7XHJcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcclxuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xyXG4gICAgdmFyIGVuZDtcclxuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xyXG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xyXG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XHJcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XHJcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XHJcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xyXG4gIH1cclxufSk7XHJcblxyXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcclxuXHJcbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcclxudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xyXG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XHJcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcclxudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcclxuXHJcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XHJcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxyXG4gIFByb3BlcnRpZXM6IHtcclxuICAgIC8qKlxyXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBhY2NlcHQ6IDAsXHJcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxyXG4gICAgYWNjZXNzS2V5OiAwLFxyXG4gICAgYWN0aW9uOiAwLFxyXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGFsbG93VHJhbnNwYXJlbmN5OiAwLFxyXG4gICAgYWx0OiAwLFxyXG4gICAgLy8gc3BlY2lmaWVzIHRhcmdldCBjb250ZXh0IGZvciBsaW5rcyB3aXRoIGBwcmVsb2FkYCB0eXBlXHJcbiAgICBhczogMCxcclxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGF1dG9Db21wbGV0ZTogMCxcclxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcclxuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBjYXB0dXJlOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGNlbGxQYWRkaW5nOiAwLFxyXG4gICAgY2VsbFNwYWNpbmc6IDAsXHJcbiAgICBjaGFyU2V0OiAwLFxyXG4gICAgY2hhbGxlbmdlOiAwLFxyXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGNpdGU6IDAsXHJcbiAgICBjbGFzc0lEOiAwLFxyXG4gICAgY2xhc3NOYW1lOiAwLFxyXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXHJcbiAgICBjb2xTcGFuOiAwLFxyXG4gICAgY29udGVudDogMCxcclxuICAgIGNvbnRlbnRFZGl0YWJsZTogMCxcclxuICAgIGNvbnRleHRNZW51OiAwLFxyXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgY29vcmRzOiAwLFxyXG4gICAgY3Jvc3NPcmlnaW46IDAsXHJcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXHJcbiAgICBkYXRlVGltZTogMCxcclxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBkaXI6IDAsXHJcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcclxuICAgIGRyYWdnYWJsZTogMCxcclxuICAgIGVuY1R5cGU6IDAsXHJcbiAgICBmb3JtOiAwLFxyXG4gICAgZm9ybUFjdGlvbjogMCxcclxuICAgIGZvcm1FbmNUeXBlOiAwLFxyXG4gICAgZm9ybU1ldGhvZDogMCxcclxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGZvcm1UYXJnZXQ6IDAsXHJcbiAgICBmcmFtZUJvcmRlcjogMCxcclxuICAgIGhlYWRlcnM6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgaGlnaDogMCxcclxuICAgIGhyZWY6IDAsXHJcbiAgICBocmVmTGFuZzogMCxcclxuICAgIGh0bWxGb3I6IDAsXHJcbiAgICBodHRwRXF1aXY6IDAsXHJcbiAgICBpY29uOiAwLFxyXG4gICAgaWQ6IDAsXHJcbiAgICBpbnB1dE1vZGU6IDAsXHJcbiAgICBpbnRlZ3JpdHk6IDAsXHJcbiAgICBpczogMCxcclxuICAgIGtleVBhcmFtczogMCxcclxuICAgIGtleVR5cGU6IDAsXHJcbiAgICBraW5kOiAwLFxyXG4gICAgbGFiZWw6IDAsXHJcbiAgICBsYW5nOiAwLFxyXG4gICAgbGlzdDogMCxcclxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgbG93OiAwLFxyXG4gICAgbWFuaWZlc3Q6IDAsXHJcbiAgICBtYXJnaW5IZWlnaHQ6IDAsXHJcbiAgICBtYXJnaW5XaWR0aDogMCxcclxuICAgIG1heDogMCxcclxuICAgIG1heExlbmd0aDogMCxcclxuICAgIG1lZGlhOiAwLFxyXG4gICAgbWVkaWFHcm91cDogMCxcclxuICAgIG1ldGhvZDogMCxcclxuICAgIG1pbjogMCxcclxuICAgIG1pbkxlbmd0aDogMCxcclxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXHJcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxyXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIG5hbWU6IDAsXHJcbiAgICBub25jZTogMCxcclxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBvcHRpbXVtOiAwLFxyXG4gICAgcGF0dGVybjogMCxcclxuICAgIHBsYWNlaG9sZGVyOiAwLFxyXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgcG9zdGVyOiAwLFxyXG4gICAgcHJlbG9hZDogMCxcclxuICAgIHByb2ZpbGU6IDAsXHJcbiAgICByYWRpb0dyb3VwOiAwLFxyXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgcmVmZXJyZXJQb2xpY3k6IDAsXHJcbiAgICByZWw6IDAsXHJcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICByb2xlOiAwLFxyXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXHJcbiAgICByb3dTcGFuOiBIQVNfTlVNRVJJQ19WQUxVRSxcclxuICAgIHNhbmRib3g6IDAsXHJcbiAgICBzY29wZTogMCxcclxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBzY3JvbGxpbmc6IDAsXHJcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIHNoYXBlOiAwLFxyXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXHJcbiAgICBzaXplczogMCxcclxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxyXG4gICAgc3BlbGxDaGVjazogMCxcclxuICAgIHNyYzogMCxcclxuICAgIHNyY0RvYzogMCxcclxuICAgIHNyY0xhbmc6IDAsXHJcbiAgICBzcmNTZXQ6IDAsXHJcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXHJcbiAgICBzdGVwOiAwLFxyXG4gICAgc3R5bGU6IDAsXHJcbiAgICBzdW1tYXJ5OiAwLFxyXG4gICAgdGFiSW5kZXg6IDAsXHJcbiAgICB0YXJnZXQ6IDAsXHJcbiAgICB0aXRsZTogMCxcclxuICAgIC8vIFNldHRpbmcgLnR5cGUgdGhyb3dzIG9uIG5vbi08aW5wdXQ+IHRhZ3NcclxuICAgIHR5cGU6IDAsXHJcbiAgICB1c2VNYXA6IDAsXHJcbiAgICB2YWx1ZTogMCxcclxuICAgIHdpZHRoOiAwLFxyXG4gICAgd21vZGU6IDAsXHJcbiAgICB3cmFwOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIGFib3V0OiAwLFxyXG4gICAgZGF0YXR5cGU6IDAsXHJcbiAgICBpbmxpc3Q6IDAsXHJcbiAgICBwcmVmaXg6IDAsXHJcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cclxuICAgIHByb3BlcnR5OiAwLFxyXG4gICAgcmVzb3VyY2U6IDAsXHJcbiAgICAndHlwZW9mJzogMCxcclxuICAgIHZvY2FiOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxyXG4gICAgYXV0b0NhcGl0YWxpemU6IDAsXHJcbiAgICBhdXRvQ29ycmVjdDogMCxcclxuICAgIC8vIGF1dG9TYXZlIGFsbG93cyBXZWJLaXQvQmxpbmsgdG8gcGVyc2lzdCB2YWx1ZXMgb2YgaW5wdXQgZmllbGRzIG9uIHBhZ2UgcmVsb2Fkc1xyXG4gICAgYXV0b1NhdmU6IDAsXHJcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXHJcbiAgICBjb2xvcjogMCxcclxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXHJcbiAgICBpdGVtUHJvcDogMCxcclxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBpdGVtVHlwZTogMCxcclxuICAgIC8vIGl0ZW1JRCBhbmQgaXRlbVJlZiBhcmUgZm9yIE1pY3JvZGF0YSBzdXBwb3J0IGFzIHdlbGwgYnV0XHJcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxyXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcclxuICAgIGl0ZW1JRDogMCxcclxuICAgIGl0ZW1SZWY6IDAsXHJcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcclxuICAgIC8vIHNlYXJjaCBmaWVsZHMgaW4gV2ViS2l0L0JsaW5rXHJcbiAgICByZXN1bHRzOiAwLFxyXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxyXG4gICAgLy8gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHNhbmRib3ggYXR0cmlidXRlIG9uIElFPDEwXHJcbiAgICBzZWN1cml0eTogMCxcclxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcclxuICAgIHVuc2VsZWN0YWJsZTogMFxyXG4gIH0sXHJcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcclxuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXHJcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXHJcbiAgICBodG1sRm9yOiAnZm9yJyxcclxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXHJcbiAgfSxcclxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcclxuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xyXG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xyXG4gICAgJz0nOiAnPTAnLFxyXG4gICAgJzonOiAnPTInXHJcbiAgfTtcclxuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogVW5lc2NhcGUgYW5kIHVud3JhcCBrZXkgZm9yIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXlcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cclxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdW5lc2NhcGVkIGtleS5cclxuICovXHJcbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xyXG4gIHZhciB1bmVzY2FwZVJlZ2V4ID0gLyg9MHw9MikvZztcclxuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xyXG4gICAgJz0wJzogJz0nLFxyXG4gICAgJz0yJzogJzonXHJcbiAgfTtcclxuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcclxuXHJcbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xyXG4gIH0pO1xyXG59XHJcblxyXG52YXIgS2V5RXNjYXBlVXRpbHMgPSB7XHJcbiAgZXNjYXBlOiBlc2NhcGUsXHJcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcclxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xyXG4gICdidXR0b24nOiB0cnVlLFxyXG4gICdjaGVja2JveCc6IHRydWUsXHJcbiAgJ2ltYWdlJzogdHJ1ZSxcclxuICAnaGlkZGVuJzogdHJ1ZSxcclxuICAncmFkaW8nOiB0cnVlLFxyXG4gICdyZXNldCc6IHRydWUsXHJcbiAgJ3N1Ym1pdCc6IHRydWVcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcclxuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBfcHJvZEludmFyaWFudCgnODcnKSA6IHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcclxuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcclxuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IF9wcm9kSW52YXJpYW50KCc4OCcpIDogdm9pZCAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcykge1xyXG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xyXG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSBjaGVja2VkTGluaycpIDogX3Byb2RJbnZhcmlhbnQoJzg5JykgOiB2b2lkIDA7XHJcbn1cclxuXHJcbnZhciBwcm9wVHlwZXMgPSB7XHJcbiAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcclxuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xyXG4gIH0sXHJcbiAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xyXG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcclxuICB9LFxyXG4gIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xyXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcclxuICBpZiAob3duZXIpIHtcclxuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xyXG4gICAgaWYgKG5hbWUpIHtcclxuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXHJcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXHJcbiAqL1xyXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcclxuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xyXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XHJcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsICdwcm9wJywgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XHJcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXHJcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cclxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpO1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB2b2lkIDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcclxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXHJcbiAgICovXHJcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XHJcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcclxuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcclxuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XHJcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXHJcbiAgICogICAgICAgICAgICAgb3IgbGluay5cclxuICAgKi9cclxuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xyXG4gICAgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcclxuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xyXG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XHJcbiAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgY2hhbmdlIGV2ZW50IHRvIGhhbmRsZVxyXG4gICAqL1xyXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XHJcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcclxuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcclxuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xyXG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XHJcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xyXG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLm9uQ2hhbmdlKSB7XHJcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRWYWx1ZVV0aWxzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXHJcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcclxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xyXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXHJcbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cclxuICovXHJcbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xyXG4gIHZhciBLbGFzcyA9IHRoaXM7XHJcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcclxuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcclxuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xyXG4gIHZhciBLbGFzcyA9IHRoaXM7XHJcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcclxuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcclxuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XHJcbiAgdmFyIEtsYXNzID0gdGhpcztcclxuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xyXG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xyXG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xyXG4gIHZhciBLbGFzcyA9IHRoaXM7XHJcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcclxuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcclxuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICB2YXIgS2xhc3MgPSB0aGlzO1xyXG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xyXG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcclxuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XHJcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XHJcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xyXG5cclxuLyoqXHJcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcclxuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXHJcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXHJcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXHJcbiAqL1xyXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XHJcbiAgLy8gQ2FzdGluZyBhcyBhbnkgc28gdGhhdCBmbG93IGlnbm9yZXMgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBhbmQgdHJ1c3RzXHJcbiAgLy8gaXQgdG8gbWF0Y2ggdGhlIHR5cGUgd2UgZGVjbGFyZWRcclxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XHJcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XHJcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xyXG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcclxuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XHJcbiAgfVxyXG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xyXG4gIHJldHVybiBOZXdLbGFzcztcclxufTtcclxuXHJcbnZhciBQb29sZWRDbGFzcyA9IHtcclxuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcclxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXHJcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxyXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXHJcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXJcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xyXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpbicpO1xyXG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcclxuXHJcbnZhciBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSA9IHJlcXVpcmUoJy4vZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUnKTtcclxudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcclxuXHJcbi8qKlxyXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxyXG4gKlxyXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcclxuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcclxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxyXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxyXG4gKlxyXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcclxuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXHJcbiAqXHJcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXHJcbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcclxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cclxuICpcclxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxyXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cclxuICpcclxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXHJcbiAqXHJcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxyXG4gKlxyXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXHJcbiAqIHwgICAgRE9NICAgICB8ICAgIC5cclxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxyXG4gKiAgICAgICB8ICAgICAgICAgICAuXHJcbiAqICAgICAgIHYgICAgICAgICAgIC5cclxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxyXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXHJcbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cclxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXHJcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxyXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcclxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXHJcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcclxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxyXG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XHJcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcclxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxyXG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XHJcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcclxuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXHJcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xyXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcclxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XHJcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xyXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXHJcbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cclxuICogfCAgICAgICAgICAgICB8ICAgLlxyXG4gKiB8ICAgICAgICAgICAgIHwgICAuXHJcbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cclxuICogICAgICAgICAgICAgICAgICAgLlxyXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxyXG4gKi9cclxuXHJcbnZhciBoYXNFdmVudFBhZ2VYWTtcclxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xyXG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcclxudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XHJcblxyXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXHJcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxyXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcclxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcclxuICB0b3BBYm9ydDogJ2Fib3J0JyxcclxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcclxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcclxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcclxuICB0b3BCbHVyOiAnYmx1cicsXHJcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxyXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxyXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXHJcbiAgdG9wQ2xpY2s6ICdjbGljaycsXHJcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXHJcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxyXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxyXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxyXG4gIHRvcENvcHk6ICdjb3B5JyxcclxuICB0b3BDdXQ6ICdjdXQnLFxyXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxyXG4gIHRvcERyYWc6ICdkcmFnJyxcclxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXHJcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcclxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcclxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxyXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxyXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXHJcbiAgdG9wRHJvcDogJ2Ryb3AnLFxyXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxyXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcclxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxyXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxyXG4gIHRvcEVycm9yOiAnZXJyb3InLFxyXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxyXG4gIHRvcElucHV0OiAnaW5wdXQnLFxyXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcclxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcclxuICB0b3BLZXlVcDogJ2tleXVwJyxcclxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXHJcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXHJcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcclxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxyXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXHJcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXHJcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcclxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXHJcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXHJcbiAgdG9wUGF1c2U6ICdwYXVzZScsXHJcbiAgdG9wUGxheTogJ3BsYXknLFxyXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcclxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcclxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXHJcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcclxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxyXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcclxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxyXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcclxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXHJcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcclxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXHJcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXHJcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXHJcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcclxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXHJcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXHJcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcclxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXHJcbiAgdG9wV2hlZWw6ICd3aGVlbCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxyXG4gKi9cclxudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcclxuXHJcbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcclxuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxyXG4gIC8vIGRpcmVjdGx5LlxyXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xyXG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcclxuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcclxuICB9XHJcbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcclxuICogZXhhbXBsZTpcclxuICpcclxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XHJcbiAqXHJcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxyXG4gICAqL1xyXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcclxuXHJcbiAgaW5qZWN0aW9uOiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xyXG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyID0gUmVhY3RFdmVudExpc3RlbmVyO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxyXG4gICAqL1xyXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XHJcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXHJcbiAgICovXHJcbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXHJcbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcclxuICAgKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xyXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxyXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcclxuICAgKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxyXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcclxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXHJcbiAgICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxyXG4gICAqXHJcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxyXG4gICAqXHJcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxyXG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXHJcbiAgICovXHJcbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcclxuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xyXG4gICAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XHJcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xyXG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcclxuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFdoZWVsJykge1xyXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3doZWVsJykpIHtcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICdtb3VzZXdoZWVsJywgbW91bnRBdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxyXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy90ZXN0cy9zY3JvbGwuaHRtbFxyXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wU2Nyb2xsJykge1xyXG5cclxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xyXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcclxuXHJcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xyXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xyXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XHJcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cclxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXHJcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wRm9jdXMnLCAnZm9jdXNpbicsIG1vdW50QXQpO1xyXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEJsdXInLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcclxuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xyXG4gICAgICAgICAgaXNMaXN0ZW5pbmcudG9wRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XHJcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xyXG4gIH0sXHJcblxyXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xyXG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvdGVjdCBhZ2FpbnN0IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkgcmV0dXJuaW5nIG51bGxcclxuICAgKiBTb21lIHBvcHVwIGJsb2NrZXIgZXh0ZW5zaW9ucyBhcHBlYXIgdG8gZG8gdGhpczpcclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY4ODdcclxuICAgKi9cclxuICBzdXBwb3J0c0V2ZW50UGFnZVhZOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XHJcbiAgICByZXR1cm4gZXYgIT0gbnVsbCAmJiAncGFnZVgnIGluIGV2O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XHJcbiAgICogYXBwbGljYXRpb24gY29kZSBjYW4gYWNjZXNzIHRoZW0gd2l0aG91dCB0cmlnZ2VyaW5nIHJlZmxvd3MuXHJcbiAgICpcclxuICAgKiBWaWV3cG9ydE1ldHJpY3MgaXMgb25seSB1c2VkIGJ5IFN5bnRoZXRpY01vdXNlL1RvdWNoRXZlbnQgYW5kIG9ubHkgd2hlblxyXG4gICAqIHBhZ2VYL3BhZ2VZIGlzbid0IHN1cHBvcnRlZCAobGVnYWN5IGJyb3dzZXJzKS5cclxuICAgKlxyXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXHJcbiAgICovXHJcbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBoYXNFdmVudFBhZ2VYWSA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zdXBwb3J0c0V2ZW50UGFnZVhZKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xyXG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xyXG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcclxuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XHJcblxyXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xyXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XHJcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcclxudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcclxuXHJcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgXCJwcm9kdWN0aW9uXCIgPT09ICd0ZXN0Jykge1xyXG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxyXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxyXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxyXG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcclxuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cclxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XHJcbiAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFrZXlVbmlxdWUpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChjaGlsZCAhPSBudWxsICYmIGtleVVuaXF1ZSkge1xyXG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFjdENoaWxkUmVjb25jaWxlciBwcm92aWRlcyBoZWxwZXJzIGZvciBpbml0aWFsaXppbmcgb3IgdXBkYXRpbmcgYSBzZXQgb2ZcclxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcclxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxyXG4gKi9cclxudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXHJcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkTm9kZXMgTmVzdGVkIGNoaWxkIG1hcHMuXHJcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcclxuICApIHtcclxuICAgIGlmIChuZXN0ZWRDaGlsZE5vZGVzID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgY2hpbGRJbnN0YW5jZXMgPSB7fTtcclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZEluc3RzLCBjaGlsZCwgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XHJcbiAgICAgIH0sIGNoaWxkSW5zdGFuY2VzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkSW5zdGFuY2VzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxyXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xyXG4gICkge1xyXG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xyXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcclxuICAgIC8vIG1vdmVkLlxyXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcclxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cclxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIG5hbWU7XHJcbiAgICB2YXIgcHJldkNoaWxkO1xyXG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xyXG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XHJcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xyXG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XHJcbiAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbCAmJiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XHJcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocHJldkNoaWxkKSB7XHJcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcclxuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cclxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCB0cnVlKTtcclxuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcclxuICAgICAgICAvLyBDcmVhdGluZyBtb3VudCBpbWFnZSBub3cgZW5zdXJlcyByZWZzIGFyZSByZXNvbHZlZCBpbiByaWdodCBvcmRlclxyXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzEwMSBmb3IgZXhwbGFuYXRpb24pLlxyXG4gICAgICAgIHZhciBuZXh0Q2hpbGRNb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KG5leHRDaGlsZEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcclxuICAgICAgICBtb3VudEltYWdlcy5wdXNoKG5leHRDaGlsZE1vdW50SW1hZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxyXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xyXG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcclxuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5bbmFtZV07XHJcbiAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XHJcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cclxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpIHtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xyXG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcclxuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkLCBzYWZlbHkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XHJcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxyXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LiBUT0RPOiBUaGVzZSBjYWxsZXJzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIGF2b2lkIHRoZVxyXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cclxuICovXHJcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcclxuXHJcbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxyXG5cclxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW5qZWN0ZWQgPSBmYWxzZTtcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xyXG5cclxuICAvKipcclxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXHJcbiAgICogdGhlIHRyZWUuXHJcbiAgICovXHJcbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBudWxsLFxyXG5cclxuICAvKipcclxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcclxuICAgKiBsYXRlciBtb3ZlIGludG8gTXVsdGlDaGlsZENvbXBvbmVudHMuXHJcbiAgICovXHJcbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcclxuXHJcbiAgaW5qZWN0aW9uOiB7XHJcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XHJcbiAgICAgICEhaW5qZWN0ZWQgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJykgOiBfcHJvZEludmFyaWFudCgnMTA0JykgOiB2b2lkIDA7XHJcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xyXG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xyXG4gICAgICBpbmplY3RlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxyXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xyXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcclxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XHJcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xyXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XHJcbn1cclxuXHJcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xyXG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIENvbXBvc2l0ZVR5cGVzID0ge1xyXG4gIEltcHVyZUNsYXNzOiAwLFxyXG4gIFB1cmVDbGFzczogMSxcclxuICBTdGF0ZWxlc3NGdW5jdGlvbmFsOiAyXHJcbn07XHJcblxyXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxyXG5TdGF0ZWxlc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XHJcbiAgdmFyIGVsZW1lbnQgPSBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xyXG4gIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCk7XHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpIHtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xyXG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpIHtcclxuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KTtcclxufVxyXG5cclxuLy8gU2VwYXJhdGVkIGludG8gYSBmdW5jdGlvbiB0byBjb250YWluIGRlb3B0aW1pemF0aW9ucyBjYXVzZWQgYnkgdHJ5L2ZpbmFsbHkuXHJcbmZ1bmN0aW9uIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZuLCBkZWJ1Z0lELCB0aW1lclR5cGUpIHtcclxuICBpZiAoZGVidWdJRCA9PT0gMCkge1xyXG4gICAgLy8gVG9wLWxldmVsIHdyYXBwZXJzIChzZWUgUmVhY3RNb3VudCkgYW5kIGVtcHR5IGNvbXBvbmVudHMgKHNlZVxyXG4gICAgLy8gUmVhY3RET01FbXB0eUNvbXBvbmVudCkgYXJlIGludmlzaWJsZSB0byBob29rcyBhbmQgZGV2dG9vbHMuXHJcbiAgICAvLyBCb3RoIGFyZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRoYXQgc2hvdWxkIGdvIGF3YXkgaW4gdGhlIGZ1dHVyZS5cclxuICAgIHJldHVybiBmbigpO1xyXG4gIH1cclxuXHJcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZm4oKTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKlxyXG4gKiAtIGNvbnN0cnVjdG9yOiBJbml0aWFsaXphdGlvbiBvZiBzdGF0ZS4gVGhlIGluc3RhbmNlIGlzIG5vdyByZXRhaW5lZC5cclxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxyXG4gKiAgIC0gcmVuZGVyXHJcbiAqICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnNdXHJcbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxyXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cclxuICogICAgIC0gY29tcG9uZW50RGlkTW91bnRcclxuICpcclxuICogICAgICAgVXBkYXRlIFBoYXNlczpcclxuICogICAgICAgLSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChvbmx5IGNhbGxlZCBpZiBwYXJlbnQgdXBkYXRlZClcclxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcclxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcclxuICogICAgICAgICAgIC0gcmVuZGVyXHJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cclxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxyXG4gKlxyXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxyXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cclxuICogICAtIFtjaGlsZHJlbiBkZXN0cm95ZWRdXHJcbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXHJcbiAqXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcclxuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG52YXIgbmV4dE1vdW50SUQgPSAxO1xyXG5cclxuLyoqXHJcbiAqIEBsZW5kcyB7UmVhY3RDb21wb3NpdGVDb21wb25lbnQucHJvdG90eXBlfVxyXG4gKi9cclxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xyXG5cclxuICAvKipcclxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQGZpbmFsXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XHJcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcclxuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xyXG5cclxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXHJcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XHJcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XHJcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcclxuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcclxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xyXG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XHJcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXHJcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcclxuXHJcbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXHJcbiAgICB0aGlzLl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0Q29udGFpbmVySW5mb1xyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dFxyXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXHJcbiAgICogQGZpbmFsXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gbmV4dE1vdW50SUQrKztcclxuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xyXG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcclxuXHJcbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XHJcblxyXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XHJcblxyXG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gdHJhbnNhY3Rpb24uZ2V0VXBkYXRlUXVldWUoKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcclxuICAgIHZhciBkb0NvbnN0cnVjdCA9IHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpO1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XHJcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xyXG5cclxuICAgIC8vIFN1cHBvcnQgZnVuY3Rpb25hbCBjb21wb25lbnRzXHJcbiAgICBpZiAoIWRvQ29uc3RydWN0ICYmIChpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkpIHtcclxuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdDtcclxuICAgICAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCByZW5kZXJlZEVsZW1lbnQpO1xyXG4gICAgICAhKGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoaW5zdCkpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNScsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIGluc3QgPSBuZXcgU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCk7XHJcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuSW1wdXJlQ2xhc3M7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxyXG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xyXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHByb3BzTXV0YXRlZCA9IGluc3QucHJvcHMgIT09IHB1YmxpY1Byb3BzO1xyXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcclxuXHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhcHJvcHNNdXRhdGVkLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArICd1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cclxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcclxuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XHJcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcclxuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xyXG5cclxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcclxuXHJcbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSBiYWNrIHRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxyXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXHJcbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xyXG4gICAgICAvLyBjYXRjaCB0aGVtIGhlcmUsIGF0IGluaXRpYWxpemF0aW9uIHRpbWUsIGluc3RlYWQuXHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0LnN0YXRlLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdC5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xyXG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuXHJcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XHJcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgbWFya3VwO1xyXG4gICAgaWYgKGluc3QudW5zdGFibGVfaGFuZGxlRXJyb3IpIHtcclxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmcocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnREaWRNb3VudCgpO1xyXG4gICAgICAgICAgfSwgX3RoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWFya3VwO1xyXG4gIH0sXHJcblxyXG4gIF9jb25zdHJ1Y3RDb21wb25lbnQ6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXI6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XHJcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcclxuXHJcbiAgICBpZiAoZG9Db25zdHJ1Y3QpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcclxuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY3RvcicpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIGNhbiBzdGlsbCBiZSBhbiBpbnN0YW5jZSBpbiBjYXNlIG9mIGZhY3RvcnkgY29tcG9uZW50c1xyXG4gICAgLy8gYnV0IHdlJ2xsIGNvdW50IHRoaXMgYXMgdGltZSBzcGVudCByZW5kZXJpbmcgYXMgdGhlIG1vcmUgY29tbW9uIGNhc2UuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcclxuICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZzogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgbWFya3VwO1xyXG4gICAgdmFyIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBSb2xsIGJhY2sgdG8gY2hlY2twb2ludCwgaGFuZGxlIGVycm9yICh3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHRoZSB0cmFuc2FjdGlvbiksIGFuZCB0YWtlIGEgbmV3IGNoZWNrcG9pbnRcclxuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlLnVuc3RhYmxlX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUodGhpcy5faW5zdGFuY2UucHJvcHMsIHRoaXMuX2luc3RhbmNlLmNvbnRleHQpO1xyXG4gICAgICB9XHJcbiAgICAgIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XHJcblxyXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KHRydWUpO1xyXG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcclxuXHJcbiAgICAgIC8vIFRyeSBhZ2FpbiAtIHdlJ3ZlIGluZm9ybWVkIHRoZSBjb21wb25lbnQgYWJvdXQgdGhlIGVycm9yLCBzbyB0aGV5IGNhbiByZW5kZXIgYW4gZXJyb3IgbWVzc2FnZSB0aGlzIHRpbWUuXHJcbiAgICAgIC8vIElmIHRoaXMgdGhyb3dzIGFnYWluLCB0aGUgZXJyb3Igd2lsbCBidWJibGUgdXAgKGFuZCBjYW4gYmUgY2F1Z2h0IGJ5IGEgaGlnaGVyIGVycm9yIGJvdW5kYXJ5KS5cclxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXJrdXA7XHJcbiAgfSxcclxuXHJcbiAgcGVyZm9ybUluaXRpYWxNb3VudDogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xyXG5cclxuICAgIHZhciBkZWJ1Z0lEID0gMDtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xyXG4gICAgICAgIH0sIGRlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcclxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXHJcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xyXG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXHJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShyZW5kZXJlZEVsZW1lbnQpO1xyXG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xyXG4gICAgdmFyIGNoaWxkID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xyXG4gICAgKTtcclxuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XHJcblxyXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBkZWJ1Z0lEKTtcclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWFya3VwO1xyXG4gIH0sXHJcblxyXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxyXG4gICAqXHJcbiAgICogQGZpbmFsXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xyXG4gICAgaWYgKCF0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuXHJcbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCAmJiAhaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcclxuICAgICAgaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSB0cnVlO1xyXG5cclxuICAgICAgaWYgKHNhZmVseSkge1xyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXROYW1lKCkgKyAnLmNvbXBvbmVudFdpbGxVbm1vdW50KCknO1xyXG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudC5iaW5kKGluc3QpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xyXG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcclxuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHNhZmVseSk7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xyXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xyXG4gICAgLy8gRXZlbiBpZiB0aGlzIGNvbXBvbmVudCBpcyBzY2hlZHVsZWQgZm9yIGFub3RoZXIgdXBkYXRlIGluIFJlYWN0VXBkYXRlcyxcclxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxyXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xyXG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcclxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXHJcbiAgICAvLyBsb25nZXIgYWNjZXNzaWJsZS5cclxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xyXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XHJcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cclxuICAgIC8vIHdoaWNoIGFsbG93IHRoZSBpbnRlcm5hbHMgdG8gYmUgcHJvcGVybHkgY2xlYW5lZCB1cCBldmVuIGlmIHRoZSB1c2VyXHJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxyXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XHJcblxyXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxyXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXHJcbiAgICAvLyBUT0RPOiBpbnN0LnByb3BzID0gbnVsbDtcclxuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xyXG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cclxuICAgKiBgY29udGV4dFR5cGVzYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcclxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XHJcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcclxuICAgIGlmICghY29udGV4dFR5cGVzKSB7XHJcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcclxuICAgIH1cclxuICAgIHZhciBtYXNrZWRDb250ZXh0ID0ge307XHJcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcclxuICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxyXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcclxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxyXG4gICAqIEByZXR1cm4ge29iamVjdH1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcclxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuICAgIHZhciBjaGlsZENvbnRleHQ7XHJcblxyXG4gICAgaWYgKGluc3QuZ2V0Q2hpbGRDb250ZXh0KSB7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGlsZENvbnRleHQpIHtcclxuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA3JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZENvbnRleHQnKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xyXG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwOCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBc3NlcnQgdGhhdCB0aGUgY29udGV4dCB0eXBlcyBhcmUgdmFsaWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NoZWNrQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAodHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCB0aGlzLmdldE5hbWUoKSwgbnVsbCwgdGhpcy5fZGVidWdJRCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcclxuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xyXG4gICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuXHJcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcclxuICAgKiBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XHJcbiAgICBpZiAodGhpcy5fcGVuZGluZ0VsZW1lbnQgIT0gbnVsbCkge1xyXG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcclxuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXHJcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxyXG4gICAqIHNraXBwZWQpIHRoZSByZW1haW5pbmcgdXBkYXRlIGxpZmVjeWNsZSBtZXRob2RzIGFyZSBjYWxsZWQgYW5kIHRoZSBET01cclxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXHJcbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XHJcbiAgICogQGludGVybmFsXHJcbiAgICogQG92ZXJyaWRhYmxlXHJcbiAgICovXHJcbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZQYXJlbnRFbGVtZW50LCBuZXh0UGFyZW50RWxlbWVudCwgcHJldlVubWFza2VkQ29udGV4dCwgbmV4dFVubWFza2VkQ29udGV4dCkge1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuICAgICEoaW5zdCAhPSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdBdHRlbXB0ZWQgdG8gdXBkYXRlIGNvbXBvbmVudCBgJXNgIHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQgKG9yIGZhaWxlZCB0byBtb3VudCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTM2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcblxyXG4gICAgdmFyIHdpbGxSZWNlaXZlID0gZmFsc2U7XHJcbiAgICB2YXIgbmV4dENvbnRleHQ7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxyXG4gICAgaWYgKHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQpIHtcclxuICAgICAgbmV4dENvbnRleHQgPSBpbnN0LmNvbnRleHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xyXG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByZXZQcm9wcyA9IHByZXZQYXJlbnRFbGVtZW50LnByb3BzO1xyXG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xyXG5cclxuICAgIC8vIE5vdCBhIHNpbXBsZSBzdGF0ZSB1cGRhdGUgYnV0IGEgcHJvcHMgdXBkYXRlXHJcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XHJcbiAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXHJcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXHJcbiAgICBpZiAod2lsbFJlY2VpdmUgJiYgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcclxuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xyXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcclxuICAgICAgaWYgKGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XHJcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3MpIHtcclxuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcclxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcclxuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cclxuICAgICAgdGhpcy5fcGVyZm9ybUNvbXBvbmVudFVwZGF0ZShuZXh0UGFyZW50RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgbmV4dFVubWFza2VkQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxyXG4gICAgICAvLyB0byBzZXQgcHJvcHMgYW5kIHN0YXRlIGJ1dCB3ZSBzaG9ydGN1dCB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlLlxyXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRQYXJlbnRFbGVtZW50O1xyXG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcclxuICAgICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcclxuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX3Byb2Nlc3NQZW5kaW5nU3RhdGU6IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xyXG4gICAgdmFyIHJlcGxhY2UgPSB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlO1xyXG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xyXG5cclxuICAgIGlmICghcXVldWUpIHtcclxuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBxdWV1ZVswXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV4dFN0YXRlID0gX2Fzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XHJcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcclxuICAgICAgX2Fzc2lnbihuZXh0U3RhdGUsIHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIGNvbnRleHQpIDogcGFydGlhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXHJcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlIE5leHQgb2JqZWN0IHRvIHNldCBhcyBzdGF0ZS5cclxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSB1bm1hc2tlZENvbnRleHRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wZXJmb3JtQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCkge1xyXG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuXHJcbiAgICB2YXIgaGFzQ29tcG9uZW50RGlkVXBkYXRlID0gQm9vbGVhbihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSk7XHJcbiAgICB2YXIgcHJldlByb3BzO1xyXG4gICAgdmFyIHByZXZTdGF0ZTtcclxuICAgIHZhciBwcmV2Q29udGV4dDtcclxuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcclxuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcclxuICAgICAgcHJldlN0YXRlID0gaW5zdC5zdGF0ZTtcclxuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcclxuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcclxuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XHJcbiAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xyXG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xyXG5cclxuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgX3RoaXMyLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xyXG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xyXG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xyXG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcclxuXHJcbiAgICB2YXIgZGVidWdJRCA9IDA7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldlJlbmRlcmVkRWxlbWVudCwgbmV4dFJlbmRlcmVkRWxlbWVudCkpIHtcclxuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgb2xkSG9zdE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNvbXBvbmVudEluc3RhbmNlKTtcclxuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBmYWxzZSk7XHJcblxyXG4gICAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKG5leHRSZW5kZXJlZEVsZW1lbnQpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XHJcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XHJcblxyXG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMuX2hvc3RQYXJlbnQsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBkZWJ1Z0lEKTtcclxuXHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKGRlYnVnSUQgIT09IDApIHtcclxuICAgICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XHJcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3JlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkNvbXBvbmVudEluc3RhbmNlKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZGVuIGluIHNoYWxsb3cgcmVuZGVyaW5nLlxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKSB7XHJcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBpbnN0LnJlbmRlcigpO1xyXG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0LnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxyXG4gICAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcclxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxyXG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nIHx8IHRoaXMuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcclxuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xyXG4gICAgfVxyXG4gICAgIShcclxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxyXG4gICAgcmVuZGVyZWRFbGVtZW50ID09PSBudWxsIHx8IHJlbmRlcmVkRWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRFbGVtZW50KSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMucmVuZGVyKCk6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDknLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxyXG4gICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcclxuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xyXG4gICAgIShpbnN0ICE9IG51bGwpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiBfcHJvZEludmFyaWFudCgnMTEwJykgOiB2b2lkIDA7XHJcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXROYW1lID8gY29tcG9uZW50LmdldE5hbWUoKSA6ICdhIGNvbXBvbmVudCc7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwgfHwgY29tcG9uZW50Ll9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xyXG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cclxuICAgKiBAZmluYWxcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xyXG4gICAgdmFyIHJlZnMgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucmVmcztcclxuICAgIGRlbGV0ZSByZWZzW3JlZl07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcclxuICAgKiBpbiBlcnJvciBtZXNzYWdlcy5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuY29uc3RydWN0b3I7XHJcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxyXG4gICAqIGlzIGV4cG9zZWQgYnkgcmVmcyBhbmQgcmV0dXJuZWQgYnkgcmVuZGVyLiBDYW4gYmUgbnVsbCBmb3Igc3RhdGVsZXNzXHJcbiAgICogY29tcG9uZW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSB0aGUgcHVibGljIGNvbXBvbmVudCBpbnN0YW5jZS5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluc3Q7XHJcbiAgfSxcclxuXHJcbiAgLy8gU3R1YlxyXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBudWxsXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XHJcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XHJcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xyXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcclxudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XHJcblxyXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XHJcbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcclxudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcclxuXHJcbnZhciBSZWFjdERPTSA9IHtcclxuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXHJcbiAgcmVuZGVyOiBSZWFjdE1vdW50LnJlbmRlcixcclxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXHJcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxyXG5cclxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cclxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxyXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxyXG59O1xyXG5cclxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXHJcbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXHJcbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xyXG4gICAgQ29tcG9uZW50VHJlZToge1xyXG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxyXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgICAgIC8vIGluc3QgaXMgYW4gaW50ZXJuYWwgaW5zdGFuY2UgKGJ1dCBjb3VsZCBiZSBhIGNvbXBvc2l0ZSlcclxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcclxuICAgICAgICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3QpIHtcclxuICAgICAgICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXHJcbiAgICBSZWNvbmNpbGVyOiBSZWFjdFJlY29uY2lsZXJcclxuICB9KTtcclxufVxyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcclxuXHJcbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXHJcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXHJcbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcclxuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IGhhdmUgdGhlIGlzc3VlIHdpdGggZGV2dG9vbHMgbG9hZGVkIG92ZXIgZmlsZTovL1xyXG4gICAgICAgIHZhciBzaG93RmlsZVVybE1lc3NhZ2UgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAoc2hvd0ZpbGVVcmxNZXNzYWdlID8gJ2FuZCB1c2UgYW4gSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgYSBmaWxlOiBVUkwpICcgOiAnJykgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRlc3RGdW5jID0gZnVuY3Rpb24gdGVzdEZuKCkge307XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZygodGVzdEZ1bmMubmFtZSB8fCB0ZXN0RnVuYy50b1N0cmluZygpKS5pbmRleE9mKCd0ZXN0Rm4nKSAhPT0gLTEsICdJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgJyArICdvZiBSZWFjdC4gV2hlbiBkZXBsb3lpbmcgUmVhY3QgYXBwcyB0byBwcm9kdWN0aW9uLCBtYWtlIHN1cmUgdG8gdXNlICcgKyAndGhlIHByb2R1Y3Rpb24gYnVpbGQgd2hpY2ggc2tpcHMgZGV2ZWxvcG1lbnQgd2FybmluZ3MgYW5kIGlzIGZhc3Rlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1taW5pZmljYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcclxuXHJcbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXHJcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxyXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcclxuXHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdm9pZCAwO1xyXG5cclxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xyXG4gICAgLy8gc2hpbXNcclxuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnRyaW1dO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09uZSBvciBtb3JlIEVTNSBzaGltcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJykgOiB2b2lkIDA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xyXG4gIHZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaycpO1xyXG4gIHZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaycpO1xyXG4gIHZhciBSZWFjdERPTUludmFsaWRBUklBSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnZhbGlkQVJJQUhvb2snKTtcclxuXHJcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rKTtcclxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2spO1xyXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NSW52YWxpZEFSSUFIb29rKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4vKiBnbG9iYWwgaGFzT3duUHJvcGVydHk6dHJ1ZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcclxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XHJcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xyXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XHJcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XHJcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcclxudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XHJcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcclxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcclxudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xyXG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XHJcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcclxudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcclxudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xyXG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcclxudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24nKTtcclxuXHJcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xyXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xyXG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XHJcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XHJcbnZhciBkZWxldGVMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyO1xyXG52YXIgZ2V0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlO1xyXG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XHJcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XHJcblxyXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXHJcbnZhciBDT05URU5UX1RZUEVTID0geyAnc3RyaW5nJzogdHJ1ZSwgJ251bWJlcic6IHRydWUgfTtcclxuXHJcbnZhciBTVFlMRSA9ICdzdHlsZSc7XHJcbnZhciBIVE1MID0gJ19faHRtbCc7XHJcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcclxuICBjaGlsZHJlbjogbnVsbCxcclxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogbnVsbCxcclxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcclxufTtcclxuXHJcbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxyXG52YXIgRE9DX0ZSQUdNRU5UX1RZUEUgPSAxMTtcclxuXHJcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcclxuICAgIHZhciBvd25lciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xyXG4gICAgaWYgKG93bmVyKSB7XHJcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xyXG4gICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcclxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcGFpcnMgPSBbXTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XHJcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcclxuICB9XHJcbiAgLy8gRGlmZmVycyBmcm9tIEpTT04uc3RyaW5naWZ5IGluIHRoYXQgdW5kZWZpbmVkIGJlY2F1c2UgdW5kZWZpbmVkIGFuZCB0aGF0XHJcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcclxuICByZXR1cm4gU3RyaW5nKG9iaik7XHJcbn1cclxuXHJcbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcclxuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XHJcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XHJcbiAgdmFyIG93bmVyTmFtZTtcclxuICBpZiAob3duZXIpIHtcclxuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcclxuICB9XHJcblxyXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcclxuXHJcbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XHJcblxyXG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdm9pZCAwO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcclxuICBpZiAoIXByb3BzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAgaWYgKHZvaWRFbGVtZW50VGFnc1tjb21wb25lbnQuX3RhZ10pIHtcclxuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcclxuICB9XHJcbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcclxuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcclxuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBfcHJvZEludmFyaWFudCgnNjEnKSA6IHZvaWQgMDtcclxuICB9XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHZvaWQgMDtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XHJcbiAgfVxyXG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzYyJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdm9pZCAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnF1ZXVlUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIsIHRyYW5zYWN0aW9uKSB7XHJcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxyXG4gICAgLy8gYnViYmxlLlxyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdm9pZCAwO1xyXG4gIH1cclxuICB2YXIgY29udGFpbmVySW5mbyA9IGluc3QuX2hvc3RDb250YWluZXJJbmZvO1xyXG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xyXG4gIHZhciBkb2MgPSBpc0RvY3VtZW50RnJhZ21lbnQgPyBjb250YWluZXJJbmZvLl9ub2RlIDogY29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcclxuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xyXG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcclxuICAgIGluc3Q6IGluc3QsXHJcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxyXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xyXG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcclxuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xyXG4gIHZhciBpbnN0ID0gdGhpcztcclxuICBSZWFjdERPTUlucHV0LnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRleHRhcmVhUG9zdE1vdW50KCkge1xyXG4gIHZhciBpbnN0ID0gdGhpcztcclxuICBSZWFjdERPTVRleHRhcmVhLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wdGlvblBvc3RNb3VudCgpIHtcclxuICB2YXIgaW5zdCA9IHRoaXM7XHJcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcclxufVxyXG5cclxudmFyIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZW1wdHlGdW5jdGlvbjtcclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldiA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICB2YXIgaGFzRXhpc3RpbmdDb250ZW50ID0gdGhpcy5fY29udGVudERlYnVnSUQgIT0gbnVsbDtcclxuICAgIHZhciBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcclxuICAgIC8vIFRoaXMgSUQgcmVwcmVzZW50cyB0aGUgaW5saW5lZCBjaGlsZCB0aGF0IGhhcyBubyBiYWNraW5nIGluc3RhbmNlOlxyXG4gICAgdmFyIGNvbnRlbnREZWJ1Z0lEID0gLWRlYnVnSUQ7XHJcblxyXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xyXG4gICAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudCh0aGlzLl9jb250ZW50RGVidWdJRCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBudWxsO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIFN0cmluZyhjb250ZW50KSwgdGhpcywgdGhpcy5fYW5jZXN0b3JJbmZvKTtcclxuICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gY29udGVudERlYnVnSUQ7XHJcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCk7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCwgZGVidWdJRCk7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcclxuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XHJcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcclxudmFyIG1lZGlhRXZlbnRzID0ge1xyXG4gIHRvcEFib3J0OiAnYWJvcnQnLFxyXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcclxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcclxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcclxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXHJcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcclxuICB0b3BFbmRlZDogJ2VuZGVkJyxcclxuICB0b3BFcnJvcjogJ2Vycm9yJyxcclxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXHJcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXHJcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcclxuICB0b3BQYXVzZTogJ3BhdXNlJyxcclxuICB0b3BQbGF5OiAncGxheScsXHJcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxyXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxyXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcclxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxyXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcclxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXHJcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxyXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcclxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxyXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcclxuICB2YXIgaW5zdCA9IHRoaXM7XHJcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXHJcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXHJcbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBfcHJvZEludmFyaWFudCgnNjMnKSA6IHZvaWQgMDtcclxuICB2YXIgbm9kZSA9IGdldE5vZGUoaW5zdCk7XHJcbiAgIW5vZGUgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzY0JykgOiB2b2lkIDA7XHJcblxyXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XHJcbiAgICBjYXNlICdpZnJhbWUnOlxyXG4gICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ3ZpZGVvJzpcclxuICAgIGNhc2UgJ2F1ZGlvJzpcclxuXHJcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XHJcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XHJcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xyXG4gICAgICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycy5wdXNoKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIG5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpXTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdpbWcnOlxyXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2Zvcm0nOlxyXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIG5vZGUpXTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdpbnB1dCc6XHJcbiAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBub2RlKV07XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIoKSB7XHJcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XHJcbn1cclxuXHJcbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxyXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cclxuXHJcbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xyXG4gICdhcmVhJzogdHJ1ZSxcclxuICAnYmFzZSc6IHRydWUsXHJcbiAgJ2JyJzogdHJ1ZSxcclxuICAnY29sJzogdHJ1ZSxcclxuICAnZW1iZWQnOiB0cnVlLFxyXG4gICdocic6IHRydWUsXHJcbiAgJ2ltZyc6IHRydWUsXHJcbiAgJ2lucHV0JzogdHJ1ZSxcclxuICAna2V5Z2VuJzogdHJ1ZSxcclxuICAnbGluayc6IHRydWUsXHJcbiAgJ21ldGEnOiB0cnVlLFxyXG4gICdwYXJhbSc6IHRydWUsXHJcbiAgJ3NvdXJjZSc6IHRydWUsXHJcbiAgJ3RyYWNrJzogdHJ1ZSxcclxuICAnd2JyJzogdHJ1ZVxyXG59O1xyXG5cclxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xyXG4gICdsaXN0aW5nJzogdHJ1ZSxcclxuICAncHJlJzogdHJ1ZSxcclxuICAndGV4dGFyZWEnOiB0cnVlXHJcbn07XHJcblxyXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXHJcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cclxuXHJcbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcclxuICAnbWVudWl0ZW0nOiB0cnVlXHJcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xyXG5cclxuLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxyXG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cclxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxyXG5cclxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxyXG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcclxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcclxuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcclxuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBfcHJvZEludmFyaWFudCgnNjUnLCB0YWcpIDogdm9pZCAwO1xyXG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xyXG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XHJcbn1cclxuXHJcbnZhciBnbG9iYWxJZENvdW50ZXIgPSAxO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXHJcbiAqIHZhbGlkIGFjY29yZGluZyB0byBgRE9NUHJvcGVydHlgLlxyXG4gKlxyXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxyXG4gKiAgLSBET00gcHJvcGVydGllczogYGNsYXNzTmFtZWAsIGBuYW1lYCwgYHRpdGxlYCwgZXRjLlxyXG4gKlxyXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxyXG4gKiBvYmplY3QgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XHJcbiAqIEBleHRlbmRzIFJlYWN0TXVsdGlDaGlsZFxyXG4gKi9cclxuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQoZWxlbWVudCkge1xyXG4gIHZhciB0YWcgPSBlbGVtZW50LnR5cGU7XHJcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcclxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgdGhpcy5fdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XHJcbiAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbnVsbDtcclxuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcclxuICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbnVsbDtcclxuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XHJcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xyXG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xyXG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xyXG4gIHRoaXMuX2RvbUlEID0gMDtcclxuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XHJcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcclxuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xyXG4gIHRoaXMuX2ZsYWdzID0gMDtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gbnVsbDtcclxuICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XHJcbiAgfVxyXG59XHJcblxyXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XHJcblxyXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxyXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHs/UmVhY3RET01Db21wb25lbnR9IHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcHV0ZWQgbWFya3VwLlxyXG4gICAqL1xyXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gZ2xvYmFsSWRDb3VudGVyKys7XHJcbiAgICB0aGlzLl9kb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcclxuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xyXG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcclxuXHJcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xyXG4gICAgICBjYXNlICdhdWRpbyc6XHJcbiAgICAgIGNhc2UgJ2Zvcm0nOlxyXG4gICAgICBjYXNlICdpZnJhbWUnOlxyXG4gICAgICBjYXNlICdpbWcnOlxyXG4gICAgICBjYXNlICdsaW5rJzpcclxuICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgY2FzZSAndmlkZW8nOlxyXG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcclxuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnaW5wdXQnOlxyXG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcclxuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdvcHRpb24nOlxyXG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XHJcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgIFJlYWN0RE9NU2VsZWN0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XHJcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XHJcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcclxuXHJcbiAgICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXHJcbiAgICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXHJcbiAgICB2YXIgbmFtZXNwYWNlVVJJO1xyXG4gICAgdmFyIHBhcmVudFRhZztcclxuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcclxuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdFBhcmVudC5fbmFtZXNwYWNlVVJJO1xyXG4gICAgICBwYXJlbnRUYWcgPSBob3N0UGFyZW50Ll90YWc7XHJcbiAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcclxuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdENvbnRhaW5lckluZm8uX25hbWVzcGFjZVVSSTtcclxuICAgICAgcGFyZW50VGFnID0gaG9zdENvbnRhaW5lckluZm8uX3RhZztcclxuICAgIH1cclxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCBuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmIHBhcmVudFRhZyA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XHJcbiAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuaHRtbDtcclxuICAgIH1cclxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xyXG4gICAgICBpZiAodGhpcy5fdGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuc3ZnO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RhZyA9PT0gJ21hdGgnKSB7XHJcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5tYXRobWw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX25hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgcGFyZW50SW5mbztcclxuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XHJcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xyXG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XHJcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXHJcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xyXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0aGlzLl90YWcsIG51bGwsIHRoaXMsIHBhcmVudEluZm8pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1vdW50SW1hZ2U7XHJcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xyXG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xyXG4gICAgICB2YXIgZWw7XHJcbiAgICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzY3JpcHQnKSB7XHJcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXHJcbiAgICAgICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxyXG4gICAgICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XHJcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwnICsgdHlwZSArICc+PC8nICsgdHlwZSArICc+JztcclxuICAgICAgICAgIGVsID0gZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmlzKSB7XHJcbiAgICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlLCBwcm9wcy5pcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjdWFzZSBvZiBhIEZpcmVmb3ggYnVnLlxyXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxyXG4gICAgICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxyXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcclxuICAgICAgfVxyXG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIGVsKTtcclxuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcclxuICAgICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XHJcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvclJvb3QoZWwpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobnVsbCwgcHJvcHMsIHRyYW5zYWN0aW9uKTtcclxuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUoZWwpO1xyXG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSk7XHJcbiAgICAgIG1vdW50SW1hZ2UgPSBsYXp5VHJlZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xyXG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcclxuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xyXG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XHJcbiAgICAgIGNhc2UgJ2lucHV0JzpcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGlucHV0UG9zdE1vdW50LCB0aGlzKTtcclxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRleHRhcmVhUG9zdE1vdW50LCB0aGlzKTtcclxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XHJcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnb3B0aW9uJzpcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxyXG4gICAqXHJcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxyXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXHJcbiAgICovXHJcbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcclxuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG5cclxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcclxuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcclxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XHJcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xyXG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcclxuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcclxuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWFya3VwID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcclxuICAgICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcclxuICAgICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hcmt1cCkge1xyXG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcclxuICAgIC8vIGJ5dGVzLlxyXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XHJcbiAgICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUm9vdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9kb21JRCk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXHJcbiAgICovXHJcbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpIHtcclxuICAgIHZhciByZXQgPSAnJztcclxuXHJcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cclxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcclxuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xyXG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcclxuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcclxuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcclxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcclxuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xyXG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcclxuICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXHJcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XHJcbiAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcclxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cclxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XHJcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxyXG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXHJcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxyXG4gICAgICByZXR1cm4gJ1xcbicgKyByZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF9jcmVhdGVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKSB7XHJcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cclxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcclxuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xyXG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XHJcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVIVE1MKGxhenlUcmVlLCBpbm5lckhUTUwuX19odG1sKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcclxuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcclxuICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcclxuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcclxuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIHRleHQgYXJlYSB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcclxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgdGV4dGFyZWEgdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xyXG4gICAgICAgIGlmIChjb250ZW50VG9Vc2UgIT09ICcnKSB7XHJcbiAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBET01MYXp5VHJlZS5xdWV1ZVRleHQobGF6eVRyZWUsIGNvbnRlbnRUb1VzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgbW91bnRJbWFnZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY2VpdmVzIGEgbmV4dCBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxyXG4gICAqL1xyXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcclxuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xyXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcclxuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgYSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxyXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XHJcbiAgICogQGludGVybmFsXHJcbiAgICogQG92ZXJyaWRhYmxlXHJcbiAgICovXHJcbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xyXG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xyXG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xyXG5cclxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XHJcbiAgICAgIGNhc2UgJ2lucHV0JzpcclxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xyXG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ29wdGlvbic6XHJcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XHJcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XHJcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XHJcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xyXG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xyXG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xyXG4gICAgdGhpcy5fdXBkYXRlRE9NQ2hpbGRyZW4obGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xyXG4gICAgICBjYXNlICdpbnB1dCc6XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cclxuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXHJcbiAgICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxyXG4gICAgICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cclxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxyXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcclxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcclxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXHJcbiAgICpcclxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XHJcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cclxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXHJcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cclxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xyXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcclxuICAgKi9cclxuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbikge1xyXG4gICAgdmFyIHByb3BLZXk7XHJcbiAgICB2YXIgc3R5bGVOYW1lO1xyXG4gICAgdmFyIHN0eWxlVXBkYXRlcztcclxuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcclxuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XHJcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xyXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xyXG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcclxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XHJcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xyXG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcclxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcclxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIGxhc3RQcm9wcykpIHtcclxuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XHJcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcclxuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xyXG4gICAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XHJcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcclxuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xyXG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG5leHRQcm9wO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdFByb3ApIHtcclxuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cclxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xyXG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXHJcbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xyXG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xyXG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cclxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xyXG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xyXG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIG5leHRQcm9wLCB0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xyXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbmV4dFByb3BzKSkge1xyXG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcclxuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShnZXROb2RlKHRoaXMpLCBwcm9wS2V5LCBuZXh0UHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IGdldE5vZGUodGhpcyk7XHJcbiAgICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcclxuICAgICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXHJcbiAgICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcclxuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XHJcbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhnZXROb2RlKHRoaXMpLCBzdHlsZVVwZGF0ZXMsIHRoaXMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcclxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcclxuICAgKi9cclxuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcclxuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xyXG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XHJcblxyXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XHJcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcclxuXHJcbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xyXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xyXG5cclxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcclxuICAgIC8vIHRoZSBvbGQgY29udGVudFxyXG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xyXG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xyXG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcclxuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcclxuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbmV4dENvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XHJcbiAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gIT0gbnVsbCkge1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxyXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xyXG4gICAgICBjYXNlICdhdWRpbyc6XHJcbiAgICAgIGNhc2UgJ2Zvcm0nOlxyXG4gICAgICBjYXNlICdpZnJhbWUnOlxyXG4gICAgICBjYXNlICdpbWcnOlxyXG4gICAgICBjYXNlICdsaW5rJzpcclxuICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgY2FzZSAndmlkZW8nOlxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2h0bWwnOlxyXG4gICAgICBjYXNlICdoZWFkJzpcclxuICAgICAgY2FzZSAnYm9keSc6XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXHJcbiAgICAgICAgICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXHJcbiAgICAgICAgICogdGFrZSBhZHZhbnRhZ2Ugb2YgUmVhY3QncyByZWNvbmNpbGlhdGlvbiBmb3Igc3R5bGluZyBhbmQgPHRpdGxlPlxyXG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPCVzPiB0cmllZCB0byB1bm1vdW50LiBCZWNhdXNlIG9mIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGl0IGlzIGltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhIHNpbmdsZSB0b3AtbGV2ZWwgY29tcG9uZW50IHRoYXQgbmV2ZXIgdW5tb3VudHMgcmVuZGVyIHRoZXNlIGVsZW1lbnRzLicsIHRoaXMuX3RhZykgOiBfcHJvZEludmFyaWFudCgnNjYnLCB0aGlzLl90YWcpIDogdm9pZCAwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XHJcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XHJcbiAgICBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnModGhpcyk7XHJcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcclxuICAgIHRoaXMuX2RvbUlEID0gMDtcclxuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBudWxsKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbl9hc3NpZ24oUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbiwgUmVhY3RNdWx0aUNoaWxkLk1peGluKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSB7XHJcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcclxudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcclxuXHJcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGdpdmVuIG5vZGUgc2hvdWxkIGJlIGNhY2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHNob3VsZFByZWNhY2hlTm9kZShub2RlLCBub2RlSUQpIHtcclxuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpID09PSBTdHJpbmcobm9kZUlEKSB8fCBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LXRleHQ6ICcgKyBub2RlSUQgKyAnICcgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIG5vZGVJRCArICcgJztcclxufVxyXG5cclxuLyoqXHJcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxyXG4gKiBob3N0IHRleHQgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxyXG4gKiBmb3IgYF9yZW5kZXJlZENoaWxkcmVuYC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgdmFyIHJlbmRlcmVkO1xyXG4gIHdoaWxlIChyZW5kZXJlZCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQpIHtcclxuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xyXG4gIH1cclxuICByZXR1cm4gY29tcG9uZW50O1xyXG59XHJcblxyXG4vKipcclxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cclxuICogRE9NIG5vZGUuIFRoZSBwYXNzZWQgYGluc3RgIGNhbiBiZSBhIGNvbXBvc2l0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XHJcbiAgdmFyIGhvc3RJbnN0ID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChpbnN0KTtcclxuICBob3N0SW5zdC5faG9zdE5vZGUgPSBub2RlO1xyXG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xyXG4gIHZhciBub2RlID0gaW5zdC5faG9zdE5vZGU7XHJcbiAgaWYgKG5vZGUpIHtcclxuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xyXG4gICAgaW5zdC5faG9zdE5vZGUgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxyXG4gKiBtYXRjaCB1cCB3aXRoIHRoZSBET00gKGVsZW1lbnQpIGNoaWxkcmVuIG9mIGBub2RlYC5cclxuICpcclxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcclxuICogY2hpbGRyZW4gb2YgYSBub2RlIHNlcXVlbnRpYWxseSBhbmQgaGF2ZSB0byB3YWxrIGZyb20gdGhlIHN0YXJ0IHRvIG91ciB0YXJnZXRcclxuICogbm9kZSBldmVyeSB0aW1lLlxyXG4gKlxyXG4gKiBTaW5jZSB3ZSB1cGRhdGUgYF9yZW5kZXJlZENoaWxkcmVuYCBhbmQgdGhlIGFjdHVhbCBET00gYXQgKHNsaWdodGx5KVxyXG4gKiBkaWZmZXJlbnQgdGltZXMsIHdlIGNvdWxkIHJhY2UgaGVyZSBhbmQgc2VlIGEgbmV3ZXIgYF9yZW5kZXJlZENoaWxkcmVuYCB0aGFuXHJcbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcclxuICogYHByZXBhcmVUb01hbmFnZUNoaWxkcmVuYCBiZWZvcmUgd2UgY2hhbmdlIGBfcmVuZGVyZWRDaGlsZHJlbmAsIGF0IHdoaWNoXHJcbiAqIHRpbWUgdGhlIGNvbnRhaW5lcidzIGNoaWxkIG5vZGVzIGFyZSBhbHdheXMgY2FjaGVkICh1bnRpbCBpdCB1bm1vdW50cykuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSkge1xyXG4gIGlmIChpbnN0Ll9mbGFncyAmIEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIGNoaWxkcmVuID0gaW5zdC5fcmVuZGVyZWRDaGlsZHJlbjtcclxuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xyXG4gIG91dGVyOiBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XHJcbiAgICBpZiAoIWNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoaWxkSW5zdCA9IGNoaWxkcmVuW25hbWVdO1xyXG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xyXG4gICAgaWYgKGNoaWxkSUQgPT09IDApIHtcclxuICAgICAgLy8gV2UncmUgY3VycmVudGx5IHVubW91bnRpbmcgdGhpcyBjaGlsZCBpbiBSZWFjdE11bHRpQ2hpbGQ7IHNraXAgaXQuXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgYXNzdW1lIHRoZSBjaGlsZCBub2RlcyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNoaWxkIGluc3RhbmNlcy5cclxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xyXG4gICAgICBpZiAoc2hvdWxkUHJlY2FjaGVOb2RlKGNoaWxkTm9kZSwgY2hpbGRJRCkpIHtcclxuICAgICAgICBwcmVjYWNoZU5vZGUoY2hpbGRJbnN0LCBjaGlsZE5vZGUpO1xyXG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIERPTSBjaGlsZHJlbiB3aXRob3V0IGZpbmRpbmcgYW4gSUQgbWF0Y2guXHJcbiAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpIDogX3Byb2RJbnZhcmlhbnQoJzMyJywgY2hpbGRJRCkgOiB2b2lkIDA7XHJcbiAgfVxyXG4gIGluc3QuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xyXG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XHJcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcclxuICB9XHJcblxyXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cclxuICB2YXIgcGFyZW50cyA9IFtdO1xyXG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xyXG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xyXG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXHJcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBjbG9zZXN0O1xyXG4gIHZhciBpbnN0O1xyXG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XHJcbiAgICBjbG9zZXN0ID0gaW5zdDtcclxuICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xyXG4gICAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2xvc2VzdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XHJcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xyXG4gIHZhciBpbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XHJcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xyXG4gICAgcmV0dXJuIGluc3Q7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcclxuICogRE9NIG5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcclxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcclxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cclxuICAhKGluc3QuX2hvc3ROb2RlICE9PSB1bmRlZmluZWQpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcclxuXHJcbiAgaWYgKGluc3QuX2hvc3ROb2RlKSB7XHJcbiAgICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XHJcbiAgfVxyXG5cclxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgRE9NIG5vZGUgd2UgaGF2ZSBjYWNoZWQuXHJcbiAgdmFyIHBhcmVudHMgPSBbXTtcclxuICB3aGlsZSAoIWluc3QuX2hvc3ROb2RlKSB7XHJcbiAgICBwYXJlbnRzLnB1c2goaW5zdCk7XHJcbiAgICAhaW5zdC5faG9zdFBhcmVudCA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBET00gdHJlZSByb290IHNob3VsZCBhbHdheXMgaGF2ZSBhIG5vZGUgcmVmZXJlbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzM0JykgOiB2b2lkIDA7XHJcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcclxuICB9XHJcblxyXG4gIC8vIE5vdyBwYXJlbnRzIGNvbnRhaW5zIGVhY2ggYW5jZXN0b3IgdGhhdCBkb2VzICpub3QqIGhhdmUgYSBjYWNoZWQgbmF0aXZlXHJcbiAgLy8gbm9kZSwgYW5kIGBpbnN0YCBpcyB0aGUgZGVlcGVzdCBhbmNlc3RvciB0aGF0IGRvZXMuXHJcbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xyXG4gICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIGluc3QuX2hvc3ROb2RlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcclxufVxyXG5cclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHtcclxuICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXHJcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcclxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlLFxyXG4gIHByZWNhY2hlQ2hpbGROb2RlczogcHJlY2FjaGVDaGlsZE5vZGVzLFxyXG4gIHByZWNhY2hlTm9kZTogcHJlY2FjaGVOb2RlLFxyXG4gIHVuY2FjaGVOb2RlOiB1bmNhY2hlTm9kZVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XHJcblxyXG52YXIgRE9DX05PREVfVFlQRSA9IDk7XHJcblxyXG5mdW5jdGlvbiBSZWFjdERPTUNvbnRhaW5lckluZm8odG9wTGV2ZWxXcmFwcGVyLCBub2RlKSB7XHJcbiAgdmFyIGluZm8gPSB7XHJcbiAgICBfdG9wTGV2ZWxXcmFwcGVyOiB0b3BMZXZlbFdyYXBwZXIsXHJcbiAgICBfaWRDb3VudGVyOiAxLFxyXG4gICAgX293bmVyRG9jdW1lbnQ6IG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFID8gbm9kZSA6IG5vZGUub3duZXJEb2N1bWVudCA6IG51bGwsXHJcbiAgICBfbm9kZTogbm9kZSxcclxuICAgIF90YWc6IG5vZGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsLFxyXG4gICAgX25hbWVzcGFjZVVSSTogbm9kZSA/IG5vZGUubmFtZXNwYWNlVVJJIDogbnVsbFxyXG4gIH07XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGluZm8uX2FuY2VzdG9ySW5mbyA9IG5vZGUgPyB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCBpbmZvLl90YWcsIG51bGwpIDogbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGluZm87XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db250YWluZXJJbmZvOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxuXHJcbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XHJcbiAgLy8gUmVhY3RDb21wb3NpdGVDb21wb25lbnQgdXNlcyB0aGlzOlxyXG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcclxuICAvLyBSZWFjdERPTUNvbXBvbmVudFRyZWUgdXNlcyB0aGVzZTpcclxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XHJcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XHJcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xyXG4gIHRoaXMuX2RvbUlEID0gMDtcclxufTtcclxuX2Fzc2lnbihSZWFjdERPTUVtcHR5Q29tcG9uZW50LnByb3RvdHlwZSwge1xyXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XHJcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xyXG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XHJcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xyXG5cclxuICAgIHZhciBub2RlVmFsdWUgPSAnIHJlYWN0LWVtcHR5OiAnICsgdGhpcy5fZG9tSUQgKyAnICc7XHJcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xyXG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xyXG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xyXG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIG5vZGUpO1xyXG4gICAgICByZXR1cm4gRE9NTGF6eVRyZWUobm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcclxuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIGluc2VydCBhIGNvbW1lbnQgbm9kZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb25cclxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXHJcbiAgICAgICAgLy8gbm90aGluZy5cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICc8IS0tJyArIG5vZGVWYWx1ZSArICctLT4nO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXHJcbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcclxuICB9LFxyXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcclxuICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUVtcHR5Q29tcG9uZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcclxuICB1c2VDcmVhdGVFbGVtZW50OiB0cnVlLFxyXG4gIHVzZUZpYmVyOiBmYWxzZVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFnczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcblxyXG4vKipcclxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXHJcbiAqL1xyXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50SW5zdCwgdXBkYXRlcykge1xyXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShwYXJlbnRJbnN0KTtcclxuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyhub2RlLCB1cGRhdGVzKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXHJcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XHJcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xyXG52YXIgZGlkV2FybkNoZWNrZWRMaW5rID0gZmFsc2U7XHJcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcclxudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcclxudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcclxudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xyXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XHJcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxyXG4gICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XHJcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xyXG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxyXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXHJcbiAqXHJcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXHJcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XHJcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxyXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxyXG4gKlxyXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcclxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxyXG4gKi9cclxudmFyIFJlYWN0RE9NSW5wdXQgPSB7XHJcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcclxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xyXG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQocHJvcHMpO1xyXG5cclxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcclxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXHJcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcclxuICAgICAgdHlwZTogdW5kZWZpbmVkLFxyXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxyXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcclxuICAgICAgc3RlcDogdW5kZWZpbmVkLFxyXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxyXG4gICAgICBtaW46IHVuZGVmaW5lZCxcclxuICAgICAgbWF4OiB1bmRlZmluZWRcclxuICAgIH0sIHByb3BzLCB7XHJcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXHJcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcclxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcclxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcclxuICB9LFxyXG5cclxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcclxuXHJcbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuXHJcbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XHJcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYGNoZWNrZWRMaW5rYCBwcm9wIG9uIGBpbnB1dGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcclxuICAgICAgICBkaWRXYXJuQ2hlY2tlZExpbmsgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcclxuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcclxuICAgICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcclxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcclxuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcclxuICAgICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXHJcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcclxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcclxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcclxuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xyXG5cclxuICAgICAgaWYgKCFpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcclxuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cclxuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcclxuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcclxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCksICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuXHJcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXHJcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cclxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcclxuXHJcbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXHJcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xyXG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxyXG4gICAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcclxuICAgICAgICAvLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcclxuICAgICAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcclxuICAgICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcclxuICAgICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuXHJcbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XHJcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cclxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XHJcblxyXG4gICAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXHJcbiAgICAvLyBzdWJtaXQgb3IgcmVzZXQgaW5wdXRzIGFzIHRob3NlIHZhbHVlcyAmIGRlZmF1bHRWYWx1ZXMgYXJlIGxpbmtlZC4gVGhleVxyXG4gICAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XHJcbiAgICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcclxuICAgIC8vIHByb3ZpZGVkLlxyXG5cclxuICAgIHN3aXRjaCAocHJvcHMudHlwZSkge1xyXG4gICAgICBjYXNlICdzdWJtaXQnOlxyXG4gICAgICBjYXNlICdyZXNldCc6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2NvbG9yJzpcclxuICAgICAgY2FzZSAnZGF0ZSc6XHJcbiAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcclxuICAgICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxyXG4gICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgIGNhc2UgJ3RpbWUnOlxyXG4gICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xyXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJztcclxuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcclxuICAgIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXHJcbiAgICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXHJcbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxyXG4gICAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cclxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xyXG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XHJcbiAgICAgIG5vZGUubmFtZSA9ICcnO1xyXG4gICAgfVxyXG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xyXG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xyXG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XHJcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xyXG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xyXG5cclxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xyXG5cclxuICAvLyBIZXJlIHdlIHVzZSBhc2FwIHRvIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaFxyXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxyXG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcclxuXHJcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xyXG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xyXG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XHJcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XHJcblxyXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcclxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXHJcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXHJcbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxyXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxyXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxyXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcclxuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XHJcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxyXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcclxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cclxuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvdGhlck5vZGUpO1xyXG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MCcpIDogdm9pZCAwO1xyXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcclxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcclxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXHJcbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xyXG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgZGVidWdJRCkge1xyXG4gIGlmICh3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcclxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xyXG5cclxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxyXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxyXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XHJcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cclxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xyXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHMoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcclxuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eShlbGVtZW50LnR5cGUsIGtleSwgZGVidWdJRCk7XHJcbiAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcclxuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xyXG4gIH0pLmpvaW4oJywgJyk7XHJcblxyXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XHJcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyhkZWJ1Z0lELCBlbGVtZW50KTtcclxufVxyXG5cclxudmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0ge1xyXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnZhbGlkQVJJQUhvb2s7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XHJcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoZWxlbWVudC50eXBlICE9PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSAhPT0gJ3RleHRhcmVhJyAmJiBlbGVtZW50LnR5cGUgIT09ICdzZWxlY3QnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChlbGVtZW50LnByb3BzICE9IG51bGwgJiYgZWxlbWVudC5wcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgdGhlIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcclxuXHJcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSB7XHJcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XHJcbiAgfSxcclxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2s7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcclxuXHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XHJcbiAgdmFyIGNvbnRlbnQgPSAnJztcclxuXHJcbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XHJcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cclxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgY29udGVudCArPSBjaGlsZDtcclxuICAgIH0gZWxzZSBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4pIHtcclxuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJykgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBjb250ZW50O1xyXG59XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXHJcbiAqL1xyXG52YXIgUmVhY3RET01PcHRpb24gPSB7XHJcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcclxuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXHJcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSBudWxsO1xyXG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xyXG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcclxuXHJcbiAgICAgIGlmIChzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ29wdGdyb3VwJykge1xyXG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgIHNlbGVjdFZhbHVlID0gUmVhY3RET01TZWxlY3QuZ2V0U2VsZWN0VmFsdWVDb250ZXh0KHNlbGVjdFBhcmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXHJcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxyXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcclxuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlICsgJyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xyXG4gICAgICAgIC8vIG11bHRpcGxlXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7IHNlbGVjdGVkOiBzZWxlY3RlZCB9O1xyXG4gIH0sXHJcblxyXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcclxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xyXG4gICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XHJcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xyXG5cclxuICAgIC8vIFJlYWQgc3RhdGUgb25seSBmcm9tIGluaXRpYWwgbW91bnQgYmVjYXVzZSA8c2VsZWN0PiB1cGRhdGVzIHZhbHVlXHJcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXHJcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcclxuICAgICAgaG9zdFByb3BzLnNlbGVjdGVkID0gaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcclxuXHJcbiAgICBpZiAoY29udGVudCkge1xyXG4gICAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBob3N0UHJvcHM7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcblxyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XHJcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xyXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XHJcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xyXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XHJcblxyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XHJcbiAgaWYgKG93bmVyKSB7XHJcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAnJztcclxufVxyXG5cclxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XHJcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xyXG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XHJcblxyXG4gIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBzZWxlY3RgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XHJcbiAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xyXG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XHJcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XHJcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcclxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcclxuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcclxuICB2YXIgb3B0aW9ucyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLm9wdGlvbnM7XHJcblxyXG4gIGlmIChtdWx0aXBsZSkge1xyXG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xyXG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcclxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXHJcbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXHJcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcclxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxyXG4gKlxyXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXHJcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cclxuICpcclxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxyXG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXHJcbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXHJcbiAqXHJcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxyXG4gKiBzZWxlY3RlZC5cclxuICovXHJcbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcclxuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xyXG4gICAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXHJcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XHJcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XHJcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxyXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcclxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxyXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxyXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XHJcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0U2VsZWN0VmFsdWVDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgLy8gUmVhY3RET01PcHRpb24gbG9va3MgYXQgdGhpcyBpbml0aWFsIHZhbHVlIHNvIHRoZSBpbml0aWFsIGdlbmVyYXRlZFxyXG4gICAgLy8gbWFya3VwIGhhcyBjb3JyZWN0IGBzZWxlY3RlZGAgYXR0cmlidXRlc1xyXG4gICAgcmV0dXJuIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuXHJcbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcclxuICAgIC8vIHRoaXMgdmFsdWUgZG93blxyXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XHJcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcclxuXHJcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XHJcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cclxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXHJcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcclxuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xyXG5cclxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xyXG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xyXG4gIH1cclxuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XHJcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG52YXIgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCA9IHJlcXVpcmUoJy4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCcpO1xyXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xyXG5cclxuLyoqXHJcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxyXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxyXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xyXG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXHJcbiAqXHJcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxyXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xyXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXHJcbiAqXHJcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxyXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcclxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcclxuICogQHJldHVybiB7b2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcclxuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xyXG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XHJcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcclxuXHJcbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxyXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xyXG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcclxuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcclxuXHJcbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xyXG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxyXG4gICAgZW5kOiBlbmRPZmZzZXRcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAqIEByZXR1cm4gez9vYmplY3R9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcclxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcblxyXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XHJcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XHJcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XHJcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xyXG5cclxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XHJcblxyXG4gIC8vIEluIEZpcmVmb3gsIHJhbmdlLnN0YXJ0Q29udGFpbmVyIGFuZCByYW5nZS5lbmRDb250YWluZXIgY2FuIGJlIFwiYW5vbnltb3VzXHJcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xyXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXHJcbiAgLy8gZXJyb3JcIiBpZiBhbnkgb2YgaXRzIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGVcclxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXHJcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcclxuICB0cnkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXHJcbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGU7XHJcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXHJcbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcclxuICAvLyB0aGlzIHZhbHVlIHdyb25nLlxyXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xyXG5cclxuICB2YXIgcmFuZ2VMZW5ndGggPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCA/IDAgOiBjdXJyZW50UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XHJcblxyXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xyXG4gIHRlbXBSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XHJcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XHJcblxyXG4gIHZhciBpc1RlbXBSYW5nZUNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHRlbXBSYW5nZS5zdGFydENvbnRhaW5lciwgdGVtcFJhbmdlLnN0YXJ0T2Zmc2V0LCB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLCB0ZW1wUmFuZ2UuZW5kT2Zmc2V0KTtcclxuXHJcbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xyXG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xyXG5cclxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxyXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcclxuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XHJcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxyXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xyXG4gIHZhciBzdGFydCwgZW5kO1xyXG5cclxuICBpZiAob2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xyXG4gICAgZW5kID0gc3RhcnQ7XHJcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcclxuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XHJcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XHJcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcclxuICB9XHJcblxyXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xyXG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xyXG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xyXG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcclxuICByYW5nZS5zZWxlY3QoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcclxuICogc2VsZWN0aW9ucy5cclxuICpcclxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XHJcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXHJcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXHJcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcclxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcclxuICovXHJcbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xyXG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcclxuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcclxuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xyXG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcclxuXHJcbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxyXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxyXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xyXG4gICAgdmFyIHRlbXAgPSBlbmQ7XHJcbiAgICBlbmQgPSBzdGFydDtcclxuICAgIHN0YXJ0ID0gdGVtcDtcclxuICB9XHJcblxyXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xyXG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XHJcblxyXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcclxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xyXG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xyXG5cclxuICAgIGlmIChzdGFydCA+IGVuZCkge1xyXG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XHJcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcclxuXHJcbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcclxuICAgKi9cclxuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xyXG4gICAqL1xyXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcclxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcclxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxuXHJcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xyXG5cclxuLyoqXHJcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XHJcbiAqXHJcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cclxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxyXG4gKlxyXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgc28gdGhhdCB0aGV5XHJcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cclxuICpcclxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXHJcbiAqXHJcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcclxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XHJcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xyXG4gIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XHJcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XHJcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xyXG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xyXG5cclxuICAvLyBQcm9wZXJ0aWVzXHJcbiAgdGhpcy5fZG9tSUQgPSAwO1xyXG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xyXG4gIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcclxuICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xyXG59O1xyXG5cclxuX2Fzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxyXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgcGFyZW50SW5mbztcclxuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XHJcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8gIT0gbnVsbCkge1xyXG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XHJcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXHJcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xyXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0aGlzLl9zdHJpbmdUZXh0LCB0aGlzLCBwYXJlbnRJbmZvKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcclxuICAgIHZhciBvcGVuaW5nVmFsdWUgPSAnIHJlYWN0LXRleHQ6ICcgKyBkb21JRCArICcgJztcclxuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XHJcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xyXG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XHJcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xyXG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xyXG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQob3BlbmluZ1ZhbHVlKTtcclxuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XHJcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcclxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3BlbmluZ0NvbW1lbnQpKTtcclxuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcclxuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX3N0cmluZ1RleHQpKSk7XHJcbiAgICAgIH1cclxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcclxuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBvcGVuaW5nQ29tbWVudCk7XHJcbiAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gY2xvc2luZ0NvbW1lbnQ7XHJcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBlc2NhcGVkVGV4dCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0aGlzLl9zdHJpbmdUZXh0KTtcclxuXHJcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xyXG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgd3JhcCB0aGlzIGJldHdlZW4gY29tbWVudCBub2RlcyBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkXHJcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxyXG4gICAgICAgIC8vIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cclxuICAgICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAnPCEtLScgKyBvcGVuaW5nVmFsdWUgKyAnLS0+JyArIGVzY2FwZWRUZXh0ICsgJzwhLS0nICsgY2xvc2luZ1ZhbHVlICsgJy0tPic7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XHJcbiAgICBpZiAobmV4dFRleHQgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XHJcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XHJcbiAgICAgIGlmIChuZXh0U3RyaW5nVGV4dCAhPT0gdGhpcy5fc3RyaW5nVGV4dCkge1xyXG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XHJcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxyXG4gICAgICAgIC8vIG90aGVyIGNvbXBvbmVudCB0eXBlcz9cclxuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XHJcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlcyA9IHRoaXMuZ2V0SG9zdE5vZGUoKTtcclxuICAgICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucmVwbGFjZURlbGltaXRlZFRleHQoY29tbWVudE5vZGVzWzBdLCBjb21tZW50Tm9kZXNbMV0sIG5leHRTdHJpbmdUZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaG9zdE5vZGUgPSB0aGlzLl9jb21tZW50Tm9kZXM7XHJcbiAgICBpZiAoaG9zdE5vZGUpIHtcclxuICAgICAgcmV0dXJuIGhvc3ROb2RlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nQ29tbWVudCkge1xyXG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcclxuICAgICAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogX3Byb2RJbnZhcmlhbnQoJzY3JywgdGhpcy5fZG9tSUQpIDogdm9pZCAwO1xyXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIC9yZWFjdC10ZXh0ICcpIHtcclxuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaG9zdE5vZGUgPSBbdGhpcy5faG9zdE5vZGUsIHRoaXMuX2Nsb3NpbmdDb21tZW50XTtcclxuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IGhvc3ROb2RlO1xyXG4gICAgcmV0dXJuIGhvc3ROb2RlO1xyXG4gIH0sXHJcblxyXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcclxuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XHJcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxyXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xyXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xyXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XHJcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxyXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXHJcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXHJcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cclxuICpcclxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxyXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cclxuICpcclxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcclxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxyXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cclxuICpcclxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxyXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cclxuICovXHJcbnZhciBSZWFjdERPTVRleHRhcmVhID0ge1xyXG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XHJcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogX3Byb2RJbnZhcmlhbnQoJzkxJykgOiB2b2lkIDA7XHJcblxyXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcclxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxyXG4gICAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcclxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitCZW4gc2VlbWVkIHRvIGxpa2UgdGhpcyBzb2x1dGlvbi5cclxuICAgIC8vIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxyXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICBjaGlsZHJlbjogJycgKyBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxyXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaG9zdFByb3BzO1xyXG4gIH0sXHJcblxyXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xyXG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHRleHRhcmVhYCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xyXG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xyXG4gICAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xyXG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxyXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcclxuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzkyJykgOiB2b2lkIDA7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnOTMnKSA6IHZvaWQgMDtcclxuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xyXG4gICAgICB9XHJcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XHJcbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWUsXHJcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcclxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XHJcblxyXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcclxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxyXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xyXG5cclxuICAgICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcclxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XHJcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxyXG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXHJcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xyXG4gICAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcclxuXHJcbiAgICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxyXG4gICAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcclxuICAgIC8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cclxuICAgIGlmICh0ZXh0Q29udGVudCA9PT0gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xyXG4gICAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xyXG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xyXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XHJcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xyXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cclxuICogZGlmZmVyZW50IHRyZWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XHJcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xyXG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEIpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcclxuXHJcbiAgdmFyIGRlcHRoQSA9IDA7XHJcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gdGVtcEEuX2hvc3RQYXJlbnQpIHtcclxuICAgIGRlcHRoQSsrO1xyXG4gIH1cclxuICB2YXIgZGVwdGhCID0gMDtcclxuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xyXG4gICAgZGVwdGhCKys7XHJcbiAgfVxyXG5cclxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXHJcbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcclxuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XHJcbiAgICBkZXB0aEEtLTtcclxuICB9XHJcblxyXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cclxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xyXG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcclxuICAgIGRlcHRoQi0tO1xyXG4gIH1cclxuXHJcbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXHJcbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xyXG4gIHdoaWxlIChkZXB0aC0tKSB7XHJcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCKSB7XHJcbiAgICAgIHJldHVybiBpbnN0QTtcclxuICAgIH1cclxuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XHJcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xyXG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzQW5jZXN0b3I6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzUnKSA6IHZvaWQgMDtcclxuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XHJcblxyXG4gIHdoaWxlIChpbnN0Qikge1xyXG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XHJcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xyXG5cclxuICByZXR1cm4gaW5zdC5faG9zdFBhcmVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xyXG4gIHZhciBwYXRoID0gW107XHJcbiAgd2hpbGUgKGluc3QpIHtcclxuICAgIHBhdGgucHVzaChpbnN0KTtcclxuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xyXG4gIH1cclxuICB2YXIgaTtcclxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcclxuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XHJcbiAgfVxyXG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XHJcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cclxuICpcclxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXHJcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XHJcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xyXG4gIHZhciBwYXRoRnJvbSA9IFtdO1xyXG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xyXG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcclxuICAgIGZyb20gPSBmcm9tLl9ob3N0UGFyZW50O1xyXG4gIH1cclxuICB2YXIgcGF0aFRvID0gW107XHJcbiAgd2hpbGUgKHRvICYmIHRvICE9PSBjb21tb24pIHtcclxuICAgIHBhdGhUby5wdXNoKHRvKTtcclxuICAgIHRvID0gdG8uX2hvc3RQYXJlbnQ7XHJcbiAgfVxyXG4gIHZhciBpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xyXG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XHJcbiAgfVxyXG4gIGZvciAoaSA9IHBhdGhUby5sZW5ndGg7IGktLSA+IDA7KSB7XHJcbiAgICBmbihwYXRoVG9baV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGlzQW5jZXN0b3I6IGlzQW5jZXN0b3IsXHJcbiAgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3I6IGdldExvd2VzdENvbW1vbkFuY2VzdG9yLFxyXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcclxuICB0cmF2ZXJzZVR3b1BoYXNlOiB0cmF2ZXJzZVR3b1BoYXNlLFxyXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogdHJhdmVyc2VFbnRlckxlYXZlXHJcbn07IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xyXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xyXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XHJcblxyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XHJcbiAgICBjaGlsZHJlbjogdHJ1ZSxcclxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxyXG4gICAga2V5OiB0cnVlLFxyXG4gICAgcmVmOiB0cnVlLFxyXG5cclxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcclxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcclxuICAgIHZhbHVlTGluazogdHJ1ZSxcclxuICAgIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxyXG4gICAgY2hlY2tlZExpbms6IHRydWUsXHJcbiAgICBpbm5lckhUTUw6IHRydWUsXHJcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXHJcbiAgICBvbkZvY3VzSW46IHRydWUsXHJcbiAgICBvbkZvY3VzT3V0OiB0cnVlXHJcbiAgfTtcclxuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xyXG5cclxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XHJcbiAgICBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcclxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxyXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcclxuXHJcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcclxuXHJcbiAgICBpZiAoc3RhbmRhcmROYW1lICE9IG51bGwpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBndWVzcyB3aGljaCBwcm9wIHRoZSB1c2VyIGludGVuZGVkLlxyXG4gICAgICAvLyBJdCBpcyBsaWtlbHkgdGhhdCB0aGUgdXNlciB3YXMganVzdCBibGluZGx5IHNwcmVhZGluZy9mb3J3YXJkaW5nIHByb3BzXHJcbiAgICAgIC8vIENvbXBvbmVudHMgc2hvdWxkIGJlIGNhcmVmdWwgdG8gb25seSByZW5kZXIgdmFsaWQgcHJvcHMvYXR0cmlidXRlcy5cclxuICAgICAgLy8gV2FybmluZyB3aWxsIGJlIGludm9rZWQgaW4gd2FyblVua25vd25Qcm9wZXJ0aWVzIHRvIGFsbG93IGdyb3VwaW5nLlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XHJcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xyXG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XHJcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xyXG4gICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcclxuICB9KS5qb2luKCcsICcpO1xyXG5cclxuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3AgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGlzIHByb3AgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcclxuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcHMgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGVzZSBwcm9wcyBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyhkZWJ1Z0lELCBlbGVtZW50KTtcclxufVxyXG5cclxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHtcclxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcclxuICB9LFxyXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vazsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcclxudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaycpO1xyXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG52YXIgcGVyZm9ybWFuY2VOb3cgPSByZXF1aXJlKCdmYmpzL2xpYi9wZXJmb3JtYW5jZU5vdycpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBob29rcyA9IFtdO1xyXG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGNhbGxIb29rKGV2ZW50LCBmbiwgY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xyXG4gIHRyeSB7XHJcbiAgICBmbi5jYWxsKGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XHJcbiAgICBkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0gPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcclxuICAgIHZhciBmbiA9IGhvb2tbZXZlbnRdO1xyXG4gICAgaWYgKGZuKSB7XHJcbiAgICAgIGNhbGxIb29rKGV2ZW50LCBmbiwgaG9vaywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcclxudmFyIGZsdXNoSGlzdG9yeSA9IFtdO1xyXG52YXIgbGlmZUN5Y2xlVGltZXJTdGFjayA9IFtdO1xyXG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XHJcbnZhciBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcclxudmFyIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IDA7XHJcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcclxudmFyIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IDA7XHJcbnZhciBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcclxudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xyXG5cclxudmFyIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBjbGVhckhpc3RvcnkoKSB7XHJcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcclxuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcclxuICByZXR1cm4gcmVnaXN0ZXJlZElEcy5yZWR1Y2UoZnVuY3Rpb24gKHRyZWUsIGlkKSB7XHJcbiAgICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XHJcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcclxuICAgIHRyZWVbaWRdID0ge1xyXG4gICAgICBkaXNwbGF5TmFtZTogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCksXHJcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXHJcbiAgICAgIHVwZGF0ZUNvdW50OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFVwZGF0ZUNvdW50KGlkKSxcclxuICAgICAgY2hpbGRJRHM6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q2hpbGRJRHMoaWQpLFxyXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cclxuICAgICAgb3duZXJJRDogb3duZXJJRCB8fCBwYXJlbnRJRCAmJiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQocGFyZW50SUQpIHx8IDAsXHJcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRFxyXG4gICAgfTtcclxuICAgIHJldHVybiB0cmVlO1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzZXRNZWFzdXJlbWVudHMoKSB7XHJcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xyXG4gIHZhciBwcmV2aW91c01lYXN1cmVtZW50cyA9IGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cztcclxuICB2YXIgcHJldmlvdXNPcGVyYXRpb25zID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suZ2V0SGlzdG9yeSgpO1xyXG5cclxuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xyXG4gICAgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcclxuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xyXG4gICAgY2xlYXJIaXN0b3J5KCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAocHJldmlvdXNNZWFzdXJlbWVudHMubGVuZ3RoIHx8IHByZXZpb3VzT3BlcmF0aW9ucy5sZW5ndGgpIHtcclxuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XHJcbiAgICBmbHVzaEhpc3RvcnkucHVzaCh7XHJcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gcHJldmlvdXNTdGFydFRpbWUsXHJcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXHJcbiAgICAgIG9wZXJhdGlvbnM6IHByZXZpb3VzT3BlcmF0aW9ucyB8fCBbXSxcclxuICAgICAgdHJlZVNuYXBzaG90OiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcylcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJIaXN0b3J5KCk7XHJcbiAgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcclxuICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpIHtcclxuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcclxuXHJcbiAgaWYgKGFsbG93Um9vdCAmJiBkZWJ1Z0lEID09PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICghZGVidWdJRCkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcclxuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcclxuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcclxuICB9XHJcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcclxuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcclxuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcclxuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcclxuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAhPT0gdGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdXZSBkaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdG9wIHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWcgaW4gUmVhY3QuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcclxuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKGlzUHJvZmlsaW5nKSB7XHJcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XHJcbiAgICAgIHRpbWVyVHlwZTogdGltZXJUeXBlLFxyXG4gICAgICBpbnN0YW5jZUlEOiBkZWJ1Z0lELFxyXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cclxuICAgIH0pO1xyXG4gIH1cclxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xyXG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xyXG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xyXG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcclxuICB2YXIgY3VycmVudFRpbWVyID0ge1xyXG4gICAgc3RhcnRUaW1lOiBjdXJyZW50VGltZXJTdGFydFRpbWUsXHJcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcclxuICAgIGRlYnVnSUQ6IGN1cnJlbnRUaW1lckRlYnVnSUQsXHJcbiAgICB0aW1lclR5cGU6IGN1cnJlbnRUaW1lclR5cGVcclxuICB9O1xyXG4gIGxpZmVDeWNsZVRpbWVyU3RhY2sucHVzaChjdXJyZW50VGltZXIpO1xyXG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IDA7XHJcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XHJcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XHJcbiAgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcclxuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKSxcclxuICAgICAgc3RhcnRUaW1lID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLnN0YXJ0VGltZSxcclxuICAgICAgbmVzdGVkRmx1c2hTdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQubmVzdGVkRmx1c2hTdGFydFRpbWUsXHJcbiAgICAgIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRCxcclxuICAgICAgdGltZXJUeXBlID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLnRpbWVyVHlwZTtcclxuXHJcbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XHJcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xyXG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gKz0gbmVzdGVkRmx1c2hEdXJhdGlvbjtcclxuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcclxuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xyXG59XHJcblxyXG52YXIgbGFzdE1hcmtUaW1lU3RhbXAgPSAwO1xyXG52YXIgY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlID1cclxuLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjM0NVxyXG50eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xyXG5cclxuZnVuY3Rpb24gc2hvdWxkTWFyayhkZWJ1Z0lEKSB7XHJcbiAgaWYgKCFpc1Byb2ZpbGluZyB8fCAhY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpO1xyXG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBpc0hvc3RFbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZyc7XHJcbiAgaWYgKGlzSG9zdEVsZW1lbnQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtCZWdpbihkZWJ1Z0lELCBtYXJrVHlwZSkge1xyXG4gIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1hcmtOYW1lID0gZGVidWdJRCArICc6OicgKyBtYXJrVHlwZTtcclxuICBsYXN0TWFya1RpbWVTdGFtcCA9IHBlcmZvcm1hbmNlTm93KCk7XHJcbiAgcGVyZm9ybWFuY2UubWFyayhtYXJrTmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtFbmQoZGVidWdJRCwgbWFya1R5cGUpIHtcclxuICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XHJcbiAgdmFyIGRpc3BsYXlOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShkZWJ1Z0lEKSB8fCAnVW5rbm93bic7XHJcblxyXG4gIC8vIENocm9tZSBoYXMgYW4gaXNzdWUgb2YgZHJvcHBpbmcgbWFya2VycyByZWNvcmRlZCB0b28gZmFzdDpcclxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NDA2NTJcclxuICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSB3aWxsIG5vdCByZXBvcnQgdmVyeSBzbWFsbCBtZWFzdXJlbWVudHMuXHJcbiAgLy8gSSBkZXRlcm1pbmVkIHRoZSBtYWdpYyBudW1iZXIgYnkgdHdlYWtpbmcgaXQgYmFjayBhbmQgZm9ydGguXHJcbiAgLy8gMC4wNW1zIHdhcyBlbm91Z2ggdG8gcHJldmVudCB0aGUgaXNzdWUsIGJ1dCBJIHNldCBpdCB0byAwLjFtcyB0byBiZSBzYWZlLlxyXG4gIC8vIFdoZW4gdGhlIGJ1ZyBpcyBmaXhlZCwgd2UgY2FuIGBtZWFzdXJlKClgIHVuY29uZGl0aW9uYWxseSBpZiB3ZSB3YW50IHRvLlxyXG4gIHZhciB0aW1lU3RhbXAgPSBwZXJmb3JtYW5jZU5vdygpO1xyXG4gIGlmICh0aW1lU3RhbXAgLSBsYXN0TWFya1RpbWVTdGFtcCA+IDAuMSkge1xyXG4gICAgdmFyIG1lYXN1cmVtZW50TmFtZSA9IGRpc3BsYXlOYW1lICsgJyBbJyArIG1hcmtUeXBlICsgJ10nO1xyXG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlbWVudE5hbWUsIG1hcmtOYW1lKTtcclxuICB9XHJcblxyXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFya05hbWUpO1xyXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMobWVhc3VyZW1lbnROYW1lKTtcclxufVxyXG5cclxudmFyIFJlYWN0RGVidWdUb29sID0ge1xyXG4gIGFkZEhvb2s6IGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICBob29rcy5wdXNoKGhvb2spO1xyXG4gIH0sXHJcbiAgcmVtb3ZlSG9vazogZnVuY3Rpb24gKGhvb2spIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGhvb2tzW2ldID09PSBob29rKSB7XHJcbiAgICAgICAgaG9va3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgaXNQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBpc1Byb2ZpbGluZztcclxuICB9LFxyXG4gIGJlZ2luUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcclxuICAgIGZsdXNoSGlzdG9yeS5sZW5ndGggPSAwO1xyXG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcclxuICAgIFJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xyXG4gIH0sXHJcbiAgZW5kUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpc1Byb2ZpbGluZyA9IGZhbHNlO1xyXG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcclxuICAgIFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xyXG4gIH0sXHJcbiAgZ2V0Rmx1c2hIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZmx1c2hIaXN0b3J5O1xyXG4gIH0sXHJcbiAgb25CZWdpbkZsdXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XHJcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xyXG4gICAgcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcclxuICAgIGVtaXRFdmVudCgnb25CZWdpbkZsdXNoJyk7XHJcbiAgfSxcclxuICBvbkVuZEZsdXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xyXG4gICAgY3VycmVudEZsdXNoTmVzdGluZy0tO1xyXG4gICAgcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XHJcbiAgICBlbWl0RXZlbnQoJ29uRW5kRmx1c2gnKTtcclxuICB9LFxyXG4gIG9uQmVnaW5MaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xyXG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xyXG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xyXG4gICAgbWFya0JlZ2luKGRlYnVnSUQsIHRpbWVyVHlwZSk7XHJcbiAgICBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XHJcbiAgfSxcclxuICBvbkVuZExpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XHJcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XHJcbiAgICBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xyXG4gICAgbWFya0VuZChkZWJ1Z0lELCB0aW1lclR5cGUpO1xyXG4gICAgZW1pdEV2ZW50KCdvbkVuZExpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcclxuICB9LFxyXG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XHJcbiAgfSxcclxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XHJcbiAgfSxcclxuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcclxuICAgIGNoZWNrRGVidWdJRChvcGVyYXRpb24uaW5zdGFuY2VJRCk7XHJcbiAgICBlbWl0RXZlbnQoJ29uSG9zdE9wZXJhdGlvbicsIG9wZXJhdGlvbik7XHJcbiAgfSxcclxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbWl0RXZlbnQoJ29uU2V0U3RhdGUnKTtcclxuICB9LFxyXG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChkZWJ1Z0lELCBjaGlsZERlYnVnSURzKSB7XHJcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XHJcbiAgICBjaGlsZERlYnVnSURzLmZvckVhY2goY2hlY2tEZWJ1Z0lEKTtcclxuICAgIGVtaXRFdmVudCgnb25TZXRDaGlsZHJlbicsIGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xyXG4gIH0sXHJcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpIHtcclxuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcclxuICAgIGNoZWNrRGVidWdJRChwYXJlbnREZWJ1Z0lELCB0cnVlKTtcclxuICAgIGVtaXRFdmVudCgnb25CZWZvcmVNb3VudENvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xyXG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICdtb3VudCcpO1xyXG4gIH0sXHJcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcclxuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcclxuICAgIG1hcmtFbmQoZGVidWdJRCwgJ21vdW50Jyk7XHJcbiAgICBlbWl0RXZlbnQoJ29uTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcclxuICB9LFxyXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xyXG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQpO1xyXG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICd1cGRhdGUnKTtcclxuICB9LFxyXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xyXG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xyXG4gICAgbWFya0VuZChkZWJ1Z0lELCAndXBkYXRlJyk7XHJcbiAgICBlbWl0RXZlbnQoJ29uVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCk7XHJcbiAgfSxcclxuICBvbkJlZm9yZVVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XHJcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XHJcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xyXG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICd1bm1vdW50Jyk7XHJcbiAgfSxcclxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XHJcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XHJcbiAgICBtYXJrRW5kKGRlYnVnSUQsICd1bm1vdW50Jyk7XHJcbiAgICBlbWl0RXZlbnQoJ29uVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xyXG4gIH0sXHJcbiAgb25UZXN0RXZlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGVtaXRFdmVudCgnb25UZXN0RXZlbnQnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBUT0RPIHJlbW92ZSB0aGVzZSB3aGVuIFJOL3d3dyBnZXRzIHVwZGF0ZWRcclxuUmVhY3REZWJ1Z1Rvb2wuYWRkRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLmFkZEhvb2s7XHJcblJlYWN0RGVidWdUb29sLnJlbW92ZURldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rO1xyXG5cclxuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rKTtcclxuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENvbXBvbmVudFRyZWVIb29rKTtcclxudmFyIHVybCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcclxuaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XHJcbiAgUmVhY3REZWJ1Z1Rvb2wuYmVnaW5Qcm9maWxpbmcoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlYnVnVG9vbDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xyXG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XHJcblxyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcclxuXHJcbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XHJcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcclxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XHJcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcclxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXHJcbn07XHJcblxyXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xyXG5cclxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xyXG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcclxufVxyXG5cclxuX2Fzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwge1xyXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xyXG5cclxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XHJcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcclxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxyXG4gICAqL1xyXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcclxuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcclxuXHJcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXHJcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0FSSUFET01Qcm9wZXJ0eUNvbmZpZycpO1xyXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQmVmb3JlSW5wdXRFdmVudFBsdWdpbicpO1xyXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XHJcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcclxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJyk7XHJcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xyXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUVtcHR5Q29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdERPTVRyZWVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL1JlYWN0RE9NVHJlZVRyYXZlcnNhbCcpO1xyXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcclxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcclxudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XHJcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbmplY3Rpb24nKTtcclxudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcclxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9TVkdET01Qcm9wZXJ0eUNvbmZpZycpO1xyXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XHJcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcclxuXHJcbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGluamVjdCgpIHtcclxuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XHJcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cclxuICAgIC8vIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgcGFja2FnZS4gVGhleSBzaG91bGQgYmUgYnVpbHQgaW5kZXBlbmRlbnRseVxyXG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcclxuXHJcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihSZWFjdEV2ZW50TGlzdGVuZXIpO1xyXG5cclxuICAvKipcclxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cclxuICAgKi9cclxuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcclxuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcclxuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdFRyZWVUcmF2ZXJzYWwoUmVhY3RET01UcmVlVHJhdmVyc2FsKTtcclxuXHJcbiAgLyoqXHJcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXHJcbiAgICogdGhlbSkuXHJcbiAgICovXHJcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcclxuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcclxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxyXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxyXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxyXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxyXG4gIH0pO1xyXG5cclxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyhSZWFjdERPTUNvbXBvbmVudCk7XHJcblxyXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XHJcblxyXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEFSSUFET01Qcm9wZXJ0eUNvbmZpZyk7XHJcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcclxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XHJcblxyXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeShmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcclxuICAgIHJldHVybiBuZXcgUmVhY3RET01FbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZSk7XHJcbiAgfSk7XHJcblxyXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XHJcbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xyXG5cclxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpbmplY3Q6IGluamVjdFxyXG59OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxyXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXHJcblxyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJFQUNUX0VMRU1FTlRfVFlQRTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZW1wdHlDb21wb25lbnRGYWN0b3J5O1xyXG5cclxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XHJcbiAgaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5OiBmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgZW1wdHlDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHtcclxuICBjcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xyXG4gICAgcmV0dXJuIGVtcHR5Q29tcG9uZW50RmFjdG9yeShpbnN0YW50aWF0ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcclxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XHJcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhKSB7XHJcbiAgdHJ5IHtcclxuICAgIGZ1bmMoYSk7XHJcbiAgfSBjYXRjaCAoeCkge1xyXG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XHJcbiAgICAgIGNhdWdodEVycm9yID0geDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XHJcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcclxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cclxuICAgKi9cclxuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcclxuXHJcbiAgLyoqXHJcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXHJcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxyXG4gICAqL1xyXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGNhdWdodEVycm9yKSB7XHJcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xyXG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgLyoqXHJcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcclxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXHJcbiAgICovXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcclxuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSkge1xyXG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEpO1xyXG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcclxuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcclxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG4gICAgICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yMzM2XHJcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xyXG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcclxuXHJcbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xyXG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcclxuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XHJcbn1cclxuXHJcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xyXG5cclxuICAvKipcclxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxyXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXHJcbiAgICovXHJcbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRFbWl0dGVyTWl4aW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcclxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcblxyXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XHJcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxyXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxyXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kUGFyZW50KGluc3QpIHtcclxuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxyXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcclxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cclxuICB3aGlsZSAoaW5zdC5faG9zdFBhcmVudCkge1xyXG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XHJcbiAgfVxyXG4gIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xyXG4gIHZhciBjb250YWluZXIgPSByb290Tm9kZS5wYXJlbnROb2RlO1xyXG4gIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcclxufVxyXG5cclxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXHJcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XHJcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XHJcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xyXG4gIHRoaXMuYW5jZXN0b3JzID0gW107XHJcbn1cclxuX2Fzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XHJcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xyXG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xyXG4gIH1cclxufSk7XHJcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xyXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KTtcclxuICB2YXIgdGFyZ2V0SW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XHJcblxyXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxyXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcclxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cclxuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxyXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XHJcbiAgZG8ge1xyXG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xyXG4gICAgYW5jZXN0b3IgPSBhbmNlc3RvciAmJiBmaW5kUGFyZW50KGFuY2VzdG9yKTtcclxuICB9IHdoaWxlIChhbmNlc3Rvcik7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xyXG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVNb25pdG9yKGNiKSB7XHJcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcclxuICBjYihzY3JvbGxQb3NpdGlvbik7XHJcbn1cclxuXHJcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XHJcbiAgX2VuYWJsZWQ6IHRydWUsXHJcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxyXG5cclxuICBXSU5ET1dfSEFORExFOiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyB3aW5kb3cgOiBudWxsLFxyXG5cclxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XHJcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XHJcbiAgfSxcclxuXHJcbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcclxuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcclxuICB9LFxyXG5cclxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cclxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcclxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cclxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcclxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XHJcbiAgfSxcclxuXHJcbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xyXG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XHJcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XHJcbiAgfSxcclxuXHJcbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcclxuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xyXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxyXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcclxuICAvLyBXaGVuIHRydWUsIGNhbGwgY29uc29sZS50aW1lKCkgYmVmb3JlIGFuZCAudGltZUVuZCgpIGFmdGVyIGVhY2ggdG9wLWxldmVsXHJcbiAgLy8gcmVuZGVyIChib3RoIGluaXRpYWwgcmVuZGVycyBhbmQgdXBkYXRlcykuIFVzZWZ1bCB3aGVuIGxvb2tpbmcgYXQgcHJvZC1tb2RlXHJcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cclxuICBsb2dUb3BMZXZlbFJlbmRlcnM6IGZhbHNlXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RmVhdHVyZUZsYWdzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcclxudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XHJcblxyXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50SW5qZWN0aW9uID0ge1xyXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcclxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxyXG4gIGluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XHJcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcclxuICB9LFxyXG4gIC8vIFRoaXMgYWNjZXB0cyBhIHRleHQgY29tcG9uZW50IGNsYXNzIHRoYXQgdGFrZXMgdGhlIHRleHQgc3RyaW5nIHRvIGJlXHJcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXHJcbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcclxuICAgIHRleHRDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBob3N0IGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cclxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcclxuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IF9wcm9kSW52YXJpYW50KCcxMTEnLCBlbGVtZW50LnR5cGUpIDogdm9pZCAwO1xyXG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcclxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZvclRleHQodGV4dCkge1xyXG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgcmV0dXJuIGNvbXBvbmVudCBpbnN0YW5jZW9mIHRleHRDb21wb25lbnRDbGFzcztcclxufVxyXG5cclxudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHtcclxuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXHJcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXHJcbiAgaXNUZXh0Q29tcG9uZW50OiBpc1RleHRDb21wb25lbnQsXHJcbiAgaW5qZWN0aW9uOiBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb25cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0Q29tcG9uZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaGlzdG9yeSA9IFtdO1xyXG5cclxudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0ge1xyXG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKG9wZXJhdGlvbikge1xyXG4gICAgaGlzdG9yeS5wdXNoKG9wZXJhdGlvbik7XHJcbiAgfSxcclxuICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5fcHJldmVudENsZWFyaW5nKSB7XHJcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzLlxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaGlzdG9yeSA9IFtdO1xyXG4gIH0sXHJcbiAgZ2V0SGlzdG9yeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGhpc3Rvcnk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vazsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XHJcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcclxudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcclxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcclxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcclxudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XHJcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xyXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcclxuXHJcbnZhciBSZWFjdEluamVjdGlvbiA9IHtcclxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxyXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXHJcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxyXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXHJcbiAgRXZlbnRQbHVnaW5VdGlsczogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24sXHJcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxyXG4gIEhvc3RDb21wb25lbnQ6IFJlYWN0SG9zdENvbXBvbmVudC5pbmplY3Rpb24sXHJcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XHJcblxyXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XHJcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcclxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XHJcblxyXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xyXG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXHJcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcclxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxyXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cclxuICovXHJcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xyXG5cclxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcclxuICB9LFxyXG5cclxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxyXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcclxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cclxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cclxuICAgKi9cclxuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xyXG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xyXG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xyXG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xyXG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xyXG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcclxuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcclxuICAgICAgfVxyXG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXHJcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXHJcbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcclxuICAgKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cclxuICAgKi9cclxuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgdmFyIHNlbGVjdGlvbjtcclxuXHJcbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xyXG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxyXG4gICAgICBzZWxlY3Rpb24gPSB7XHJcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxyXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XHJcbiAgICAgIC8vIElFOCBpbnB1dC5cclxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XHJcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxyXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xyXG4gICAgICAgIHNlbGVjdGlvbiA9IHtcclxuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcclxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXHJcbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXHJcbiAgICogdGhlIGlucHV0LlxyXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcclxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXHJcbiAgICovXHJcbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XHJcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XHJcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcclxuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcclxuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xyXG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcclxuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XHJcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xyXG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XHJcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxyXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xyXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcclxuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cclxuICovXHJcblxyXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBFUzY6IHZhciBSZWFjdEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xyXG5cclxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXHJcbiAgICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcclxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cclxuICAgKi9cclxuICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xyXG4gIH0sXHJcblxyXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlO1xyXG4gIH0sXHJcblxyXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9PSB1bmRlZmluZWQ7XHJcbiAgfSxcclxuXHJcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlTWFwOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIFJlYWN0SW5zdHJ1bWVudGF0aW9uIHdpdGggYSBfX0RFVl9fIGNoZWNrXHJcblxyXG52YXIgZGVidWdUb29sID0gbnVsbDtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIFJlYWN0RGVidWdUb29sID0gcmVxdWlyZSgnLi9SZWFjdERlYnVnVG9vbCcpO1xyXG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XHJcblxyXG4gIHZhciB3YXJuSW52YWxpZFNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge1xyXG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcclxuICB9LFxyXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xyXG4gIH0sXHJcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vazsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xyXG5cclxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xyXG52YXIgQ09NTUVOVF9TVEFSVCA9IC9ePFxcIVxcLVxcLS87XHJcblxyXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcclxuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXHJcbiAgICovXHJcbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xyXG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xyXG5cclxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MsIGNvbW1lbnRzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcclxuICAgIGlmIChDT01NRU5UX1NUQVJULnRlc3QobWFya3VwKSkge1xyXG4gICAgICByZXR1cm4gbWFya3VwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKFRBR19FTkQsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIiQmJyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcclxuICAgKi9cclxuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xyXG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XHJcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XHJcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XHJcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XHJcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XHJcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBSZWFjdERPTUNvbnRhaW5lckluZm8gPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29udGFpbmVySW5mbycpO1xyXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XHJcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcclxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcclxudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xyXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xyXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcclxudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcblxyXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xyXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xyXG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xyXG52YXIgUk9PVF9BVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FO1xyXG5cclxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcclxudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xyXG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XHJcblxyXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXHJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcclxuICovXHJcbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcclxuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XHJcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XHJcbiAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXHJcbiAqIGEgUmVhY3QgY29tcG9uZW50XHJcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgaWYgKCFjb250YWluZXIpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xyXG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcclxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cclxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cclxuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cclxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cclxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXHJcbiAqL1xyXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcclxuICB2YXIgbWFya2VyTmFtZTtcclxuICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XHJcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzLmNoaWxkO1xyXG4gICAgdmFyIHR5cGUgPSB3cmFwcGVkRWxlbWVudC50eXBlO1xyXG4gICAgbWFya2VyTmFtZSA9ICdSZWFjdCBtb3VudDogJyArICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUpO1xyXG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cclxuICApO1xyXG5cclxuICBpZiAobWFya2VyTmFtZSkge1xyXG4gICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xyXG4gIH1cclxuXHJcbiAgd3JhcHBlckluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gd3JhcHBlckluc3RhbmNlO1xyXG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgd3JhcHBlckluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xyXG59XHJcblxyXG4vKipcclxuICogQmF0Y2hlZCBtb3VudC5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xyXG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcclxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovXHJcbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xyXG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcclxuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXHJcbiAqIEBmaW5hbFxyXG4gKiBAaW50ZXJuYWxcclxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxyXG4gKi9cclxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIsIHNhZmVseSkge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoKCk7XHJcbiAgfVxyXG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xyXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxyXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XHJcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaGFzIGEgZGlyZWN0IFJlYWN0LXJlbmRlcmVkIGNoaWxkIHRoYXQgaXNcclxuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXHJcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxyXG4gKlxyXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXHJcbiAqIHJlbmRlcmVkIGJ5IFJlYWN0IGJ1dCBpcyBub3QgYSByb290IGVsZW1lbnQuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKSB7XHJcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gIGlmIChyb290RWwpIHtcclxuICAgIHZhciBpbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcclxuICAgIHJldHVybiAhIShpbnN0ICYmIGluc3QuX2hvc3RQYXJlbnQpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgUmVhY3QgRE9NIGVsZW1lbnQgYW5kXHJcbiAqIGl0IGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC5cclxuICpcclxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSB7XHJcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gIHJldHVybiAhIShyb290RWwgJiYgaXNSZWFjdE5vZGUocm9vdEVsKSAmJiAhUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcclxuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgUmVhY3Qgbm9kZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIFJlYWN0IERPTSBub2RlLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGlzUmVhY3ROb2RlKG5vZGUpIHtcclxuICByZXR1cm4gaXNWYWxpZENvbnRhaW5lcihub2RlKSAmJiAobm9kZS5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gIHZhciBwcmV2SG9zdEluc3RhbmNlID0gcm9vdEVsICYmIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XHJcbiAgcmV0dXJuIHByZXZIb3N0SW5zdGFuY2UgJiYgIXByZXZIb3N0SW5zdGFuY2UuX2hvc3RQYXJlbnQgPyBwcmV2SG9zdEluc3RhbmNlIDogbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcclxuICByZXR1cm4gcm9vdCA/IHJvb3QuX2hvc3RDb250YWluZXJJbmZvLl90b3BMZXZlbFdyYXBwZXIgOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXHJcbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcclxuICogaGVyZS5cclxuICovXHJcbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcclxudmFyIFRvcExldmVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnJvb3RJRCA9IHRvcExldmVsUm9vdENvdW50ZXIrKztcclxufTtcclxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XHJcbn1cclxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGQ7XHJcbn07XHJcblRvcExldmVsV3JhcHBlci5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXHJcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxyXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxyXG4gKlxyXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxyXG4gKiAgICAgY29tcG9uZW50LFxyXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXHJcbiAqICAgKTtcclxuICpcclxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cclxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcclxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxyXG4gKiAgICAgPC9kaXY+XHJcbiAqICAgPC9kaXY+XHJcbiAqXHJcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXHJcbiAqL1xyXG52YXIgUmVhY3RNb3VudCA9IHtcclxuXHJcbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZWQgYnkgZGV2dG9vbHMuIFRoZSBrZXlzIGFyZSBub3QgaW1wb3J0YW50LlxyXG4gICAqL1xyXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXHJcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxyXG4gICAqIGNoYW5nZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxyXG4gICAqL1xyXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XHJcbiAgICByZW5kZXJDYWxsYmFjaygpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXHJcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cclxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cclxuICAgKi9cclxuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xyXG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KTtcclxuICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLiBIb29rZWQgYnkgaG9va3MhXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXHJcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcclxuICAgKi9cclxuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XHJcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcclxuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xyXG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG5cclxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzcnKSA6IHZvaWQgMDtcclxuXHJcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XHJcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBmYWxzZSk7XHJcblxyXG4gICAgLy8gVGhlIGluaXRpYWwgcmVuZGVyIGlzIHN5bmNocm9ub3VzIGJ1dCBhbnkgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmdcclxuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcclxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cclxuXHJcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcclxuXHJcbiAgICB2YXIgd3JhcHBlcklEID0gY29tcG9uZW50SW5zdGFuY2UuX2luc3RhbmNlLnJvb3RJRDtcclxuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xyXG5cclxuICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXHJcbiAgICpcclxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxyXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxyXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cclxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cclxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxyXG4gICAqL1xyXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xyXG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBSZWFjdEluc3RhbmNlTWFwLmhhcyhwYXJlbnRDb21wb25lbnQpKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzM4JykgOiB2b2lkIDA7XHJcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XHJcbiAgfSxcclxuXHJcbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xyXG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAnUmVhY3RET00ucmVuZGVyJyk7XHJcbiAgICAhUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDpcclxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcclxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XHJcblxyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcclxuXHJcbiAgICB2YXIgbmV4dFdyYXBwZWRFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIHsgY2hpbGQ6IG5leHRFbGVtZW50IH0pO1xyXG5cclxuICAgIHZhciBuZXh0Q29udGV4dDtcclxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgdmFyIHBhcmVudEluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXh0Q29udGV4dCA9IGVtcHR5T2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xyXG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcy5jaGlsZDtcclxuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcclxuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm4gcHVibGljSW5zdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XHJcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcclxuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xyXG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xyXG4gICAgICAgIHdoaWxlIChyb290RWxlbWVudFNpYmxpbmcpIHtcclxuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcclxuICAgICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcclxuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb21wb25lbnQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxyXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcclxuICAgKlxyXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXHJcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXHJcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXHJcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXHJcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cclxuICAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXHJcbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnVubW91bnRjb21wb25lbnRhdG5vZGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXHJcbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcclxuICAgKi9cclxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcclxuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xyXG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxyXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG5cclxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gICAgaWYgKCFwcmV2Q29tcG9uZW50KSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXHJcbiAgICAgIC8vIHJvb3Qgbm9kZS5cclxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxyXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgY29udGFpbmVyLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSk7XHJcblxyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcclxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIHByZXZDb21wb25lbnQsIGNvbnRhaW5lciwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuXHJcbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBpbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XHJcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcclxuXHJcbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcclxuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XHJcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XHJcbiAgICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgcm9vdEVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgY2hlY2tzdW0gPSByb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xyXG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XHJcblxyXG4gICAgICAgIHZhciByb290TWFya3VwID0gcm9vdEVsZW1lbnQub3V0ZXJIVE1MO1xyXG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xyXG5cclxuICAgICAgICB2YXIgbm9ybWFsaXplZE1hcmt1cCA9IG1hcmt1cDtcclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcclxuICAgICAgICAgIC8vIHdpbGwgaGF2ZSBvY2N1cnJlZCB3aGljaCB3aWxsIG5vdCBiZSBwcmVzZW50IGluIGBtYXJrdXBgLiBIZXJlLFxyXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxyXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZXI7XHJcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xyXG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuaW5uZXJIVE1MID0gbWFya3VwO1xyXG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xyXG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbm9ybWFsaXplZE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XHJcblxyXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gdGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSBtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSBzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzIGFuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBfcHJvZEludmFyaWFudCgnNDInLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgYXR0ZW1wdGVkIHRvIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgKyAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICsgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICsgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICsgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgKyAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArICdvciBzZXJ2ZXI6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XHJcblxyXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcclxuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcclxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XHJcbiAgICAgIH1cclxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xyXG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIGhvc3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICBpZiAoaG9zdE5vZGUuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcclxuICAgICAgICAgIGluc3RhbmNlSUQ6IGhvc3ROb2RlLl9kZWJ1Z0lELFxyXG4gICAgICAgICAgdHlwZTogJ21vdW50JyxcclxuICAgICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XHJcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xyXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcclxudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xyXG5cclxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XHJcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XHJcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAnSU5TRVJUX01BUktVUCcsXHJcbiAgICBjb250ZW50OiBtYXJrdXAsXHJcbiAgICBmcm9tSW5kZXg6IG51bGwsXHJcbiAgICBmcm9tTm9kZTogbnVsbCxcclxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXHJcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xyXG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogJ01PVkVfRVhJU1RJTkcnLFxyXG4gICAgY29udGVudDogbnVsbCxcclxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXHJcbiAgICBmcm9tTm9kZTogUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKGNoaWxkKSxcclxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXHJcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKSB7XHJcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAnUkVNT1ZFX05PREUnLFxyXG4gICAgY29udGVudDogbnVsbCxcclxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXHJcbiAgICBmcm9tTm9kZTogbm9kZSxcclxuICAgIHRvSW5kZXg6IG51bGwsXHJcbiAgICBhZnRlck5vZGU6IG51bGxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIG1hcmt1cCBvZiBhIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlU2V0TWFya3VwKG1hcmt1cCkge1xyXG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogJ1NFVF9NQVJLVVAnLFxyXG4gICAgY29udGVudDogbWFya3VwLFxyXG4gICAgZnJvbUluZGV4OiBudWxsLFxyXG4gICAgZnJvbU5vZGU6IG51bGwsXHJcbiAgICB0b0luZGV4OiBudWxsLFxyXG4gICAgYWZ0ZXJOb2RlOiBudWxsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZVRleHRDb250ZW50KHRleHRDb250ZW50KSB7XHJcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAnVEVYVF9DT05URU5UJyxcclxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxyXG4gICAgZnJvbUluZGV4OiBudWxsLFxyXG4gICAgZnJvbU5vZGU6IG51bGwsXHJcbiAgICB0b0luZGV4OiBudWxsLFxyXG4gICAgYWZ0ZXJOb2RlOiBudWxsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFB1c2ggYW4gdXBkYXRlLCBpZiBhbnksIG9udG8gdGhlIHF1ZXVlLiBDcmVhdGVzIGEgbmV3IHF1ZXVlIGlmIG5vbmUgaXNcclxuICogcGFzc2VkIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcXVldWUuIE11dGF0aXZlLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5xdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XHJcbiAgaWYgKHVwZGF0ZSkge1xyXG4gICAgcXVldWUgPSBxdWV1ZSB8fCBbXTtcclxuICAgIHF1ZXVlLnB1c2godXBkYXRlKTtcclxuICB9XHJcbiAgcmV0dXJuIHF1ZXVlO1xyXG59XHJcblxyXG4vKipcclxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKGluc3QsIHVwZGF0ZVF1ZXVlKSB7XHJcbiAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKGluc3QsIHVwZGF0ZVF1ZXVlKTtcclxufVxyXG5cclxudmFyIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZW1wdHlGdW5jdGlvbjtcclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YXIgZ2V0RGVidWdJRCA9IGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICBpZiAoIWluc3QuX2RlYnVnSUQpIHtcclxuICAgICAgLy8gQ2hlY2sgZm9yIEFSVC1saWtlIGluc3RhbmNlcy4gVE9ETzogVGhpcyBpcyBzaWxseS9ncm9zcy5cclxuICAgICAgdmFyIGludGVybmFsO1xyXG4gICAgICBpZiAoaW50ZXJuYWwgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0KSkge1xyXG4gICAgICAgIGluc3QgPSBpbnRlcm5hbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluc3QuX2RlYnVnSUQ7XHJcbiAgfTtcclxuICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xyXG4gICAgdmFyIGRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xyXG4gICAgLy8gVE9ETzogUmVhY3QgTmF0aXZlIGVtcHR5IGNvbXBvbmVudHMgYXJlIGFsc28gbXVsdGljaGlsZC5cclxuICAgIC8vIFRoaXMgbWVhbnMgdGhleSBzdGlsbCBnZXQgaW50byB0aGlzIG1ldGhvZCBidXQgZG9uJ3QgaGF2ZSBfZGVidWdJRC5cclxuICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkcmVuID8gT2JqZWN0LmtleXMoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2tleV0uX2RlYnVnSUQ7XHJcbiAgICAgIH0pIDogW10pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBjbGFzcyBSZWFjdE11bHRpQ2hpbGRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgUmVhY3RNdWx0aUNoaWxkID0ge1xyXG5cclxuICAvKipcclxuICAgKiBQcm92aWRlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3IgY29tcG9uZW50cyB0aGF0IG11c3QgcmVjb25jaWxlIG11bHRpcGxlXHJcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxyXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cclxuICAgKlxyXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cclxuICAgKi9cclxuICBNaXhpbjoge1xyXG5cclxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHZhciBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcclxuICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcclxuICAgICAgdmFyIG5leHRDaGlsZHJlbjtcclxuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xyXG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcclxuICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xyXG4gICAgICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XHJcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcclxuICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxyXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cclxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuXHJcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xyXG4gICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcclxuICAgICAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XHJcbiAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XHJcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XHJcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNoaWxkcmVuKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xyXG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcclxuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cclxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xyXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXHJcbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VUZXh0Q29udGVudChuZXh0Q29udGVudCldO1xyXG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0TWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdXBkYXRlTWFya3VwOiBmdW5jdGlvbiAobmV4dE1hcmt1cCkge1xyXG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcclxuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cclxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xyXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVNldE1hcmt1cChuZXh0TWFya3VwKV07XHJcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXHJcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcclxuICAgICAgLy8gSG9vayB1c2VkIGJ5IFJlYWN0IEFSVFxyXG4gICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cclxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgICAqIEBmaW5hbFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcclxuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XHJcbiAgICAgIHZhciByZW1vdmVkTm9kZXMgPSB7fTtcclxuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XHJcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB1cGRhdGVzID0gbnVsbDtcclxuICAgICAgdmFyIG5hbWU7XHJcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcclxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxyXG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcclxuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XHJcbiAgICAgIC8vIGBuZXh0TW91bnRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggbmV3bHkgbW91bnRlZCBjaGlsZC5cclxuICAgICAgdmFyIG5leHRNb3VudEluZGV4ID0gMDtcclxuICAgICAgdmFyIGxhc3RQbGFjZWROb2RlID0gbnVsbDtcclxuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xyXG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XHJcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcclxuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcclxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgbGFzdEluZGV4KSk7XHJcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XHJcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cclxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xyXG4gICAgICAgICAgICAvLyBUaGUgYHJlbW92ZWROb2Rlc2AgbG9vcCBiZWxvdyB3aWxsIGFjdHVhbGx5IHJlbW92ZSB0aGUgY2hpbGQuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cclxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX21vdW50Q2hpbGRBdEluZGV4KG5leHRDaGlsZCwgbW91bnRJbWFnZXNbbmV4dE1vdW50SW5kZXhdLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkpO1xyXG4gICAgICAgICAgbmV4dE1vdW50SW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dEluZGV4Kys7XHJcbiAgICAgICAgbGFzdFBsYWNlZE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUobmV4dENoaWxkKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXHJcbiAgICAgIGZvciAobmFtZSBpbiByZW1vdmVkTm9kZXMpIHtcclxuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdLCByZW1vdmVkTm9kZXNbbmFtZV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHVwZGF0ZXMpIHtcclxuICAgICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcclxuXHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXHJcbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC4gSXQgZG9lcyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhbnlcclxuICAgICAqIGJhY2tlbmQgb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoc2FmZWx5KSB7XHJcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcclxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSk7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xyXG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cclxuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxyXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cclxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKSB7XHJcbiAgICAgIHJldHVybiBtYWtlSW5zZXJ0TWFya3VwKG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgY2hpbGQuX21vdW50SW5kZXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XHJcbiAgICAgIHJldHVybiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxyXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX21vdW50Q2hpbGRBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3VubW91bnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XHJcbiAgICAgIHZhciB1cGRhdGUgPSB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkLCBub2RlKTtcclxuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xyXG4gICAgICByZXR1cm4gdXBkYXRlO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdE5vZGVUeXBlcyA9IHtcclxuICBIT1NUOiAwLFxyXG4gIENPTVBPU0lURTogMSxcclxuICBFTVBUWTogMixcclxuXHJcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XHJcbiAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5FTVBUWTtcclxuICAgIH0gZWxzZSBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcclxuICAgICAgaWYgKHR5cGVvZiBub2RlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5IT1NUO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBub2RlOiAlcycsIG5vZGUpIDogX3Byb2RJbnZhcmlhbnQoJzI2Jywgbm9kZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vZGVUeXBlczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXHJcbiAqIEBmaW5hbFxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZE93bmVyKG9iamVjdCkge1xyXG4gIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxyXG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cclxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXHJcbiAqXHJcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxyXG4gKlxyXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgIHJldHVybiAoXHJcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cclxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cclxuICogICAgICAgICA8L2Rpdj5cclxuICogICAgICAgKTtcclxuICogICAgIH0sXHJcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcclxuICogICAgIH0sXHJcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xyXG4gKiAgICAgfVxyXG4gKiAgIH0pO1xyXG4gKlxyXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cclxuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXHJcbiAqXHJcbiAqIEBjbGFzcyBSZWFjdE93bmVyXHJcbiAqL1xyXG52YXIgUmVhY3RPd25lciA9IHtcclxuICAvKipcclxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cclxuICAgKiBAZmluYWxcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XHJcbiAgICAhaXNWYWxpZE93bmVyKG93bmVyKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzExOScpIDogdm9pZCAwO1xyXG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGJ5IHJlZiBmcm9tIGFuIG93bmVyIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIG9mIHRoZSByZWYgdG8gcmVtb3ZlLlxyXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXHJcbiAgICogQGZpbmFsXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XHJcbiAgICAhaXNWYWxpZE93bmVyKG93bmVyKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjAnKSA6IHZvaWQgMDtcclxuICAgIHZhciBvd25lclB1YmxpY0luc3RhbmNlID0gb3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKTtcclxuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAncyBvd25lciBpcyBzdGlsbCBhbGl2ZSBhbmQgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWZcclxuICAgIC8vIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXHJcbiAgICBpZiAob3duZXJQdWJsaWNJbnN0YW5jZSAmJiBvd25lclB1YmxpY0luc3RhbmNlLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcclxuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RPd25lcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xyXG4gICAgcHJvcDogJ3Byb3AnLFxyXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxyXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XHJcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcclxudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XHJcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xyXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcclxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gU2VsZWN0aW9uIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXHJcbiAgICovXHJcbiAgY2xvc2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24ucmVzdG9yZVNlbGVjdGlvblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cclxuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcclxuICogRE9NKS5cclxuICovXHJcbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXHJcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxyXG4gICAqL1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xyXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQoZmFsc2UpO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxyXG4gICAqICAgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlIHRoZSByZWNvbmNpbGlhdGlvbiBvY2N1cnJlZC4gYGNsb3NlYFxyXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxyXG4gICAqL1xyXG4gIGNsb3NlOiBmdW5jdGlvbiAocHJldmlvdXNseUVuYWJsZWQpIHtcclxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYSBxdWV1ZSBmb3IgY29sbGVjdGluZyBgY29tcG9uZW50RGlkTW91bnRgIGFuZFxyXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cclxuICovXHJcbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cclxuICAgKi9cclxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXHJcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cclxuICogZWFjaCBvdGhlci5cclxuICovXHJcbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtTRUxFQ1RJT05fUkVTVE9SQVRJT04sIEVWRU5UX1NVUFBSRVNTSU9OLCBPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBUUkFOU0FDVElPTl9XUkFQUEVSUy5wdXNoKHtcclxuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXHJcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEN1cnJlbnRseTpcclxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcclxuICogLSBTdXBwcmVzc2VzIGV2ZW50cy5cclxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXHJcbiAqXHJcbiAqIEZ1dHVyZTpcclxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxyXG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxyXG4gKiAtIEltcGxlbWVudC9pbnRlZ3JhdGUgd2l0aCBjdXN0b21pemVkIGNvbnN0cmFpbnQgYmFzZWQgbGF5b3V0IHN5c3RlbSBhbmQga2VlcFxyXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxyXG4gKlxyXG4gKiBAY2xhc3MgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbih1c2VDcmVhdGVFbGVtZW50KSB7XHJcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xyXG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXHJcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXHJcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXHJcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxyXG4gIC8vIGBSZWFjdERPTVRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcclxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XHJcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcclxuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSB1c2VDcmVhdGVFbGVtZW50O1xyXG59XHJcblxyXG52YXIgTWl4aW4gPSB7XHJcbiAgLyoqXHJcbiAgICogQHNlZSBUcmFuc2FjdGlvblxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cclxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxyXG4gICAqL1xyXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cclxuICAgKi9cclxuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cclxuICAgKi9cclxuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlIC0tIGlmIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIG1ldGhvZCBpc1xyXG4gICAqIHBhc3NlZCB0byBgcm9sbGJhY2tgLCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSByZXNldCB0byB0aGF0IHN0YXRlLlxyXG4gICAqL1xyXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHJlYWN0TW91bnRSZWFkeSBpcyB0aGUgb3VyIG9ubHkgc3RhdGVmdWwgd3JhcHBlclxyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcclxuICB9LFxyXG5cclxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcclxuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXHJcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxyXG4gICAqL1xyXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XHJcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxuX2Fzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIE1peGluKTtcclxuXHJcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxuXHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxyXG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xyXG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xyXG59XHJcblxyXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSB0aGUgY29udGFpbmluZyBob3N0IGNvbXBvbmVudCBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXHJcbiAgKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xyXG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcmt1cDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXHJcbiAgICogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAuXHJcbiAgICovXHJcbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZS5nZXRIb3N0Tm9kZSgpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXHJcbiAgICpcclxuICAgKiBAZmluYWxcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgc2FmZWx5KSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xyXG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KHNhZmVseSk7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcclxuXHJcbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IHByZXZFbGVtZW50ICYmIGNvbnRleHQgPT09IGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIHtcclxuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXHJcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXHJcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxyXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxyXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxyXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhbiBlbGVtZW50IGNyZWF0ZWQgb3V0c2lkZSBhIGNvbXBvc2l0ZSB0byBiZVxyXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxyXG5cclxuICAgICAgLy8gVE9ETzogQmFpbGluZyBvdXQgZWFybHkgaXMganVzdCBhIHBlcmYgb3B0aW1pemF0aW9uIHJpZ2h0P1xyXG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgbmV4dEVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xyXG5cclxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xyXG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuXHJcbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcclxuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciAhPT0gdXBkYXRlQmF0Y2hOdW1iZXIpIHtcclxuICAgICAgLy8gVGhlIGNvbXBvbmVudCdzIGVucXVldWVkIGJhdGNoIG51bWJlciBzaG91bGQgYWx3YXlzIGJlIHRoZSBjdXJyZW50XHJcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IFVuZXhwZWN0ZWQgYmF0Y2ggbnVtYmVyIChjdXJyZW50ICVzLCAnICsgJ3BlbmRpbmcgJXMpJywgdXBkYXRlQmF0Y2hOdW1iZXIsIGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyKSA6IHZvaWQgMDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcclxuXHJcbnZhciBSZWFjdFJlZiA9IHt9O1xyXG5cclxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xyXG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBMZWdhY3kgcmVmXHJcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcclxuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmVmKG51bGwpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBMZWdhY3kgcmVmXHJcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xyXG4gIH1cclxufVxyXG5cclxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XHJcbiAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xyXG4gIH1cclxufTtcclxuXHJcblJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMgPSBmdW5jdGlvbiAocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XHJcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXHJcbiAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBlbGVtZW50IGluc3RlYWRcclxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcclxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXHJcblxyXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcclxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXHJcbiAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXHJcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxyXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cclxuXHJcbiAgdmFyIHByZXZSZWYgPSBudWxsO1xyXG4gIHZhciBwcmV2T3duZXIgPSBudWxsO1xyXG4gIGlmIChwcmV2RWxlbWVudCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJldkVsZW1lbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICBwcmV2UmVmID0gcHJldkVsZW1lbnQucmVmO1xyXG4gICAgcHJldk93bmVyID0gcHJldkVsZW1lbnQuX293bmVyO1xyXG4gIH1cclxuXHJcbiAgdmFyIG5leHRSZWYgPSBudWxsO1xyXG4gIHZhciBuZXh0T3duZXIgPSBudWxsO1xyXG4gIGlmIChuZXh0RWxlbWVudCAhPT0gbnVsbCAmJiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICBuZXh0UmVmID0gbmV4dEVsZW1lbnQucmVmO1xyXG4gICAgbmV4dE93bmVyID0gbmV4dEVsZW1lbnQuX293bmVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHByZXZSZWYgIT09IG5leHRSZWYgfHxcclxuICAvLyBJZiBvd25lciBjaGFuZ2VzIGJ1dCB3ZSBoYXZlIGFuIHVuY2hhbmdlZCBmdW5jdGlvbiByZWYsIGRvbid0IHVwZGF0ZSByZWZzXHJcbiAgdHlwZW9mIG5leHRSZWYgPT09ICdzdHJpbmcnICYmIG5leHRPd25lciAhPT0gcHJldk93bmVyO1xyXG59O1xyXG5cclxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XHJcbiAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWY7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XHJcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcclxudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xyXG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZScpO1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXHJcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cclxuICogZWFjaCBvdGhlci5cclxuICovXHJcbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtdO1xyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBUUkFOU0FDVElPTl9XUkFQUEVSUy5wdXNoKHtcclxuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXHJcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcclxuICB9KTtcclxufVxyXG5cclxudmFyIG5vb3BDYWxsYmFja1F1ZXVlID0ge1xyXG4gIGVucXVldWU6IGZ1bmN0aW9uICgpIHt9XHJcbn07XHJcblxyXG4vKipcclxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cclxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJUb1N0YXRpY01hcmt1cFxyXG4gKi9cclxuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xyXG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcclxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XHJcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XHJcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG5ldyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKHRoaXMpO1xyXG59XHJcblxyXG52YXIgTWl4aW4gPSB7XHJcbiAgLyoqXHJcbiAgICogQHNlZSBUcmFuc2FjdGlvblxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXHJcbiAgICovXHJcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxyXG4gICAqL1xyXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5vb3BDYWxsYmFja1F1ZXVlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxyXG4gICAqL1xyXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVRdWV1ZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xyXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cclxuICAgKi9cclxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxyXG59O1xyXG5cclxuX2Fzc2lnbihSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIE1peGluKTtcclxuXHJcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XHJcblxyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgdXBkYXRlIHF1ZXVlIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcuXHJcbiAqIEl0IGRlbGVnYXRlcyB0byBSZWFjdFVwZGF0ZVF1ZXVlIHdoaWxlIHNlcnZlciByZW5kZXJpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kXHJcbiAqIHN3aXRjaGVzIHRvIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLlxyXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKi9cclxuXHJcbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIFJlYWN0U2VydmVyVXBkYXRlUXVldWUodHJhbnNhY3Rpb24pIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKTtcclxuXHJcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAZmluYWxcclxuICAgKi9cclxuXHJcblxyXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZChwdWJsaWNJbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcclxuICAgKiBoYXZlIHByb2Nlc3NlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cclxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcblxyXG5cclxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlQ2FsbGJhY2sgPSBmdW5jdGlvbiBlbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XHJcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xyXG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcclxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cclxuICAgKlxyXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcclxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcclxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcblxyXG5cclxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlRm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlRm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpIHtcclxuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XHJcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXHJcbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxyXG4gICAqXHJcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cclxuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuXHJcblxyXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVSZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XHJcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xyXG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcclxuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcclxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcclxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcblxyXG5cclxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlU2V0U3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xyXG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcclxuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XHJcbn0oKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XHJcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChhcmcpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XHJcbiAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gdHlwZTtcclxuICB9XHJcbiAgdmFyIGRpc3BsYXlOYW1lID0gYXJnLmNvbnN0cnVjdG9yICYmIGFyZy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHR5cGU7XHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xyXG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xyXG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lICsgJyAoa2V5czogJyArIGtleXMuam9pbignLCAnKSArICcpJztcclxuICB9XHJcbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcclxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcclxuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XHJcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cclxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXHJcbiAgICAgIC8vIHRoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSB3YXJuZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZSBtZXRob2QuXHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGN0b3IgJiYgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyAnICsgJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciAnICsgJ3NpZGUtZWZmZWN0cyBhcmUgYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvICcgKyAnYGNvbXBvbmVudFdpbGxNb3VudGAuJywgY2FsbGVyTmFtZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcclxuICogcmVjb25jaWxpYXRpb24gc3RlcC5cclxuICovXHJcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAZmluYWxcclxuICAgKi9cclxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcclxuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xyXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcclxuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcclxuICAgICAgLy8gdGhpcyBoYWNrLlxyXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXHJcbiAgICogaGF2ZSBwcm9jZXNzZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsZXJOYW1lIE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XHJcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xyXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xyXG5cclxuICAgIC8vIFByZXZpb3VzbHkgd2Ugd291bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgZGlkbid0IGhhdmUgYW4gaW50ZXJuYWxcclxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcclxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cclxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBpZ25vcmUgY2FsbGJhY2tzIGluIGNvbXBvbmVudFdpbGxNb3VudC4gU2VlXHJcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cclxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xyXG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cclxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXHJcbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xyXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXHJcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xyXG4gIH0sXHJcblxyXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XHJcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcclxuICAgIH1cclxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxyXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxyXG4gICAqXHJcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxyXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxyXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xyXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xyXG5cclxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cclxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXHJcbiAgICpcclxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xyXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xyXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcclxuXHJcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xyXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IHRydWU7XHJcblxyXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcclxuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcclxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcclxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocGFydGlhbFN0YXRlICE9IG51bGwsICdzZXRTdGF0ZSguLi4pOiBZb3UgcGFzc2VkIGFuIHVuZGVmaW5lZCBvciBudWxsIHN0YXRlIG9iamVjdDsgJyArICdpbnN0ZWFkLCB1c2UgZm9yY2VVcGRhdGUoKS4nKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XHJcblxyXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSB8fCAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbXSk7XHJcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XHJcblxyXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcclxuICB9LFxyXG5cclxuICBlbnF1ZXVlRWxlbWVudEludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KSB7XHJcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5leHRFbGVtZW50O1xyXG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXHJcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0ID0gbmV4dENvbnRleHQ7XHJcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xyXG4gIH0sXHJcblxyXG4gIHZhbGlkYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xyXG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcclxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xyXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XHJcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcclxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XHJcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcclxudmFyIHVwZGF0ZUJhdGNoTnVtYmVyID0gMDtcclxudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcclxudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xyXG5cclxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gZW5zdXJlSW5qZWN0ZWQoKSB7XHJcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyMycpIDogdm9pZCAwO1xyXG59XHJcblxyXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoO1xyXG4gIH0sXHJcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCAhPT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxyXG4gICAgICAvLyB0aGVzZSBuZXcgdXBkYXRlcyBzbyB0aGF0IGlmIEEncyBjb21wb25lbnREaWRVcGRhdGUgY2FsbHMgc2V0U3RhdGUgb25cclxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xyXG4gICAgICAvLyBzZXRTdGF0ZS5cclxuICAgICAgZGlydHlDb21wb25lbnRzLnNwbGljZSgwLCB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCk7XHJcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XHJcbiAgfSxcclxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcclxuXHJcbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XHJcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xyXG4gIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcclxuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xyXG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXHJcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL3RydWUpO1xyXG59XHJcblxyXG5fYXNzaWduKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwge1xyXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcclxuICB9LFxyXG5cclxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XHJcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcclxuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XHJcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xyXG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XHJcbiAgfSxcclxuXHJcbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcclxuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXHJcbiAgICAvLyB3aXRoIHRoaXMgdHJhbnNhY3Rpb24ncyB3cmFwcGVycyBhcm91bmQgaXQuXHJcbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XHJcbiAgfVxyXG59KTtcclxuXHJcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcclxuXHJcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XHJcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcclxuICByZXR1cm4gYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXHJcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cclxuICovXHJcbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xyXG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xyXG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XHJcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byBtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBfcHJvZEludmFyaWFudCgnMTI0JywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IHZvaWQgMDtcclxuXHJcbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XHJcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxyXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxyXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcclxuXHJcbiAgLy8gQW55IHVwZGF0ZXMgZW5xdWV1ZWQgd2hpbGUgcmVjb25jaWxpbmcgbXVzdCBiZSBwZXJmb3JtZWQgYWZ0ZXIgdGhpcyBlbnRpcmVcclxuICAvLyBiYXRjaC4gT3RoZXJ3aXNlLCBpZiBkaXJ0eUNvbXBvbmVudHMgaXMgW0EsIEJdIHdoZXJlIEEgaGFzIGNoaWxkcmVuIEIgYW5kXHJcbiAgLy8gQywgQiBjb3VsZCB1cGRhdGUgdHdpY2UgaW4gYSBzaW5nbGUgYmF0Y2ggaWYgQydzIHJlbmRlciBlbnF1ZXVlcyBhbiB1cGRhdGVcclxuICAvLyB0byBCIChzaW5jZSBCIHdvdWxkIGhhdmUgYWxyZWFkeSB1cGRhdGVkLCB3ZSBzaG91bGQgc2tpcCBpdCwgYW5kIHRoZSBvbmx5XHJcbiAgLy8gd2F5IHdlIGNhbiBrbm93IHRvIGRvIHNvIGlzIGJ5IGNoZWNraW5nIHRoZSBiYXRjaCBjb3VudGVyKS5cclxuICB1cGRhdGVCYXRjaE51bWJlcisrO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxyXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcclxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cclxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XHJcblxyXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXHJcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xyXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxyXG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcclxuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XHJcblxyXG4gICAgdmFyIG1hcmtlck5hbWU7XHJcbiAgICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XHJcbiAgICAgIHZhciBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgLy8gRHVjayB0eXBlIFRvcExldmVsV3JhcHBlci4gVGhpcyBpcyBwcm9iYWJseSBhbHdheXMgdHJ1ZS5cclxuICAgICAgaWYgKGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZS5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyKSB7XHJcbiAgICAgICAgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50O1xyXG4gICAgICB9XHJcbiAgICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgdXBkYXRlOiAnICsgbmFtZWRDb21wb25lbnQuZ2V0TmFtZSgpO1xyXG4gICAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcik7XHJcblxyXG4gICAgaWYgKG1hcmtlck5hbWUpIHtcclxuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYWxsYmFja3MpIHtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcclxuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcclxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXHJcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXHJcbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XHJcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xyXG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XHJcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xyXG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XHJcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcclxuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XHJcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxyXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cclxuICovXHJcbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XHJcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcclxuXHJcbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXHJcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XHJcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXHJcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcclxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxyXG5cclxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcclxuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XHJcbiAgaWYgKGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCkge1xyXG4gICAgY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9IHVwZGF0ZUJhdGNoTnVtYmVyICsgMTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xyXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmV1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjUnKSA6IHZvaWQgMDtcclxuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xyXG59XHJcblxyXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xyXG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcclxuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogX3Byb2RJbnZhcmlhbnQoJzEyNicpIDogdm9pZCAwO1xyXG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcclxuICB9LFxyXG5cclxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcclxuICAgICFfYmF0Y2hpbmdTdHJhdGVneSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTI3JykgOiB2b2lkIDA7XHJcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBfcHJvZEludmFyaWFudCgnMTI4JykgOiB2b2lkIDA7XHJcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogX3Byb2RJbnZhcmlhbnQoJzEyOScpIDogdm9pZCAwO1xyXG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBSZWFjdFVwZGF0ZXMgPSB7XHJcbiAgLyoqXHJcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcclxuXHJcbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxyXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXHJcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcclxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcclxuICBhc2FwOiBhc2FwXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS40LjInOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBOUyA9IHtcclxuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxyXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcclxufTtcclxuXHJcbi8vIFdlIHVzZSBhdHRyaWJ1dGVzIGZvciBldmVyeXRoaW5nIFNWRyBzbyBsZXQncyBhdm9pZCBzb21lIGR1cGxpY2F0aW9uIGFuZCBydW5cclxuLy8gY29kZSBpbnN0ZWFkLlxyXG4vLyBUaGUgZm9sbG93aW5nIGFyZSBhbGwgc3BlY2lmaWVkIGluIHRoZSBIVE1MIGNvbmZpZyBhbHJlYWR5IHNvIHdlIGV4Y2x1ZGUgaGVyZS5cclxuLy8gLSBjbGFzcyAoYXMgY2xhc3NOYW1lKVxyXG4vLyAtIGNvbG9yXHJcbi8vIC0gaGVpZ2h0XHJcbi8vIC0gaWRcclxuLy8gLSBsYW5nXHJcbi8vIC0gbWF4XHJcbi8vIC0gbWVkaWFcclxuLy8gLSBtZXRob2RcclxuLy8gLSBtaW5cclxuLy8gLSBuYW1lXHJcbi8vIC0gc3R5bGVcclxuLy8gLSB0YXJnZXRcclxuLy8gLSB0eXBlXHJcbi8vIC0gd2lkdGhcclxudmFyIEFUVFJTID0ge1xyXG4gIGFjY2VudEhlaWdodDogJ2FjY2VudC1oZWlnaHQnLFxyXG4gIGFjY3VtdWxhdGU6IDAsXHJcbiAgYWRkaXRpdmU6IDAsXHJcbiAgYWxpZ25tZW50QmFzZWxpbmU6ICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxyXG4gIGFsbG93UmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXHJcbiAgYWxwaGFiZXRpYzogMCxcclxuICBhbXBsaXR1ZGU6IDAsXHJcbiAgYXJhYmljRm9ybTogJ2FyYWJpYy1mb3JtJyxcclxuICBhc2NlbnQ6IDAsXHJcbiAgYXR0cmlidXRlTmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxyXG4gIGF0dHJpYnV0ZVR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcclxuICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcclxuICBhemltdXRoOiAwLFxyXG4gIGJhc2VGcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcclxuICBiYXNlUHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcclxuICBiYXNlbGluZVNoaWZ0OiAnYmFzZWxpbmUtc2hpZnQnLFxyXG4gIGJib3g6IDAsXHJcbiAgYmVnaW46IDAsXHJcbiAgYmlhczogMCxcclxuICBieTogMCxcclxuICBjYWxjTW9kZTogJ2NhbGNNb2RlJyxcclxuICBjYXBIZWlnaHQ6ICdjYXAtaGVpZ2h0JyxcclxuICBjbGlwOiAwLFxyXG4gIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcclxuICBjbGlwUnVsZTogJ2NsaXAtcnVsZScsXHJcbiAgY2xpcFBhdGhVbml0czogJ2NsaXBQYXRoVW5pdHMnLFxyXG4gIGNvbG9ySW50ZXJwb2xhdGlvbjogJ2NvbG9yLWludGVycG9sYXRpb24nLFxyXG4gIGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnM6ICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLFxyXG4gIGNvbG9yUHJvZmlsZTogJ2NvbG9yLXByb2ZpbGUnLFxyXG4gIGNvbG9yUmVuZGVyaW5nOiAnY29sb3ItcmVuZGVyaW5nJyxcclxuICBjb250ZW50U2NyaXB0VHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcclxuICBjb250ZW50U3R5bGVUeXBlOiAnY29udGVudFN0eWxlVHlwZScsXHJcbiAgY3Vyc29yOiAwLFxyXG4gIGN4OiAwLFxyXG4gIGN5OiAwLFxyXG4gIGQ6IDAsXHJcbiAgZGVjZWxlcmF0ZTogMCxcclxuICBkZXNjZW50OiAwLFxyXG4gIGRpZmZ1c2VDb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXHJcbiAgZGlyZWN0aW9uOiAwLFxyXG4gIGRpc3BsYXk6IDAsXHJcbiAgZGl2aXNvcjogMCxcclxuICBkb21pbmFudEJhc2VsaW5lOiAnZG9taW5hbnQtYmFzZWxpbmUnLFxyXG4gIGR1cjogMCxcclxuICBkeDogMCxcclxuICBkeTogMCxcclxuICBlZGdlTW9kZTogJ2VkZ2VNb2RlJyxcclxuICBlbGV2YXRpb246IDAsXHJcbiAgZW5hYmxlQmFja2dyb3VuZDogJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcclxuICBlbmQ6IDAsXHJcbiAgZXhwb25lbnQ6IDAsXHJcbiAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxyXG4gIGZpbGw6IDAsXHJcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxyXG4gIGZpbGxSdWxlOiAnZmlsbC1ydWxlJyxcclxuICBmaWx0ZXI6IDAsXHJcbiAgZmlsdGVyUmVzOiAnZmlsdGVyUmVzJyxcclxuICBmaWx0ZXJVbml0czogJ2ZpbHRlclVuaXRzJyxcclxuICBmbG9vZENvbG9yOiAnZmxvb2QtY29sb3InLFxyXG4gIGZsb29kT3BhY2l0eTogJ2Zsb29kLW9wYWNpdHknLFxyXG4gIGZvY3VzYWJsZTogMCxcclxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxyXG4gIGZvbnRTaXplOiAnZm9udC1zaXplJyxcclxuICBmb250U2l6ZUFkanVzdDogJ2ZvbnQtc2l6ZS1hZGp1c3QnLFxyXG4gIGZvbnRTdHJldGNoOiAnZm9udC1zdHJldGNoJyxcclxuICBmb250U3R5bGU6ICdmb250LXN0eWxlJyxcclxuICBmb250VmFyaWFudDogJ2ZvbnQtdmFyaWFudCcsXHJcbiAgZm9udFdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcclxuICBmb3JtYXQ6IDAsXHJcbiAgZnJvbTogMCxcclxuICBmeDogMCxcclxuICBmeTogMCxcclxuICBnMTogMCxcclxuICBnMjogMCxcclxuICBnbHlwaE5hbWU6ICdnbHlwaC1uYW1lJyxcclxuICBnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbDogJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLFxyXG4gIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcclxuICBnbHlwaFJlZjogJ2dseXBoUmVmJyxcclxuICBncmFkaWVudFRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcclxuICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXHJcbiAgaGFuZ2luZzogMCxcclxuICBob3JpekFkdlg6ICdob3Jpei1hZHYteCcsXHJcbiAgaG9yaXpPcmlnaW5YOiAnaG9yaXotb3JpZ2luLXgnLFxyXG4gIGlkZW9ncmFwaGljOiAwLFxyXG4gIGltYWdlUmVuZGVyaW5nOiAnaW1hZ2UtcmVuZGVyaW5nJyxcclxuICAnaW4nOiAwLFxyXG4gIGluMjogMCxcclxuICBpbnRlcmNlcHQ6IDAsXHJcbiAgazogMCxcclxuICBrMTogMCxcclxuICBrMjogMCxcclxuICBrMzogMCxcclxuICBrNDogMCxcclxuICBrZXJuZWxNYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxyXG4gIGtlcm5lbFVuaXRMZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcclxuICBrZXJuaW5nOiAwLFxyXG4gIGtleVBvaW50czogJ2tleVBvaW50cycsXHJcbiAga2V5U3BsaW5lczogJ2tleVNwbGluZXMnLFxyXG4gIGtleVRpbWVzOiAna2V5VGltZXMnLFxyXG4gIGxlbmd0aEFkanVzdDogJ2xlbmd0aEFkanVzdCcsXHJcbiAgbGV0dGVyU3BhY2luZzogJ2xldHRlci1zcGFjaW5nJyxcclxuICBsaWdodGluZ0NvbG9yOiAnbGlnaHRpbmctY29sb3InLFxyXG4gIGxpbWl0aW5nQ29uZUFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxyXG4gIGxvY2FsOiAwLFxyXG4gIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxyXG4gIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxyXG4gIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcclxuICBtYXJrZXJIZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxyXG4gIG1hcmtlclVuaXRzOiAnbWFya2VyVW5pdHMnLFxyXG4gIG1hcmtlcldpZHRoOiAnbWFya2VyV2lkdGgnLFxyXG4gIG1hc2s6IDAsXHJcbiAgbWFza0NvbnRlbnRVbml0czogJ21hc2tDb250ZW50VW5pdHMnLFxyXG4gIG1hc2tVbml0czogJ21hc2tVbml0cycsXHJcbiAgbWF0aGVtYXRpY2FsOiAwLFxyXG4gIG1vZGU6IDAsXHJcbiAgbnVtT2N0YXZlczogJ251bU9jdGF2ZXMnLFxyXG4gIG9mZnNldDogMCxcclxuICBvcGFjaXR5OiAwLFxyXG4gIG9wZXJhdG9yOiAwLFxyXG4gIG9yZGVyOiAwLFxyXG4gIG9yaWVudDogMCxcclxuICBvcmllbnRhdGlvbjogMCxcclxuICBvcmlnaW46IDAsXHJcbiAgb3ZlcmZsb3c6IDAsXHJcbiAgb3ZlcmxpbmVQb3NpdGlvbjogJ292ZXJsaW5lLXBvc2l0aW9uJyxcclxuICBvdmVybGluZVRoaWNrbmVzczogJ292ZXJsaW5lLXRoaWNrbmVzcycsXHJcbiAgcGFpbnRPcmRlcjogJ3BhaW50LW9yZGVyJyxcclxuICBwYW5vc2UxOiAncGFub3NlLTEnLFxyXG4gIHBhdGhMZW5ndGg6ICdwYXRoTGVuZ3RoJyxcclxuICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXHJcbiAgcGF0dGVyblRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxyXG4gIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXHJcbiAgcG9pbnRlckV2ZW50czogJ3BvaW50ZXItZXZlbnRzJyxcclxuICBwb2ludHM6IDAsXHJcbiAgcG9pbnRzQXRYOiAncG9pbnRzQXRYJyxcclxuICBwb2ludHNBdFk6ICdwb2ludHNBdFknLFxyXG4gIHBvaW50c0F0WjogJ3BvaW50c0F0WicsXHJcbiAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxyXG4gIHByZXNlcnZlQXNwZWN0UmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcclxuICBwcmltaXRpdmVVbml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcclxuICByOiAwLFxyXG4gIHJhZGl1czogMCxcclxuICByZWZYOiAncmVmWCcsXHJcbiAgcmVmWTogJ3JlZlknLFxyXG4gIHJlbmRlcmluZ0ludGVudDogJ3JlbmRlcmluZy1pbnRlbnQnLFxyXG4gIHJlcGVhdENvdW50OiAncmVwZWF0Q291bnQnLFxyXG4gIHJlcGVhdER1cjogJ3JlcGVhdER1cicsXHJcbiAgcmVxdWlyZWRFeHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcclxuICByZXF1aXJlZEZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXHJcbiAgcmVzdGFydDogMCxcclxuICByZXN1bHQ6IDAsXHJcbiAgcm90YXRlOiAwLFxyXG4gIHJ4OiAwLFxyXG4gIHJ5OiAwLFxyXG4gIHNjYWxlOiAwLFxyXG4gIHNlZWQ6IDAsXHJcbiAgc2hhcGVSZW5kZXJpbmc6ICdzaGFwZS1yZW5kZXJpbmcnLFxyXG4gIHNsb3BlOiAwLFxyXG4gIHNwYWNpbmc6IDAsXHJcbiAgc3BlY3VsYXJDb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxyXG4gIHNwZWN1bGFyRXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcclxuICBzcGVlZDogMCxcclxuICBzcHJlYWRNZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxyXG4gIHN0YXJ0T2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxyXG4gIHN0ZERldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXHJcbiAgc3RlbWg6IDAsXHJcbiAgc3RlbXY6IDAsXHJcbiAgc3RpdGNoVGlsZXM6ICdzdGl0Y2hUaWxlcycsXHJcbiAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXHJcbiAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxyXG4gIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLFxyXG4gIHN0cmlrZXRocm91Z2hUaGlja25lc3M6ICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsXHJcbiAgc3RyaW5nOiAwLFxyXG4gIHN0cm9rZTogMCxcclxuICBzdHJva2VEYXNoYXJyYXk6ICdzdHJva2UtZGFzaGFycmF5JyxcclxuICBzdHJva2VEYXNob2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxyXG4gIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXHJcbiAgc3Ryb2tlTGluZWpvaW46ICdzdHJva2UtbGluZWpvaW4nLFxyXG4gIHN0cm9rZU1pdGVybGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXHJcbiAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcclxuICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXHJcbiAgc3VyZmFjZVNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcclxuICBzeXN0ZW1MYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcclxuICB0YWJsZVZhbHVlczogJ3RhYmxlVmFsdWVzJyxcclxuICB0YXJnZXRYOiAndGFyZ2V0WCcsXHJcbiAgdGFyZ2V0WTogJ3RhcmdldFknLFxyXG4gIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXHJcbiAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxyXG4gIHRleHRSZW5kZXJpbmc6ICd0ZXh0LXJlbmRlcmluZycsXHJcbiAgdGV4dExlbmd0aDogJ3RleHRMZW5ndGgnLFxyXG4gIHRvOiAwLFxyXG4gIHRyYW5zZm9ybTogMCxcclxuICB1MTogMCxcclxuICB1MjogMCxcclxuICB1bmRlcmxpbmVQb3NpdGlvbjogJ3VuZGVybGluZS1wb3NpdGlvbicsXHJcbiAgdW5kZXJsaW5lVGhpY2tuZXNzOiAndW5kZXJsaW5lLXRoaWNrbmVzcycsXHJcbiAgdW5pY29kZTogMCxcclxuICB1bmljb2RlQmlkaTogJ3VuaWNvZGUtYmlkaScsXHJcbiAgdW5pY29kZVJhbmdlOiAndW5pY29kZS1yYW5nZScsXHJcbiAgdW5pdHNQZXJFbTogJ3VuaXRzLXBlci1lbScsXHJcbiAgdkFscGhhYmV0aWM6ICd2LWFscGhhYmV0aWMnLFxyXG4gIHZIYW5naW5nOiAndi1oYW5naW5nJyxcclxuICB2SWRlb2dyYXBoaWM6ICd2LWlkZW9ncmFwaGljJyxcclxuICB2TWF0aGVtYXRpY2FsOiAndi1tYXRoZW1hdGljYWwnLFxyXG4gIHZhbHVlczogMCxcclxuICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcclxuICB2ZXJzaW9uOiAwLFxyXG4gIHZlcnRBZHZZOiAndmVydC1hZHYteScsXHJcbiAgdmVydE9yaWdpblg6ICd2ZXJ0LW9yaWdpbi14JyxcclxuICB2ZXJ0T3JpZ2luWTogJ3ZlcnQtb3JpZ2luLXknLFxyXG4gIHZpZXdCb3g6ICd2aWV3Qm94JyxcclxuICB2aWV3VGFyZ2V0OiAndmlld1RhcmdldCcsXHJcbiAgdmlzaWJpbGl0eTogMCxcclxuICB3aWR0aHM6IDAsXHJcbiAgd29yZFNwYWNpbmc6ICd3b3JkLXNwYWNpbmcnLFxyXG4gIHdyaXRpbmdNb2RlOiAnd3JpdGluZy1tb2RlJyxcclxuICB4OiAwLFxyXG4gIHhIZWlnaHQ6ICd4LWhlaWdodCcsXHJcbiAgeDE6IDAsXHJcbiAgeDI6IDAsXHJcbiAgeENoYW5uZWxTZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxyXG4gIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxyXG4gIHhsaW5rQXJjcm9sZTogJ3hsaW5rOmFyY3JvbGUnLFxyXG4gIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxyXG4gIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxyXG4gIHhsaW5rU2hvdzogJ3hsaW5rOnNob3cnLFxyXG4gIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXHJcbiAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXHJcbiAgeG1sQmFzZTogJ3htbDpiYXNlJyxcclxuICB4bWxuczogMCxcclxuICB4bWxuc1hsaW5rOiAneG1sbnM6eGxpbmsnLFxyXG4gIHhtbExhbmc6ICd4bWw6bGFuZycsXHJcbiAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnLFxyXG4gIHk6IDAsXHJcbiAgeTE6IDAsXHJcbiAgeTI6IDAsXHJcbiAgeUNoYW5uZWxTZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxyXG4gIHo6IDAsXHJcbiAgem9vbUFuZFBhbjogJ3pvb21BbmRQYW4nXHJcbn07XHJcblxyXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XHJcbiAgUHJvcGVydGllczoge30sXHJcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xyXG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcclxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXHJcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxyXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcclxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXHJcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcclxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXHJcbiAgICB4bWxCYXNlOiBOUy54bWwsXHJcbiAgICB4bWxMYW5nOiBOUy54bWwsXHJcbiAgICB4bWxTcGFjZTogTlMueG1sXHJcbiAgfSxcclxuICBET01BdHRyaWJ1dGVOYW1lczoge31cclxufTtcclxuXHJcbk9iamVjdC5rZXlzKEFUVFJTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW2tleV0gPSAwO1xyXG4gIGlmIChBVFRSU1trZXldKSB7XHJcbiAgICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1trZXldID0gQVRUUlNba2V5XTtcclxuICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZzsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcclxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xyXG5cclxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XHJcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xyXG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XHJcblxyXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcclxuXHJcbnZhciBldmVudFR5cGVzID0ge1xyXG4gIHNlbGVjdDoge1xyXG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcclxuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcclxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXHJcbiAgICB9LFxyXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcclxudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcclxudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xyXG52YXIgbW91c2VEb3duID0gZmFsc2U7XHJcblxyXG4vLyBUcmFjayB3aGV0aGVyIGEgbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cclxuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXHJcbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcclxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxyXG4gKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xyXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxyXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xyXG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxyXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXHJcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcclxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxyXG4gICAgfTtcclxuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xyXG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXHJcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXHJcbiAgICAgIHRvcDogcmFuZ2UuYm91bmRpbmdUb3AsXHJcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxyXG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcclxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XHJcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxyXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxyXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXHJcbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XHJcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcclxuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xyXG5cclxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcblxyXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xyXG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcclxuXHJcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xyXG5cclxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXHJcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxyXG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXHJcbiAqIC0gdGV4dGFyZWFcclxuICogLSBjb250ZW50RWRpdGFibGVcclxuICpcclxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcclxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxyXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxyXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXHJcbiAqL1xyXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XHJcblxyXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXHJcblxyXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcclxuXHJcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xyXG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cclxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxyXG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XHJcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcclxuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXHJcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cclxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcclxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XHJcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxyXG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG5cclxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcclxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XHJcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcclxuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcclxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcclxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXHJcbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cclxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcclxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XHJcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcclxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9LFxyXG5cclxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uU2VsZWN0Jykge1xyXG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xyXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNBbmltYXRpb25FdmVudCcpO1xyXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUb3VjaEV2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudCcpO1xyXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xyXG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xyXG5cclxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XHJcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBUdXJuc1xyXG4gKiBbJ2Fib3J0JywgLi4uXVxyXG4gKiBpbnRvXHJcbiAqIGV2ZW50VHlwZXMgPSB7XHJcbiAqICAgJ2Fib3J0Jzoge1xyXG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcclxuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxyXG4gKiAgICAgICBjYXB0dXJlZDogJ29uQWJvcnRDYXB0dXJlJyxcclxuICogICAgIH0sXHJcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcclxuICogICB9LFxyXG4gKiAgIC4uLlxyXG4gKiB9O1xyXG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XHJcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cclxuICogfTtcclxuICovXHJcbnZhciBldmVudFR5cGVzID0ge307XHJcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcclxuWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2JsdXInLCAnY2FuUGxheScsICdjYW5QbGF5VGhyb3VnaCcsICdjbGljaycsICdjb250ZXh0TWVudScsICdjb3B5JywgJ2N1dCcsICdkb3VibGVDbGljaycsICdkcmFnJywgJ2RyYWdFbmQnLCAnZHJhZ0VudGVyJywgJ2RyYWdFeGl0JywgJ2RyYWdMZWF2ZScsICdkcmFnT3ZlcicsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlcnJvcicsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbG9hZCcsICdsb2FkZWREYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRTdGFydCcsICdtb3VzZURvd24nLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwcm9ncmVzcycsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3Njcm9sbCcsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1Ym1pdCcsICdzdXNwZW5kJywgJ3RpbWVVcGRhdGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XHJcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcclxuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XHJcblxyXG4gIHZhciB0eXBlID0ge1xyXG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcclxuICAgICAgYnViYmxlZDogb25FdmVudCxcclxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcclxuICAgIH0sXHJcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cclxuICB9O1xyXG4gIGV2ZW50VHlwZXNbZXZlbnRdID0gdHlwZTtcclxuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcclxufSk7XHJcblxyXG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0RGljdGlvbmFyeUtleShpbnN0KSB7XHJcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxyXG4gIHJldHVybiAnLicgKyBpbnN0Ll9yb290Tm9kZUlEO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xyXG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcclxufVxyXG5cclxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xyXG5cclxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxyXG5cclxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xyXG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xyXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcclxuICAgICAgY2FzZSAndG9wQWJvcnQnOlxyXG4gICAgICBjYXNlICd0b3BDYW5QbGF5JzpcclxuICAgICAgY2FzZSAndG9wQ2FuUGxheVRocm91Z2gnOlxyXG4gICAgICBjYXNlICd0b3BEdXJhdGlvbkNoYW5nZSc6XHJcbiAgICAgIGNhc2UgJ3RvcEVtcHRpZWQnOlxyXG4gICAgICBjYXNlICd0b3BFbmNyeXB0ZWQnOlxyXG4gICAgICBjYXNlICd0b3BFbmRlZCc6XHJcbiAgICAgIGNhc2UgJ3RvcEVycm9yJzpcclxuICAgICAgY2FzZSAndG9wSW5wdXQnOlxyXG4gICAgICBjYXNlICd0b3BJbnZhbGlkJzpcclxuICAgICAgY2FzZSAndG9wTG9hZCc6XHJcbiAgICAgIGNhc2UgJ3RvcExvYWRlZERhdGEnOlxyXG4gICAgICBjYXNlICd0b3BMb2FkZWRNZXRhZGF0YSc6XHJcbiAgICAgIGNhc2UgJ3RvcExvYWRTdGFydCc6XHJcbiAgICAgIGNhc2UgJ3RvcFBhdXNlJzpcclxuICAgICAgY2FzZSAndG9wUGxheSc6XHJcbiAgICAgIGNhc2UgJ3RvcFBsYXlpbmcnOlxyXG4gICAgICBjYXNlICd0b3BQcm9ncmVzcyc6XHJcbiAgICAgIGNhc2UgJ3RvcFJhdGVDaGFuZ2UnOlxyXG4gICAgICBjYXNlICd0b3BSZXNldCc6XHJcbiAgICAgIGNhc2UgJ3RvcFNlZWtlZCc6XHJcbiAgICAgIGNhc2UgJ3RvcFNlZWtpbmcnOlxyXG4gICAgICBjYXNlICd0b3BTdGFsbGVkJzpcclxuICAgICAgY2FzZSAndG9wU3VibWl0JzpcclxuICAgICAgY2FzZSAndG9wU3VzcGVuZCc6XHJcbiAgICAgIGNhc2UgJ3RvcFRpbWVVcGRhdGUnOlxyXG4gICAgICBjYXNlICd0b3BWb2x1bWVDaGFuZ2UnOlxyXG4gICAgICBjYXNlICd0b3BXYWl0aW5nJzpcclxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xyXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxyXG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXHJcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcclxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxyXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxyXG4gICAgICBjYXNlICd0b3BLZXlVcCc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxyXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcENsaWNrJzpcclxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcclxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXHJcbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcclxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcclxuICAgICAgY2FzZSAndG9wTW91c2VNb3ZlJzpcclxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XHJcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XHJcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XHJcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcclxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wRHJhZyc6XHJcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxyXG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxyXG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XHJcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XHJcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcclxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcclxuICAgICAgY2FzZSAndG9wRHJvcCc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxyXG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XHJcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XHJcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxyXG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxyXG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcclxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BXaGVlbCc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxyXG4gICAgICBjYXNlICd0b3BDdXQnOlxyXG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBfcHJvZEludmFyaWFudCgnODYnLCB0b3BMZXZlbFR5cGUpIDogdm9pZCAwO1xyXG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xyXG4gICAgcmV0dXJuIGV2ZW50O1xyXG4gIH0sXHJcblxyXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcclxuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXHJcbiAgICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XHJcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXHJcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXHJcbiAgICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxyXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XHJcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xyXG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xyXG4gICAgICBpZiAoIW9uQ2xpY2tMaXN0ZW5lcnNba2V5XSkge1xyXG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xyXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XHJcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xyXG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0ucmVtb3ZlKCk7XHJcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxyXG4gKi9cclxudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xyXG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXHJcbiAgZWxhcHNlZFRpbWU6IG51bGwsXHJcbiAgcHNldWRvRWxlbWVudDogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cclxuICovXHJcbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcclxuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbn1cclxuXHJcblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXHJcbiAqL1xyXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcclxuICBkYXRhOiBudWxsXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cclxuICovXHJcbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAgZGF0YVRyYW5zZmVyOiBudWxsXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxufVxyXG5cclxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XHJcblxyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcclxudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XHJcblxyXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cclxuICovXHJcbnZhciBFdmVudEludGVyZmFjZSA9IHtcclxuICB0eXBlOiBudWxsLFxyXG4gIHRhcmdldDogbnVsbCxcclxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXHJcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXHJcbiAgZXZlbnRQaGFzZTogbnVsbCxcclxuICBidWJibGVzOiBudWxsLFxyXG4gIGNhbmNlbGFibGU6IG51bGwsXHJcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcclxuICB9LFxyXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXHJcbiAgaXNUcnVzdGVkOiBudWxsXHJcbn07XHJcblxyXG4vKipcclxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxyXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxyXG4gKlxyXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxyXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcclxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxyXG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxyXG4gKlxyXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XHJcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXHJcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxyXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xyXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XHJcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcclxuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcclxuICB9XHJcblxyXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcclxuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcclxuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XHJcblxyXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcclxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcclxuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xyXG4gICAgfVxyXG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XHJcbiAgICBpZiAobm9ybWFsaXplKSB7XHJcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XHJcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xyXG4gIH1cclxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xyXG5cclxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcclxuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XHJcbiAgICBpZiAoIWV2ZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcclxuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XHJcbiAgfSxcclxuXHJcbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xyXG4gICAgaWYgKCFldmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXHJcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXHJcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXHJcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcclxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXHJcbiAgICAgIC8vIElFIHNwZWNpZmljKS5cclxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xyXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxyXG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cclxuICAgKi9cclxuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cclxuICAgKi9cclxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XHJcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZXZlbnREZWZhdWx0JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbigncHJldmVudERlZmF1bHQnLCBlbXB0eUZ1bmN0aW9uKSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XHJcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXHJcbiAgICBTeW50aGV0aWNFdmVudCA9IG5ldyBQcm94eShTeW50aGV0aWNFdmVudCwge1xyXG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xyXG4gICAgICB9LFxyXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xyXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gJyArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xyXG4gIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXHJcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXHJcbiAqL1xyXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xyXG4gIHZhciBTdXBlciA9IHRoaXM7XHJcblxyXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XHJcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XHJcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XHJcblxyXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xyXG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcclxuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcclxuXHJcbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xyXG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcclxuXHJcbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xyXG59O1xyXG5cclxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcclxuXHJcbi8qKlxyXG4gICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXHJcbiAgKlxyXG4gICogQHBhcmFtIHtvYmplY3R9IFN5bnRoZXRpY0V2ZW50XHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcclxuICAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XHJcbiAgKi9cclxuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XHJcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xyXG4gIHJldHVybiB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBzZXQ6IHNldCxcclxuICAgIGdldDogZ2V0XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xyXG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XHJcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xyXG4gICAgcmV0dXJuIHZhbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcclxuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XHJcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcclxuICAgIHJldHVybiBnZXRWYWw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XHJcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMsICcgKyAneW91XFwncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiAnICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xyXG4gIH1cclxufSIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xyXG4gKi9cclxudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XHJcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcclxuICovXHJcbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xyXG4gIGRhdGE6IG51bGxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbn1cclxuXHJcblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xyXG5cclxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcclxudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xyXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXHJcbiAqL1xyXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcclxuICBrZXk6IGdldEV2ZW50S2V5LFxyXG4gIGxvY2F0aW9uOiBudWxsLFxyXG4gIGN0cmxLZXk6IG51bGwsXHJcbiAgc2hpZnRLZXk6IG51bGwsXHJcbiAgYWx0S2V5OiBudWxsLFxyXG4gIG1ldGFLZXk6IG51bGwsXHJcbiAgcmVwZWF0OiBudWxsLFxyXG4gIGxvY2FsZTogbnVsbCxcclxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXHJcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxyXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxyXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxyXG5cclxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XHJcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXHJcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xyXG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9LFxyXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxyXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxyXG5cclxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxyXG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XHJcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXHJcbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxyXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XHJcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSxcclxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxyXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXHJcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xyXG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcclxuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbn1cclxuXHJcblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XHJcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xyXG5cclxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xyXG4gKi9cclxudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAgc2NyZWVuWDogbnVsbCxcclxuICBzY3JlZW5ZOiBudWxsLFxyXG4gIGNsaWVudFg6IG51bGwsXHJcbiAgY2xpZW50WTogbnVsbCxcclxuICBjdHJsS2V5OiBudWxsLFxyXG4gIHNoaWZ0S2V5OiBudWxsLFxyXG4gIGFsdEtleTogbnVsbCxcclxuICBtZXRhS2V5OiBudWxsLFxyXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcclxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXHJcbiAgICAvLyB3aGljaDogIDEgMiAzXHJcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcclxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XHJcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xyXG4gICAgICByZXR1cm4gYnV0dG9uO1xyXG4gICAgfVxyXG4gICAgLy8gSUU8OVxyXG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcclxuICAgIC8vIGJ1dHRvbjogMCAwIDBcclxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcclxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XHJcbiAgfSxcclxuICBidXR0b25zOiBudWxsLFxyXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xyXG4gIH0sXHJcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cclxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcclxuICB9LFxyXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xyXG5cclxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xyXG4gKi9cclxudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAgdG91Y2hlczogbnVsbCxcclxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxyXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxyXG4gIGFsdEtleTogbnVsbCxcclxuICBtZXRhS2V5OiBudWxsLFxyXG4gIGN0cmxLZXk6IG51bGwsXHJcbiAgc2hpZnRLZXk6IG51bGwsXHJcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbn1cclxuXHJcblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIEV2ZW50XHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XHJcbiAqL1xyXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xyXG4gIHByb3BlcnR5TmFtZTogbnVsbCxcclxuICBlbGFwc2VkVGltZTogbnVsbCxcclxuICBwc2V1ZG9FbGVtZW50OiBudWxsXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xyXG5cclxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cclxuICovXHJcbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xyXG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcclxuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcclxuICAgIGlmICh0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcclxuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxyXG4gICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcclxuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cclxuICAgIGlmIChkb2MpIHtcclxuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICB9LFxyXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbn1cclxuXHJcblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cclxuICovXHJcbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xyXG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxyXG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cclxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xyXG4gIH0sXHJcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XHJcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXHJcbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcclxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cclxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcclxuICB9LFxyXG4gIGRlbHRhWjogbnVsbCxcclxuXHJcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXHJcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cclxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxyXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxyXG4gIGRlbHRhTW9kZTogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbnZhciBPQlNFUlZFRF9FUlJPUiA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxyXG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcclxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXHJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxyXG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcclxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxyXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxyXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxyXG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxyXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcclxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXHJcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcclxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cclxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcclxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFVzZSBjYXNlczpcclxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cclxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXHJcbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXHJcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cclxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXHJcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxyXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcclxuICogICBjb250ZW50LlxyXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcclxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cclxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxyXG4gKlxyXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XHJcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxyXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxyXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXHJcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cclxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxyXG4gKlxyXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cclxuICovXHJcbnZhciBUcmFuc2FjdGlvbkltcGwgPSB7XHJcbiAgLyoqXHJcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xyXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcclxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXHJcbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxyXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cclxuICAgKi9cclxuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XHJcbiAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGEpIHtcclxuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhID0gW107XHJcbiAgICB9XHJcbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcclxuICB9LFxyXG5cclxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPn0gQXJyYXkgb2YgdHJhbnNhY3Rpb24gd3JhcHBlcnMuXHJcbiAgICovXHJcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcclxuXHJcbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIHdpdGhpbiBhIHNhZmV0eSB3aW5kb3cuIFVzZSB0aGlzIGZvciB0aGUgdG9wIGxldmVsXHJcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXHJcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXHJcbiAgICogdG8gYmluZCBpbiBtYW55IGNhc2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBTY29wZSB0byBpbnZva2UgZnJvbS5cclxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD89fSBjIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD89fSBmIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxyXG4gICAqL1xyXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyNycpIDogdm9pZCAwO1xyXG4gICAgdmFyIGVycm9yVGhyb3duO1xyXG4gICAgdmFyIHJldDtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcclxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xyXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xyXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXHJcbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcclxuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xyXG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XHJcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xyXG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxyXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cclxuICAgICAgICAgIC8vIGhlcmUuXHJcbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xyXG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XHJcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXHJcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxyXG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXHJcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBPQlNFUlZFRF9FUlJPUjtcclxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IE9CU0VSVkVEX0VSUk9SKSB7XHJcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcclxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXHJcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXHJcbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcclxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcclxuICAgKiBpbnZva2VkKS5cclxuICAgKi9cclxuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcclxuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBfcHJvZEludmFyaWFudCgnMjgnKSA6IHZvaWQgMDtcclxuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcclxuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XHJcbiAgICAgIHZhciBlcnJvclRocm93bjtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXHJcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xyXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXHJcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cclxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XHJcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBPQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XHJcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xyXG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXHJcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXHJcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbkltcGw7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcclxuXHJcbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXHJcblxyXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXHJcblxyXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xyXG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcclxuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcclxuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcclxuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxyXG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XHJcbiAqXHJcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxyXG4gKlxyXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xyXG4gICEobmV4dCAhPSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xyXG5cclxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcblxyXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XHJcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cclxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcclxuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcclxuICAgIHJldHVybiBjdXJyZW50O1xyXG4gIH1cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcclxuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cclxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhY2N1bXVsYXRlSW50bzsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1PRCA9IDY1NTIxO1xyXG5cclxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XHJcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXHJcbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gKGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgU2hlZXRKUyB2ZXJzaW9uKSBoYXMgYmVlbiBvcHRpbWl6ZWRcclxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXHJcbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxyXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcclxuICB2YXIgYSA9IDE7XHJcbiAgdmFyIGIgPSAwO1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xyXG4gIHZhciBtID0gbCAmIH4weDM7XHJcbiAgd2hpbGUgKGkgPCBtKSB7XHJcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcclxuICAgIGZvciAoOyBpIDwgbjsgaSArPSA0KSB7XHJcbiAgICAgIGIgKz0gKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDMpKTtcclxuICAgIH1cclxuICAgIGEgJT0gTU9EO1xyXG4gICAgYiAlPSBNT0Q7XHJcbiAgfVxyXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBiICs9IGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xyXG4gIH1cclxuICBhICU9IE1PRDtcclxuICBiICU9IE1PRDtcclxuICByZXR1cm4gYSB8IGIgPDwgMTY7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xyXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XHJcblxyXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIFwicHJvZHVjdGlvblwiID09PSAndGVzdCcpIHtcclxuICAvLyBUZW1wb3JhcnkgaGFjay5cclxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcclxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcclxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxufVxyXG5cclxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cclxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXHJcbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxyXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xyXG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcclxuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xyXG4gICAgICB2YXIgZXJyb3I7XHJcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXHJcbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cclxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxyXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cclxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcclxuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xyXG4gICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIGVycm9yID0gZXg7XHJcbiAgICAgIH1cclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xyXG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXHJcbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xyXG5cclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XHJcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYzsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4vKiBnbG9iYWxzIE1TQXBwICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXHJcbiAqL1xyXG5cclxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcclxuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmdW5jO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xyXG52YXIgc3R5bGVXYXJuaW5ncyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcclxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcclxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cclxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XHJcbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cclxuICovXHJcbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xyXG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcclxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXHJcbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxyXG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxyXG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XHJcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXHJcbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxyXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xyXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxyXG5cclxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xyXG4gIGlmIChpc0VtcHR5KSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xyXG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XHJcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXHJcbiAgICAgIC8vIGRvZXNuJ3QgcmVxdWlyZSB1bml0cywgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXJuIGFib3V0IGl0LlxyXG4gICAgICBpZiAoY29tcG9uZW50ICYmIHZhbHVlICE9PSAnMCcpIHtcclxuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBvd25lci5nZXROYW1lKCkgOiBudWxsO1xyXG4gICAgICAgIGlmIChvd25lck5hbWUgJiYgIXN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSkge1xyXG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAob3duZXJOYW1lKSB7XHJcbiAgICAgICAgICB2YXIgd2FybmluZ3MgPSBzdHlsZVdhcm5pbmdzW293bmVyTmFtZV07XHJcbiAgICAgICAgICB3YXJuZWQgPSB3YXJuaW5nc1tuYW1lXTtcclxuICAgICAgICAgIGlmICghd2FybmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmdzW25hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcclxuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYSBgJXNgIHRhZyAob3duZXI6IGAlc2ApIHdhcyBwYXNzZWQgYSBudW1lcmljIHN0cmluZyB2YWx1ZSAnICsgJ2ZvciBDU1MgcHJvcGVydHkgYCVzYCAodmFsdWU6IGAlc2ApIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCAnICsgJ2FzIGEgdW5pdGxlc3MgbnVtYmVyIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3QuJywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLCBvd25lck5hbWUgfHwgJ3Vua25vd24nLCBuYW1lLCB2YWx1ZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlICsgJ3B4JztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBCYXNlZCBvbiB0aGUgZXNjYXBlLWh0bWwgbGlicmFyeSwgd2hpY2ggaXMgdXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgYmVsb3c6XHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBBbmRyZWFzIEx1YmJlXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuICogQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcclxuLyoqXHJcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XHJcblxyXG4vKipcclxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICogQHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xyXG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XHJcblxyXG4gIGlmICghbWF0Y2gpIHtcclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuICB2YXIgZXNjYXBlO1xyXG4gIHZhciBodG1sID0gJyc7XHJcbiAgdmFyIGluZGV4ID0gMDtcclxuICB2YXIgbGFzdEluZGV4ID0gMDtcclxuXHJcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgIGNhc2UgMzQ6XHJcbiAgICAgICAgLy8gXCJcclxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzODpcclxuICAgICAgICAvLyAmXHJcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzOTpcclxuICAgICAgICAvLyAnXHJcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNjA6XHJcbiAgICAgICAgLy8gPFxyXG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA2MjpcclxuICAgICAgICAvLyA+XHJcbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XHJcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICBodG1sICs9IGVzY2FwZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xyXG59XHJcbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxyXG5cclxuXHJcbi8qKlxyXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cclxuICpcclxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcclxuICBpZiAodHlwZW9mIHRleHQgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcclxuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcclxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxyXG4gICAgLy8gZm9yIG51bWVyaWMgZG9tIGlkcy5cclxuICAgIHJldHVybiAnJyArIHRleHQ7XHJcbiAgfVxyXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xyXG5cclxudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLmZpbmRkb21ub2RlXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XHJcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xyXG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgdmFyIGluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChjb21wb25lbnRPckVsZW1lbnQpO1xyXG4gIGlmIChpbnN0KSB7XHJcbiAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XHJcbiAgICByZXR1cm4gaW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIDogbnVsbDtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0NCcpIDogdm9pZCAwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzQ1JywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiB2b2lkIDA7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XHJcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XHJcblxyXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIFwicHJvZHVjdGlvblwiID09PSAndGVzdCcpIHtcclxuICAvLyBUZW1wb3JhcnkgaGFjay5cclxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcclxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcclxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cclxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cclxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxyXG4gKiBAcGFyYW0ge251bWJlcj19IHNlbGZEZWJ1Z0lEIE9wdGlvbmFsIGRlYnVnSUQgb2YgdGhlIGN1cnJlbnQgaW50ZXJuYWwgaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xyXG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxyXG4gIGlmICh0cmF2ZXJzZUNvbnRleHQgJiYgdHlwZW9mIHRyYXZlcnNlQ29udGV4dCA9PT0gJ29iamVjdCcpIHtcclxuICAgIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XHJcbiAgICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcclxuICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWtleVVuaXF1ZSkge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcclxuICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxyXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cclxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIHNlbGZEZWJ1Z0lEKSB7XHJcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxuICB9XHJcbiAgdmFyIHJlc3VsdCA9IHt9O1xyXG5cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcclxuICAgICAgcmV0dXJuIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcclxuICAgIH0sIHJlc3VsdCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxyXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXHJcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxyXG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xyXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xyXG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcclxuICB9IGVsc2UgaWYgKGFycikge1xyXG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcclxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxyXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cclxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcclxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcclxuICB2YXIgY2hhckNvZGU7XHJcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xyXG5cclxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xyXG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcclxuXHJcbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXHJcbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcclxuICAgICAgY2hhckNvZGUgPSAxMztcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cclxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcclxuICB9XHJcblxyXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxyXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXHJcbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xyXG4gICAgcmV0dXJuIGNoYXJDb2RlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIDA7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcclxuICovXHJcbnZhciBub3JtYWxpemVLZXkgPSB7XHJcbiAgJ0VzYyc6ICdFc2NhcGUnLFxyXG4gICdTcGFjZWJhcic6ICcgJyxcclxuICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxyXG4gICdVcCc6ICdBcnJvd1VwJyxcclxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXHJcbiAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcclxuICAnRGVsJzogJ0RlbGV0ZScsXHJcbiAgJ1dpbic6ICdPUycsXHJcbiAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxyXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcclxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxyXG4gICdNb3pQcmludGFibGVLZXknOiAnVW5pZGVudGlmaWVkJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxyXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXHJcbiAqL1xyXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XHJcbiAgODogJ0JhY2tzcGFjZScsXHJcbiAgOTogJ1RhYicsXHJcbiAgMTI6ICdDbGVhcicsXHJcbiAgMTM6ICdFbnRlcicsXHJcbiAgMTY6ICdTaGlmdCcsXHJcbiAgMTc6ICdDb250cm9sJyxcclxuICAxODogJ0FsdCcsXHJcbiAgMTk6ICdQYXVzZScsXHJcbiAgMjA6ICdDYXBzTG9jaycsXHJcbiAgMjc6ICdFc2NhcGUnLFxyXG4gIDMyOiAnICcsXHJcbiAgMzM6ICdQYWdlVXAnLFxyXG4gIDM0OiAnUGFnZURvd24nLFxyXG4gIDM1OiAnRW5kJyxcclxuICAzNjogJ0hvbWUnLFxyXG4gIDM3OiAnQXJyb3dMZWZ0JyxcclxuICAzODogJ0Fycm93VXAnLFxyXG4gIDM5OiAnQXJyb3dSaWdodCcsXHJcbiAgNDA6ICdBcnJvd0Rvd24nLFxyXG4gIDQ1OiAnSW5zZXJ0JyxcclxuICA0NjogJ0RlbGV0ZScsXHJcbiAgMTEyOiAnRjEnLCAxMTM6ICdGMicsIDExNDogJ0YzJywgMTE1OiAnRjQnLCAxMTY6ICdGNScsIDExNzogJ0Y2JyxcclxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxyXG4gIDE0NDogJ051bUxvY2snLFxyXG4gIDE0NTogJ1Njcm9sbExvY2snLFxyXG4gIDIyNDogJ01ldGEnXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xyXG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcclxuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xyXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxyXG5cclxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXHJcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cclxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XHJcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xyXG4gICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxyXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XHJcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcclxuXHJcbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cclxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxyXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcclxuICB9XHJcbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XHJcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXHJcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxyXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xyXG4gIH1cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXHJcbiAqL1xyXG5cclxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xyXG4gICdBbHQnOiAnYWx0S2V5JyxcclxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcclxuICAnTWV0YSc6ICdtZXRhS2V5JyxcclxuICAnU2hpZnQnOiAnc2hpZnRLZXknXHJcbn07XHJcblxyXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxyXG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXHJcbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXHJcbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XHJcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcclxuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcclxuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xyXG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcclxuICB9XHJcbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xyXG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcclxuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxyXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcclxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xyXG5cclxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXHJcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cclxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxyXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudFRhcmdldDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XHJcblxyXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KSB7XHJcbiAgdmFyIHR5cGU7XHJcblxyXG4gIHdoaWxlICgodHlwZSA9IGluc3QuX3JlbmRlcmVkTm9kZVR5cGUpID09PSBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEUpIHtcclxuICAgIGluc3QgPSBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5IT1NUKSB7XHJcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XHJcbiAgfSBlbHNlIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKiBnbG9iYWwgU3ltYm9sICovXHJcblxyXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XHJcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cclxuICpcclxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XHJcbiAqXHJcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XHJcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xyXG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XHJcbiAqICAgICAgIC4uLlxyXG4gKiAgICAgfVxyXG4gKlxyXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcclxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XHJcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcclxuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiBpdGVyYXRvckZuO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgbmV4dERlYnVnSUQgPSAxO1xyXG5cclxuZnVuY3Rpb24gZ2V0TmV4dERlYnVnSUQoKSB7XHJcbiAgcmV0dXJuIG5leHREZWJ1Z0lEKys7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0TmV4dERlYnVnSUQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxyXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcclxuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcclxuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcclxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxyXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cclxuICovXHJcbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcclxuICB3aGlsZSAobm9kZSkge1xyXG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcclxuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICB9XHJcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cclxuICpcclxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcclxuICogQHJldHVybiB7P29iamVjdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XHJcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcclxuICB2YXIgbm9kZVN0YXJ0ID0gMDtcclxuICB2YXIgbm9kZUVuZCA9IDA7XHJcblxyXG4gIHdoaWxlIChub2RlKSB7XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xyXG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBub2RlOiBub2RlLFxyXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciBjb250ZW50S2V5ID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXHJcbiAqXHJcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcclxuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XHJcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XHJcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxyXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xyXG4gIH1cclxuICByZXR1cm4gY29udGVudEtleTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XHJcbiAgdmFyIHByZWZpeGVzID0ge307XHJcblxyXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xyXG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xyXG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcclxuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gIHJldHVybiBwcmVmaXhlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cclxuICovXHJcbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcclxuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcclxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcclxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXHJcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXHJcbiAqL1xyXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XHJcblxyXG4vKipcclxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXHJcbiAqL1xyXG52YXIgc3R5bGUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxyXG4gKi9cclxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xyXG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XHJcblxyXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXHJcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXHJcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXHJcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cclxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcclxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xyXG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XHJcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLy8gU2FtZSBhcyBhYm92ZVxyXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcclxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcclxuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcclxuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcclxuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XHJcbiAgICByZXR1cm4gZXZlbnROYW1lO1xyXG4gIH1cclxuXHJcbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XHJcblxyXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcclxuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcclxuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcclxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xyXG5cclxudmFyIGdldE5leHREZWJ1Z0lEID0gcmVxdWlyZSgnLi9nZXROZXh0RGVidWdJRCcpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxyXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB0aGlzLmNvbnN0cnVjdChlbGVtZW50KTtcclxufTtcclxuX2Fzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCwge1xyXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XHJcbiAgaWYgKG93bmVyKSB7XHJcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcclxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxyXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXHJcbiAqIEBwcm90ZWN0ZWRcclxuICovXHJcbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSwgc2hvdWxkSGF2ZURlYnVnSUQpIHtcclxuICB2YXIgaW5zdGFuY2U7XHJcblxyXG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XHJcbiAgICBpbnN0YW5jZSA9IFJlYWN0RW1wdHlDb21wb25lbnQuY3JlYXRlKGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XHJcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcclxuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdmFyIGluZm8gPSAnJztcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyAnaXRcXCdzIGRlZmluZWQgaW4uJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oZWxlbWVudC5fb3duZXIpO1xyXG4gICAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiBfcHJvZEludmFyaWFudCgnMTMwJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xyXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgdGVtcG9yYXJpbHkgYXZhaWxhYmxlIGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGFyZSBub3Qgc3RyaW5nXHJcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9ucy4gSS5lLiBBUlQuIE9uY2UgdGhvc2UgYXJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBzdHJpbmdcclxuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxyXG4gICAgICBpbnN0YW5jZSA9IG5ldyBlbGVtZW50LnR5cGUoZWxlbWVudCk7XHJcblxyXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxyXG4gICAgICBpZiAoIWluc3RhbmNlLmdldEhvc3ROb2RlKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPSBpbnN0YW5jZS5nZXROYXRpdmVOb2RlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XHJcbiAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnN0YW5jZUZvclRleHQobm9kZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcxMzEnLCB0eXBlb2Ygbm9kZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG5cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UudW5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJywgJ09ubHkgUmVhY3QgQ29tcG9uZW50cyBjYW4gYmUgbW91bnRlZC4nKSA6IHZvaWQgMDtcclxuICB9XHJcblxyXG4gIC8vIFRoZXNlIHR3byBmaWVsZHMgYXJlIHVzZWQgYnkgdGhlIERPTSBhbmQgQVJUIGRpZmZpbmcgYWxnb3JpdGhtc1xyXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcclxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXHJcbiAgaW5zdGFuY2UuX21vdW50SW5kZXggPSAwO1xyXG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcclxuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBnZXROZXh0RGVidWdJRCgpIDogMDtcclxuICB9XHJcblxyXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcclxuICAvLyBub3QgZ2V0IGFueSBuZXcgZmllbGRzIGFkZGVkIHRvIHRoZW0gYXQgdGhpcyBwb2ludC5cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xyXG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluc3RhbmNlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciB1c2VIYXNGZWF0dXJlO1xyXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XHJcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcclxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXHJcbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcclxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cclxuICpcclxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXHJcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxyXG4gKlxyXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxyXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xyXG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcclxuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XHJcblxyXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcclxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XHJcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XHJcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXHJcbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpc0V2ZW50U3VwcG9ydGVkOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XHJcbiAqL1xyXG5cclxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XHJcbiAgJ2NvbG9yJzogdHJ1ZSxcclxuICAnZGF0ZSc6IHRydWUsXHJcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcclxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICdlbWFpbCc6IHRydWUsXHJcbiAgJ21vbnRoJzogdHJ1ZSxcclxuICAnbnVtYmVyJzogdHJ1ZSxcclxuICAncGFzc3dvcmQnOiB0cnVlLFxyXG4gICdyYW5nZSc6IHRydWUsXHJcbiAgJ3NlYXJjaCc6IHRydWUsXHJcbiAgJ3RlbCc6IHRydWUsXHJcbiAgJ3RleHQnOiB0cnVlLFxyXG4gICd0aW1lJzogdHJ1ZSxcclxuICAndXJsJzogdHJ1ZSxcclxuICAnd2Vlayc6IHRydWVcclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XHJcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcclxuXHJcbi8qKlxyXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cclxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XHJcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxyXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cclxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXHJcbiAqIEl0IGFsd2F5cyB0aHJvd3MuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcclxuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcclxuXHJcbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcclxuXHJcbiAgZm9yICh2YXIgYXJnSWR4ID0gMDsgYXJnSWR4IDwgYXJnQ291bnQ7IGFyZ0lkeCsrKSB7XHJcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcclxuICB9XHJcblxyXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xyXG5cclxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcclxuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXHJcblxyXG4gIHRocm93IGVycm9yO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XHJcblxyXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xyXG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XHJcblxyXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xyXG5cclxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxyXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXHJcbiAqIGV2ZW4gaW4gSUU4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xyXG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxyXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cclxuICAvLyB0aGUgdGFyZ2V0IG5vZGVcclxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcclxuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xyXG4gICAgdmFyIHN2Z05vZGUgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xyXG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xyXG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcclxuICB9XHJcbn0pO1xyXG5cclxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xyXG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xyXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXHJcbiAgLy8gd2hpdGVzcGFjZSBpbiByb290IFRleHROb2RlcyBpcyBhbHNvIGNvbGxhcHNlZC5cclxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxyXG5cclxuICAvLyBGZWF0dXJlIGRldGVjdGlvbjsgb25seSBJRTggaXMga25vd24gdG8gYmVoYXZlIGltcHJvcGVybHkgbGlrZSB0aGlzLlxyXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcclxuICBpZiAodGVzdEVsZW1lbnQuaW5uZXJIVE1MID09PSAnJykge1xyXG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcclxuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXHJcbiAgICAgIC8vIG5vZGVzIHdoZW4gcHJvY2Vzc2luZyBpbm5lckhUTUwsIGlubmVySFRNTCBvbiB1cGRhdGVkIG5vZGVzIHN1ZmZlcnNcclxuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xyXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cclxuICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBvbiBhIGRldGFjaGVkIG5vZGU/XHJcbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cclxuICAgICAgLy8gdGhpbiBhaXIgb24gSUU4LCB0aGlzIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyB2aXNpYmxlIHRleHRcclxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcclxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cclxuICAgICAgaWYgKFdISVRFU1BBQ0VfVEVTVC50ZXN0KGh0bWwpIHx8IGh0bWxbMF0gPT09ICc8JyAmJiBOT05WSVNJQkxFX1RFU1QudGVzdChodG1sKSkge1xyXG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cclxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cclxuICAgICAgICAvLyBVZ2xpZnlKUyBkcm9wcyBVK0ZFRkYgY2hhcnMgd2hlbiBwYXJzaW5nLCBzbyB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxyXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xyXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvYmxvYi92Mi40LjIwL2xpYi9wYXJzZS5qcyNMMjE2XHJcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xyXG5cclxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxyXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cclxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICB0ZXN0RWxlbWVudCA9IG51bGw7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xyXG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxyXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcclxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xyXG4gKiBhcyBpdCBzaG91bGQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XHJcbiAgaWYgKHRleHQpIHtcclxuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xyXG5cclxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcclxuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG59O1xyXG5cclxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xyXG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xyXG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xyXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xyXG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzZXRUZXh0Q29udGVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xyXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xyXG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxyXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XHJcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXHJcbiAqIEBwcm90ZWN0ZWRcclxuICovXHJcblxyXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcclxuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xyXG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XHJcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcclxuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcclxuICB9XHJcblxyXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcclxuICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XHJcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcclxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XHJcblxyXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgU0VQQVJBVE9SID0gJy4nO1xyXG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cclxuICogaXNvbW9ycGhpYyBhbmQgcmVuZGVyZXJzLiBXZSBjb3VsZCBleHRyYWN0IHRoaXMgdG8gYVxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcclxuICogcGF0dGVybi5cclxuICovXHJcblxyXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XHJcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcclxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cclxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xyXG4gICAgLy8gRXhwbGljaXQga2V5XHJcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xyXG4gIH1cclxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxyXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cclxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxyXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cclxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcclxuICogcHJvY2Vzcy5cclxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XHJcblxyXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcclxuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxyXG4gICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XHJcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxyXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cclxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XHJcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxyXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcclxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXHJcbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcblxyXG4gIHZhciBjaGlsZDtcclxuICB2YXIgbmV4dE5hbWU7XHJcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXHJcbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xyXG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcclxuICAgIGlmIChpdGVyYXRvckZuKSB7XHJcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XHJcbiAgICAgIHZhciBzdGVwO1xyXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xyXG4gICAgICAgIHZhciBpaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xyXG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XHJcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XHJcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xyXG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcclxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cclxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xyXG4gICAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XHJcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcclxuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcclxuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XHJcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XHJcbiAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XHJcbiAgICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3VidHJlZUNvdW50O1xyXG59XHJcblxyXG4vKipcclxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XHJcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcclxuICpcclxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxyXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXHJcbiAqXHJcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxyXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxyXG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cclxuICpcclxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXHJcbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXHJcbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xyXG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcclxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxyXG4gIC8vXHJcbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcclxuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxyXG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxyXG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cclxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXHJcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXHJcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cclxuXHJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxyXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcclxuXHJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcclxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxyXG5cclxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XHJcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXHJcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xyXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcclxuXHJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXHJcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcclxuXHJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xyXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcclxuXHJcbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xyXG4gICAgY3VycmVudDogbnVsbCxcclxuXHJcbiAgICBmb3JtVGFnOiBudWxsLFxyXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXHJcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxyXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXHJcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcclxuXHJcbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxyXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcclxuICB9O1xyXG5cclxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XHJcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XHJcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xyXG5cclxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcclxuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xyXG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XHJcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcclxuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XHJcblxyXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcclxuICAgIH1cclxuICAgIGlmICh0YWcgPT09ICdhJykge1xyXG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcclxuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XHJcbiAgICB9XHJcbiAgICBpZiAodGFnID09PSAncCcpIHtcclxuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcclxuICAgIH1cclxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcclxuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcclxuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlclxyXG4gICAqL1xyXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xyXG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXHJcbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcclxuICAgICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xyXG4gICAgICBjYXNlICdvcHRncm91cCc6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xyXG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XHJcbiAgICAgIC8vIGJ1dFxyXG4gICAgICBjYXNlICdvcHRpb24nOlxyXG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XHJcblxyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXHJcbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXHJcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXHJcblxyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxyXG4gICAgICBjYXNlICd0cic6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcclxuICAgICAgY2FzZSAndGJvZHknOlxyXG4gICAgICBjYXNlICd0aGVhZCc6XHJcbiAgICAgIGNhc2UgJ3Rmb290JzpcclxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcclxuXHJcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXHJcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcclxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XHJcblxyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxyXG4gICAgICBjYXNlICd0YWJsZSc6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XHJcblxyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXHJcbiAgICAgIGNhc2UgJ2hlYWQnOlxyXG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxyXG4gICAgICBjYXNlICdodG1sJzpcclxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XHJcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcclxuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcclxuICAgIHN3aXRjaCAodGFnKSB7XHJcbiAgICAgIGNhc2UgJ2gxJzpcclxuICAgICAgY2FzZSAnaDInOlxyXG4gICAgICBjYXNlICdoMyc6XHJcbiAgICAgIGNhc2UgJ2g0JzpcclxuICAgICAgY2FzZSAnaDUnOlxyXG4gICAgICBjYXNlICdoNic6XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xyXG5cclxuICAgICAgY2FzZSAncnAnOlxyXG4gICAgICBjYXNlICdydCc6XHJcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XHJcblxyXG4gICAgICBjYXNlICdib2R5JzpcclxuICAgICAgY2FzZSAnY2FwdGlvbic6XHJcbiAgICAgIGNhc2UgJ2NvbCc6XHJcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcclxuICAgICAgY2FzZSAnZnJhbWUnOlxyXG4gICAgICBjYXNlICdoZWFkJzpcclxuICAgICAgY2FzZSAnaHRtbCc6XHJcbiAgICAgIGNhc2UgJ3Rib2R5JzpcclxuICAgICAgY2FzZSAndGQnOlxyXG4gICAgICBjYXNlICd0Zm9vdCc6XHJcbiAgICAgIGNhc2UgJ3RoJzpcclxuICAgICAgY2FzZSAndGhlYWQnOlxyXG4gICAgICBjYXNlICd0cic6XHJcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcclxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXHJcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXHJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlclxyXG4gICAqL1xyXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XHJcbiAgICBzd2l0Y2ggKHRhZykge1xyXG4gICAgICBjYXNlICdhZGRyZXNzJzpcclxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XHJcbiAgICAgIGNhc2UgJ2FzaWRlJzpcclxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XHJcbiAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxyXG4gICAgICBjYXNlICdkaWFsb2cnOlxyXG4gICAgICBjYXNlICdkaXInOlxyXG4gICAgICBjYXNlICdkaXYnOlxyXG4gICAgICBjYXNlICdkbCc6XHJcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcclxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XHJcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XHJcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XHJcbiAgICAgIGNhc2UgJ2hlYWRlcic6XHJcbiAgICAgIGNhc2UgJ2hncm91cCc6XHJcbiAgICAgIGNhc2UgJ21haW4nOlxyXG4gICAgICBjYXNlICdtZW51JzpcclxuICAgICAgY2FzZSAnbmF2JzpcclxuICAgICAgY2FzZSAnb2wnOlxyXG4gICAgICBjYXNlICdwJzpcclxuICAgICAgY2FzZSAnc2VjdGlvbic6XHJcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxyXG4gICAgICBjYXNlICd1bCc6XHJcblxyXG4gICAgICBjYXNlICdwcmUnOlxyXG4gICAgICBjYXNlICdsaXN0aW5nJzpcclxuXHJcbiAgICAgIGNhc2UgJ3RhYmxlJzpcclxuXHJcbiAgICAgIGNhc2UgJ2hyJzpcclxuXHJcbiAgICAgIGNhc2UgJ3htcCc6XHJcblxyXG4gICAgICBjYXNlICdoMSc6XHJcbiAgICAgIGNhc2UgJ2gyJzpcclxuICAgICAgY2FzZSAnaDMnOlxyXG4gICAgICBjYXNlICdoNCc6XHJcbiAgICAgIGNhc2UgJ2g1JzpcclxuICAgICAgY2FzZSAnaDYnOlxyXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XHJcblxyXG4gICAgICBjYXNlICdmb3JtJzpcclxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xyXG5cclxuICAgICAgY2FzZSAnbGknOlxyXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcclxuXHJcbiAgICAgIGNhc2UgJ2RkJzpcclxuICAgICAgY2FzZSAnZHQnOlxyXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XHJcblxyXG4gICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcclxuXHJcbiAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xyXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cclxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xyXG5cclxuICAgICAgY2FzZSAnbm9icic6XHJcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcclxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0YWNrID0gW107XHJcbiAgICBkbyB7XHJcbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xyXG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcclxuICAgIHN0YWNrLnJldmVyc2UoKTtcclxuICAgIHJldHVybiBzdGFjaztcclxuICB9O1xyXG5cclxuICB2YXIgZGlkV2FybiA9IHt9O1xyXG5cclxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XHJcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XHJcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xyXG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XHJcblxyXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNoaWxkVGFnID09IG51bGwsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKSA6IHZvaWQgMDtcclxuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcclxuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XHJcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcclxuXHJcbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcclxuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xyXG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xyXG5cclxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuXHJcbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xyXG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcclxuXHJcbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcclxuICAgICAgdmFyIGk7XHJcblxyXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xyXG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcclxuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XHJcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xyXG4gICAgICB9KTtcclxuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcclxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XHJcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXHJcbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcclxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXHJcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XHJcblxyXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XHJcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xyXG5cclxuICAgICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XHJcbiAgICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xyXG4gICAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcclxuICAgICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XHJcbiAgICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcclxuICAgICAgICAgIHdoaXRlc3BhY2VJbmZvID0gJyBNYWtlIHN1cmUgeW91IGRvblxcJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gJyArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xyXG4gICAgICAgIHZhciBpbmZvID0gJyc7XHJcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XHJcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgb3duZXJJbmZvLCBpbmZvKSA6IHZvaWQgMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB2b2lkIDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XHJcblxyXG4gIC8vIEZvciB0ZXN0aW5nXHJcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcclxuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcclxuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XHJcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcclxuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xyXG4gIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcclxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xyXG52YXIgUmVhY3RQdXJlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdFB1cmVDb21wb25lbnQnKTtcclxudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcclxudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xyXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcclxudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xyXG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcclxuXHJcbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XHJcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XHJcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcclxuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XHJcbiAgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xyXG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XHJcbn1cclxuXHJcbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcclxuICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCwgJ1JlYWN0Ll9fc3ByZWFkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gVXNlICcgKyAnT2JqZWN0LmFzc2lnbiBkaXJlY3RseSBvciBhbm90aGVyIGhlbHBlciBmdW5jdGlvbiB3aXRoIHNpbWlsYXIgJyArICdzZW1hbnRpY3MuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8geW91ciBjb21waWxlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcHJlYWQtZGVwcmVjYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcclxuICAgIHdhcm5lZCA9IHRydWU7XHJcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWFjdCA9IHtcclxuXHJcbiAgLy8gTW9kZXJuXHJcblxyXG4gIENoaWxkcmVuOiB7XHJcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxyXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxyXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXHJcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXHJcbiAgICBvbmx5OiBvbmx5Q2hpbGRcclxuICB9LFxyXG5cclxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxyXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0UHVyZUNvbXBvbmVudCxcclxuXHJcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcclxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcclxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxyXG5cclxuICAvLyBDbGFzc2ljXHJcblxyXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXHJcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3MsXHJcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcclxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XHJcbiAgICAvLyBDdXJyZW50bHkgYSBub29wLiBXaWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRyYWNlIG1peGlucy5cclxuICAgIHJldHVybiBtaXhpbjtcclxuICB9LFxyXG5cclxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xyXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cclxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxyXG5cclxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXHJcblxyXG4gIC8vIERlcHJlY2F0ZWQgaG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nLlxyXG4gIF9fc3ByZWFkOiBfX3NwcmVhZFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XHJcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xyXG5cclxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XHJcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XHJcblxyXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcclxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcclxuXHJcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XHJcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XHJcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxyXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xyXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXHJcbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXHJcbiAqL1xyXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xyXG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcclxuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcclxuICB0aGlzLmNvdW50ID0gMDtcclxufVxyXG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5mdW5jID0gbnVsbDtcclxuICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gIHRoaXMuY291bnQgPSAwO1xyXG59O1xyXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XHJcblxyXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XHJcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxyXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcclxuXHJcbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxyXG4gKlxyXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gKiBsZWFmIGNoaWxkLlxyXG4gKlxyXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xyXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcclxuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gIH1cclxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xyXG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcclxuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xyXG59XHJcblxyXG4vKipcclxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXHJcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXHJcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cclxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxyXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXHJcbiAqL1xyXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcclxuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcclxuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcclxuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcclxuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xyXG4gIHRoaXMuY291bnQgPSAwO1xyXG59XHJcbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcclxuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XHJcbiAgdGhpcy5mdW5jID0gbnVsbDtcclxuICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gIHRoaXMuY291bnQgPSAwO1xyXG59O1xyXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XHJcblxyXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcclxuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxyXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXHJcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxyXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcclxuXHJcblxyXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XHJcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xyXG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xyXG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcclxuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxyXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xyXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cclxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xyXG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XHJcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XHJcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XHJcbiAgfVxyXG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xyXG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XHJcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xyXG59XHJcblxyXG4vKipcclxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcclxuICpcclxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gKiBsZWFmIGNoaWxkLlxyXG4gKlxyXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cclxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cclxuICovXHJcbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XHJcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxuICB9XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXHJcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxyXG4gKlxyXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxyXG4gKi9cclxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xyXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxyXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XHJcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxyXG4gIG1hcDogbWFwQ2hpbGRyZW4sXHJcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcclxuICBjb3VudDogY291bnRDaGlsZHJlbixcclxuICB0b0FycmF5OiB0b0FycmF5XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcclxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xyXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XHJcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcclxuXHJcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgTUlYSU5TX0tFWSA9ICdtaXhpbnMnO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxyXG4vLyBoYXZlIC5uYW1lIHNldCB0byB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgYmVpbmcgYXNzaWduZWQgdG8uXHJcbmZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XHJcbiAgcmV0dXJuIGZuO1xyXG59XHJcblxyXG4vKipcclxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cclxuICovXHJcblxyXG5cclxudmFyIGluamVjdGVkTWl4aW5zID0gW107XHJcblxyXG4vKipcclxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcclxuICogb3IgaG9zdCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXHJcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcclxuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXHJcbiAqXHJcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XHJcbiAqICAgICB9XHJcbiAqICAgfSk7XHJcbiAqXHJcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcclxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXHJcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cclxuICpcclxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2FycmF5fVxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIG1peGluczogJ0RFRklORV9NQU5ZJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXHJcbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxyXG4gICAqXHJcbiAgICogQHR5cGUge29iamVjdH1cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBzdGF0aWNzOiAnREVGSU5FX01BTlknLFxyXG5cclxuICAvKipcclxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge29iamVjdH1cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGNvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICogQG9wdGlvbmFsXHJcbiAgICovXHJcbiAgY2hpbGRDb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXHJcbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxyXG4gICAqXHJcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxyXG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fVxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGdldERlZmF1bHRQcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxyXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cclxuICAgKlxyXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgKiAgICAgcmV0dXJuIHtcclxuICAgKiAgICAgICBpc09uOiBmYWxzZSxcclxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxyXG4gICAqICAgICB9XHJcbiAgICogICB9XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICogQG9wdGlvbmFsXHJcbiAgICovXHJcbiAgZ2V0SW5pdGlhbFN0YXRlOiAnREVGSU5FX01BTllfTUVSR0VEJyxcclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fVxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcclxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cclxuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cclxuICAgKlxyXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XHJcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xyXG4gICAqICAgfVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XHJcbiAgICogQG5vc2lkZWVmZmVjdHNcclxuICAgKiBAcmVxdWlyZWRcclxuICAgKi9cclxuICByZW5kZXI6ICdERUZJTkVfT05DRScsXHJcblxyXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxyXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXHJcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXHJcbiAgICpcclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBjb21wb25lbnRXaWxsTW91bnQ6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cclxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqXHJcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcclxuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXHJcbiAgICpcclxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcclxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXHJcbiAgICpcclxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcclxuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcclxuICAgKiAgICAgfSk7XHJcbiAgICogICB9XHJcbiAgICpcclxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxyXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcclxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcclxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cclxuICAgKlxyXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcclxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XHJcbiAgICogdXBkYXRlLlxyXG4gICAqXHJcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xyXG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcclxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxyXG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcclxuICAgKiAgIH1cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6ICdERUZJTkVfT05DRScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cclxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXHJcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXHJcbiAgICpcclxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxyXG4gICAqXHJcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAqXHJcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcclxuICAgKiBiZWVuIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXHJcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXHJcbiAgICpcclxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXHJcbiAgICpcclxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cclxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cclxuICAgKlxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAnREVGSU5FX01BTlknLFxyXG5cclxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cclxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAb3ZlcnJpZGFibGVcclxuICAgKi9cclxuICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cclxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xyXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxyXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXHJcbiAqL1xyXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xyXG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XHJcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xyXG4gIH0sXHJcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xyXG4gICAgaWYgKG1peGlucykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xyXG4gICAgfVxyXG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xyXG4gIH0sXHJcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsICdjb250ZXh0Jyk7XHJcbiAgICB9XHJcbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XHJcbiAgfSxcclxuICAvKipcclxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcclxuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cclxuICAgKi9cclxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XHJcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XHJcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcclxuICAgIH1cclxuICB9LFxyXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xyXG4gICAgfVxyXG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xyXG4gIH0sXHJcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XHJcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XHJcbiAgfSxcclxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcclxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XHJcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXHJcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xyXG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xyXG5cclxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxyXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICEoc3BlY1BvbGljeSA9PT0gJ09WRVJSSURFX0JBU0UnKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzczJywgbmFtZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG5cclxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXHJcbiAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcclxuICAgICEoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NCcsIG5hbWUpIDogdm9pZCAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxyXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcclxuICBpZiAoIXNwZWMpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XHJcbiAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xyXG5cclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaXNNaXhpblZhbGlkLCAnJXM6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgJyArICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgKyAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICsgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc1JykgOiB2b2lkIDA7XHJcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NicpIDogdm9pZCAwO1xyXG5cclxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcclxuXHJcbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXHJcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXHJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXHJcbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcclxuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xyXG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XHJcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcclxuICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XHJcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xyXG5cclxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcclxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XHJcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxyXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXHJcbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xyXG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcclxuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XHJcbiAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcclxuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XHJcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XHJcblxyXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXHJcbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyB3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzcnLCBzcGVjUG9saWN5LCBuYW1lKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcclxuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cclxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xyXG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpIHtcclxuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcclxuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXHJcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XHJcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcclxuICBpZiAoIXN0YXRpY3MpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XHJcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xyXG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XHJcbiAgICAhIWlzUmVzZXJ2ZWQgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkIHByb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc4JywgbmFtZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcclxuICAgICEhaXNJbmhlcml0ZWQgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OScsIG5hbWUpIDogdm9pZCAwO1xyXG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cclxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxyXG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XHJcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IF9wcm9kSW52YXJpYW50KCc4MCcpIDogdm9pZCAwO1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XHJcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IFRyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byBnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzIHdpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogX3Byb2RJbnZhcmlhbnQoJzgxJywga2V5KSA6IHZvaWQgMDtcclxuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG9uZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxyXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xyXG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAoYSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBiO1xyXG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcbiAgICB2YXIgYyA9IHt9O1xyXG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcclxuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XHJcbiAgICByZXR1cm4gYztcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXHJcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xyXG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxyXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xyXG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XHJcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XHJcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xyXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XHJcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xyXG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxyXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cclxuICAgICAgLy8gbGV0J3Mgd2Fybi5cclxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcclxuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcclxuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gYm91bmRNZXRob2Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xyXG4gIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcclxuICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XHJcbiAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcclxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cclxuICovXHJcbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxyXG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cclxuICAgKi9cclxuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcclxuICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAZmluYWxcclxuICAgKi9cclxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XHJcbl9hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xyXG4gKi9cclxudmFyIFJlYWN0Q2xhc3MgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cclxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cclxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcclxuICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cclxuICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxyXG4gICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cclxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xyXG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcclxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxyXG5cclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdm9pZCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xyXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcclxuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XHJcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xyXG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xyXG5cclxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXHJcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxyXG5cclxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXHJcbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xyXG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcclxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXHJcbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzgyJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcblxyXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xyXG4gICAgfSk7XHJcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xyXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XHJcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcclxuXHJcbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcclxuXHJcbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cclxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcclxuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxyXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxyXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxyXG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXHJcbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcclxuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xyXG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBfcHJvZEludmFyaWFudCgnODMnKSA6IHZvaWQgMDtcclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cclxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xyXG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xyXG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XHJcbiAgfSxcclxuXHJcbiAgaW5qZWN0aW9uOiB7XHJcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XHJcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcclxuXHJcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcclxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cclxuICovXHJcbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XHJcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XHJcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcclxuICAvLyByZW5kZXJlci5cclxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xyXG59XHJcblxyXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXHJcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXHJcbiAqXHJcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXHJcbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXHJcbiAqXHJcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcclxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXHJcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XHJcbiAqIGNvbXBsZXRlZC5cclxuICpcclxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXHJcbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxyXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxyXG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxyXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxyXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xyXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cclxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxyXG4gKiBAZmluYWxcclxuICogQHByb3RlY3RlZFxyXG4gKi9cclxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcclxuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogX3Byb2RJbnZhcmlhbnQoJzg1JykgOiB2b2lkIDA7XHJcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xyXG4gIGlmIChjYWxsYmFjaykge1xyXG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcclxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcclxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcclxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cclxuICpcclxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXHJcbiAqIEBmaW5hbFxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xyXG4gIGlmIChjYWxsYmFjaykge1xyXG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcclxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcclxuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXHJcbiAqL1xyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcclxuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcclxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXHJcbiAgfTtcclxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcclxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSkgOiB2b2lkIDA7XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcclxuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XHJcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG5mdW5jdGlvbiBpc05hdGl2ZShmbikge1xyXG4gIC8vIEJhc2VkIG9uIGlzTmF0aXZlKCkgZnJvbSBMb2Rhc2hcclxuICB2YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xyXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nXHJcbiAgLy8gVGFrZSBhbiBleGFtcGxlIG5hdGl2ZSBmdW5jdGlvbiBzb3VyY2UgZm9yIGNvbXBhcmlzb25cclxuICAuY2FsbChoYXNPd25Qcm9wZXJ0eSlcclxuICAvLyBTdHJpcCByZWdleCBjaGFyYWN0ZXJzIHNvIHdlIGNhbiB1c2UgaXQgZm9yIHJlZ2V4XHJcbiAgLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcclxuICAvLyBSZW1vdmUgaGFzT3duUHJvcGVydHkgZnJvbSB0aGUgdGVtcGxhdGUgdG8gbWFrZSBpdCBnZW5lcmljXHJcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnKTtcclxuICB0cnkge1xyXG4gICAgdmFyIHNvdXJjZSA9IGZ1bmNUb1N0cmluZy5jYWxsKGZuKTtcclxuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3Qoc291cmNlKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBjYW5Vc2VDb2xsZWN0aW9ucyA9XHJcbi8vIEFycmF5LmZyb21cclxudHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiZcclxuLy8gTWFwXHJcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxyXG4vLyBNYXAucHJvdG90eXBlLmtleXNcclxuTWFwLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwLnByb3RvdHlwZS5rZXlzKSAmJlxyXG4vLyBTZXRcclxudHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQpICYmXHJcbi8vIFNldC5wcm90b3R5cGUua2V5c1xyXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xyXG5cclxudmFyIHNldEl0ZW07XHJcbnZhciBnZXRJdGVtO1xyXG52YXIgcmVtb3ZlSXRlbTtcclxudmFyIGdldEl0ZW1JRHM7XHJcbnZhciBhZGRSb290O1xyXG52YXIgcmVtb3ZlUm9vdDtcclxudmFyIGdldFJvb3RJRHM7XHJcblxyXG5pZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcclxuICB2YXIgaXRlbU1hcCA9IG5ldyBNYXAoKTtcclxuICB2YXIgcm9vdElEU2V0ID0gbmV3IFNldCgpO1xyXG5cclxuICBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XHJcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XHJcbiAgfTtcclxuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xyXG4gIH07XHJcbiAgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xyXG4gIH07XHJcbiAgZ2V0SXRlbUlEcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcclxuICB9O1xyXG5cclxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICByb290SURTZXQuYWRkKGlkKTtcclxuICB9O1xyXG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJvb3RJRFNldFsnZGVsZXRlJ10oaWQpO1xyXG4gIH07XHJcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3RJRFNldC5rZXlzKCkpO1xyXG4gIH07XHJcbn0gZWxzZSB7XHJcbiAgdmFyIGl0ZW1CeUtleSA9IHt9O1xyXG4gIHZhciByb290QnlLZXkgPSB7fTtcclxuXHJcbiAgLy8gVXNlIG5vbi1udW1lcmljIGtleXMgdG8gcHJldmVudCBWOCBwZXJmb3JtYW5jZSBpc3N1ZXM6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxyXG4gIHZhciBnZXRLZXlGcm9tSUQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiAnLicgKyBpZDtcclxuICB9O1xyXG4gIHZhciBnZXRJREZyb21LZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQoa2V5LnN1YnN0cigxKSwgMTApO1xyXG4gIH07XHJcblxyXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcclxuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xyXG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xyXG4gIH07XHJcbiAgZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XHJcbiAgICByZXR1cm4gaXRlbUJ5S2V5W2tleV07XHJcbiAgfTtcclxuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcclxuICAgIGRlbGV0ZSBpdGVtQnlLZXlba2V5XTtcclxuICB9O1xyXG4gIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbUJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcclxuICB9O1xyXG5cclxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcclxuICAgIHJvb3RCeUtleVtrZXldID0gdHJ1ZTtcclxuICB9O1xyXG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xyXG4gICAgZGVsZXRlIHJvb3RCeUtleVtrZXldO1xyXG4gIH07XHJcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290QnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIHB1cmdlRGVlcChpZCkge1xyXG4gIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgaWYgKGl0ZW0pIHtcclxuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XHJcblxyXG4gICAgcmVtb3ZlSXRlbShpZCk7XHJcbiAgICBjaGlsZElEcy5mb3JFYWNoKHB1cmdlRGVlcCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XHJcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcclxuICAgIHJldHVybiAnI2VtcHR5JztcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcclxuICAgIHJldHVybiAnI3RleHQnO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY3JpYmVJRChpZCkge1xyXG4gIHZhciBuYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCk7XHJcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xyXG4gIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcclxuICB2YXIgb3duZXJOYW1lO1xyXG4gIGlmIChvd25lcklEKSB7XHJcbiAgICBvd25lck5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpO1xyXG4gIH1cclxuICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcclxuICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZSwgb3duZXJOYW1lKTtcclxufVxyXG5cclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSB7XHJcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGlkLCBuZXh0Q2hpbGRJRHMpIHtcclxuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgICAhaXRlbSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogX3Byb2RJbnZhcmlhbnQoJzE0NCcpIDogdm9pZCAwO1xyXG4gICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRDaGlsZElEcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgbmV4dENoaWxkSUQgPSBuZXh0Q2hpbGRJRHNbaV07XHJcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXRJdGVtKG5leHRDaGlsZElEKTtcclxuICAgICAgIW5leHRDaGlsZCA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob29rIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MCcpIDogdm9pZCAwO1xyXG4gICAgICAhKG5leHRDaGlsZC5jaGlsZElEcyAhPSBudWxsIHx8IHR5cGVvZiBuZXh0Q2hpbGQuZWxlbWVudCAhPT0gJ29iamVjdCcgfHwgbmV4dENoaWxkLmVsZW1lbnQgPT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25TZXRDaGlsZHJlbigpIHRvIGZpcmUgZm9yIGEgY29udGFpbmVyIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDEnKSA6IHZvaWQgMDtcclxuICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnNzEnKSA6IHZvaWQgMDtcclxuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XHJcbiAgICAgICAgbmV4dENoaWxkLnBhcmVudElEID0gaWQ7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGJ1dCBtb3VudGluZyBhIG5ldyByb290IGR1cmluZyBpblxyXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXHJcbiAgICAgICAgLy8gYmUgcHVyZ2VkIGZyb20gb3VyIHRyZWUgZGF0YSBzbyB0aGVpciBwYXJlbnQgaWQgaXMgbWlzc2luZy5cclxuICAgICAgfVxyXG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uQmVmb3JlTW91bnRDb21wb25lbnQoKSBwYXJlbnQgYW5kIG9uU2V0Q2hpbGRyZW4oKSB0byBiZSBjb25zaXN0ZW50ICglcyBoYXMgcGFyZW50cyAlcyBhbmQgJXMpLicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IF9wcm9kSW52YXJpYW50KCcxNDInLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfSxcclxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XHJcbiAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgcGFyZW50SUQ6IHBhcmVudElELFxyXG4gICAgICB0ZXh0OiBudWxsLFxyXG4gICAgICBjaGlsZElEczogW10sXHJcbiAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgIHVwZGF0ZUNvdW50OiAwXHJcbiAgICB9O1xyXG4gICAgc2V0SXRlbShpZCwgaXRlbSk7XHJcbiAgfSxcclxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XHJcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xyXG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xyXG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxyXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaXRlbS5lbGVtZW50ID0gZWxlbWVudDtcclxuICB9LFxyXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgICFpdGVtID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XHJcbiAgICBpdGVtLmlzTW91bnRlZCA9IHRydWU7XHJcbiAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcclxuICAgIGlmIChpc1Jvb3QpIHtcclxuICAgICAgYWRkUm9vdChpZCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xyXG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xyXG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxyXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaXRlbS51cGRhdGVDb3VudCsrO1xyXG4gIH0sXHJcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgICBpZiAoaXRlbSkge1xyXG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGV4aXN0cy5cclxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnkgY2hpbGQgdGhyZXcgd2hpbGUgbW91bnRpbmcuIFRoZW4gdGhpcyBpbnN0YW5jZSBuZXZlclxyXG4gICAgICAvLyBnb3QgYSBjaGFuY2UgdG8gbW91bnQsIGJ1dCBpdCBzdGlsbCBnZXRzIGFuIHVubW91bnRpbmcgZXZlbnQgZHVyaW5nXHJcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxyXG4gICAgICBpdGVtLmlzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcclxuICAgICAgaWYgKGlzUm9vdCkge1xyXG4gICAgICAgIHJlbW92ZVJvb3QoaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB1bm1vdW50ZWRJRHMucHVzaChpZCk7XHJcbiAgfSxcclxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChSZWFjdENvbXBvbmVudFRyZWVIb29rLl9wcmV2ZW50UHVyZ2luZykge1xyXG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLlxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGlkID0gdW5tb3VudGVkSURzW2ldO1xyXG4gICAgICBwdXJnZURlZXAoaWQpO1xyXG4gICAgfVxyXG4gICAgdW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XHJcbiAgfSxcclxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgIHJldHVybiBpdGVtID8gaXRlbS5pc01vdW50ZWQgOiBmYWxzZTtcclxuICB9LFxyXG4gIGdldEN1cnJlbnRTdGFja0FkZGVuZHVtOiBmdW5jdGlvbiAodG9wRWxlbWVudCkge1xyXG4gICAgdmFyIGluZm8gPSAnJztcclxuICAgIGlmICh0b3BFbGVtZW50KSB7XHJcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUodG9wRWxlbWVudCk7XHJcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xyXG4gICAgICBpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgdG9wRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdXJyZW50T3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xyXG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcclxuXHJcbiAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoaWQpO1xyXG4gICAgcmV0dXJuIGluZm87XHJcbiAgfSxcclxuICBnZXRTdGFja0FkZGVuZHVtQnlJRDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgaW5mbyA9ICcnO1xyXG4gICAgd2hpbGUgKGlkKSB7XHJcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVJRChpZCk7XHJcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5mbztcclxuICB9LFxyXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uY2hpbGRJRHMgOiBbXTtcclxuICB9LFxyXG4gIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcclxuICB9LFxyXG4gIGdldEVsZW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgIHJldHVybiBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcclxuICB9LFxyXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xyXG4gICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Ll9vd25lcikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50Ll9vd25lci5fZGVidWdJRDtcclxuICB9LFxyXG4gIGdldFBhcmVudElEOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xyXG4gIH0sXHJcbiAgZ2V0U291cmNlOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgICB2YXIgZWxlbWVudCA9IGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xyXG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuX3NvdXJjZSA6IG51bGw7XHJcbiAgICByZXR1cm4gc291cmNlO1xyXG4gIH0sXHJcbiAgZ2V0VGV4dDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XHJcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgcmV0dXJuICcnICsgZWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgIHJldHVybiBpdGVtID8gaXRlbS51cGRhdGVDb3VudCA6IDA7XHJcbiAgfSxcclxuXHJcblxyXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHMsXHJcbiAgZ2V0UmVnaXN0ZXJlZElEczogZ2V0SXRlbUlEc1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXHJcbiAqXHJcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcclxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxyXG4gKi9cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xyXG5cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XHJcbiAgICovXHJcbiAgY3VycmVudDogbnVsbFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDdXJyZW50T3duZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG52YXIgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xyXG4gIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXHJcbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0ge1xyXG4gIGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2EnKSxcclxuICBhYmJyOiBjcmVhdGVET01GYWN0b3J5KCdhYmJyJyksXHJcbiAgYWRkcmVzczogY3JlYXRlRE9NRmFjdG9yeSgnYWRkcmVzcycpLFxyXG4gIGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ2FyZWEnKSxcclxuICBhcnRpY2xlOiBjcmVhdGVET01GYWN0b3J5KCdhcnRpY2xlJyksXHJcbiAgYXNpZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FzaWRlJyksXHJcbiAgYXVkaW86IGNyZWF0ZURPTUZhY3RvcnkoJ2F1ZGlvJyksXHJcbiAgYjogY3JlYXRlRE9NRmFjdG9yeSgnYicpLFxyXG4gIGJhc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jhc2UnKSxcclxuICBiZGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JkaScpLFxyXG4gIGJkbzogY3JlYXRlRE9NRmFjdG9yeSgnYmRvJyksXHJcbiAgYmlnOiBjcmVhdGVET01GYWN0b3J5KCdiaWcnKSxcclxuICBibG9ja3F1b3RlOiBjcmVhdGVET01GYWN0b3J5KCdibG9ja3F1b3RlJyksXHJcbiAgYm9keTogY3JlYXRlRE9NRmFjdG9yeSgnYm9keScpLFxyXG4gIGJyOiBjcmVhdGVET01GYWN0b3J5KCdicicpLFxyXG4gIGJ1dHRvbjogY3JlYXRlRE9NRmFjdG9yeSgnYnV0dG9uJyksXHJcbiAgY2FudmFzOiBjcmVhdGVET01GYWN0b3J5KCdjYW52YXMnKSxcclxuICBjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdjYXB0aW9uJyksXHJcbiAgY2l0ZTogY3JlYXRlRE9NRmFjdG9yeSgnY2l0ZScpLFxyXG4gIGNvZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvZGUnKSxcclxuICBjb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbCcpLFxyXG4gIGNvbGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdjb2xncm91cCcpLFxyXG4gIGRhdGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGEnKSxcclxuICBkYXRhbGlzdDogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YWxpc3QnKSxcclxuICBkZDogY3JlYXRlRE9NRmFjdG9yeSgnZGQnKSxcclxuICBkZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlbCcpLFxyXG4gIGRldGFpbHM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RldGFpbHMnKSxcclxuICBkZm46IGNyZWF0ZURPTUZhY3RvcnkoJ2RmbicpLFxyXG4gIGRpYWxvZzogY3JlYXRlRE9NRmFjdG9yeSgnZGlhbG9nJyksXHJcbiAgZGl2OiBjcmVhdGVET01GYWN0b3J5KCdkaXYnKSxcclxuICBkbDogY3JlYXRlRE9NRmFjdG9yeSgnZGwnKSxcclxuICBkdDogY3JlYXRlRE9NRmFjdG9yeSgnZHQnKSxcclxuICBlbTogY3JlYXRlRE9NRmFjdG9yeSgnZW0nKSxcclxuICBlbWJlZDogY3JlYXRlRE9NRmFjdG9yeSgnZW1iZWQnKSxcclxuICBmaWVsZHNldDogY3JlYXRlRE9NRmFjdG9yeSgnZmllbGRzZXQnKSxcclxuICBmaWdjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdmaWdjYXB0aW9uJyksXHJcbiAgZmlndXJlOiBjcmVhdGVET01GYWN0b3J5KCdmaWd1cmUnKSxcclxuICBmb290ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvb3RlcicpLFxyXG4gIGZvcm06IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvcm0nKSxcclxuICBoMTogY3JlYXRlRE9NRmFjdG9yeSgnaDEnKSxcclxuICBoMjogY3JlYXRlRE9NRmFjdG9yeSgnaDInKSxcclxuICBoMzogY3JlYXRlRE9NRmFjdG9yeSgnaDMnKSxcclxuICBoNDogY3JlYXRlRE9NRmFjdG9yeSgnaDQnKSxcclxuICBoNTogY3JlYXRlRE9NRmFjdG9yeSgnaDUnKSxcclxuICBoNjogY3JlYXRlRE9NRmFjdG9yeSgnaDYnKSxcclxuICBoZWFkOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkJyksXHJcbiAgaGVhZGVyOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkZXInKSxcclxuICBoZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2hncm91cCcpLFxyXG4gIGhyOiBjcmVhdGVET01GYWN0b3J5KCdocicpLFxyXG4gIGh0bWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2h0bWwnKSxcclxuICBpOiBjcmVhdGVET01GYWN0b3J5KCdpJyksXHJcbiAgaWZyYW1lOiBjcmVhdGVET01GYWN0b3J5KCdpZnJhbWUnKSxcclxuICBpbWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltZycpLFxyXG4gIGlucHV0OiBjcmVhdGVET01GYWN0b3J5KCdpbnB1dCcpLFxyXG4gIGluczogY3JlYXRlRE9NRmFjdG9yeSgnaW5zJyksXHJcbiAga2JkOiBjcmVhdGVET01GYWN0b3J5KCdrYmQnKSxcclxuICBrZXlnZW46IGNyZWF0ZURPTUZhY3RvcnkoJ2tleWdlbicpLFxyXG4gIGxhYmVsOiBjcmVhdGVET01GYWN0b3J5KCdsYWJlbCcpLFxyXG4gIGxlZ2VuZDogY3JlYXRlRE9NRmFjdG9yeSgnbGVnZW5kJyksXHJcbiAgbGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpJyksXHJcbiAgbGluazogY3JlYXRlRE9NRmFjdG9yeSgnbGluaycpLFxyXG4gIG1haW46IGNyZWF0ZURPTUZhY3RvcnkoJ21haW4nKSxcclxuICBtYXA6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcCcpLFxyXG4gIG1hcms6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcmsnKSxcclxuICBtZW51OiBjcmVhdGVET01GYWN0b3J5KCdtZW51JyksXHJcbiAgbWVudWl0ZW06IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnVpdGVtJyksXHJcbiAgbWV0YTogY3JlYXRlRE9NRmFjdG9yeSgnbWV0YScpLFxyXG4gIG1ldGVyOiBjcmVhdGVET01GYWN0b3J5KCdtZXRlcicpLFxyXG4gIG5hdjogY3JlYXRlRE9NRmFjdG9yeSgnbmF2JyksXHJcbiAgbm9zY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ25vc2NyaXB0JyksXHJcbiAgb2JqZWN0OiBjcmVhdGVET01GYWN0b3J5KCdvYmplY3QnKSxcclxuICBvbDogY3JlYXRlRE9NRmFjdG9yeSgnb2wnKSxcclxuICBvcHRncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnb3B0Z3JvdXAnKSxcclxuICBvcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGlvbicpLFxyXG4gIG91dHB1dDogY3JlYXRlRE9NRmFjdG9yeSgnb3V0cHV0JyksXHJcbiAgcDogY3JlYXRlRE9NRmFjdG9yeSgncCcpLFxyXG4gIHBhcmFtOiBjcmVhdGVET01GYWN0b3J5KCdwYXJhbScpLFxyXG4gIHBpY3R1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BpY3R1cmUnKSxcclxuICBwcmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3ByZScpLFxyXG4gIHByb2dyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdwcm9ncmVzcycpLFxyXG4gIHE6IGNyZWF0ZURPTUZhY3RvcnkoJ3EnKSxcclxuICBycDogY3JlYXRlRE9NRmFjdG9yeSgncnAnKSxcclxuICBydDogY3JlYXRlRE9NRmFjdG9yeSgncnQnKSxcclxuICBydWJ5OiBjcmVhdGVET01GYWN0b3J5KCdydWJ5JyksXHJcbiAgczogY3JlYXRlRE9NRmFjdG9yeSgncycpLFxyXG4gIHNhbXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3NhbXAnKSxcclxuICBzY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3NjcmlwdCcpLFxyXG4gIHNlY3Rpb246IGNyZWF0ZURPTUZhY3RvcnkoJ3NlY3Rpb24nKSxcclxuICBzZWxlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3NlbGVjdCcpLFxyXG4gIHNtYWxsOiBjcmVhdGVET01GYWN0b3J5KCdzbWFsbCcpLFxyXG4gIHNvdXJjZTogY3JlYXRlRE9NRmFjdG9yeSgnc291cmNlJyksXHJcbiAgc3BhbjogY3JlYXRlRE9NRmFjdG9yeSgnc3BhbicpLFxyXG4gIHN0cm9uZzogY3JlYXRlRE9NRmFjdG9yeSgnc3Ryb25nJyksXHJcbiAgc3R5bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0eWxlJyksXHJcbiAgc3ViOiBjcmVhdGVET01GYWN0b3J5KCdzdWInKSxcclxuICBzdW1tYXJ5OiBjcmVhdGVET01GYWN0b3J5KCdzdW1tYXJ5JyksXHJcbiAgc3VwOiBjcmVhdGVET01GYWN0b3J5KCdzdXAnKSxcclxuICB0YWJsZTogY3JlYXRlRE9NRmFjdG9yeSgndGFibGUnKSxcclxuICB0Ym9keTogY3JlYXRlRE9NRmFjdG9yeSgndGJvZHknKSxcclxuICB0ZDogY3JlYXRlRE9NRmFjdG9yeSgndGQnKSxcclxuICB0ZXh0YXJlYTogY3JlYXRlRE9NRmFjdG9yeSgndGV4dGFyZWEnKSxcclxuICB0Zm9vdDogY3JlYXRlRE9NRmFjdG9yeSgndGZvb3QnKSxcclxuICB0aDogY3JlYXRlRE9NRmFjdG9yeSgndGgnKSxcclxuICB0aGVhZDogY3JlYXRlRE9NRmFjdG9yeSgndGhlYWQnKSxcclxuICB0aW1lOiBjcmVhdGVET01GYWN0b3J5KCd0aW1lJyksXHJcbiAgdGl0bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpdGxlJyksXHJcbiAgdHI6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyJyksXHJcbiAgdHJhY2s6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyYWNrJyksXHJcbiAgdTogY3JlYXRlRE9NRmFjdG9yeSgndScpLFxyXG4gIHVsOiBjcmVhdGVET01GYWN0b3J5KCd1bCcpLFxyXG4gICd2YXInOiBjcmVhdGVET01GYWN0b3J5KCd2YXInKSxcclxuICB2aWRlbzogY3JlYXRlRE9NRmFjdG9yeSgndmlkZW8nKSxcclxuICB3YnI6IGNyZWF0ZURPTUZhY3RvcnkoJ3dicicpLFxyXG5cclxuICAvLyBTVkdcclxuICBjaXJjbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpcmNsZScpLFxyXG4gIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxyXG4gIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcclxuICBlbGxpcHNlOiBjcmVhdGVET01GYWN0b3J5KCdlbGxpcHNlJyksXHJcbiAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxyXG4gIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxyXG4gIGxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmUnKSxcclxuICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcclxuICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXHJcbiAgcGF0aDogY3JlYXRlRE9NRmFjdG9yeSgncGF0aCcpLFxyXG4gIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcclxuICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXHJcbiAgcG9seWxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlsaW5lJyksXHJcbiAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXHJcbiAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxyXG4gIHN0b3A6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0b3AnKSxcclxuICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxyXG4gIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcclxuICB0c3BhbjogY3JlYXRlRE9NRmFjdG9yeSgndHNwYW4nKVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcclxuXHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcblxyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcclxuXHJcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcclxuICBrZXk6IHRydWUsXHJcbiAgcmVmOiB0cnVlLFxyXG4gIF9fc2VsZjogdHJ1ZSxcclxuICBfX3NvdXJjZTogdHJ1ZVxyXG59O1xyXG5cclxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xyXG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XHJcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xyXG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XHJcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XHJcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfTtcclxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcclxuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XHJcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfTtcclxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcclxuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xyXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xyXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xyXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHR5cGVcclxuICogQHBhcmFtIHsqfSBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXHJcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcclxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcclxuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xyXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXHJcbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxyXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxyXG4gKiBAcGFyYW0geyp9IG93bmVyXHJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xyXG4gIHZhciBlbGVtZW50ID0ge1xyXG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcclxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXHJcblxyXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxyXG4gICAgdHlwZTogdHlwZSxcclxuICAgIGtleToga2V5LFxyXG4gICAgcmVmOiByZWYsXHJcbiAgICBwcm9wczogcHJvcHMsXHJcblxyXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cclxuICAgIF9vd25lcjogb3duZXJcclxuICB9O1xyXG5cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxyXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cclxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cclxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxyXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcclxuXHJcbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxyXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxyXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcclxuICAgIC8vIGlnbm9yZXMgaXQuXHJcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWU6IHNlbGZcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXHJcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWU6IHNvdXJjZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IGZhbHNlO1xyXG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcclxuICAgICAgZWxlbWVudC5fc291cmNlID0gc291cmNlO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcclxuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcclxuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cclxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcclxuICovXHJcblJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcclxuICB2YXIgcHJvcE5hbWU7XHJcblxyXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcclxuICB2YXIgcHJvcHMgPSB7fTtcclxuXHJcbiAgdmFyIGtleSA9IG51bGw7XHJcbiAgdmFyIHJlZiA9IG51bGw7XHJcbiAgdmFyIHNlbGYgPSBudWxsO1xyXG4gIHZhciBzb3VyY2UgPSBudWxsO1xyXG5cclxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcclxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XHJcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xyXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xyXG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xyXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxyXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcclxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cclxuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cclxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcclxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcclxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcclxuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xyXG4gICAgfVxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcclxuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcclxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xyXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xyXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcclxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgaWYgKGtleSB8fCByZWYpIHtcclxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xyXG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcclxuICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVmKSB7XHJcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxyXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxyXG4gKi9cclxuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcclxuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcclxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cclxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXHJcbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXHJcbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXHJcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcclxuICByZXR1cm4gZmFjdG9yeTtcclxufTtcclxuXHJcblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3S2V5KSB7XHJcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcclxuXHJcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcclxuICovXHJcblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xyXG4gIHZhciBwcm9wTmFtZTtcclxuXHJcbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxyXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xyXG5cclxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXHJcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xyXG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcclxuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxyXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcclxuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXHJcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxyXG4gIC8vIHRydWUgb3duZXIuXHJcbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcclxuXHJcbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxyXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xyXG5cclxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcclxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XHJcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxyXG4gICAgICByZWYgPSBjb25maWcucmVmO1xyXG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xyXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcclxuICAgIHZhciBkZWZhdWx0UHJvcHM7XHJcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcclxuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcclxuICAgIH1cclxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcclxuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXHJcbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXHJcbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XHJcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XHJcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XHJcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xyXG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcclxuICAgIH1cclxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcclxuICB9XHJcblxyXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxyXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxyXG4gKiBAZmluYWxcclxuICovXHJcblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XHJcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXHJcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXHJcbiAqIHRoYXQgc3VwcG9ydCBpdC5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XHJcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XHJcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xyXG5cclxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XHJcblxyXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XHJcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xyXG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XHJcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xyXG4gICAgaWYgKG5hbWUpIHtcclxuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxyXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cclxuICogdXBkYXRlcy5cclxuICovXHJcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xyXG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XHJcblxyXG4gIGlmICghaW5mbykge1xyXG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XHJcbiAgICBpZiAocGFyZW50TmFtZSkge1xyXG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBpbmZvO1xyXG59XHJcblxyXG4vKipcclxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxyXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcclxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXHJcbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xyXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cclxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XHJcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xyXG5cclxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xyXG5cclxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XHJcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcclxuXHJcbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcclxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXHJcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxyXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XHJcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcclxuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxyXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcclxuICB9XHJcblxyXG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCkpIDogdm9pZCAwO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxyXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcclxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cclxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xyXG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xyXG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xyXG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcclxuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXHJcbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcclxuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKG5vZGUpIHtcclxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcclxuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXHJcbiAgICBpZiAoaXRlcmF0b3JGbikge1xyXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XHJcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xyXG4gICAgICAgIHZhciBzdGVwO1xyXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxyXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcclxuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XHJcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XHJcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xyXG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XHJcblxyXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcclxuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XHJcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xyXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cclxuICAgIGlmICghdmFsaWRUeXBlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgaW5mbyA9ICcnO1xyXG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArICdpdFxcJ3MgZGVmaW5lZCBpbi4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXHJcbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXHJcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXHJcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXHJcbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXHJcbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xyXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxyXG4gICAgaWYgKHZhbGlkVHlwZSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9LFxyXG5cclxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xyXG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXHJcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcclxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XHJcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XHJcbiAgfSxcclxuXHJcbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XHJcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xyXG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cclxuICovXHJcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQGZpbmFsXHJcbiAgICovXHJcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXHJcbiAgICogaGF2ZSBwcm9jZXNzZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcclxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cclxuICAgKlxyXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcclxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcclxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcclxuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXHJcbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxyXG4gICAqXHJcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cclxuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcclxuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXHJcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXHJcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XHJcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcclxuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xyXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XHJcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcclxuXHJcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xyXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxyXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxyXG4gKlxyXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XHJcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICogICAgIHByb3BUeXBlczoge1xyXG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXHJcbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXHJcbiAqXHJcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cclxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxyXG4gKlxyXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cclxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxyXG4gKiAgICAgfSxcclxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XHJcbiAqICAgfSk7XHJcbiAqXHJcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcclxuICpcclxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXHJcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xyXG4gKlxyXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXHJcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAqICAgIHByb3BUeXBlczoge1xyXG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cclxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcclxuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XHJcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcclxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcclxuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcclxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xyXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcclxuICogICAgICAgICAgKTtcclxuICogICAgICAgIH1cclxuICogICAgICB9XHJcbiAqICAgIH0sXHJcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxyXG4gKiAgfSk7XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuXHJcbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XHJcblxyXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XHJcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxyXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXHJcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXHJcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXHJcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXHJcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXHJcbiAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXHJcblxyXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcclxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXHJcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXHJcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcclxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxyXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxyXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXHJcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxyXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXHJcbn07XHJcblxyXG4vKipcclxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcclxuICovXHJcbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cclxuZnVuY3Rpb24gaXMoeCwgeSkge1xyXG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cclxuICBpZiAoeCA9PT0geSkge1xyXG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXHJcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxyXG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxyXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcclxuICB9XHJcbn1cclxuLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXHJcblxyXG4vKipcclxuICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxyXG4gKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyIHdlIGRvbid0IHVzZSByZWFsXHJcbiAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cclxuICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxyXG4gKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcclxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gIHRoaXMuc3RhY2sgPSAnJztcclxufVxyXG4vLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXHJcblByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xyXG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xyXG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xyXG4gICAgICAgIGlmICghbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldKSB7XHJcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgKyAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgKyAnYW5kIHdpbGwgbm90IHdvcmsgaW4gcHJvZHVjdGlvbiB3aXRoIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICsgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsIHByb3BGdWxsTmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XHJcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XHJcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XHJcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcclxuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcclxuXHJcbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XHJcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcclxuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XHJcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xyXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cclxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxyXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XHJcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XHJcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xyXG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcclxuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcclxuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcclxuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XHJcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XHJcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xyXG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xyXG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xyXG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcclxuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xyXG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xyXG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcclxuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcclxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcclxuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcclxuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XHJcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XHJcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xyXG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcclxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcclxuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcclxuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcclxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcclxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XHJcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xyXG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xyXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcclxuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XHJcbiAgICAgIGlmICghY2hlY2tlcikge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xyXG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcclxuICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcclxuICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcclxuICAgICAgICB2YXIgc3RlcDtcclxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcclxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXHJcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xyXG4gIC8vIE5hdGl2ZSBTeW1ib2wuXHJcbiAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xyXG4gIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxyXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cclxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XHJcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcclxuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XHJcbiAgICByZXR1cm4gJ2FycmF5JztcclxuICB9XHJcbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxyXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXHJcbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cclxuICAgIHJldHVybiAnb2JqZWN0JztcclxuICB9XHJcbiAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XHJcbiAgICByZXR1cm4gJ3N5bWJvbCc7XHJcbiAgfVxyXG4gIHJldHVybiBwcm9wVHlwZTtcclxufVxyXG5cclxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxyXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cclxuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XHJcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcclxuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICByZXR1cm4gJ2RhdGUnO1xyXG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgcmV0dXJuICdyZWdleHAnO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcHJvcFR5cGU7XHJcbn1cclxuXHJcbi8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXHJcbmZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcclxuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcclxuICAgIHJldHVybiBBTk9OWU1PVVM7XHJcbiAgfVxyXG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcclxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xyXG5cclxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cclxuICovXHJcbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xyXG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBSZWFjdENvbXBvbmVudC5cclxuICB0aGlzLnByb3BzID0gcHJvcHM7XHJcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcclxuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxyXG4gIC8vIHJlbmRlcmVyLlxyXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cclxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gUmVhY3RDb21wb25lbnQucHJvdG90eXBlO1xyXG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XHJcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWFjdFB1cmVDb21wb25lbnQ7XHJcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxyXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XHJcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHRyeSB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XHJcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XHJcbiAgfSBjYXRjaCAoeCkge1xyXG4gICAgLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XHJcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcclxuXHJcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgXCJwcm9kdWN0aW9uXCIgPT09ICd0ZXN0Jykge1xyXG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxyXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxyXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxyXG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxufVxyXG5cclxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cclxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXHJcbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxyXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xyXG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcclxuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xyXG4gICAgICB2YXIgZXJyb3I7XHJcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXHJcbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cclxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxyXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cclxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcclxuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xyXG4gICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIGVycm9yID0gZXg7XHJcbiAgICAgIH1cclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xyXG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXHJcbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xyXG5cclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XHJcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXHJcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxyXG4gKlxyXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXHJcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXHJcbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxyXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXHJcbiAqIHN0cnVjdHVyZS5cclxuICovXHJcbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xyXG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xyXG4gIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcclxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XHJcblxyXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgU0VQQVJBVE9SID0gJy4nO1xyXG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cclxuICogaXNvbW9ycGhpYyBhbmQgcmVuZGVyZXJzLiBXZSBjb3VsZCBleHRyYWN0IHRoaXMgdG8gYVxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcclxuICogcGF0dGVybi5cclxuICovXHJcblxyXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XHJcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcclxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cclxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xyXG4gICAgLy8gRXhwbGljaXQga2V5XHJcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xyXG4gIH1cclxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxyXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cclxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxyXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cclxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcclxuICogcHJvY2Vzcy5cclxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XHJcblxyXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcclxuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxyXG4gICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XHJcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxyXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cclxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XHJcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxyXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcclxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXHJcbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcblxyXG4gIHZhciBjaGlsZDtcclxuICB2YXIgbmV4dE5hbWU7XHJcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXHJcbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xyXG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcclxuICAgIGlmIChpdGVyYXRvckZuKSB7XHJcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XHJcbiAgICAgIHZhciBzdGVwO1xyXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xyXG4gICAgICAgIHZhciBpaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xyXG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XHJcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XHJcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xyXG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcclxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cclxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xyXG4gICAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XHJcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcclxuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcclxuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XHJcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XHJcbiAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XHJcbiAgICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3VidHJlZUNvdW50O1xyXG59XHJcblxyXG4vKipcclxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XHJcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcclxuICpcclxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxyXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXHJcbiAqXHJcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxyXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxyXG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cclxuICpcclxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXHJcbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXHJcbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xyXG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xyXG4iLCIvKiFcclxuICogWFJlZ0V4cC5idWlsZCAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMi0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqIEluc3BpcmVkIGJ5IExlYSBWZXJvdSdzIFJlZ0V4cC5jcmVhdGUgPGxlYS52ZXJvdS5tZT5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFhSZWdFeHApIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgUkVHRVhfREFUQSA9ICd4cmVnZXhwJztcclxuICAgIHZhciBzdWJQYXJ0cyA9IC8oXFwoKSg/IVxcPyl8XFxcXChbMS05XVxcZCopfFxcXFxbXFxzXFxTXXxcXFsoPzpbXlxcXFxcXF1dfFxcXFxbXFxzXFxTXSkqXS9nO1xyXG4gICAgdmFyIHBhcnRzID0gWFJlZ0V4cC51bmlvbihbL1xcKHt7KFtcXHckXSspfX1cXCl8e3soW1xcdyRdKyl9fS8sIHN1YlBhcnRzXSwgJ2cnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmlwcyBhIGxlYWRpbmcgYF5gIGFuZCB0cmFpbGluZyB1bmVzY2FwZWQgYCRgLCBpZiBib3RoIGFyZSBwcmVzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFBhdHRlcm4gdG8gcHJvY2Vzcy5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFBhdHRlcm4gd2l0aCBlZGdlIGFuY2hvcnMgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVhbmNob3IocGF0dGVybikge1xyXG4gICAgICAgIC8vIEFsbG93IGFueSBudW1iZXIgb2YgZW1wdHkgbm9uY2FwdHVyaW5nIGdyb3VwcyBiZWZvcmUvYWZ0ZXIgYW5jaG9ycywgYmVjYXVzZSByZWdleGVzXHJcbiAgICAgICAgLy8gYnVpbHQvZ2VuZXJhdGVkIGJ5IFhSZWdFeHAgc29tZXRpbWVzIGluY2x1ZGUgdGhlbVxyXG4gICAgICAgIHZhciBsZWFkaW5nQW5jaG9yID0gL14oPzpcXChcXD86XFwpKSpcXF4vLFxyXG4gICAgICAgICAgICB0cmFpbGluZ0FuY2hvciA9IC9cXCQoPzpcXChcXD86XFwpKSokLztcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBsZWFkaW5nQW5jaG9yLnRlc3QocGF0dGVybikgJiZcclxuICAgICAgICAgICAgdHJhaWxpbmdBbmNob3IudGVzdChwYXR0ZXJuKSAmJlxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgdHJhaWxpbmcgYCRgIGlzbid0IGVzY2FwZWRcclxuICAgICAgICAgICAgdHJhaWxpbmdBbmNob3IudGVzdChwYXR0ZXJuLnJlcGxhY2UoL1xcXFxbXFxzXFxTXS9nLCAnJykpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UobGVhZGluZ0FuY2hvciwgJycpLnJlcGxhY2UodHJhaWxpbmdBbmNob3IsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIHByb3ZpZGVkIHZhbHVlIHRvIGFuIFhSZWdFeHAuIE5hdGl2ZSBSZWdFeHAgZmxhZ3MgYXJlIG5vdCBwcmVzZXJ2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0LlxyXG4gICAgICogQHJldHVybnMge1JlZ0V4cH0gWFJlZ0V4cCBvYmplY3Qgd2l0aCBYUmVnRXhwIHN5bnRheCBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhc1hSZWdFeHAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gWFJlZ0V4cC5pc1JlZ0V4cCh2YWx1ZSkgP1xyXG4gICAgICAgICAgICAodmFsdWVbUkVHRVhfREFUQV0gJiYgdmFsdWVbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzID9cclxuICAgICAgICAgICAgICAgIC8vIERvbid0IHJlY29tcGlsZSwgdG8gcHJlc2VydmUgY2FwdHVyZSBuYW1lc1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgOlxyXG4gICAgICAgICAgICAgICAgLy8gUmVjb21waWxlIGFzIFhSZWdFeHBcclxuICAgICAgICAgICAgICAgIFhSZWdFeHAodmFsdWUuc291cmNlKVxyXG4gICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgLy8gQ29tcGlsZSBzdHJpbmcgYXMgWFJlZ0V4cFxyXG4gICAgICAgICAgICBYUmVnRXhwKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyByZWdleGVzIHVzaW5nIG5hbWVkIHN1YnBhdHRlcm5zLCBmb3IgcmVhZGFiaWxpdHkgYW5kIHBhdHRlcm4gcmV1c2UuIEJhY2tyZWZlcmVuY2VzIGluXHJcbiAgICAgKiB0aGUgb3V0ZXIgcGF0dGVybiBhbmQgcHJvdmlkZWQgc3VicGF0dGVybnMgYXJlIGF1dG9tYXRpY2FsbHkgcmVudW1iZXJlZCB0byB3b3JrIGNvcnJlY3RseS5cclxuICAgICAqIE5hdGl2ZSBmbGFncyB1c2VkIGJ5IHByb3ZpZGVkIHN1YnBhdHRlcm5zIGFyZSBpZ25vcmVkIGluIGZhdm9yIG9mIHRoZSBgZmxhZ3NgIGFyZ3VtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFhSZWdFeHAgcGF0dGVybiB1c2luZyBge3tuYW1lfX1gIGZvciBlbWJlZGRlZCBzdWJwYXR0ZXJucy4gQWxsb3dzXHJcbiAgICAgKiAgIGAoe3tuYW1lfX0pYCBhcyBzaG9ydGhhbmQgZm9yIGAoPzxuYW1lPnt7bmFtZX19KWAuIFBhdHRlcm5zIGNhbm5vdCBiZSBlbWJlZGRlZCB3aXRoaW5cclxuICAgICAqICAgY2hhcmFjdGVyIGNsYXNzZXMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3VicyBMb29rdXAgb2JqZWN0IGZvciBuYW1lZCBzdWJwYXR0ZXJucy4gVmFsdWVzIGNhbiBiZSBzdHJpbmdzIG9yIHJlZ2V4ZXMuIEFcclxuICAgICAqICAgbGVhZGluZyBgXmAgYW5kIHRyYWlsaW5nIHVuZXNjYXBlZCBgJGAgYXJlIHN0cmlwcGVkIGZyb20gc3VicGF0dGVybnMsIGlmIGJvdGggYXJlIHByZXNlbnQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXSBBbnkgY29tYmluYXRpb24gb2YgWFJlZ0V4cCBmbGFncy5cclxuICAgICAqIEByZXR1cm5zIHtSZWdFeHB9IFJlZ2V4IHdpdGggaW50ZXJwb2xhdGVkIHN1YnBhdHRlcm5zLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdGltZSA9IFhSZWdFeHAuYnVpbGQoJyg/eCleIHt7aG91cnN9fSAoe3ttaW51dGVzfX0pICQnLCB7XHJcbiAgICAgKiAgIGhvdXJzOiBYUmVnRXhwLmJ1aWxkKCd7e2gxMn19IDogfCB7e2gyNH19Jywge1xyXG4gICAgICogICAgIGgxMjogLzFbMC0yXXwwP1sxLTldLyxcclxuICAgICAqICAgICBoMjQ6IC8yWzAtM118WzAxXVswLTldL1xyXG4gICAgICogICB9LCAneCcpLFxyXG4gICAgICogICBtaW51dGVzOiAvXlswLTVdWzAtOV0kL1xyXG4gICAgICogfSk7XHJcbiAgICAgKiB0aW1lLnRlc3QoJzEwOjU5Jyk7IC8vIC0+IHRydWVcclxuICAgICAqIFhSZWdFeHAuZXhlYygnMTA6NTknLCB0aW1lKS5taW51dGVzOyAvLyAtPiAnNTknXHJcbiAgICAgKi9cclxuICAgIFhSZWdFeHAuYnVpbGQgPSBmdW5jdGlvbihwYXR0ZXJuLCBzdWJzLCBmbGFncykge1xyXG4gICAgICAgIHZhciBpbmxpbmVGbGFncyA9IC9eXFwoXFw/KFtcXHckXSspXFwpLy5leGVjKHBhdHRlcm4pLFxyXG4gICAgICAgICAgICBkYXRhID0ge30sXHJcbiAgICAgICAgICAgIG51bUNhcHMgPSAwLCAvLyAnQ2FwcycgaXMgc2hvcnQgZm9yIGNhcHR1cmVzXHJcbiAgICAgICAgICAgIG51bVByaW9yQ2FwcyxcclxuICAgICAgICAgICAgbnVtT3V0ZXJDYXBzID0gMCxcclxuICAgICAgICAgICAgb3V0ZXJDYXBzTWFwID0gWzBdLFxyXG4gICAgICAgICAgICBvdXRlckNhcE5hbWVzLFxyXG4gICAgICAgICAgICBzdWIsXHJcbiAgICAgICAgICAgIHA7XHJcblxyXG4gICAgICAgIC8vIEFkZCBmbGFncyB3aXRoaW4gYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIgdG8gdGhlIG92ZXJhbGwgcGF0dGVybidzIGZsYWdzXHJcbiAgICAgICAgaWYgKGlubGluZUZsYWdzKSB7XHJcbiAgICAgICAgICAgIGZsYWdzID0gZmxhZ3MgfHwgJyc7XHJcbiAgICAgICAgICAgIGlubGluZUZsYWdzWzFdLnJlcGxhY2UoLy4vZywgZnVuY3Rpb24oZmxhZykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgICAgIGZsYWdzICs9IChmbGFncy5pbmRleE9mKGZsYWcpID4gLTEgPyAnJyA6IGZsYWcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAocCBpbiBzdWJzKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJzLmhhc093blByb3BlcnR5KHApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXNzaW5nIHRvIFhSZWdFeHAgZW5hYmxlcyBleHRlbmRlZCBzeW50YXggYW5kIGVuc3VyZXMgaW5kZXBlbmRlbnQgdmFsaWRpdHksXHJcbiAgICAgICAgICAgICAgICAvLyBsZXN0IGFuIHVuZXNjYXBlZCBgKGAsIGApYCwgYFtgLCBvciB0cmFpbGluZyBgXFxgIGJyZWFrcyB0aGUgYCg/OilgIHdyYXBwZXIuIEZvclxyXG4gICAgICAgICAgICAgICAgLy8gc3VicGF0dGVybnMgcHJvdmlkZWQgYXMgbmF0aXZlIHJlZ2V4ZXMsIGl0IGRpZXMgb24gb2N0YWxzIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgLy8gdXNlZCB0byBob2xkIGV4dGVuZGVkIHJlZ2V4IGluc3RhbmNlIGRhdGEsIGZvciBzaW1wbGljaXR5XHJcbiAgICAgICAgICAgICAgICBzdWIgPSBhc1hSZWdFeHAoc3Vic1twXSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhW3BdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlYW5jaG9yaW5nIGFsbG93cyBlbWJlZGRpbmcgaW5kZXBlbmRlbnRseSB1c2VmdWwgYW5jaG9yZWQgcmVnZXhlcy4gSWYgeW91XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhbGx5IG5lZWQgdG8ga2VlcCB5b3VyIGFuY2hvcnMsIGRvdWJsZSB0aGVtIChpLmUuLCBgXl4uLi4kJGApXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZGVhbmNob3Ioc3ViLnNvdXJjZSksXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IHN1YltSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMgfHwgW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBhc3NpbmcgdG8gWFJlZ0V4cCBkaWVzIG9uIG9jdGFscyBhbmQgZW5zdXJlcyB0aGUgb3V0ZXIgcGF0dGVybiBpcyBpbmRlcGVuZGVudGx5IHZhbGlkO1xyXG4gICAgICAgIC8vIGhlbHBzIGtlZXAgdGhpcyBzaW1wbGUuIE5hbWVkIGNhcHR1cmVzIHdpbGwgYmUgcHV0IGJhY2tcclxuICAgICAgICBwYXR0ZXJuID0gYXNYUmVnRXhwKHBhdHRlcm4pO1xyXG4gICAgICAgIG91dGVyQ2FwTmFtZXMgPSBwYXR0ZXJuW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcyB8fCBbXTtcclxuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zb3VyY2UucmVwbGFjZShwYXJ0cywgZnVuY3Rpb24oJDAsICQxLCAkMiwgJDMsICQ0KSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJOYW1lID0gJDEgfHwgJDIsXHJcbiAgICAgICAgICAgICAgICBjYXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgaW50cm8sXHJcbiAgICAgICAgICAgICAgICBsb2NhbENhcEluZGV4O1xyXG4gICAgICAgICAgICAvLyBOYW1lZCBzdWJwYXR0ZXJuXHJcbiAgICAgICAgICAgIGlmIChzdWJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoc3ViTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuZGVmaW5lZCBwcm9wZXJ0eSAnICsgJDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gTmFtZWQgc3VicGF0dGVybiB3YXMgd3JhcHBlZCBpbiBhIGNhcHR1cmluZyBncm91cFxyXG4gICAgICAgICAgICAgICAgaWYgKCQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FwTmFtZSA9IG91dGVyQ2FwTmFtZXNbbnVtT3V0ZXJDYXBzXTtcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckNhcHNNYXBbKytudW1PdXRlckNhcHNdID0gKytudW1DYXBzO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBuYW1lZCBncm91cCwgcHJlc2VydmUgdGhlIG5hbWUuIE90aGVyd2lzZSwgdXNlIHRoZSBzdWJwYXR0ZXJuIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB0aGUgY2FwdHVyZSBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgaW50cm8gPSAnKD88JyArIChjYXBOYW1lIHx8IHN1Yk5hbWUpICsgJz4nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnRybyA9ICcoPzonO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbnVtUHJpb3JDYXBzID0gbnVtQ2FwcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRybyArIGRhdGFbc3ViTmFtZV0ucGF0dGVybi5yZXBsYWNlKHN1YlBhcnRzLCBmdW5jdGlvbihtYXRjaCwgcGFyZW4sIGJhY2tyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJpbmcgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwTmFtZSA9IGRhdGFbc3ViTmFtZV0ubmFtZXNbbnVtQ2FwcyAtIG51bVByaW9yQ2Fwc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrbnVtQ2FwcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2FwdHVyZSBoYXMgYSBuYW1lLCBwcmVzZXJ2ZSB0aGUgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoPzwnICsgY2FwTmFtZSArICc+JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2tyZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJhY2tyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDYXBJbmRleCA9ICtiYWNrcmVmIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV3cml0ZSB0aGUgYmFja3JlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtzdWJOYW1lXS5uYW1lc1tsb2NhbENhcEluZGV4XSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHByZXNlcnZlIHRoZSBiYWNrcmVmZXJlbmNlIG5hbWUgaW4gY2FzZSB1c2luZyBmbGFnIGBuYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxrPCcgKyBkYXRhW3N1Yk5hbWVdLm5hbWVzW2xvY2FsQ2FwSW5kZXhdICsgJz4nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcJyArICgrYmFja3JlZiArIG51bVByaW9yQ2Fwcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgICAgICAgICAgICAgIH0pICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENhcHR1cmluZyBncm91cFxyXG4gICAgICAgICAgICBpZiAoJDMpIHtcclxuICAgICAgICAgICAgICAgIGNhcE5hbWUgPSBvdXRlckNhcE5hbWVzW251bU91dGVyQ2Fwc107XHJcbiAgICAgICAgICAgICAgICBvdXRlckNhcHNNYXBbKytudW1PdXRlckNhcHNdID0gKytudW1DYXBzO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2FwdHVyZSBoYXMgYSBuYW1lLCBwcmVzZXJ2ZSB0aGUgbmFtZVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyg/PCcgKyBjYXBOYW1lICsgJz4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBCYWNrcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJDQpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsQ2FwSW5kZXggPSArJDQgLSAxO1xyXG4gICAgICAgICAgICAgICAgLy8gUmV3cml0ZSB0aGUgYmFja3JlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyQ2FwTmFtZXNbbG9jYWxDYXBJbmRleF0gP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gcHJlc2VydmUgdGhlIGJhY2tyZWZlcmVuY2UgbmFtZSBpbiBjYXNlIHVzaW5nIGZsYWcgYG5gXHJcbiAgICAgICAgICAgICAgICAgICAgJ1xcXFxrPCcgKyBvdXRlckNhcE5hbWVzW2xvY2FsQ2FwSW5kZXhdICsgJz4nIDpcclxuICAgICAgICAgICAgICAgICAgICAnXFxcXCcgKyBvdXRlckNhcHNNYXBbKyQ0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJDA7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBYUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuICAgIH07XHJcblxyXG59O1xyXG4iLCIvKiFcclxuICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZSAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAwOS0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihYUmVnRXhwKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0Y2ggZGV0YWlsIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcHJvdmlkZWQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3cobmFtZSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaCBzdHJpbmdzIGJldHdlZW4gb3V0ZXJtb3N0IGxlZnQgYW5kIHJpZ2h0IGRlbGltaXRlcnMsIG9yIGFuIGFycmF5IG9mXHJcbiAgICAgKiBvYmplY3RzIHdpdGggZGV0YWlsZWQgbWF0Y2ggcGFydHMgYW5kIHBvc2l0aW9uIGRhdGEuIEFuIGVycm9yIGlzIHRocm93biBpZiBkZWxpbWl0ZXJzIGFyZVxyXG4gICAgICogdW5iYWxhbmNlZCB3aXRoaW4gdGhlIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxlZnQgTGVmdCBkZWxpbWl0ZXIgYXMgYW4gWFJlZ0V4cCBwYXR0ZXJuLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJpZ2h0IFJpZ2h0IGRlbGltaXRlciBhcyBhbiBYUmVnRXhwIHBhdHRlcm4uXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXSBBbnkgbmF0aXZlIG9yIFhSZWdFeHAgZmxhZ3MsIHVzZWQgZm9yIHRoZSBsZWZ0IGFuZCByaWdodCBkZWxpbWl0ZXJzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBMZXRzIHlvdSBzcGVjaWZ5IGB2YWx1ZU5hbWVzYCBhbmQgYGVzY2FwZUNoYXJgIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIG1hdGNoZXMsIG9yIGFuIGVtcHR5IGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAvLyBCYXNpYyB1c2FnZVxyXG4gICAgICogdmFyIHN0ciA9ICcodCgoZSkpcyl0KCkoaW5nKSc7XHJcbiAgICAgKiBYUmVnRXhwLm1hdGNoUmVjdXJzaXZlKHN0ciwgJ1xcXFwoJywgJ1xcXFwpJywgJ2cnKTtcclxuICAgICAqIC8vIC0+IFsndCgoZSkpcycsICcnLCAnaW5nJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBFeHRlbmRlZCBpbmZvcm1hdGlvbiBtb2RlIHdpdGggdmFsdWVOYW1lc1xyXG4gICAgICogc3RyID0gJ0hlcmUgaXMgPGRpdj4gPGRpdj5hbjwvZGl2PjwvZGl2PiBleGFtcGxlJztcclxuICAgICAqIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUoc3RyLCAnPGRpdlxcXFxzKj4nLCAnPC9kaXY+JywgJ2dpJywge1xyXG4gICAgICogICB2YWx1ZU5hbWVzOiBbJ2JldHdlZW4nLCAnbGVmdCcsICdtYXRjaCcsICdyaWdodCddXHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vIC0+IFtcclxuICAgICAqIC8vIHtuYW1lOiAnYmV0d2VlbicsIHZhbHVlOiAnSGVyZSBpcyAnLCAgICAgICBzdGFydDogMCwgIGVuZDogOH0sXHJcbiAgICAgKiAvLyB7bmFtZTogJ2xlZnQnLCAgICB2YWx1ZTogJzxkaXY+JywgICAgICAgICAgc3RhcnQ6IDgsICBlbmQ6IDEzfSxcclxuICAgICAqIC8vIHtuYW1lOiAnbWF0Y2gnLCAgIHZhbHVlOiAnIDxkaXY+YW48L2Rpdj4nLCBzdGFydDogMTMsIGVuZDogMjd9LFxyXG4gICAgICogLy8ge25hbWU6ICdyaWdodCcsICAgdmFsdWU6ICc8L2Rpdj4nLCAgICAgICAgIHN0YXJ0OiAyNywgZW5kOiAzM30sXHJcbiAgICAgKiAvLyB7bmFtZTogJ2JldHdlZW4nLCB2YWx1ZTogJyBleGFtcGxlJywgICAgICAgc3RhcnQ6IDMzLCBlbmQ6IDQxfVxyXG4gICAgICogLy8gXVxyXG4gICAgICpcclxuICAgICAqIC8vIE9taXR0aW5nIHVubmVlZGVkIHBhcnRzIHdpdGggbnVsbCB2YWx1ZU5hbWVzLCBhbmQgdXNpbmcgZXNjYXBlQ2hhclxyXG4gICAgICogc3RyID0gJy4uLnsxfS5cXFxce3tmdW5jdGlvbih4LHkpe3JldHVybiB7eTp4fX19JztcclxuICAgICAqIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUoc3RyLCAneycsICd9JywgJ2cnLCB7XHJcbiAgICAgKiAgIHZhbHVlTmFtZXM6IFsnbGl0ZXJhbCcsIG51bGwsICd2YWx1ZScsIG51bGxdLFxyXG4gICAgICogICBlc2NhcGVDaGFyOiAnXFxcXCdcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gLT4gW1xyXG4gICAgICogLy8ge25hbWU6ICdsaXRlcmFsJywgdmFsdWU6ICcuLi4nLCAgc3RhcnQ6IDAsIGVuZDogM30sXHJcbiAgICAgKiAvLyB7bmFtZTogJ3ZhbHVlJywgICB2YWx1ZTogJzEnLCAgICBzdGFydDogNCwgZW5kOiA1fSxcclxuICAgICAqIC8vIHtuYW1lOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLlxcXFx7Jywgc3RhcnQ6IDYsIGVuZDogOX0sXHJcbiAgICAgKiAvLyB7bmFtZTogJ3ZhbHVlJywgICB2YWx1ZTogJ2Z1bmN0aW9uKHgseSl7cmV0dXJuIHt5Onh9fScsIHN0YXJ0OiAxMCwgZW5kOiAzN31cclxuICAgICAqIC8vIF1cclxuICAgICAqXHJcbiAgICAgKiAvLyBTdGlja3kgbW9kZSB2aWEgZmxhZyB5XHJcbiAgICAgKiBzdHIgPSAnPDE+PDw8Mj4+PjwzPjQ8NT4nO1xyXG4gICAgICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZShzdHIsICc8JywgJz4nLCAnZ3knKTtcclxuICAgICAqIC8vIC0+IFsnMScsICc8PDI+PicsICczJ11cclxuICAgICAqL1xyXG4gICAgWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKHN0ciwgbGVmdCwgcmlnaHQsIGZsYWdzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgZmxhZ3MgPSBmbGFncyB8fCAnJztcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgZ2xvYmFsID0gZmxhZ3MuaW5kZXhPZignZycpID4gLTEsXHJcbiAgICAgICAgICAgIHN0aWNreSA9IGZsYWdzLmluZGV4T2YoJ3knKSA+IC0xLFxyXG4gICAgICAgICAgICAvLyBGbGFnIGB5YCBpcyBjb250cm9sbGVkIGludGVybmFsbHlcclxuICAgICAgICAgICAgYmFzaWNGbGFncyA9IGZsYWdzLnJlcGxhY2UoL3kvZywgJycpLFxyXG4gICAgICAgICAgICBlc2NhcGVDaGFyID0gb3B0aW9ucy5lc2NhcGVDaGFyLFxyXG4gICAgICAgICAgICB2TiA9IG9wdGlvbnMudmFsdWVOYW1lcyxcclxuICAgICAgICAgICAgb3V0cHV0ID0gW10sXHJcbiAgICAgICAgICAgIG9wZW5Ub2tlbnMgPSAwLFxyXG4gICAgICAgICAgICBkZWxpbVN0YXJ0ID0gMCxcclxuICAgICAgICAgICAgZGVsaW1FbmQgPSAwLFxyXG4gICAgICAgICAgICBsYXN0T3V0ZXJFbmQgPSAwLFxyXG4gICAgICAgICAgICBvdXRlclN0YXJ0LFxyXG4gICAgICAgICAgICBpbm5lclN0YXJ0LFxyXG4gICAgICAgICAgICBsZWZ0TWF0Y2gsXHJcbiAgICAgICAgICAgIHJpZ2h0TWF0Y2gsXHJcbiAgICAgICAgICAgIGVzYztcclxuICAgICAgICBsZWZ0ID0gWFJlZ0V4cChsZWZ0LCBiYXNpY0ZsYWdzKTtcclxuICAgICAgICByaWdodCA9IFhSZWdFeHAocmlnaHQsIGJhc2ljRmxhZ3MpO1xyXG5cclxuICAgICAgICBpZiAoZXNjYXBlQ2hhcikge1xyXG4gICAgICAgICAgICBpZiAoZXNjYXBlQ2hhci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBlc2NhcGUgY2hhcmFjdGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXNjYXBlQ2hhciA9IFhSZWdFeHAuZXNjYXBlKGVzY2FwZUNoYXIpO1xyXG4gICAgICAgICAgICAvLyBVc2luZyBgWFJlZ0V4cC51bmlvbmAgc2FmZWx5IHJld3JpdGVzIGJhY2tyZWZlcmVuY2VzIGluIGBsZWZ0YCBhbmQgYHJpZ2h0YFxyXG4gICAgICAgICAgICBlc2MgPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAgICAgJyg/OicgKyBlc2NhcGVDaGFyICsgJ1tcXFxcU1xcXFxzXXwoPzooPyEnICtcclxuICAgICAgICAgICAgICAgICAgICBYUmVnRXhwLnVuaW9uKFtsZWZ0LCByaWdodF0pLnNvdXJjZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJylbXicgKyBlc2NhcGVDaGFyICsgJ10pKykrJyxcclxuICAgICAgICAgICAgICAgIC8vIEZsYWdzIGBneWAgbm90IG5lZWRlZCBoZXJlXHJcbiAgICAgICAgICAgICAgICBmbGFncy5yZXBsYWNlKC9bXmltdV0rL2csICcnKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgLy8gSWYgdXNpbmcgYW4gZXNjYXBlIGNoYXJhY3RlciwgYWR2YW5jZSB0byB0aGUgZGVsaW1pdGVyJ3MgbmV4dCBzdGFydGluZyBwb3NpdGlvbixcclxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgYW55IGVzY2FwZWQgY2hhcmFjdGVycyBpbiBiZXR3ZWVuXHJcbiAgICAgICAgICAgIGlmIChlc2NhcGVDaGFyKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxpbUVuZCArPSAoWFJlZ0V4cC5leGVjKHN0ciwgZXNjLCBkZWxpbUVuZCwgJ3N0aWNreScpIHx8IFsnJ10pWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWZ0TWF0Y2ggPSBYUmVnRXhwLmV4ZWMoc3RyLCBsZWZ0LCBkZWxpbUVuZCk7XHJcbiAgICAgICAgICAgIHJpZ2h0TWF0Y2ggPSBYUmVnRXhwLmV4ZWMoc3RyLCByaWdodCwgZGVsaW1FbmQpO1xyXG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBsZWZ0bW9zdCBtYXRjaCBvbmx5XHJcbiAgICAgICAgICAgIGlmIChsZWZ0TWF0Y2ggJiYgcmlnaHRNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRNYXRjaC5pbmRleCA8PSByaWdodE1hdGNoLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRNYXRjaCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRNYXRjaCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUGF0aHMgKExNOiBsZWZ0TWF0Y2gsIFJNOiByaWdodE1hdGNoLCBPVDogb3BlblRva2Vucyk6XHJcbiAgICAgICAgICAgIC8vIExNIHwgUk0gfCBPVCB8IFJlc3VsdFxyXG4gICAgICAgICAgICAvLyAxICB8IDAgIHwgMSAgfCBsb29wXHJcbiAgICAgICAgICAgIC8vIDEgIHwgMCAgfCAwICB8IGxvb3BcclxuICAgICAgICAgICAgLy8gMCAgfCAxICB8IDEgIHwgbG9vcFxyXG4gICAgICAgICAgICAvLyAwICB8IDEgIHwgMCAgfCB0aHJvd1xyXG4gICAgICAgICAgICAvLyAwICB8IDAgIHwgMSAgfCB0aHJvd1xyXG4gICAgICAgICAgICAvLyAwICB8IDAgIHwgMCAgfCBicmVha1xyXG4gICAgICAgICAgICAvLyBUaGUgcGF0aHMgYWJvdmUgZG9uJ3QgaW5jbHVkZSB0aGUgc3RpY2t5IG1vZGUgc3BlY2lhbCBjYXNlLiBUaGUgbG9vcCBlbmRzIGFmdGVyIHRoZVxyXG4gICAgICAgICAgICAvLyBmaXJzdCBjb21wbGV0ZWQgbWF0Y2ggaWYgbm90IGBnbG9iYWxgLlxyXG4gICAgICAgICAgICBpZiAobGVmdE1hdGNoIHx8IHJpZ2h0TWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGRlbGltU3RhcnQgPSAobGVmdE1hdGNoIHx8IHJpZ2h0TWF0Y2gpLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgZGVsaW1FbmQgPSBkZWxpbVN0YXJ0ICsgKGxlZnRNYXRjaCB8fCByaWdodE1hdGNoKVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wZW5Ub2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGlja3kgJiYgIW9wZW5Ub2tlbnMgJiYgZGVsaW1TdGFydCA+IGxhc3RPdXRlckVuZCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnRNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuVG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJTdGFydCA9IGRlbGltU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTdGFydCA9IGRlbGltRW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKytvcGVuVG9rZW5zO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0TWF0Y2ggJiYgb3BlblRva2Vucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEtLW9wZW5Ub2tlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZOWzBdICYmIG91dGVyU3RhcnQgPiBsYXN0T3V0ZXJFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyh2TlswXSwgc3RyLnNsaWNlKGxhc3RPdXRlckVuZCwgb3V0ZXJTdGFydCksIGxhc3RPdXRlckVuZCwgb3V0ZXJTdGFydCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2TlsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KHZOWzFdLCBzdHIuc2xpY2Uob3V0ZXJTdGFydCwgaW5uZXJTdGFydCksIG91dGVyU3RhcnQsIGlubmVyU3RhcnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodk5bMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyh2TlsyXSwgc3RyLnNsaWNlKGlubmVyU3RhcnQsIGRlbGltU3RhcnQpLCBpbm5lclN0YXJ0LCBkZWxpbVN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZOWzNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3codk5bM10sIHN0ci5zbGljZShkZWxpbVN0YXJ0LCBkZWxpbUVuZCksIGRlbGltU3RhcnQsIGRlbGltRW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UoaW5uZXJTdGFydCwgZGVsaW1TdGFydCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsYXN0T3V0ZXJFbmQgPSBkZWxpbUVuZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYmFsYW5jZWQgZGVsaW1pdGVyIGZvdW5kIGluIHN0cmluZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxpbWl0ZXIgbWF0Y2hlZCBhbiBlbXB0eSBzdHJpbmcsIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcclxuICAgICAgICAgICAgaWYgKGRlbGltU3RhcnQgPT09IGRlbGltRW5kKSB7XHJcbiAgICAgICAgICAgICAgICArK2RlbGltRW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZ2xvYmFsICYmICFzdGlja3kgJiYgdk4gJiYgdk5bMF0gJiYgc3RyLmxlbmd0aCA+IGxhc3RPdXRlckVuZCkge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChyb3codk5bMF0sIHN0ci5zbGljZShsYXN0T3V0ZXJFbmQpLCBsYXN0T3V0ZXJFbmQsIHN0ci5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9O1xyXG5cclxufTtcclxuIiwiLyohXHJcbiAqIFhSZWdFeHAgVW5pY29kZSBCYXNlIDMuMS4xXHJcbiAqIDx4cmVnZXhwLmNvbT5cclxuICogU3RldmVuIExldml0aGFuIChjKSAyMDA4LTIwMTYgTUlUIExpY2Vuc2VcclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFhSZWdFeHApIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYmFzZSBzdXBwb3J0IGZvciBVbmljb2RlIG1hdGNoaW5nOlxyXG4gICAgICogLSBBZGRzIHN5bnRheCBgXFxwey4ufWAgZm9yIG1hdGNoaW5nIFVuaWNvZGUgdG9rZW5zLiBUb2tlbnMgY2FuIGJlIGludmVydGVkIHVzaW5nIGBcXFB7Li59YCBvclxyXG4gICAgICogICBgXFxwe14uLn1gLiBUb2tlbiBuYW1lcyBpZ25vcmUgY2FzZSwgc3BhY2VzLCBoeXBoZW5zLCBhbmQgdW5kZXJzY29yZXMuIFlvdSBjYW4gb21pdCB0aGVcclxuICAgICAqICAgYnJhY2VzIGZvciB0b2tlbiBuYW1lcyB0aGF0IGFyZSBhIHNpbmdsZSBsZXR0ZXIgKGUuZy4gYFxccExgIG9yIGBQTGApLlxyXG4gICAgICogLSBBZGRzIGZsYWcgQSAoYXN0cmFsKSwgd2hpY2ggZW5hYmxlcyAyMS1iaXQgVW5pY29kZSBzdXBwb3J0LlxyXG4gICAgICogLSBBZGRzIHRoZSBgWFJlZ0V4cC5hZGRVbmljb2RlRGF0YWAgbWV0aG9kIHVzZWQgYnkgb3RoZXIgYWRkb25zIHRvIHByb3ZpZGUgY2hhcmFjdGVyIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogVW5pY29kZSBCYXNlIHJlbGllcyBvbiBleHRlcm5hbGx5IHByb3ZpZGVkIFVuaWNvZGUgY2hhcmFjdGVyIGRhdGEuIE9mZmljaWFsIGFkZG9ucyBhcmVcclxuICAgICAqIGF2YWlsYWJsZSB0byBwcm92aWRlIGRhdGEgZm9yIFVuaWNvZGUgY2F0ZWdvcmllcywgc2NyaXB0cywgYmxvY2tzLCBhbmQgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVxdWlyZXMgWFJlZ0V4cFxyXG4gICAgICovXHJcblxyXG4gICAgLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcbiAgICAvLyBQcml2YXRlIHN0dWZmXHJcbiAgICAvLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuXHJcbiAgICAvLyBTdG9yYWdlIGZvciBVbmljb2RlIGRhdGFcclxuICAgIHZhciB1bmljb2RlID0ge307XHJcblxyXG4gICAgLy8gUmV1c2UgdXRpbHNcclxuICAgIHZhciBkZWMgPSBYUmVnRXhwLl9kZWM7XHJcbiAgICB2YXIgaGV4ID0gWFJlZ0V4cC5faGV4O1xyXG4gICAgdmFyIHBhZDQgPSBYUmVnRXhwLl9wYWQ0O1xyXG5cclxuICAgIC8vIEdlbmVyYXRlcyBhIHRva2VuIGxvb2t1cCBuYW1lOiBsb3dlcmNhc2UsIHdpdGggaHlwaGVucywgc3BhY2VzLCBhbmQgdW5kZXJzY29yZXMgcmVtb3ZlZFxyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bLSBfXSsvZywgJycpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0cyB0aGUgZGVjaW1hbCBjb2RlIG9mIGEgbGl0ZXJhbCBjb2RlIHVuaXQsIFxceEhILCBcXHVISEhILCBvciBhIGJhY2tzbGFzaC1lc2NhcGVkIGxpdGVyYWxcclxuICAgIGZ1bmN0aW9uIGNoYXJDb2RlKGNocikge1xyXG4gICAgICAgIHZhciBlc2MgPSAvXlxcXFxbeHVdKC4rKS8uZXhlYyhjaHIpO1xyXG4gICAgICAgIHJldHVybiBlc2MgP1xyXG4gICAgICAgICAgICBkZWMoZXNjWzFdKSA6XHJcbiAgICAgICAgICAgIGNoci5jaGFyQ29kZUF0KGNoci5jaGFyQXQoMCkgPT09ICdcXFxcJyA/IDEgOiAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbnZlcnRzIGEgbGlzdCBvZiBvcmRlcmVkIEJNUCBjaGFyYWN0ZXJzIGFuZCByYW5nZXNcclxuICAgIGZ1bmN0aW9uIGludmVydEJtcChyYW5nZSkge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSAnJztcclxuICAgICAgICB2YXIgbGFzdEVuZCA9IC0xO1xyXG4gICAgICAgIFhSZWdFeHAuZm9yRWFjaChcclxuICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgIC8oXFxcXHguLnxcXFxcdS4uLi58XFxcXD9bXFxzXFxTXSkoPzotKFxcXFx4Li58XFxcXHUuLi4ufFxcXFw/W1xcc1xcU10pKT8vLFxyXG4gICAgICAgICAgICBmdW5jdGlvbihtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBjaGFyQ29kZShtWzFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydCA+IChsYXN0RW5kICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJ1xcXFx1JyArIHBhZDQoaGV4KGxhc3RFbmQgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gKGxhc3RFbmQgKyAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJy1cXFxcdScgKyBwYWQ0KGhleChzdGFydCAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0RW5kID0gY2hhckNvZGUobVsyXSB8fCBtWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKGxhc3RFbmQgPCAweEZGRkYpIHtcclxuICAgICAgICAgICAgb3V0cHV0ICs9ICdcXFxcdScgKyBwYWQ0KGhleChsYXN0RW5kICsgMSkpO1xyXG4gICAgICAgICAgICBpZiAobGFzdEVuZCA8IDB4RkZGRSkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICctXFxcXHVGRkZGJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlcyBhbiBpbnZlcnRlZCBCTVAgcmFuZ2Ugb24gZmlyc3QgdXNlXHJcbiAgICBmdW5jdGlvbiBjYWNoZUludmVydGVkQm1wKHNsdWcpIHtcclxuICAgICAgICB2YXIgcHJvcCA9ICdiISc7XHJcbiAgICAgICAgcmV0dXJuIHVuaWNvZGVbc2x1Z11bcHJvcF0gfHwgKFxyXG4gICAgICAgICAgICB1bmljb2RlW3NsdWddW3Byb3BdID0gaW52ZXJ0Qm1wKHVuaWNvZGVbc2x1Z10uYm1wKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tYmluZXMgYW5kIG9wdGlvbmFsbHkgbmVnYXRlcyBCTVAgYW5kIGFzdHJhbCBkYXRhXHJcbiAgICBmdW5jdGlvbiBidWlsZEFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpIHtcclxuICAgICAgICB2YXIgaXRlbSA9IHVuaWNvZGVbc2x1Z10sXHJcbiAgICAgICAgICAgIGNvbWJpbmVkID0gJyc7XHJcbiAgICAgICAgaWYgKGl0ZW0uYm1wICYmICFpdGVtLmlzQm1wTGFzdCkge1xyXG4gICAgICAgICAgICBjb21iaW5lZCA9ICdbJyArIGl0ZW0uYm1wICsgJ10nICsgKGl0ZW0uYXN0cmFsID8gJ3wnIDogJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5hc3RyYWwpIHtcclxuICAgICAgICAgICAgY29tYmluZWQgKz0gaXRlbS5hc3RyYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmlzQm1wTGFzdCAmJiBpdGVtLmJtcCkge1xyXG4gICAgICAgICAgICBjb21iaW5lZCArPSAoaXRlbS5hc3RyYWwgPyAnfCcgOiAnJykgKyAnWycgKyBpdGVtLmJtcCArICddJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXN0cmFsIFVuaWNvZGUgdG9rZW5zIGFsd2F5cyBtYXRjaCBhIGNvZGUgcG9pbnQsIG5ldmVyIGEgY29kZSB1bml0XHJcbiAgICAgICAgcmV0dXJuIGlzTmVnYXRlZCA/XHJcbiAgICAgICAgICAgICcoPzooPyEnICsgY29tYmluZWQgKyAnKSg/OltcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcMC1cXHVGRkZGXSkpJyA6XHJcbiAgICAgICAgICAgICcoPzonICsgY29tYmluZWQgKyAnKSc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnVpbGRzIGEgY29tcGxldGUgYXN0cmFsIHBhdHRlcm4gb24gZmlyc3QgdXNlXHJcbiAgICBmdW5jdGlvbiBjYWNoZUFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpIHtcclxuICAgICAgICB2YXIgcHJvcCA9IGlzTmVnYXRlZCA/ICdhIScgOiAnYT0nO1xyXG4gICAgICAgIHJldHVybiB1bmljb2RlW3NsdWddW3Byb3BdIHx8IChcclxuICAgICAgICAgICAgdW5pY29kZVtzbHVnXVtwcm9wXSA9IGJ1aWxkQXN0cmFsKHNsdWcsIGlzTmVnYXRlZClcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG4gICAgLy8gQ29yZSBmdW5jdGlvbmFsaXR5XHJcbiAgICAvLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuXHJcbiAgICAvKlxyXG4gICAgICogQWRkIFVuaWNvZGUgdG9rZW4gc3ludGF4OiBcXHB7Li59LCBcXFB7Li59LCBcXHB7Xi4ufS4gQWxzbyBhZGQgYXN0cmFsIG1vZGUgKGZsYWcgQSkuXHJcbiAgICAgKi9cclxuICAgIFhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAgICAgLy8gVXNlIGAqYCBpbnN0ZWFkIG9mIGArYCB0byBhdm9pZCBjYXB0dXJpbmcgYF5gIGFzIHRoZSB0b2tlbiBuYW1lIGluIGBcXHB7Xn1gXHJcbiAgICAgICAgL1xcXFwoW3BQXSkoPzp7KFxcXj8pKFtefV0qKX18KFtBLVphLXpdKSkvLFxyXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSwgZmxhZ3MpIHtcclxuICAgICAgICAgICAgdmFyIEVSUl9ET1VCTEVfTkVHID0gJ0ludmFsaWQgZG91YmxlIG5lZ2F0aW9uICcsXHJcbiAgICAgICAgICAgICAgICBFUlJfVU5LTk9XTl9OQU1FID0gJ1Vua25vd24gVW5pY29kZSB0b2tlbiAnLFxyXG4gICAgICAgICAgICAgICAgRVJSX1VOS05PV05fUkVGID0gJ1VuaWNvZGUgdG9rZW4gbWlzc2luZyBkYXRhICcsXHJcbiAgICAgICAgICAgICAgICBFUlJfQVNUUkFMX09OTFkgPSAnQXN0cmFsIG1vZGUgcmVxdWlyZWQgZm9yIFVuaWNvZGUgdG9rZW4gJyxcclxuICAgICAgICAgICAgICAgIEVSUl9BU1RSQUxfSU5fQ0xBU1MgPSAnQXN0cmFsIG1vZGUgZG9lcyBub3Qgc3VwcG9ydCBVbmljb2RlIHRva2VucyB3aXRoaW4gY2hhcmFjdGVyIGNsYXNzZXMnLFxyXG4gICAgICAgICAgICAgICAgLy8gTmVnYXRlZCB2aWEgXFxQey4ufSBvciBcXHB7Xi4ufVxyXG4gICAgICAgICAgICAgICAgaXNOZWdhdGVkID0gbWF0Y2hbMV0gPT09ICdQJyB8fCAhIW1hdGNoWzJdLFxyXG4gICAgICAgICAgICAgICAgLy8gU3dpdGNoIGZyb20gQk1QICgwLUZGRkYpIHRvIGFzdHJhbCAoMC0xMEZGRkYpIG1vZGUgdmlhIGZsYWcgQVxyXG4gICAgICAgICAgICAgICAgaXNBc3RyYWxNb2RlID0gZmxhZ3MuaW5kZXhPZignQScpID4gLTEsXHJcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBsb29rdXAgbmFtZS4gQ2hlY2sgYFs0XWAgZmlyc3QgdG8gYXZvaWQgcGFzc2luZyBgdW5kZWZpbmVkYCB2aWEgYFxccHt9YFxyXG4gICAgICAgICAgICAgICAgc2x1ZyA9IG5vcm1hbGl6ZShtYXRjaFs0XSB8fCBtYXRjaFszXSksXHJcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBkYXRhIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgaXRlbSA9IHVuaWNvZGVbc2x1Z107XHJcblxyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdQJyAmJiBtYXRjaFsyXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9ET1VCTEVfTkVHICsgbWF0Y2hbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdW5pY29kZS5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9VTktOT1dOX05BTUUgKyBtYXRjaFswXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN3aXRjaCB0byB0aGUgbmVnYXRlZCBmb3JtIG9mIHRoZSByZWZlcmVuY2VkIFVuaWNvZGUgdG9rZW5cclxuICAgICAgICAgICAgaWYgKGl0ZW0uaW52ZXJzZU9mKSB7XHJcbiAgICAgICAgICAgICAgICBzbHVnID0gbm9ybWFsaXplKGl0ZW0uaW52ZXJzZU9mKTtcclxuICAgICAgICAgICAgICAgIGlmICghdW5pY29kZS5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihFUlJfVU5LTk9XTl9SRUYgKyBtYXRjaFswXSArICcgLT4gJyArIGl0ZW0uaW52ZXJzZU9mKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGl0ZW0gPSB1bmljb2RlW3NsdWddO1xyXG4gICAgICAgICAgICAgICAgaXNOZWdhdGVkID0gIWlzTmVnYXRlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCEoaXRlbS5ibXAgfHwgaXNBc3RyYWxNb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9BU1RSQUxfT05MWSArIG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNBc3RyYWxNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoRVJSX0FTVFJBTF9JTl9DTEFTUyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlQXN0cmFsKHNsdWcsIGlzTmVnYXRlZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzY29wZSA9PT0gJ2NsYXNzJyA/XHJcbiAgICAgICAgICAgICAgICAoaXNOZWdhdGVkID8gY2FjaGVJbnZlcnRlZEJtcChzbHVnKSA6IGl0ZW0uYm1wKSA6XHJcbiAgICAgICAgICAgICAgICAoaXNOZWdhdGVkID8gJ1teJyA6ICdbJykgKyBpdGVtLmJtcCArICddJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2NvcGU6ICdhbGwnLFxyXG4gICAgICAgICAgICBvcHRpb25hbEZsYWdzOiAnQScsXHJcbiAgICAgICAgICAgIGxlYWRDaGFyOiAnXFxcXCdcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0byB0aGUgbGlzdCBvZiBVbmljb2RlIHRva2VucyB0aGF0IFhSZWdFeHAgcmVnZXhlcyBjYW4gbWF0Y2ggdmlhIGBcXHBgIG9yIGBcXFBgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgT2JqZWN0cyB3aXRoIG5hbWVkIGNoYXJhY3RlciByYW5nZXMuIEVhY2ggb2JqZWN0IG1heSBoYXZlIHByb3BlcnRpZXNcclxuICAgICAqICAgYG5hbWVgLCBgYWxpYXNgLCBgaXNCbXBMYXN0YCwgYGludmVyc2VPZmAsIGBibXBgLCBhbmQgYGFzdHJhbGAuIEFsbCBidXQgYG5hbWVgIGFyZVxyXG4gICAgICogICBvcHRpb25hbCwgYWx0aG91Z2ggb25lIG9mIGBibXBgIG9yIGBhc3RyYWxgIGlzIHJlcXVpcmVkICh1bmxlc3MgYGludmVyc2VPZmAgaXMgc2V0KS4gSWZcclxuICAgICAqICAgYGFzdHJhbGAgaXMgYWJzZW50LCB0aGUgYGJtcGAgZGF0YSBpcyB1c2VkIGZvciBCTVAgYW5kIGFzdHJhbCBtb2Rlcy4gSWYgYGJtcGAgaXMgYWJzZW50LFxyXG4gICAgICogICB0aGUgbmFtZSBlcnJvcnMgaW4gQk1QIG1vZGUgYnV0IHdvcmtzIGluIGFzdHJhbCBtb2RlLiBJZiBib3RoIGBibXBgIGFuZCBgYXN0cmFsYCBhcmVcclxuICAgICAqICAgcHJvdmlkZWQsIHRoZSBgYm1wYCBkYXRhIG9ubHkgaXMgdXNlZCBpbiBCTVAgbW9kZSwgYW5kIHRoZSBjb21iaW5hdGlvbiBvZiBgYm1wYCBhbmRcclxuICAgICAqICAgYGFzdHJhbGAgZGF0YSBpcyB1c2VkIGluIGFzdHJhbCBtb2RlLiBgaXNCbXBMYXN0YCBpcyBuZWVkZWQgd2hlbiBhIHRva2VuIG1hdGNoZXMgb3JwaGFuXHJcbiAgICAgKiAgIGhpZ2ggc3Vycm9nYXRlcyAqYW5kKiB1c2VzIHN1cnJvZ2F0ZSBwYWlycyB0byBtYXRjaCBhc3RyYWwgY29kZSBwb2ludHMuIFRoZSBgYm1wYCBhbmRcclxuICAgICAqICAgYGFzdHJhbGAgZGF0YSBzaG91bGQgYmUgYSBjb21iaW5hdGlvbiBvZiBsaXRlcmFsIGNoYXJhY3RlcnMgYW5kIGBcXHhISGAgb3IgYFxcdUhISEhgIGVzY2FwZVxyXG4gICAgICogICBzZXF1ZW5jZXMsIHdpdGggaHlwaGVucyB0byBjcmVhdGUgcmFuZ2VzLiBBbnkgcmVnZXggbWV0YWNoYXJhY3RlcnMgaW4gdGhlIGRhdGEgc2hvdWxkIGJlXHJcbiAgICAgKiAgIGVzY2FwZWQsIGFwYXJ0IGZyb20gcmFuZ2UtY3JlYXRpbmcgaHlwaGVucy4gVGhlIGBhc3RyYWxgIGRhdGEgY2FuIGFkZGl0aW9uYWxseSB1c2VcclxuICAgICAqICAgY2hhcmFjdGVyIGNsYXNzZXMgYW5kIGFsdGVybmF0aW9uLCBhbmQgc2hvdWxkIHVzZSBzdXJyb2dhdGUgcGFpcnMgdG8gcmVwcmVzZW50IGFzdHJhbCBjb2RlXHJcbiAgICAgKiAgIHBvaW50cy4gYGludmVyc2VPZmAgY2FuIGJlIHVzZWQgdG8gYXZvaWQgZHVwbGljYXRpbmcgY2hhcmFjdGVyIGRhdGEgaWYgYSBVbmljb2RlIHRva2VuIGlzXHJcbiAgICAgKiAgIGRlZmluZWQgYXMgdGhlIGV4YWN0IGludmVyc2Ugb2YgYW5vdGhlciB0b2tlbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogLy8gQmFzaWMgdXNlXHJcbiAgICAgKiBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKFt7XHJcbiAgICAgKiAgIG5hbWU6ICdYRGlnaXQnLFxyXG4gICAgICogICBhbGlhczogJ0hleGFkZWNpbWFsJyxcclxuICAgICAqICAgYm1wOiAnMC05QS1GYS1mJ1xyXG4gICAgICogfV0pO1xyXG4gICAgICogWFJlZ0V4cCgnXFxcXHB7WERpZ2l0fTpcXFxccHtIZXhhZGVjaW1hbH0rJykudGVzdCgnMDozRCcpOyAvLyAtPiB0cnVlXHJcbiAgICAgKi9cclxuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgdmFyIEVSUl9OT19OQU1FID0gJ1VuaWNvZGUgdG9rZW4gcmVxdWlyZXMgbmFtZScsXHJcbiAgICAgICAgICAgIEVSUl9OT19EQVRBID0gJ1VuaWNvZGUgdG9rZW4gaGFzIG5vIGNoYXJhY3RlciBkYXRhICcsXHJcbiAgICAgICAgICAgIGl0ZW0sXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW0ubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9OT19OQU1FKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShpdGVtLmludmVyc2VPZiB8fCBpdGVtLmJtcCB8fCBpdGVtLmFzdHJhbCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfTk9fREFUQSArIGl0ZW0ubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW5pY29kZVtub3JtYWxpemUoaXRlbS5uYW1lKV0gPSBpdGVtO1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5hbGlhcykge1xyXG4gICAgICAgICAgICAgICAgdW5pY29kZVtub3JtYWxpemUoaXRlbS5hbGlhcyldID0gaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIHBhdHRlcm4gY2FjaGUgdXNlZCBieSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yLCBzaW5jZSB0aGUgc2FtZSBwYXR0ZXJuIGFuZFxyXG4gICAgICAgIC8vIGZsYWdzIG1pZ2h0IG5vdyBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHRzXHJcbiAgICAgICAgWFJlZ0V4cC5jYWNoZS5mbHVzaCgncGF0dGVybnMnKTtcclxuICAgIH07XHJcblxyXG59O1xyXG4iLCIvKiFcclxuICogWFJlZ0V4cCBVbmljb2RlIEJsb2NrcyAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMC0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqIFVuaWNvZGUgZGF0YSBieSBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc2J5bmVucy5iZT5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFhSZWdFeHApIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgc3VwcG9ydCBmb3IgYWxsIFVuaWNvZGUgYmxvY2tzLiBCbG9jayBuYW1lcyB1c2UgdGhlIHByZWZpeCAnSW4nLiBFLmcuLFxyXG4gICAgICogYFxccHtJbkJhc2ljTGF0aW59YC4gVG9rZW4gbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIGFuZCBhbnkgc3BhY2VzLCBoeXBoZW5zLCBhbmRcclxuICAgICAqIHVuZGVyc2NvcmVzIGFyZSBpZ25vcmVkLlxyXG4gICAgICpcclxuICAgICAqIFVzZXMgVW5pY29kZSA4LjAuMC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVxdWlyZXMgWFJlZ0V4cCwgVW5pY29kZSBCYXNlXHJcbiAgICAgKi9cclxuXHJcbiAgICBpZiAoIVhSZWdFeHAuYWRkVW5pY29kZURhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuaWNvZGUgQmFzZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgVW5pY29kZSBCbG9ja3MnKTtcclxuICAgIH1cclxuXHJcbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFlZ2Vhbl9OdW1iZXJzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDAwLVxcdUREM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BaG9tJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERjAwLVxcdURGM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BbGNoZW1pY2FsX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNEW1xcdURGMDAtXFx1REY3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFscGhhYmV0aWNfUHJlc2VudGF0aW9uX0Zvcm1zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RkIwMC1cXHVGQjRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BbmF0b2xpYW5fSGllcm9nbHlwaHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODExW1xcdURDMDAtXFx1REU3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFuY2llbnRfR3JlZWtfTXVzaWNhbF9Ob3RhdGlvbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1REUwMC1cXHVERTRGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQW5jaWVudF9HcmVla19OdW1iZXJzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDQwLVxcdUREOEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BbmNpZW50X1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdUREOTAtXFx1RERDRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA2MDAtXFx1MDZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQXJhYmljX0V4dGVuZGVkX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwOEEwLVxcdTA4RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpY19NYXRoZW1hdGljYWxfQWxwaGFiZXRpY19TeW1ib2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQltcXHVERTAwLVxcdURFRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWNfUHJlc2VudGF0aW9uX0Zvcm1zX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVGQjUwLVxcdUZERkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpY19QcmVzZW50YXRpb25fRm9ybXNfQicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFNzAtXFx1RkVGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQXJhYmljX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNzUwLVxcdTA3N0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFybWVuaWFuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDUzMC1cXHUwNThGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BcnJvd3MnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMTkwLVxcdTIxRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkF2ZXN0YW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGMDAtXFx1REYzRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhbGluZXNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUIwMC1cXHUxQjdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CYW11bScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE2QTAtXFx1QTZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQmFtdW1fU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REMwMC1cXHVERTNGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQmFzaWNfTGF0aW4nLFxyXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx4N0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhc3NhX1ZhaCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REVEMC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQmF0YWsnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQkMwLVxcdTFCRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJlbmdhbGknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwOTgwLVxcdTA5RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJsb2NrX0VsZW1lbnRzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjU4MC1cXHUyNTlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Cb3BvbW9mbycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxMDAtXFx1MzEyRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQm9wb21vZm9fRXh0ZW5kZWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMUEwLVxcdTMxQkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJveF9EcmF3aW5nJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjUwMC1cXHUyNTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CcmFobWknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDMDAtXFx1REM3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJyYWlsbGVfUGF0dGVybnMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyODAwLVxcdTI4RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJ1Z2luZXNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUEwMC1cXHUxQTFGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CdWhpZCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3NDAtXFx1MTc1RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQnl6YW50aW5lX011c2ljYWxfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1REMwMC1cXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX0NvbXBhdGliaWxpdHknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMzAwLVxcdTMzRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19Db21wYXRpYmlsaXR5X0Zvcm1zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RkUzMC1cXHVGRTRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfQ29tcGF0aWJpbGl0eV9JZGVvZ3JhcGhzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RjkwMC1cXHVGQUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfQ29tcGF0aWJpbGl0eV9JZGVvZ3JhcGhzX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODdFW1xcdURDMDAtXFx1REUxRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19SYWRpY2Fsc19TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkU4MC1cXHUyRUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfU3Ryb2tlcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxQzAtXFx1MzFFRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1N5bWJvbHNfYW5kX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzAwMC1cXHUzMDNGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1NEUwMC1cXHU5RkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzX0V4dGVuc2lvbl9BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzQwMC1cXHU0REJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzX0V4dGVuc2lvbl9CJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdUQ4NDAtXFx1RDg2OF1bXFx1REMwMC1cXHVERkZGXXxcXHVEODY5W1xcdURDMDAtXFx1REVERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19VbmlmaWVkX0lkZW9ncmFwaHNfRXh0ZW5zaW9uX0MnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZEW1xcdURDMDAtXFx1REYzRl18W1xcdUQ4NkEtXFx1RDg2Q11bXFx1REMwMC1cXHVERkZGXXxcXHVEODY5W1xcdURGMDAtXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19VbmlmaWVkX0lkZW9ncmFwaHNfRXh0ZW5zaW9uX0QnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZEW1xcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzX0V4dGVuc2lvbl9FJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBRl18XFx1RDg2RVtcXHVEQzIwLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DYXJpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURFQTAtXFx1REVERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNhdWNhc2lhbl9BbGJhbmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REQzMC1cXHVERDZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ2hha21hJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDAwLVxcdURENEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DaGFtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUEwMC1cXHVBQTVGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DaGVyb2tlZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTEzQTAtXFx1MTNGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ2hlcm9rZWVfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFCNzAtXFx1QUJCRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDMwMC1cXHUwMzZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfRXh0ZW5kZWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQUIwLVxcdTFBRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MURDMC1cXHUxREZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMEQwLVxcdTIwRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvbWJpbmluZ19IYWxmX01hcmtzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RkUyMC1cXHVGRTJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db21tb25fSW5kaWNfTnVtYmVyX0Zvcm1zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTgzMC1cXHVBODNGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db250cm9sX1BpY3R1cmVzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjQwMC1cXHUyNDNGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db3B0aWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyQzgwLVxcdTJDRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvcHRpY19FcGFjdF9OdW1iZXJzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERUUwLVxcdURFRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db3VudGluZ19Sb2RfTnVtZXJhbHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURGNjAtXFx1REY3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkN1bmVpZm9ybScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDhbXFx1REMwMC1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ3VuZWlmb3JtX051bWJlcnNfYW5kX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwOVtcXHVEQzAwLVxcdURDN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DdXJyZW5jeV9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjBBMC1cXHUyMENGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DeXByaW90X1N5bGxhYmFyeScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REMwMC1cXHVEQzNGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ3lyaWxsaWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNDAwLVxcdTA0RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkN5cmlsbGljX0V4dGVuZGVkX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyREUwLVxcdTJERkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkN5cmlsbGljX0V4dGVuZGVkX0InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBNjQwLVxcdUE2OUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkN5cmlsbGljX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNTAwLVxcdTA1MkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkRlc2VyZXQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDMDAtXFx1REM0Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkRldmFuYWdhcmknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwOTAwLVxcdTA5N0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkRldmFuYWdhcmlfRXh0ZW5kZWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBOEUwLVxcdUE4RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkRpbmdiYXRzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjcwMC1cXHUyN0JGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Eb21pbm9fVGlsZXMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdURDMzAtXFx1REM5Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkR1cGxveWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyRltcXHVEQzAwLVxcdURDOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5FYXJseV9EeW5hc3RpY19DdW5laWZvcm0nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA5W1xcdURDODAtXFx1REQ0Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkVneXB0aWFuX0hpZXJvZ2x5cGhzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwQ1tcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRWxiYXNhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REQwMC1cXHVERDJGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRW1vdGljb25zJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERTAwLVxcdURFNEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5FbmNsb3NlZF9BbHBoYW51bWVyaWNfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1REQwMC1cXHVEREZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRW5jbG9zZWRfQWxwaGFudW1lcmljcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI0NjAtXFx1MjRGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRW5jbG9zZWRfQ0pLX0xldHRlcnNfYW5kX01vbnRocycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMyMDAtXFx1MzJGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRW5jbG9zZWRfSWRlb2dyYXBoaWNfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1REUwMC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRXRoaW9waWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxMjAwLVxcdTEzN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkV0aGlvcGljX0V4dGVuZGVkJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkQ4MC1cXHUyRERGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5FdGhpb3BpY19FeHRlbmRlZF9BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUIwMC1cXHVBQjJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5FdGhpb3BpY19TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTM4MC1cXHUxMzlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5HZW5lcmFsX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjAwMC1cXHUyMDZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5HZW9tZXRyaWNfU2hhcGVzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjVBMC1cXHUyNUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5HZW9tZXRyaWNfU2hhcGVzX0V4dGVuZGVkJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERjgwLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5HZW9yZ2lhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTEwQTAtXFx1MTBGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR2VvcmdpYW5fU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJEMDAtXFx1MkQyRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR2xhZ29saXRpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJDMDAtXFx1MkM1RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR290aGljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjMwLVxcdURGNEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5HcmFudGhhJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERjAwLVxcdURGN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5HcmVla19FeHRlbmRlZCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFGMDAtXFx1MUZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR3JlZWtfYW5kX0NvcHRpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzNzAtXFx1MDNGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR3VqYXJhdGknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQTgwLVxcdTBBRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkd1cm11a2hpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEEwMC1cXHUwQTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IYWxmd2lkdGhfYW5kX0Z1bGx3aWR0aF9Gb3JtcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZGMDAtXFx1RkZFRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSGFuZ3VsX0NvbXBhdGliaWxpdHlfSmFtbycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxMzAtXFx1MzE4RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSGFuZ3VsX0phbW8nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxMTAwLVxcdTExRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9KYW1vX0V4dGVuZGVkX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBOTYwLVxcdUE5N0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9KYW1vX0V4dGVuZGVkX0InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVEN0IwLVxcdUQ3RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9TeWxsYWJsZXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQzAwLVxcdUQ3QUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbnVub28nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzIwLVxcdTE3M0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhdHJhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1RENFMC1cXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSGVicmV3JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDU5MC1cXHUwNUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IaWdoX1ByaXZhdGVfVXNlX1N1cnJvZ2F0ZXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVEQjgwLVxcdURCRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhpZ2hfU3Vycm9nYXRlcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUQ4MDAtXFx1REI3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSGlyYWdhbmEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMDQwLVxcdTMwOUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbklQQV9FeHRlbnNpb25zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDI1MC1cXHUwMkFGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5JZGVvZ3JhcGhpY19EZXNjcmlwdGlvbl9DaGFyYWN0ZXJzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkZGMC1cXHUyRkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5JbXBlcmlhbF9BcmFtYWljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzQwLVxcdURDNUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5JbnNjcmlwdGlvbmFsX1BhaGxhdmknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGNjAtXFx1REY3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkluc2NyaXB0aW9uYWxfUGFydGhpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGNDAtXFx1REY1Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkphdmFuZXNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTk4MC1cXHVBOURGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LYWl0aGknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDODAtXFx1RENDRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkthbmFfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkNbXFx1REMwMC1cXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2FuYnVuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzE5MC1cXHUzMTlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LYW5neGlfUmFkaWNhbHMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyRjAwLVxcdTJGREYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkthbm5hZGEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQzgwLVxcdTBDRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkthdGFrYW5hJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzBBMC1cXHUzMEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LYXRha2FuYV9QaG9uZXRpY19FeHRlbnNpb25zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzFGMC1cXHUzMUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LYXlhaF9MaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5MDAtXFx1QTkyRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2hhcm9zaHRoaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REUwMC1cXHVERTVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2htZXInLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzgwLVxcdTE3RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbktobWVyX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxOUUwLVxcdTE5RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbktob2praScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REUwMC1cXHVERTRGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2h1ZGF3YWRpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERUIwLVxcdURFRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYW8nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwRTgwLVxcdTBFRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0FkZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxRTAwLVxcdTFFRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMTAwLVxcdTAxN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMTgwLVxcdTAyNEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0MnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyQzYwLVxcdTJDN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0QnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBNzIwLVxcdUE3RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQjMwLVxcdUFCNkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluXzFfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceDgwLVxceEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MZXBjaGEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQzAwLVxcdTFDNEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxldHRlcmxpa2VfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTIxMDAtXFx1MjE0RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTGltYnUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxOTAwLVxcdTE5NEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxpbmVhcl9BJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERTAwLVxcdURGN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MaW5lYXJfQl9JZGVvZ3JhbXMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURDODAtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxpbmVhcl9CX1N5bGxhYmFyeScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REMwMC1cXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTGlzdScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE0RDAtXFx1QTRGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTG93X1N1cnJvZ2F0ZXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVEQzAwLVxcdURGRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkx5Y2lhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REU4MC1cXHVERTlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTHlkaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDIwLVxcdUREM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NYWhhamFuaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REQ1MC1cXHVERDdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWFoam9uZ19UaWxlcycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1REMwMC1cXHVEQzJGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWFsYXlhbGFtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEQwMC1cXHUwRDdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NYW5kYWljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDg0MC1cXHUwODVGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NYW5pY2hhZWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERUMwLVxcdURFRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NYXRoZW1hdGljYWxfQWxwaGFudW1lcmljX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM1W1xcdURDMDAtXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1hdGhlbWF0aWNhbF9PcGVyYXRvcnMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMjAwLVxcdTIyRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1lZXRlaV9NYXllaycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFCQzAtXFx1QUJGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWVldGVpX01heWVrX0V4dGVuc2lvbnMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQUUwLVxcdUFBRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1lbmRlX0tpa2FrdWknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNBW1xcdURDMDAtXFx1RENERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1lcm9pdGljX0N1cnNpdmUnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREQTAtXFx1RERGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1lcm9pdGljX0hpZXJvZ2x5cGhzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDgwLVxcdUREOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NaWFvJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQltcXHVERjAwLVxcdURGOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NaXNjZWxsYW5lb3VzX01hdGhlbWF0aWNhbF9TeW1ib2xzX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyN0MwLVxcdTI3RUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfTWF0aGVtYXRpY2FsX1N5bWJvbHNfQicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI5ODAtXFx1MjlGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19TeW1ib2xzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjYwMC1cXHUyNkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NaXNjZWxsYW5lb3VzX1N5bWJvbHNfYW5kX0Fycm93cycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJCMDAtXFx1MkJGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19TeW1ib2xzX2FuZF9QaWN0b2dyYXBocycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REMwMC1cXHVEREZGXXxcXHVEODNDW1xcdURGMDAtXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfVGVjaG5pY2FsJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjMwMC1cXHUyM0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Nb2RpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERTAwLVxcdURFNUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Nb2RpZmllcl9Ub25lX0xldHRlcnMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBNzAwLVxcdUE3MUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1vbmdvbGlhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE4MDAtXFx1MThBRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTXJvJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERTQwLVxcdURFNkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NdWx0YW5pJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERTgwLVxcdURFQUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NdXNpY2FsX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdUREMDAtXFx1RERGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk15YW5tYXInLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxMDAwLVxcdTEwOUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk15YW5tYXJfRXh0ZW5kZWRfQScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBNjAtXFx1QUE3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTXlhbm1hcl9FeHRlbmRlZF9CJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTlFMC1cXHVBOUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5OS28nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwN0MwLVxcdTA3RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk5hYmF0YWVhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM4MC1cXHVEQ0FGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTmV3X1RhaV9MdWUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxOTgwLVxcdTE5REYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk51bWJlcl9Gb3JtcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTIxNTAtXFx1MjE4RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT2doYW0nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNjgwLVxcdTE2OUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sX0NoaWtpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUM1MC1cXHUxQzdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfSHVuZ2FyaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzgwLVxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfSXRhbGljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjAwLVxcdURGMkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfTm9ydGhfQXJhYmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REU4MC1cXHVERTlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT2xkX1Blcm1pYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REY1MC1cXHVERjdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT2xkX1BlcnNpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGQTAtXFx1REZERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9Tb3V0aF9BcmFiaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERTYwLVxcdURFN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfVHVya2ljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzAwLVxcdURDNEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5PcHRpY2FsX0NoYXJhY3Rlcl9SZWNvZ25pdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI0NDAtXFx1MjQ1RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT3JpeWEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQjAwLVxcdTBCN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9ybmFtZW50YWxfRGluZ2JhdHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNEW1xcdURFNTAtXFx1REU3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9zbWFueWEnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDODAtXFx1RENBRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBhaGF3aF9IbW9uZycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REYwMC1cXHVERjhGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUGFsbXlyZW5lJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzYwLVxcdURDN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5QYXVfQ2luX0hhdScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDZbXFx1REVDMC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUGhhZ3NfcGEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBODQwLVxcdUE4N0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBoYWlzdG9zX0Rpc2MnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURERDAtXFx1RERGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBob2VuaWNpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREMDAtXFx1REQxRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBob25ldGljX0V4dGVuc2lvbnMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxRDAwLVxcdTFEN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBob25ldGljX0V4dGVuc2lvbnNfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFEODAtXFx1MURCRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUGxheWluZ19DYXJkcycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1RENBMC1cXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUHJpdmF0ZV9Vc2VfQXJlYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUUwMDAtXFx1RjhGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUHNhbHRlcl9QYWhsYXZpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjgwLVxcdURGQUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5SZWphbmcnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBOTMwLVxcdUE5NUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblJ1bWlfTnVtZXJhbF9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVERTYwLVxcdURFN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5SdW5pYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE2QTAtXFx1MTZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2FtYXJpdGFuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDgwMC1cXHUwODNGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TYXVyYXNodHJhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTg4MC1cXHVBOERGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TaGFyYWRhJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDgwLVxcdUREREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TaGF2aWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzUwLVxcdURDN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TaG9ydGhhbmRfRm9ybWF0X0NvbnRyb2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyRltcXHVEQ0EwLVxcdURDQUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TaWRkaGFtJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERDgwLVxcdURERkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TaW5oYWxhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEQ4MC1cXHUwREZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TaW5oYWxhX0FyY2hhaWNfTnVtYmVycycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1RERFMC1cXHVEREZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU21hbGxfRm9ybV9WYXJpYW50cycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFNTAtXFx1RkU2RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU29yYV9Tb21wZW5nJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQ0QwLVxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TcGFjaW5nX01vZGlmaWVyX0xldHRlcnMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMkIwLVxcdTAyRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblNwZWNpYWxzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RkZGMC1cXHVGRkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdW5kYW5lc2UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQjgwLVxcdTFCQkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN1bmRhbmVzZV9TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUNDMC1cXHUxQ0NGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBlcnNjcmlwdHNfYW5kX1N1YnNjcmlwdHMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMDcwLVxcdTIwOUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9BcnJvd3NfQScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI3RjAtXFx1MjdGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX0Fycm93c19CJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjkwMC1cXHUyOTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YWxfQXJyb3dzX0MnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNFW1xcdURDMDAtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9NYXRoZW1hdGljYWxfT3BlcmF0b3JzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkEwMC1cXHUyQUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YWxfUHVuY3R1YXRpb24nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyRTAwLVxcdTJFN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9TeW1ib2xzX2FuZF9QaWN0b2dyYXBocycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0VbXFx1REQwMC1cXHVEREZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFyeV9Qcml2YXRlX1VzZV9BcmVhX0EnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REI4MC1cXHVEQkJGXVtcXHVEQzAwLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YXJ5X1ByaXZhdGVfVXNlX0FyZWFfQicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEQkMwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN1dHRvbl9TaWduV3JpdGluZycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzZbXFx1REMwMC1cXHVERUFGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3lsb3RpX05hZ3JpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTgwMC1cXHVBODJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TeXJpYWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNzAwLVxcdTA3NEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRhZ2Fsb2cnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzAwLVxcdTE3MUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRhZ2JhbndhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTc2MC1cXHUxNzdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UYWdzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1REI0MFtcXHVEQzAwLVxcdURDN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UYWlfTGUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxOTUwLVxcdTE5N0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRhaV9UaGFtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUEyMC1cXHUxQUFGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UYWlfVmlldCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBODAtXFx1QUFERidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGFpX1h1YW5fSmluZ19TeW1ib2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERjAwLVxcdURGNUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UYWtyaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REU4MC1cXHVERUNGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGFtaWwnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQjgwLVxcdTBCRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRlbHVndScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBDMDAtXFx1MEM3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGhhYW5hJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDc4MC1cXHUwN0JGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UaGFpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEUwMC1cXHUwRTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UaWJldGFuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEYwMC1cXHUwRkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UaWZpbmFnaCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJEMzAtXFx1MkQ3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGlyaHV0YScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REM4MC1cXHVEQ0RGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVHJhbnNwb3J0X2FuZF9NYXBfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REU4MC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVWdhcml0aWMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGODAtXFx1REY5Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblVuaWZpZWRfQ2FuYWRpYW5fQWJvcmlnaW5hbF9TeWxsYWJpY3MnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNDAwLVxcdTE2N0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblVuaWZpZWRfQ2FuYWRpYW5fQWJvcmlnaW5hbF9TeWxsYWJpY3NfRXh0ZW5kZWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxOEIwLVxcdTE4RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblZhaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE1MDAtXFx1QTYzRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVmFyaWF0aW9uX1NlbGVjdG9ycycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFMDAtXFx1RkUwRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVmFyaWF0aW9uX1NlbGVjdG9yc19TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1REI0MFtcXHVERDAwLVxcdURERUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5WZWRpY19FeHRlbnNpb25zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUNEMC1cXHUxQ0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5WZXJ0aWNhbF9Gb3JtcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFMTAtXFx1RkUxRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luV2FyYW5nX0NpdGknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURDQTAtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbllpX1JhZGljYWxzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTQ5MC1cXHVBNENGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5ZaV9TeWxsYWJsZXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBMDAwLVxcdUE0OEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbllpamluZ19IZXhhZ3JhbV9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1NERDMC1cXHU0REZGJ1xyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG5cclxufTtcclxuIiwiLyohXHJcbiAqIFhSZWdFeHAgVW5pY29kZSBDYXRlZ29yaWVzIDMuMS4xXHJcbiAqIDx4cmVnZXhwLmNvbT5cclxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEwLTIwMTYgTUlUIExpY2Vuc2VcclxuICogVW5pY29kZSBkYXRhIGJ5IE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzYnluZW5zLmJlPlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oWFJlZ0V4cCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBzdXBwb3J0IGZvciBVbmljb2RlJ3MgZ2VuZXJhbCBjYXRlZ29yaWVzLiBFLmcuLCBgXFxwe0x1fWAgb3IgYFxccHtVcHBlcmNhc2UgTGV0dGVyfWAuIFNlZVxyXG4gICAgICogY2F0ZWdvcnkgZGVzY3JpcHRpb25zIGluIFVBWCAjNDQgPGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDQvI0dDX1ZhbHVlc19UYWJsZT4uIFRva2VuXHJcbiAgICAgKiBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgYW5kIGFueSBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBVc2VzIFVuaWNvZGUgOC4wLjAuXHJcbiAgICAgKlxyXG4gICAgICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKCFYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmljb2RlIEJhc2UgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIFVuaWNvZGUgQ2F0ZWdvcmllcycpO1xyXG4gICAgfVxyXG5cclxuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0MnLFxyXG4gICAgICAgICAgICBhbGlhczogJ090aGVyJyxcclxuICAgICAgICAgICAgaXNCbXBMYXN0OiB0cnVlLFxyXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx4MUZcXHg3Ri1cXHg5RlxceEFEXFx1MDM3OFxcdTAzNzlcXHUwMzgwLVxcdTAzODNcXHUwMzhCXFx1MDM4RFxcdTAzQTJcXHUwNTMwXFx1MDU1N1xcdTA1NThcXHUwNTYwXFx1MDU4OFxcdTA1OEJcXHUwNThDXFx1MDU5MFxcdTA1QzgtXFx1MDVDRlxcdTA1RUItXFx1MDVFRlxcdTA1RjUtXFx1MDYwNVxcdTA2MUNcXHUwNjFEXFx1MDZERFxcdTA3MEVcXHUwNzBGXFx1MDc0QlxcdTA3NENcXHUwN0IyLVxcdTA3QkZcXHUwN0ZCLVxcdTA3RkZcXHUwODJFXFx1MDgyRlxcdTA4M0ZcXHUwODVDXFx1MDg1RFxcdTA4NUYtXFx1MDg5RlxcdTA4QjUtXFx1MDhFMlxcdTA5ODRcXHUwOThEXFx1MDk4RVxcdTA5OTFcXHUwOTkyXFx1MDlBOVxcdTA5QjFcXHUwOUIzLVxcdTA5QjVcXHUwOUJBXFx1MDlCQlxcdTA5QzVcXHUwOUM2XFx1MDlDOVxcdTA5Q0FcXHUwOUNGLVxcdTA5RDZcXHUwOUQ4LVxcdTA5REJcXHUwOURFXFx1MDlFNFxcdTA5RTVcXHUwOUZDLVxcdTBBMDBcXHUwQTA0XFx1MEEwQi1cXHUwQTBFXFx1MEExMVxcdTBBMTJcXHUwQTI5XFx1MEEzMVxcdTBBMzRcXHUwQTM3XFx1MEEzQVxcdTBBM0JcXHUwQTNEXFx1MEE0My1cXHUwQTQ2XFx1MEE0OVxcdTBBNEFcXHUwQTRFLVxcdTBBNTBcXHUwQTUyLVxcdTBBNThcXHUwQTVEXFx1MEE1Ri1cXHUwQTY1XFx1MEE3Ni1cXHUwQTgwXFx1MEE4NFxcdTBBOEVcXHUwQTkyXFx1MEFBOVxcdTBBQjFcXHUwQUI0XFx1MEFCQVxcdTBBQkJcXHUwQUM2XFx1MEFDQVxcdTBBQ0VcXHUwQUNGXFx1MEFEMS1cXHUwQURGXFx1MEFFNFxcdTBBRTVcXHUwQUYyLVxcdTBBRjhcXHUwQUZBLVxcdTBCMDBcXHUwQjA0XFx1MEIwRFxcdTBCMEVcXHUwQjExXFx1MEIxMlxcdTBCMjlcXHUwQjMxXFx1MEIzNFxcdTBCM0FcXHUwQjNCXFx1MEI0NVxcdTBCNDZcXHUwQjQ5XFx1MEI0QVxcdTBCNEUtXFx1MEI1NVxcdTBCNTgtXFx1MEI1QlxcdTBCNUVcXHUwQjY0XFx1MEI2NVxcdTBCNzgtXFx1MEI4MVxcdTBCODRcXHUwQjhCLVxcdTBCOERcXHUwQjkxXFx1MEI5Ni1cXHUwQjk4XFx1MEI5QlxcdTBCOURcXHUwQkEwLVxcdTBCQTJcXHUwQkE1LVxcdTBCQTdcXHUwQkFCLVxcdTBCQURcXHUwQkJBLVxcdTBCQkRcXHUwQkMzLVxcdTBCQzVcXHUwQkM5XFx1MEJDRVxcdTBCQ0ZcXHUwQkQxLVxcdTBCRDZcXHUwQkQ4LVxcdTBCRTVcXHUwQkZCLVxcdTBCRkZcXHUwQzA0XFx1MEMwRFxcdTBDMTFcXHUwQzI5XFx1MEMzQS1cXHUwQzNDXFx1MEM0NVxcdTBDNDlcXHUwQzRFLVxcdTBDNTRcXHUwQzU3XFx1MEM1Qi1cXHUwQzVGXFx1MEM2NFxcdTBDNjVcXHUwQzcwLVxcdTBDNzdcXHUwQzgwXFx1MEM4NFxcdTBDOERcXHUwQzkxXFx1MENBOVxcdTBDQjRcXHUwQ0JBXFx1MENCQlxcdTBDQzVcXHUwQ0M5XFx1MENDRS1cXHUwQ0Q0XFx1MENENy1cXHUwQ0REXFx1MENERlxcdTBDRTRcXHUwQ0U1XFx1MENGMFxcdTBDRjMtXFx1MEQwMFxcdTBEMDRcXHUwRDBEXFx1MEQxMVxcdTBEM0JcXHUwRDNDXFx1MEQ0NVxcdTBENDlcXHUwRDRGLVxcdTBENTZcXHUwRDU4LVxcdTBENUVcXHUwRDY0XFx1MEQ2NVxcdTBENzYtXFx1MEQ3OFxcdTBEODBcXHUwRDgxXFx1MEQ4NFxcdTBEOTctXFx1MEQ5OVxcdTBEQjJcXHUwREJDXFx1MERCRVxcdTBEQkZcXHUwREM3LVxcdTBEQzlcXHUwRENCLVxcdTBEQ0VcXHUwREQ1XFx1MEREN1xcdTBERTAtXFx1MERFNVxcdTBERjBcXHUwREYxXFx1MERGNS1cXHUwRTAwXFx1MEUzQi1cXHUwRTNFXFx1MEU1Qy1cXHUwRTgwXFx1MEU4M1xcdTBFODVcXHUwRTg2XFx1MEU4OVxcdTBFOEJcXHUwRThDXFx1MEU4RS1cXHUwRTkzXFx1MEU5OFxcdTBFQTBcXHUwRUE0XFx1MEVBNlxcdTBFQThcXHUwRUE5XFx1MEVBQ1xcdTBFQkFcXHUwRUJFXFx1MEVCRlxcdTBFQzVcXHUwRUM3XFx1MEVDRVxcdTBFQ0ZcXHUwRURBXFx1MEVEQlxcdTBFRTAtXFx1MEVGRlxcdTBGNDhcXHUwRjZELVxcdTBGNzBcXHUwRjk4XFx1MEZCRFxcdTBGQ0RcXHUwRkRCLVxcdTBGRkZcXHUxMEM2XFx1MTBDOC1cXHUxMENDXFx1MTBDRVxcdTEwQ0ZcXHUxMjQ5XFx1MTI0RVxcdTEyNEZcXHUxMjU3XFx1MTI1OVxcdTEyNUVcXHUxMjVGXFx1MTI4OVxcdTEyOEVcXHUxMjhGXFx1MTJCMVxcdTEyQjZcXHUxMkI3XFx1MTJCRlxcdTEyQzFcXHUxMkM2XFx1MTJDN1xcdTEyRDdcXHUxMzExXFx1MTMxNlxcdTEzMTdcXHUxMzVCXFx1MTM1Q1xcdTEzN0QtXFx1MTM3RlxcdTEzOUEtXFx1MTM5RlxcdTEzRjZcXHUxM0Y3XFx1MTNGRVxcdTEzRkZcXHUxNjlELVxcdTE2OUZcXHUxNkY5LVxcdTE2RkZcXHUxNzBEXFx1MTcxNS1cXHUxNzFGXFx1MTczNy1cXHUxNzNGXFx1MTc1NC1cXHUxNzVGXFx1MTc2RFxcdTE3NzFcXHUxNzc0LVxcdTE3N0ZcXHUxN0RFXFx1MTdERlxcdTE3RUEtXFx1MTdFRlxcdTE3RkEtXFx1MTdGRlxcdTE4MEVcXHUxODBGXFx1MTgxQS1cXHUxODFGXFx1MTg3OC1cXHUxODdGXFx1MThBQi1cXHUxOEFGXFx1MThGNi1cXHUxOEZGXFx1MTkxRlxcdTE5MkMtXFx1MTkyRlxcdTE5M0MtXFx1MTkzRlxcdTE5NDEtXFx1MTk0M1xcdTE5NkVcXHUxOTZGXFx1MTk3NS1cXHUxOTdGXFx1MTlBQy1cXHUxOUFGXFx1MTlDQS1cXHUxOUNGXFx1MTlEQi1cXHUxOUREXFx1MUExQ1xcdTFBMURcXHUxQTVGXFx1MUE3RFxcdTFBN0VcXHUxQThBLVxcdTFBOEZcXHUxQTlBLVxcdTFBOUZcXHUxQUFFXFx1MUFBRlxcdTFBQkYtXFx1MUFGRlxcdTFCNEMtXFx1MUI0RlxcdTFCN0QtXFx1MUI3RlxcdTFCRjQtXFx1MUJGQlxcdTFDMzgtXFx1MUMzQVxcdTFDNEEtXFx1MUM0Q1xcdTFDODAtXFx1MUNCRlxcdTFDQzgtXFx1MUNDRlxcdTFDRjdcXHUxQ0ZBLVxcdTFDRkZcXHUxREY2LVxcdTFERkJcXHUxRjE2XFx1MUYxN1xcdTFGMUVcXHUxRjFGXFx1MUY0NlxcdTFGNDdcXHUxRjRFXFx1MUY0RlxcdTFGNThcXHUxRjVBXFx1MUY1Q1xcdTFGNUVcXHUxRjdFXFx1MUY3RlxcdTFGQjVcXHUxRkM1XFx1MUZENFxcdTFGRDVcXHUxRkRDXFx1MUZGMFxcdTFGRjFcXHUxRkY1XFx1MUZGRlxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2RlxcdTIwNzJcXHUyMDczXFx1MjA4RlxcdTIwOUQtXFx1MjA5RlxcdTIwQkYtXFx1MjBDRlxcdTIwRjEtXFx1MjBGRlxcdTIxOEMtXFx1MjE4RlxcdTIzRkItXFx1MjNGRlxcdTI0MjctXFx1MjQzRlxcdTI0NEItXFx1MjQ1RlxcdTJCNzRcXHUyQjc1XFx1MkI5NlxcdTJCOTdcXHUyQkJBLVxcdTJCQkNcXHUyQkM5XFx1MkJEMi1cXHUyQkVCXFx1MkJGMC1cXHUyQkZGXFx1MkMyRlxcdTJDNUZcXHUyQ0Y0LVxcdTJDRjhcXHUyRDI2XFx1MkQyOC1cXHUyRDJDXFx1MkQyRVxcdTJEMkZcXHUyRDY4LVxcdTJENkVcXHUyRDcxLVxcdTJEN0VcXHUyRDk3LVxcdTJEOUZcXHUyREE3XFx1MkRBRlxcdTJEQjdcXHUyREJGXFx1MkRDN1xcdTJEQ0ZcXHUyREQ3XFx1MkRERlxcdTJFNDMtXFx1MkU3RlxcdTJFOUFcXHUyRUY0LVxcdTJFRkZcXHUyRkQ2LVxcdTJGRUZcXHUyRkZDLVxcdTJGRkZcXHUzMDQwXFx1MzA5N1xcdTMwOThcXHUzMTAwLVxcdTMxMDRcXHUzMTJFLVxcdTMxMzBcXHUzMThGXFx1MzFCQi1cXHUzMUJGXFx1MzFFNC1cXHUzMUVGXFx1MzIxRlxcdTMyRkZcXHU0REI2LVxcdTREQkZcXHU5RkQ2LVxcdTlGRkZcXHVBNDhELVxcdUE0OEZcXHVBNEM3LVxcdUE0Q0ZcXHVBNjJDLVxcdUE2M0ZcXHVBNkY4LVxcdUE2RkZcXHVBN0FFXFx1QTdBRlxcdUE3QjgtXFx1QTdGNlxcdUE4MkMtXFx1QTgyRlxcdUE4M0EtXFx1QTgzRlxcdUE4NzgtXFx1QTg3RlxcdUE4QzUtXFx1QThDRFxcdUE4REEtXFx1QThERlxcdUE4RkVcXHVBOEZGXFx1QTk1NC1cXHVBOTVFXFx1QTk3RC1cXHVBOTdGXFx1QTlDRVxcdUE5REEtXFx1QTlERFxcdUE5RkZcXHVBQTM3LVxcdUFBM0ZcXHVBQTRFXFx1QUE0RlxcdUFBNUFcXHVBQTVCXFx1QUFDMy1cXHVBQURBXFx1QUFGNy1cXHVBQjAwXFx1QUIwN1xcdUFCMDhcXHVBQjBGXFx1QUIxMFxcdUFCMTctXFx1QUIxRlxcdUFCMjdcXHVBQjJGXFx1QUI2Ni1cXHVBQjZGXFx1QUJFRVxcdUFCRUZcXHVBQkZBLVxcdUFCRkZcXHVEN0E0LVxcdUQ3QUZcXHVEN0M3LVxcdUQ3Q0FcXHVEN0ZDLVxcdUY4RkZcXHVGQTZFXFx1RkE2RlxcdUZBREEtXFx1RkFGRlxcdUZCMDctXFx1RkIxMlxcdUZCMTgtXFx1RkIxQ1xcdUZCMzdcXHVGQjNEXFx1RkIzRlxcdUZCNDJcXHVGQjQ1XFx1RkJDMi1cXHVGQkQyXFx1RkQ0MC1cXHVGRDRGXFx1RkQ5MFxcdUZEOTFcXHVGREM4LVxcdUZERUZcXHVGREZFXFx1RkRGRlxcdUZFMUEtXFx1RkUxRlxcdUZFNTNcXHVGRTY3XFx1RkU2Qy1cXHVGRTZGXFx1RkU3NVxcdUZFRkQtXFx1RkYwMFxcdUZGQkYtXFx1RkZDMVxcdUZGQzhcXHVGRkM5XFx1RkZEMFxcdUZGRDFcXHVGRkQ4XFx1RkZEOVxcdUZGREQtXFx1RkZERlxcdUZGRTdcXHVGRkVGLVxcdUZGRkJcXHVGRkZFXFx1RkZGRicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1RENGNi1cXHVEQ0ZGXFx1REQyN1xcdUREMjhcXHVERDczLVxcdUREN0FcXHVEREU5LVxcdURERkZcXHVERTQ2LVxcdURFRkZcXHVERjU3LVxcdURGNUZcXHVERjcyLVxcdURGRkZdfFxcdUQ4MzZbXFx1REU4Qy1cXHVERTlBXFx1REVBMFxcdURFQjAtXFx1REZGRl18XFx1RDgzQ1tcXHVEQzJDLVxcdURDMkZcXHVEQzk0LVxcdURDOUZcXHVEQ0FGXFx1RENCMFxcdURDQzBcXHVEQ0QwXFx1RENGNi1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ2RlxcdUREOUItXFx1RERFNVxcdURFMDMtXFx1REUwRlxcdURFM0ItXFx1REUzRlxcdURFNDktXFx1REU0RlxcdURFNTItXFx1REVGRl18XFx1RDgxQVtcXHVERTM5LVxcdURFM0ZcXHVERTVGXFx1REU2QS1cXHVERTZEXFx1REU3MC1cXHVERUNGXFx1REVFRVxcdURFRUZcXHVERUY2LVxcdURFRkZcXHVERjQ2LVxcdURGNEZcXHVERjVBXFx1REY2MlxcdURGNzgtXFx1REY3Q1xcdURGOTAtXFx1REZGRl18XFx1RDgwOVtcXHVEQzZGXFx1REM3NS1cXHVEQzdGXFx1REQ0NC1cXHVERkZGXXxcXHVEODFCW1xcdURDMDAtXFx1REVGRlxcdURGNDUtXFx1REY0RlxcdURGN0YtXFx1REY4RVxcdURGQTAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzFFXFx1REMxRl18XFx1RDgzRFtcXHVERDdBXFx1RERBNFxcdURFRDEtXFx1REVERlxcdURFRUQtXFx1REVFRlxcdURFRjQtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgwMVtcXHVEQzlFXFx1REM5RlxcdURDQUEtXFx1RENGRlxcdUREMjgtXFx1REQyRlxcdURENjQtXFx1REQ2RVxcdURENzAtXFx1RERGRlxcdURGMzctXFx1REYzRlxcdURGNTYtXFx1REY1RlxcdURGNjgtXFx1REZGRl18XFx1RDgwMFtcXHVEQzBDXFx1REMyN1xcdURDM0JcXHVEQzNFXFx1REM0RVxcdURDNEZcXHVEQzVFLVxcdURDN0ZcXHVEQ0ZCLVxcdURDRkZcXHVERDAzLVxcdUREMDZcXHVERDM0LVxcdUREMzZcXHVERDhELVxcdUREOEZcXHVERDlDLVxcdUREOUZcXHVEREExLVxcdUREQ0ZcXHVEREZFLVxcdURFN0ZcXHVERTlELVxcdURFOUZcXHVERUQxLVxcdURFREZcXHVERUZDLVxcdURFRkZcXHVERjI0LVxcdURGMkZcXHVERjRCLVxcdURGNEZcXHVERjdCLVxcdURGN0ZcXHVERjlFXFx1REZDNC1cXHVERkM3XFx1REZENi1cXHVERkZGXXxcXHVEODY5W1xcdURFRDctXFx1REVGRl18XFx1RDgzQltcXHVEQzAwLVxcdURERkZcXHVERTA0XFx1REUyMFxcdURFMjNcXHVERTI1XFx1REUyNlxcdURFMjhcXHVERTMzXFx1REUzOFxcdURFM0FcXHVERTNDLVxcdURFNDFcXHVERTQzLVxcdURFNDZcXHVERTQ4XFx1REU0QVxcdURFNENcXHVERTUwXFx1REU1M1xcdURFNTVcXHVERTU2XFx1REU1OFxcdURFNUFcXHVERTVDXFx1REU1RVxcdURFNjBcXHVERTYzXFx1REU2NVxcdURFNjZcXHVERTZCXFx1REU3M1xcdURFNzhcXHVERTdEXFx1REU3RlxcdURFOEFcXHVERTlDLVxcdURFQTBcXHVERUE0XFx1REVBQVxcdURFQkMtXFx1REVFRlxcdURFRjItXFx1REZGRl18XFx1RDg3RVtcXHVERTFFLVxcdURGRkZdfFxcdURCNDBbXFx1REMwMC1cXHVEQ0ZGXFx1RERGMC1cXHVERkZGXXxcXHVEODA0W1xcdURDNEUtXFx1REM1MVxcdURDNzAtXFx1REM3RVxcdURDQkRcXHVEQ0MyLVxcdURDQ0ZcXHVEQ0U5LVxcdURDRUZcXHVEQ0ZBLVxcdURDRkZcXHVERDM1XFx1REQ0NC1cXHVERDRGXFx1REQ3Ny1cXHVERDdGXFx1RERDRVxcdUREQ0ZcXHVEREUwXFx1RERGNS1cXHVEREZGXFx1REUxMlxcdURFM0UtXFx1REU3RlxcdURFODdcXHVERTg5XFx1REU4RVxcdURFOUVcXHVERUFBLVxcdURFQUZcXHVERUVCLVxcdURFRUZcXHVERUZBLVxcdURFRkZcXHVERjA0XFx1REYwRFxcdURGMEVcXHVERjExXFx1REYxMlxcdURGMjlcXHVERjMxXFx1REYzNFxcdURGM0FcXHVERjNCXFx1REY0NVxcdURGNDZcXHVERjQ5XFx1REY0QVxcdURGNEVcXHVERjRGXFx1REY1MS1cXHVERjU2XFx1REY1OC1cXHVERjVDXFx1REY2NFxcdURGNjVcXHVERjZELVxcdURGNkZcXHVERjc1LVxcdURGRkZdfFxcdUQ4M0FbXFx1RENDNVxcdURDQzZcXHVEQ0Q3LVxcdURGRkZdfFxcdUQ4MERbXFx1REMyRi1cXHVERkZGXXxcXHVEODZEW1xcdURGMzUtXFx1REYzRl18W1xcdUQ4MDdcXHVEODBBXFx1RDgwQlxcdUQ4MEUtXFx1RDgxMFxcdUQ4MTItXFx1RDgxOVxcdUQ4MUMtXFx1RDgyQlxcdUQ4MkRcXHVEODJFXFx1RDgzMC1cXHVEODMzXFx1RDgzNy1cXHVEODM5XFx1RDgzRlxcdUQ4NzQtXFx1RDg3RFxcdUQ4N0YtXFx1REIzRlxcdURCNDEtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxcXHVEODA2W1xcdURDMDAtXFx1REM5RlxcdURDRjMtXFx1RENGRVxcdUREMDAtXFx1REVCRlxcdURFRjktXFx1REZGRl18XFx1RDgwM1tcXHVEQzQ5LVxcdURDN0ZcXHVEQ0IzLVxcdURDQkZcXHVEQ0YzLVxcdURDRjlcXHVERDAwLVxcdURFNUZcXHVERTdGLVxcdURGRkZdfFxcdUQ4MzVbXFx1REM1NVxcdURDOURcXHVEQ0EwXFx1RENBMVxcdURDQTNcXHVEQ0E0XFx1RENBN1xcdURDQThcXHVEQ0FEXFx1RENCQVxcdURDQkNcXHVEQ0M0XFx1REQwNlxcdUREMEJcXHVERDBDXFx1REQxNVxcdUREMURcXHVERDNBXFx1REQzRlxcdURENDVcXHVERDQ3LVxcdURENDlcXHVERDUxXFx1REVBNlxcdURFQTdcXHVERkNDXFx1REZDRF18XFx1RDgwNVtcXHVEQzAwLVxcdURDN0ZcXHVEQ0M4LVxcdURDQ0ZcXHVEQ0RBLVxcdUREN0ZcXHVEREI2XFx1RERCN1xcdUREREUtXFx1RERGRlxcdURFNDUtXFx1REU0RlxcdURFNUEtXFx1REU3RlxcdURFQjgtXFx1REVCRlxcdURFQ0EtXFx1REVGRlxcdURGMUEtXFx1REYxQ1xcdURGMkMtXFx1REYyRlxcdURGNDAtXFx1REZGRl18XFx1RDgwMltcXHVEQzA2XFx1REMwN1xcdURDMDlcXHVEQzM2XFx1REMzOS1cXHVEQzNCXFx1REMzRFxcdURDM0VcXHVEQzU2XFx1REM5Ri1cXHVEQ0E2XFx1RENCMC1cXHVEQ0RGXFx1RENGM1xcdURDRjYtXFx1RENGQVxcdUREMUMtXFx1REQxRVxcdUREM0EtXFx1REQzRVxcdURENDAtXFx1REQ3RlxcdUREQjgtXFx1RERCQlxcdURERDBcXHVEREQxXFx1REUwNFxcdURFMDctXFx1REUwQlxcdURFMTRcXHVERTE4XFx1REUzNC1cXHVERTM3XFx1REUzQi1cXHVERTNFXFx1REU0OC1cXHVERTRGXFx1REU1OS1cXHVERTVGXFx1REVBMC1cXHVERUJGXFx1REVFNy1cXHVERUVBXFx1REVGNy1cXHVERUZGXFx1REYzNi1cXHVERjM4XFx1REY1NlxcdURGNTdcXHVERjczLVxcdURGNzdcXHVERjkyLVxcdURGOThcXHVERjlELVxcdURGQThcXHVERkIwLVxcdURGRkZdfFxcdUQ4MDhbXFx1REY5QS1cXHVERkZGXXxcXHVEODJGW1xcdURDNkItXFx1REM2RlxcdURDN0QtXFx1REM3RlxcdURDODktXFx1REM4RlxcdURDOUFcXHVEQzlCXFx1RENBMC1cXHVERkZGXXxcXHVEODJDW1xcdURDMDItXFx1REZGRl18XFx1RDgxMVtcXHVERTQ3LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVERDBGXFx1REQxOS1cXHVERDdGXFx1REQ4NS1cXHVEREJGXFx1RERDMS1cXHVERkZGXXxcXHVEODczW1xcdURFQTItXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDYycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnQ29udHJvbCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcMC1cXHgxRlxceDdGLVxceDlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ2YnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0Zvcm1hdCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkInLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1RDgwNFxcdURDQkQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDbicsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnVW5hc3NpZ25lZCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzNzhcXHUwMzc5XFx1MDM4MC1cXHUwMzgzXFx1MDM4QlxcdTAzOERcXHUwM0EyXFx1MDUzMFxcdTA1NTdcXHUwNTU4XFx1MDU2MFxcdTA1ODhcXHUwNThCXFx1MDU4Q1xcdTA1OTBcXHUwNUM4LVxcdTA1Q0ZcXHUwNUVCLVxcdTA1RUZcXHUwNUY1LVxcdTA1RkZcXHUwNjFEXFx1MDcwRVxcdTA3NEJcXHUwNzRDXFx1MDdCMi1cXHUwN0JGXFx1MDdGQi1cXHUwN0ZGXFx1MDgyRVxcdTA4MkZcXHUwODNGXFx1MDg1Q1xcdTA4NURcXHUwODVGLVxcdTA4OUZcXHUwOEI1LVxcdTA4RTJcXHUwOTg0XFx1MDk4RFxcdTA5OEVcXHUwOTkxXFx1MDk5MlxcdTA5QTlcXHUwOUIxXFx1MDlCMy1cXHUwOUI1XFx1MDlCQVxcdTA5QkJcXHUwOUM1XFx1MDlDNlxcdTA5QzlcXHUwOUNBXFx1MDlDRi1cXHUwOUQ2XFx1MDlEOC1cXHUwOURCXFx1MDlERVxcdTA5RTRcXHUwOUU1XFx1MDlGQy1cXHUwQTAwXFx1MEEwNFxcdTBBMEItXFx1MEEwRVxcdTBBMTFcXHUwQTEyXFx1MEEyOVxcdTBBMzFcXHUwQTM0XFx1MEEzN1xcdTBBM0FcXHUwQTNCXFx1MEEzRFxcdTBBNDMtXFx1MEE0NlxcdTBBNDlcXHUwQTRBXFx1MEE0RS1cXHUwQTUwXFx1MEE1Mi1cXHUwQTU4XFx1MEE1RFxcdTBBNUYtXFx1MEE2NVxcdTBBNzYtXFx1MEE4MFxcdTBBODRcXHUwQThFXFx1MEE5MlxcdTBBQTlcXHUwQUIxXFx1MEFCNFxcdTBBQkFcXHUwQUJCXFx1MEFDNlxcdTBBQ0FcXHUwQUNFXFx1MEFDRlxcdTBBRDEtXFx1MEFERlxcdTBBRTRcXHUwQUU1XFx1MEFGMi1cXHUwQUY4XFx1MEFGQS1cXHUwQjAwXFx1MEIwNFxcdTBCMERcXHUwQjBFXFx1MEIxMVxcdTBCMTJcXHUwQjI5XFx1MEIzMVxcdTBCMzRcXHUwQjNBXFx1MEIzQlxcdTBCNDVcXHUwQjQ2XFx1MEI0OVxcdTBCNEFcXHUwQjRFLVxcdTBCNTVcXHUwQjU4LVxcdTBCNUJcXHUwQjVFXFx1MEI2NFxcdTBCNjVcXHUwQjc4LVxcdTBCODFcXHUwQjg0XFx1MEI4Qi1cXHUwQjhEXFx1MEI5MVxcdTBCOTYtXFx1MEI5OFxcdTBCOUJcXHUwQjlEXFx1MEJBMC1cXHUwQkEyXFx1MEJBNS1cXHUwQkE3XFx1MEJBQi1cXHUwQkFEXFx1MEJCQS1cXHUwQkJEXFx1MEJDMy1cXHUwQkM1XFx1MEJDOVxcdTBCQ0VcXHUwQkNGXFx1MEJEMS1cXHUwQkQ2XFx1MEJEOC1cXHUwQkU1XFx1MEJGQi1cXHUwQkZGXFx1MEMwNFxcdTBDMERcXHUwQzExXFx1MEMyOVxcdTBDM0EtXFx1MEMzQ1xcdTBDNDVcXHUwQzQ5XFx1MEM0RS1cXHUwQzU0XFx1MEM1N1xcdTBDNUItXFx1MEM1RlxcdTBDNjRcXHUwQzY1XFx1MEM3MC1cXHUwQzc3XFx1MEM4MFxcdTBDODRcXHUwQzhEXFx1MEM5MVxcdTBDQTlcXHUwQ0I0XFx1MENCQVxcdTBDQkJcXHUwQ0M1XFx1MENDOVxcdTBDQ0UtXFx1MENENFxcdTBDRDctXFx1MENERFxcdTBDREZcXHUwQ0U0XFx1MENFNVxcdTBDRjBcXHUwQ0YzLVxcdTBEMDBcXHUwRDA0XFx1MEQwRFxcdTBEMTFcXHUwRDNCXFx1MEQzQ1xcdTBENDVcXHUwRDQ5XFx1MEQ0Ri1cXHUwRDU2XFx1MEQ1OC1cXHUwRDVFXFx1MEQ2NFxcdTBENjVcXHUwRDc2LVxcdTBENzhcXHUwRDgwXFx1MEQ4MVxcdTBEODRcXHUwRDk3LVxcdTBEOTlcXHUwREIyXFx1MERCQ1xcdTBEQkVcXHUwREJGXFx1MERDNy1cXHUwREM5XFx1MERDQi1cXHUwRENFXFx1MERENVxcdTBERDdcXHUwREUwLVxcdTBERTVcXHUwREYwXFx1MERGMVxcdTBERjUtXFx1MEUwMFxcdTBFM0ItXFx1MEUzRVxcdTBFNUMtXFx1MEU4MFxcdTBFODNcXHUwRTg1XFx1MEU4NlxcdTBFODlcXHUwRThCXFx1MEU4Q1xcdTBFOEUtXFx1MEU5M1xcdTBFOThcXHUwRUEwXFx1MEVBNFxcdTBFQTZcXHUwRUE4XFx1MEVBOVxcdTBFQUNcXHUwRUJBXFx1MEVCRVxcdTBFQkZcXHUwRUM1XFx1MEVDN1xcdTBFQ0VcXHUwRUNGXFx1MEVEQVxcdTBFREJcXHUwRUUwLVxcdTBFRkZcXHUwRjQ4XFx1MEY2RC1cXHUwRjcwXFx1MEY5OFxcdTBGQkRcXHUwRkNEXFx1MEZEQi1cXHUwRkZGXFx1MTBDNlxcdTEwQzgtXFx1MTBDQ1xcdTEwQ0VcXHUxMENGXFx1MTI0OVxcdTEyNEVcXHUxMjRGXFx1MTI1N1xcdTEyNTlcXHUxMjVFXFx1MTI1RlxcdTEyODlcXHUxMjhFXFx1MTI4RlxcdTEyQjFcXHUxMkI2XFx1MTJCN1xcdTEyQkZcXHUxMkMxXFx1MTJDNlxcdTEyQzdcXHUxMkQ3XFx1MTMxMVxcdTEzMTZcXHUxMzE3XFx1MTM1QlxcdTEzNUNcXHUxMzdELVxcdTEzN0ZcXHUxMzlBLVxcdTEzOUZcXHUxM0Y2XFx1MTNGN1xcdTEzRkVcXHUxM0ZGXFx1MTY5RC1cXHUxNjlGXFx1MTZGOS1cXHUxNkZGXFx1MTcwRFxcdTE3MTUtXFx1MTcxRlxcdTE3MzctXFx1MTczRlxcdTE3NTQtXFx1MTc1RlxcdTE3NkRcXHUxNzcxXFx1MTc3NC1cXHUxNzdGXFx1MTdERVxcdTE3REZcXHUxN0VBLVxcdTE3RUZcXHUxN0ZBLVxcdTE3RkZcXHUxODBGXFx1MTgxQS1cXHUxODFGXFx1MTg3OC1cXHUxODdGXFx1MThBQi1cXHUxOEFGXFx1MThGNi1cXHUxOEZGXFx1MTkxRlxcdTE5MkMtXFx1MTkyRlxcdTE5M0MtXFx1MTkzRlxcdTE5NDEtXFx1MTk0M1xcdTE5NkVcXHUxOTZGXFx1MTk3NS1cXHUxOTdGXFx1MTlBQy1cXHUxOUFGXFx1MTlDQS1cXHUxOUNGXFx1MTlEQi1cXHUxOUREXFx1MUExQ1xcdTFBMURcXHUxQTVGXFx1MUE3RFxcdTFBN0VcXHUxQThBLVxcdTFBOEZcXHUxQTlBLVxcdTFBOUZcXHUxQUFFXFx1MUFBRlxcdTFBQkYtXFx1MUFGRlxcdTFCNEMtXFx1MUI0RlxcdTFCN0QtXFx1MUI3RlxcdTFCRjQtXFx1MUJGQlxcdTFDMzgtXFx1MUMzQVxcdTFDNEEtXFx1MUM0Q1xcdTFDODAtXFx1MUNCRlxcdTFDQzgtXFx1MUNDRlxcdTFDRjdcXHUxQ0ZBLVxcdTFDRkZcXHUxREY2LVxcdTFERkJcXHUxRjE2XFx1MUYxN1xcdTFGMUVcXHUxRjFGXFx1MUY0NlxcdTFGNDdcXHUxRjRFXFx1MUY0RlxcdTFGNThcXHUxRjVBXFx1MUY1Q1xcdTFGNUVcXHUxRjdFXFx1MUY3RlxcdTFGQjVcXHUxRkM1XFx1MUZENFxcdTFGRDVcXHUxRkRDXFx1MUZGMFxcdTFGRjFcXHUxRkY1XFx1MUZGRlxcdTIwNjVcXHUyMDcyXFx1MjA3M1xcdTIwOEZcXHUyMDlELVxcdTIwOUZcXHUyMEJGLVxcdTIwQ0ZcXHUyMEYxLVxcdTIwRkZcXHUyMThDLVxcdTIxOEZcXHUyM0ZCLVxcdTIzRkZcXHUyNDI3LVxcdTI0M0ZcXHUyNDRCLVxcdTI0NUZcXHUyQjc0XFx1MkI3NVxcdTJCOTZcXHUyQjk3XFx1MkJCQS1cXHUyQkJDXFx1MkJDOVxcdTJCRDItXFx1MkJFQlxcdTJCRjAtXFx1MkJGRlxcdTJDMkZcXHUyQzVGXFx1MkNGNC1cXHUyQ0Y4XFx1MkQyNlxcdTJEMjgtXFx1MkQyQ1xcdTJEMkVcXHUyRDJGXFx1MkQ2OC1cXHUyRDZFXFx1MkQ3MS1cXHUyRDdFXFx1MkQ5Ny1cXHUyRDlGXFx1MkRBN1xcdTJEQUZcXHUyREI3XFx1MkRCRlxcdTJEQzdcXHUyRENGXFx1MkREN1xcdTJEREZcXHUyRTQzLVxcdTJFN0ZcXHUyRTlBXFx1MkVGNC1cXHUyRUZGXFx1MkZENi1cXHUyRkVGXFx1MkZGQy1cXHUyRkZGXFx1MzA0MFxcdTMwOTdcXHUzMDk4XFx1MzEwMC1cXHUzMTA0XFx1MzEyRS1cXHUzMTMwXFx1MzE4RlxcdTMxQkItXFx1MzFCRlxcdTMxRTQtXFx1MzFFRlxcdTMyMUZcXHUzMkZGXFx1NERCNi1cXHU0REJGXFx1OUZENi1cXHU5RkZGXFx1QTQ4RC1cXHVBNDhGXFx1QTRDNy1cXHVBNENGXFx1QTYyQy1cXHVBNjNGXFx1QTZGOC1cXHVBNkZGXFx1QTdBRVxcdUE3QUZcXHVBN0I4LVxcdUE3RjZcXHVBODJDLVxcdUE4MkZcXHVBODNBLVxcdUE4M0ZcXHVBODc4LVxcdUE4N0ZcXHVBOEM1LVxcdUE4Q0RcXHVBOERBLVxcdUE4REZcXHVBOEZFXFx1QThGRlxcdUE5NTQtXFx1QTk1RVxcdUE5N0QtXFx1QTk3RlxcdUE5Q0VcXHVBOURBLVxcdUE5RERcXHVBOUZGXFx1QUEzNy1cXHVBQTNGXFx1QUE0RVxcdUFBNEZcXHVBQTVBXFx1QUE1QlxcdUFBQzMtXFx1QUFEQVxcdUFBRjctXFx1QUIwMFxcdUFCMDdcXHVBQjA4XFx1QUIwRlxcdUFCMTBcXHVBQjE3LVxcdUFCMUZcXHVBQjI3XFx1QUIyRlxcdUFCNjYtXFx1QUI2RlxcdUFCRUVcXHVBQkVGXFx1QUJGQS1cXHVBQkZGXFx1RDdBNC1cXHVEN0FGXFx1RDdDNy1cXHVEN0NBXFx1RDdGQy1cXHVEN0ZGXFx1RkE2RVxcdUZBNkZcXHVGQURBLVxcdUZBRkZcXHVGQjA3LVxcdUZCMTJcXHVGQjE4LVxcdUZCMUNcXHVGQjM3XFx1RkIzRFxcdUZCM0ZcXHVGQjQyXFx1RkI0NVxcdUZCQzItXFx1RkJEMlxcdUZENDAtXFx1RkQ0RlxcdUZEOTBcXHVGRDkxXFx1RkRDOC1cXHVGREVGXFx1RkRGRVxcdUZERkZcXHVGRTFBLVxcdUZFMUZcXHVGRTUzXFx1RkU2N1xcdUZFNkMtXFx1RkU2RlxcdUZFNzVcXHVGRUZEXFx1RkVGRVxcdUZGMDBcXHVGRkJGLVxcdUZGQzFcXHVGRkM4XFx1RkZDOVxcdUZGRDBcXHVGRkQxXFx1RkZEOFxcdUZGRDlcXHVGRkRELVxcdUZGREZcXHVGRkU3XFx1RkZFRi1cXHVGRkY4XFx1RkZGRVxcdUZGRkYnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEQjQwW1xcdURDMDBcXHVEQzAyLVxcdURDMUZcXHVEQzgwLVxcdURDRkZcXHVEREYwLVxcdURGRkZdfFxcdUQ4MzRbXFx1RENGNi1cXHVEQ0ZGXFx1REQyN1xcdUREMjhcXHVEREU5LVxcdURERkZcXHVERTQ2LVxcdURFRkZcXHVERjU3LVxcdURGNUZcXHVERjcyLVxcdURGRkZdfFxcdUQ4M0NbXFx1REMyQy1cXHVEQzJGXFx1REM5NC1cXHVEQzlGXFx1RENBRlxcdURDQjBcXHVEQ0MwXFx1RENEMFxcdURDRjYtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENkZcXHVERDlCLVxcdURERTVcXHVERTAzLVxcdURFMEZcXHVERTNCLVxcdURFM0ZcXHVERTQ5LVxcdURFNEZcXHVERTUyLVxcdURFRkZdfFxcdUQ4MUFbXFx1REUzOS1cXHVERTNGXFx1REU1RlxcdURFNkEtXFx1REU2RFxcdURFNzAtXFx1REVDRlxcdURFRUVcXHVERUVGXFx1REVGNi1cXHVERUZGXFx1REY0Ni1cXHVERjRGXFx1REY1QVxcdURGNjJcXHVERjc4LVxcdURGN0NcXHVERjkwLVxcdURGRkZdfFxcdUQ4MDlbXFx1REM2RlxcdURDNzUtXFx1REM3RlxcdURENDQtXFx1REZGRl18XFx1RDgxQltcXHVEQzAwLVxcdURFRkZcXHVERjQ1LVxcdURGNEZcXHVERjdGLVxcdURGOEVcXHVERkEwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMxRVxcdURDMUZdfFxcdUQ4M0RbXFx1REQ3QVxcdUREQTRcXHVERUQxLVxcdURFREZcXHVERUVELVxcdURFRUZcXHVERUY0LVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4MDFbXFx1REM5RVxcdURDOUZcXHVEQ0FBLVxcdURDRkZcXHVERDI4LVxcdUREMkZcXHVERDY0LVxcdURENkVcXHVERDcwLVxcdURERkZcXHVERjM3LVxcdURGM0ZcXHVERjU2LVxcdURGNUZcXHVERjY4LVxcdURGRkZdfFxcdUQ4MDBbXFx1REMwQ1xcdURDMjdcXHVEQzNCXFx1REMzRVxcdURDNEVcXHVEQzRGXFx1REM1RS1cXHVEQzdGXFx1RENGQi1cXHVEQ0ZGXFx1REQwMy1cXHVERDA2XFx1REQzNC1cXHVERDM2XFx1REQ4RC1cXHVERDhGXFx1REQ5Qy1cXHVERDlGXFx1RERBMS1cXHVERENGXFx1RERGRS1cXHVERTdGXFx1REU5RC1cXHVERTlGXFx1REVEMS1cXHVERURGXFx1REVGQy1cXHVERUZGXFx1REYyNC1cXHVERjJGXFx1REY0Qi1cXHVERjRGXFx1REY3Qi1cXHVERjdGXFx1REY5RVxcdURGQzQtXFx1REZDN1xcdURGRDYtXFx1REZGRl18XFx1RDg2OVtcXHVERUQ3LVxcdURFRkZdfFxcdUQ4M0JbXFx1REMwMC1cXHVEREZGXFx1REUwNFxcdURFMjBcXHVERTIzXFx1REUyNVxcdURFMjZcXHVERTI4XFx1REUzM1xcdURFMzhcXHVERTNBXFx1REUzQy1cXHVERTQxXFx1REU0My1cXHVERTQ2XFx1REU0OFxcdURFNEFcXHVERTRDXFx1REU1MFxcdURFNTNcXHVERTU1XFx1REU1NlxcdURFNThcXHVERTVBXFx1REU1Q1xcdURFNUVcXHVERTYwXFx1REU2M1xcdURFNjVcXHVERTY2XFx1REU2QlxcdURFNzNcXHVERTc4XFx1REU3RFxcdURFN0ZcXHVERThBXFx1REU5Qy1cXHVERUEwXFx1REVBNFxcdURFQUFcXHVERUJDLVxcdURFRUZcXHVERUYyLVxcdURGRkZdfFtcXHVEQkJGXFx1REJGRl1bXFx1REZGRVxcdURGRkZdfFxcdUQ4N0VbXFx1REUxRS1cXHVERkZGXXxcXHVEODJGW1xcdURDNkItXFx1REM2RlxcdURDN0QtXFx1REM3RlxcdURDODktXFx1REM4RlxcdURDOUFcXHVEQzlCXFx1RENBNC1cXHVERkZGXXxcXHVEODNBW1xcdURDQzVcXHVEQ0M2XFx1RENENy1cXHVERkZGXXxcXHVEODBEW1xcdURDMkYtXFx1REZGRl18XFx1RDg2RFtcXHVERjM1LVxcdURGM0ZdfFtcXHVEODA3XFx1RDgwQVxcdUQ4MEJcXHVEODBFLVxcdUQ4MTBcXHVEODEyLVxcdUQ4MTlcXHVEODFDLVxcdUQ4MkJcXHVEODJEXFx1RDgyRVxcdUQ4MzAtXFx1RDgzM1xcdUQ4MzctXFx1RDgzOVxcdUQ4M0ZcXHVEODc0LVxcdUQ4N0RcXHVEODdGLVxcdURCM0ZcXHVEQjQxLVxcdURCN0ZdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwNltcXHVEQzAwLVxcdURDOUZcXHVEQ0YzLVxcdURDRkVcXHVERDAwLVxcdURFQkZcXHVERUY5LVxcdURGRkZdfFxcdUQ4MDNbXFx1REM0OS1cXHVEQzdGXFx1RENCMy1cXHVEQ0JGXFx1RENGMy1cXHVEQ0Y5XFx1REQwMC1cXHVERTVGXFx1REU3Ri1cXHVERkZGXXxcXHVEODM1W1xcdURDNTVcXHVEQzlEXFx1RENBMFxcdURDQTFcXHVEQ0EzXFx1RENBNFxcdURDQTdcXHVEQ0E4XFx1RENBRFxcdURDQkFcXHVEQ0JDXFx1RENDNFxcdUREMDZcXHVERDBCXFx1REQwQ1xcdUREMTVcXHVERDFEXFx1REQzQVxcdUREM0ZcXHVERDQ1XFx1REQ0Ny1cXHVERDQ5XFx1REQ1MVxcdURFQTZcXHVERUE3XFx1REZDQ1xcdURGQ0RdfFxcdUQ4MzZbXFx1REU4Qy1cXHVERTlBXFx1REVBMFxcdURFQjAtXFx1REZGRl18XFx1RDgwNVtcXHVEQzAwLVxcdURDN0ZcXHVEQ0M4LVxcdURDQ0ZcXHVEQ0RBLVxcdUREN0ZcXHVEREI2XFx1RERCN1xcdUREREUtXFx1RERGRlxcdURFNDUtXFx1REU0RlxcdURFNUEtXFx1REU3RlxcdURFQjgtXFx1REVCRlxcdURFQ0EtXFx1REVGRlxcdURGMUEtXFx1REYxQ1xcdURGMkMtXFx1REYyRlxcdURGNDAtXFx1REZGRl18XFx1RDgwMltcXHVEQzA2XFx1REMwN1xcdURDMDlcXHVEQzM2XFx1REMzOS1cXHVEQzNCXFx1REMzRFxcdURDM0VcXHVEQzU2XFx1REM5Ri1cXHVEQ0E2XFx1RENCMC1cXHVEQ0RGXFx1RENGM1xcdURDRjYtXFx1RENGQVxcdUREMUMtXFx1REQxRVxcdUREM0EtXFx1REQzRVxcdURENDAtXFx1REQ3RlxcdUREQjgtXFx1RERCQlxcdURERDBcXHVEREQxXFx1REUwNFxcdURFMDctXFx1REUwQlxcdURFMTRcXHVERTE4XFx1REUzNC1cXHVERTM3XFx1REUzQi1cXHVERTNFXFx1REU0OC1cXHVERTRGXFx1REU1OS1cXHVERTVGXFx1REVBMC1cXHVERUJGXFx1REVFNy1cXHVERUVBXFx1REVGNy1cXHVERUZGXFx1REYzNi1cXHVERjM4XFx1REY1NlxcdURGNTdcXHVERjczLVxcdURGNzdcXHVERjkyLVxcdURGOThcXHVERjlELVxcdURGQThcXHVERkIwLVxcdURGRkZdfFxcdUQ4MDhbXFx1REY5QS1cXHVERkZGXXxcXHVEODA0W1xcdURDNEUtXFx1REM1MVxcdURDNzAtXFx1REM3RVxcdURDQzItXFx1RENDRlxcdURDRTktXFx1RENFRlxcdURDRkEtXFx1RENGRlxcdUREMzVcXHVERDQ0LVxcdURENEZcXHVERDc3LVxcdUREN0ZcXHVERENFXFx1RERDRlxcdURERTBcXHVEREY1LVxcdURERkZcXHVERTEyXFx1REUzRS1cXHVERTdGXFx1REU4N1xcdURFODlcXHVERThFXFx1REU5RVxcdURFQUEtXFx1REVBRlxcdURFRUItXFx1REVFRlxcdURFRkEtXFx1REVGRlxcdURGMDRcXHVERjBEXFx1REYwRVxcdURGMTFcXHVERjEyXFx1REYyOVxcdURGMzFcXHVERjM0XFx1REYzQVxcdURGM0JcXHVERjQ1XFx1REY0NlxcdURGNDlcXHVERjRBXFx1REY0RVxcdURGNEZcXHVERjUxLVxcdURGNTZcXHVERjU4LVxcdURGNUNcXHVERjY0XFx1REY2NVxcdURGNkQtXFx1REY2RlxcdURGNzUtXFx1REZGRl18XFx1RDgyQ1tcXHVEQzAyLVxcdURGRkZdfFxcdUQ4MTFbXFx1REU0Ny1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1REQwRlxcdUREMTktXFx1REQ3RlxcdUREODUtXFx1RERCRlxcdUREQzEtXFx1REZGRl18XFx1RDg3M1tcXHVERUEyLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ28nLFxyXG4gICAgICAgICAgICBhbGlhczogJ1ByaXZhdGVfVXNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RTAwMC1cXHVGOEZGJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdURCODAtXFx1REJCRVxcdURCQzAtXFx1REJGRV1bXFx1REMwMC1cXHVERkZGXXxbXFx1REJCRlxcdURCRkZdW1xcdURDMDAtXFx1REZGRF0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDcycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnU3Vycm9nYXRlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RDgwMC1cXHVERkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTCcsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnTGV0dGVyJyxcclxuICAgICAgICAgICAgYm1wOiAnQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMbCcsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnTG93ZXJjYXNlX0xldHRlcicsXHJcbiAgICAgICAgICAgIGJtcDogJ2EtelxceEI1XFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJBRlxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0ItXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxRDAwLVxcdTFEMkJcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEOUFcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTg0XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdCXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2RlxcdUE3NzEtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI2MC1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MzVbXFx1REMxQS1cXHVEQzMzXFx1REM0RS1cXHVEQzU0XFx1REM1Ni1cXHVEQzY3XFx1REM4Mi1cXHVEQzlCXFx1RENCNi1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1RENDRlxcdURDRUEtXFx1REQwM1xcdUREMUUtXFx1REQzN1xcdURENTItXFx1REQ2QlxcdUREODYtXFx1REQ5RlxcdUREQkEtXFx1REREM1xcdURERUUtXFx1REUwN1xcdURFMjItXFx1REUzQlxcdURFNTYtXFx1REU2RlxcdURFOEEtXFx1REVBNVxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVFMVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYxQlxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY1NVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REY4RlxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDOVxcdURGQ0JdfFxcdUQ4MDFbXFx1REMyOC1cXHVEQzRGXXxcXHVEODA2W1xcdURDQzAtXFx1RENERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMbScsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnTW9kaWZpZXJfTGV0dGVyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDJCMC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzc0XFx1MDM3QVxcdTA1NTlcXHUwNjQwXFx1MDZFNVxcdTA2RTZcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwOTcxXFx1MEU0NlxcdTBFQzZcXHUxMEZDXFx1MTdEN1xcdTE4NDNcXHUxQUE3XFx1MUM3OC1cXHUxQzdEXFx1MUQyQy1cXHUxRDZBXFx1MUQ3OFxcdTFEOUItXFx1MURCRlxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MkM3Q1xcdTJDN0RcXHUyRDZGXFx1MkUyRlxcdTMwMDVcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzA5RFxcdTMwOUVcXHUzMEZDLVxcdTMwRkVcXHVBMDE1XFx1QTRGOC1cXHVBNEZEXFx1QTYwQ1xcdUE2N0ZcXHVBNjlDXFx1QTY5RFxcdUE3MTctXFx1QTcxRlxcdUE3NzBcXHVBNzg4XFx1QTdGOFxcdUE3RjlcXHVBOUNGXFx1QTlFNlxcdUFBNzBcXHVBQUREXFx1QUFGM1xcdUFBRjRcXHVBQjVDLVxcdUFCNUZcXHVGRjcwXFx1RkY5RVxcdUZGOUYnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURGNDAtXFx1REY0M118XFx1RDgxQltcXHVERjkzLVxcdURGOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTG8nLFxyXG4gICAgICAgICAgICBhbGlhczogJ090aGVyX0xldHRlcicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceEFBXFx4QkFcXHUwMUJCXFx1MDFDMC1cXHUwMUMzXFx1MDI5NFxcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDYzRlxcdTA2NDEtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDgwMC1cXHUwODE1XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcyLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBEMC1cXHUxMEZBXFx1MTBGRC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0RDXFx1MTgyMC1cXHUxODQyXFx1MTg0NC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzc3XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUyMTM1LVxcdTIxMzhcXHUyRDMwLVxcdTJENjdcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA2XFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBMDE0XFx1QTAxNi1cXHVBNDhDXFx1QTREMC1cXHVBNEY3XFx1QTUwMC1cXHVBNjBCXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjZFXFx1QTZBMC1cXHVBNkU1XFx1QTc4RlxcdUE3RjdcXHVBN0ZCLVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5RTAtXFx1QTlFNFxcdUE5RTctXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE2RlxcdUFBNzEtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREJcXHVBQURDXFx1QUFFMC1cXHVBQUVBXFx1QUFGMlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGNjYtXFx1RkY2RlxcdUZGNzEtXFx1RkY5RFxcdUZGQTAtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODAzW1xcdURDMDAtXFx1REM0OF18XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MDFbXFx1REM1MC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0x0JyxcclxuICAgICAgICAgICAgYWxpYXM6ICdUaXRsZWNhc2VfTGV0dGVyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDFDNVxcdTAxQzhcXHUwMUNCXFx1MDFGMlxcdTFGODgtXFx1MUY4RlxcdTFGOTgtXFx1MUY5RlxcdTFGQTgtXFx1MUZBRlxcdTFGQkNcXHUxRkNDXFx1MUZGQydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0x1JyxcclxuICAgICAgICAgICAgYWxpYXM6ICdVcHBlcmNhc2VfTGV0dGVyJyxcclxuICAgICAgICAgICAgYm1wOiAnQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE4M1xcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FEXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDZbXFx1RENBMC1cXHVEQ0JGXXxcXHVEODAzW1xcdURDODAtXFx1RENCMl18XFx1RDgwMVtcXHVEQzAwLVxcdURDMjddfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzE5XFx1REMzNC1cXHVEQzREXFx1REM2OC1cXHVEQzgxXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I1XFx1RENEMC1cXHVEQ0U5XFx1REQwNFxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDM4XFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDZDLVxcdUREODVcXHVEREEwLVxcdUREQjlcXHVEREQ0LVxcdURERURcXHVERTA4LVxcdURFMjFcXHVERTNDLVxcdURFNTVcXHVERTcwLVxcdURFODlcXHVERUE4LVxcdURFQzBcXHVERUUyLVxcdURFRkFcXHVERjFDLVxcdURGMzRcXHVERjU2LVxcdURGNkVcXHVERjkwLVxcdURGQThcXHVERkNBXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ00nLFxyXG4gICAgICAgICAgICBhbGlhczogJ01hcmsnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhFMy1cXHUwOTAzXFx1MDkzQS1cXHUwOTNDXFx1MDkzRS1cXHUwOTRGXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxLVxcdTA5ODNcXHUwOUJDXFx1MDlCRS1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwQTAxLVxcdTBBMDNcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEFCQ1xcdTBBQkUtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEIwMS1cXHUwQjAzXFx1MEIzQ1xcdTBCM0UtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQ3XFx1MEMwMC1cXHUwQzAzXFx1MEMzRS1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODEtXFx1MEM4M1xcdTBDQkNcXHUwQ0JFLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMS1cXHUwRDAzXFx1MEQzRS1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MlxcdTBEODNcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERjJcXHUwREYzXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQjlcXHUwRUJCXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRVxcdTBGM0ZcXHUwRjcxLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJCLVxcdTEwM0VcXHUxMDU2LVxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNkRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOERcXHUxMDhGXFx1MTA5QS1cXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjQtXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxOEE5XFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MUExNy1cXHUxQTFCXFx1MUE1NS1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFCRVxcdTFCMDAtXFx1MUIwNFxcdTFCMzQtXFx1MUI0NFxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUI4MlxcdTFCQTEtXFx1MUJBRFxcdTFCRTYtXFx1MUJGM1xcdTFDMjQtXFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFOFxcdTFDRURcXHUxQ0YyLVxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGNVxcdTFERkMtXFx1MURGRlxcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODIzLVxcdUE4MjdcXHVBODgwXFx1QTg4MVxcdUE4QjQtXFx1QThDNFxcdUE4RTAtXFx1QThGMVxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1M1xcdUE5ODAtXFx1QTk4M1xcdUE5QjMtXFx1QTlDMFxcdUE5RTVcXHVBQTI5LVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBNERcXHVBQTdCLVxcdUFBN0RcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVCLVxcdUFBRUZcXHVBQUY1XFx1QUFGNlxcdUFCRTMtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1RENCMC1cXHVEQ0MzXFx1RERBRi1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREQ1xcdURERERcXHVERTMwLVxcdURFNDBcXHVERUFCLVxcdURFQjdcXHVERjFELVxcdURGMkJdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODA0W1xcdURDMDAtXFx1REMwMlxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MlxcdURDQjAtXFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQzNFxcdURENzNcXHVERDgwLVxcdUREODJcXHVEREIzLVxcdUREQzBcXHVERENBLVxcdUREQ0NcXHVERTJDLVxcdURFMzdcXHVERURGLVxcdURFRUFcXHVERjAwLVxcdURGMDNcXHVERjNDXFx1REYzRS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjU3XFx1REY2MlxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MUJbXFx1REY1MS1cXHVERjdFXFx1REY4Ri1cXHVERjkyXXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01jJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdTcGFjaW5nX01hcmsnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwOTAzXFx1MDkzQlxcdTA5M0UtXFx1MDk0MFxcdTA5NDktXFx1MDk0Q1xcdTA5NEVcXHUwOTRGXFx1MDk4MlxcdTA5ODNcXHUwOUJFLVxcdTA5QzBcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MDlEN1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjNFXFx1MEI0MFxcdTBCNDdcXHUwQjQ4XFx1MEI0QlxcdTBCNENcXHUwQjU3XFx1MEJCRVxcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBCRDdcXHUwQzAxLVxcdTBDMDNcXHUwQzQxLVxcdTBDNDRcXHUwQzgyXFx1MEM4M1xcdTBDQkVcXHUwQ0MwLVxcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MENENVxcdTBDRDZcXHUwRDAyXFx1MEQwM1xcdTBEM0UtXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBENTdcXHUwRDgyXFx1MEQ4M1xcdTBEQ0YtXFx1MEREMVxcdTBERDgtXFx1MERERlxcdTBERjJcXHUwREYzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAyQlxcdTEwMkNcXHUxMDMxXFx1MTAzOFxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNkRcXHUxMDgzXFx1MTA4NFxcdTEwODctXFx1MTA4Q1xcdTEwOEZcXHUxMDlBLVxcdTEwOUNcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTYxXFx1MUE2M1xcdTFBNjRcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzNVxcdTFCM0JcXHUxQjNELVxcdTFCNDFcXHUxQjQzXFx1MUI0NFxcdTFCODJcXHUxQkExXFx1MUJBNlxcdTFCQTdcXHUxQkFBXFx1MUJFN1xcdTFCRUEtXFx1MUJFQ1xcdTFCRUVcXHUxQkYyXFx1MUJGM1xcdTFDMjQtXFx1MUMyQlxcdTFDMzRcXHUxQzM1XFx1MUNFMVxcdTFDRjJcXHUxQ0YzXFx1MzAyRVxcdTMwMkZcXHVBODIzXFx1QTgyNFxcdUE4MjdcXHVBODgwXFx1QTg4MVxcdUE4QjQtXFx1QThDM1xcdUE5NTJcXHVBOTUzXFx1QTk4M1xcdUE5QjRcXHVBOUI1XFx1QTlCQVxcdUE5QkJcXHVBOUJELVxcdUE5QzBcXHVBQTJGXFx1QUEzMFxcdUFBMzNcXHVBQTM0XFx1QUE0RFxcdUFBN0JcXHVBQTdEXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURENjVcXHVERDY2XFx1REQ2RC1cXHVERDcyXXxcXHVEODA0W1xcdURDMDBcXHVEQzAyXFx1REM4MlxcdURDQjAtXFx1RENCMlxcdURDQjdcXHVEQ0I4XFx1REQyQ1xcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdURFMkMtXFx1REUyRVxcdURFMzJcXHVERTMzXFx1REUzNVxcdURFRTAtXFx1REVFMlxcdURGMDJcXHVERjAzXFx1REYzRVxcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTdcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQ0IwLVxcdURDQjJcXHVEQ0I5XFx1RENCQi1cXHVEQ0JFXFx1RENDMVxcdUREQUYtXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyMFxcdURGMjFcXHVERjI2XXxcXHVEODFCW1xcdURGNTEtXFx1REY3RV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNZScsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnRW5jbG9zaW5nX01hcmsnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNDg4XFx1MDQ4OVxcdTFBQkVcXHUyMERELVxcdTIwRTBcXHUyMEUyLVxcdTIwRTRcXHVBNjcwLVxcdUE2NzInXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNbicsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnTm9uc3BhY2luZ19NYXJrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlFMlxcdTA5RTNcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEIwMVxcdTBCM0NcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTZcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkMwXFx1MEJDRFxcdTBDMDBcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENFMlxcdTBDRTNcXHUwRDAxXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENjJcXHUwRDYzXFx1MERDQVxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCOVxcdTBFQkJcXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCMDNcXHUxQjM0XFx1MUIzNi1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGNVxcdTFERkMtXFx1MURGRlxcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJEXFx1MzA5OVxcdTMwOUFcXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QThDNFxcdUE4RTAtXFx1QThGMVxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgzNFtcXHVERDY3LVxcdURENjlcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGOEYtXFx1REY5Ml18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVERENBLVxcdUREQ0NcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNDXFx1REY0MFxcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ04nLFxyXG4gICAgICAgICAgICBhbGlhczogJ051bWJlcicsXHJcbiAgICAgICAgICAgIGJtcDogJzAtOVxceEIyXFx4QjNcXHhCOVxceEJDLVxceEJFXFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MDlGNC1cXHUwOUY5XFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEI3Mi1cXHUwQjc3XFx1MEJFNi1cXHUwQkYyXFx1MEM2Ni1cXHUwQzZGXFx1MEM3OC1cXHUwQzdFXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDc1XFx1MERFNi1cXHUwREVGXFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjMzXFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTM2OS1cXHUxMzdDXFx1MTZFRS1cXHUxNkYwXFx1MTdFMC1cXHUxN0U5XFx1MTdGMC1cXHUxN0Y5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOURBXFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1MjA3MFxcdTIwNzQtXFx1MjA3OVxcdTIwODAtXFx1MjA4OVxcdTIxNTAtXFx1MjE4MlxcdTIxODUtXFx1MjE4OVxcdTI0NjAtXFx1MjQ5QlxcdTI0RUEtXFx1MjRGRlxcdTI3NzYtXFx1Mjc5M1xcdTJDRkRcXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzOC1cXHUzMDNBXFx1MzE5Mi1cXHUzMTk1XFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1QTYyMC1cXHVBNjI5XFx1QTZFNi1cXHVBNkVGXFx1QTgzMC1cXHVBODM1XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QTlGMC1cXHVBOUY5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDA3LVxcdUREMzNcXHVERDQwLVxcdURENzhcXHVERDhBXFx1REQ4QlxcdURFRTEtXFx1REVGQlxcdURGMjAtXFx1REYyM1xcdURGNDFcXHVERjRBXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDQTAtXFx1RENBOV18XFx1RDgwM1tcXHVEQ0ZBLVxcdURDRkZcXHVERTYwLVxcdURFN0VdfFxcdUQ4MzVbXFx1REZDRS1cXHVERkZGXXxcXHVEODNBW1xcdURDQzctXFx1RENDRl18XFx1RDgxQVtcXHVERTYwLVxcdURFNjlcXHVERjUwLVxcdURGNTlcXHVERjVCLVxcdURGNjFdfFxcdUQ4MDZbXFx1RENFMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDNTItXFx1REM2RlxcdURDRjAtXFx1RENGOVxcdUREMzYtXFx1REQzRlxcdURERDAtXFx1REREOVxcdURERTEtXFx1RERGNFxcdURFRjAtXFx1REVGOV18XFx1RDgzNFtcXHVERjYwLVxcdURGNzFdfFxcdUQ4M0NbXFx1REQwMC1cXHVERDBDXXxcXHVEODA5W1xcdURDMDAtXFx1REM2RV18XFx1RDgwMltcXHVEQzU4LVxcdURDNUZcXHVEQzc5LVxcdURDN0ZcXHVEQ0E3LVxcdURDQUZcXHVEQ0ZCLVxcdURDRkZcXHVERDE2LVxcdUREMUJcXHVEREJDXFx1RERCRFxcdUREQzAtXFx1RERDRlxcdURERDItXFx1RERGRlxcdURFNDAtXFx1REU0N1xcdURFN0RcXHVERTdFXFx1REU5RC1cXHVERTlGXFx1REVFQi1cXHVERUVGXFx1REY1OC1cXHVERjVGXFx1REY3OC1cXHVERjdGXFx1REZBOS1cXHVERkFGXXxcXHVEODA1W1xcdURDRDAtXFx1RENEOVxcdURFNTAtXFx1REU1OVxcdURFQzAtXFx1REVDOVxcdURGMzAtXFx1REYzQl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdOZCcsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnRGVjaW1hbF9OdW1iZXInLFxyXG4gICAgICAgICAgICBibXA6ICcwLTlcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcXHUwN0MwLVxcdTA3QzlcXHUwOTY2LVxcdTA5NkZcXHUwOUU2LVxcdTA5RUZcXHUwQTY2LVxcdTBBNkZcXHUwQUU2LVxcdTBBRUZcXHUwQjY2LVxcdTBCNkZcXHUwQkU2LVxcdTBCRUZcXHUwQzY2LVxcdTBDNkZcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENkZcXHUwREU2LVxcdTBERUZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDkwLVxcdTEwOTlcXHUxN0UwLVxcdTE3RTlcXHUxODEwLVxcdTE4MTlcXHUxOTQ2LVxcdTE5NEZcXHUxOUQwLVxcdTE5RDlcXHUxQTgwLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQjUwLVxcdTFCNTlcXHUxQkIwLVxcdTFCQjlcXHUxQzQwLVxcdTFDNDlcXHUxQzUwLVxcdTFDNTlcXHVBNjIwLVxcdUE2MjlcXHVBOEQwLVxcdUE4RDlcXHVBOTAwLVxcdUE5MDlcXHVBOUQwLVxcdUE5RDlcXHVBOUYwLVxcdUE5RjlcXHVBQTUwLVxcdUFBNTlcXHVBQkYwLVxcdUFCRjlcXHVGRjEwLVxcdUZGMTknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDQTAtXFx1RENBOV18XFx1RDgzNVtcXHVERkNFLVxcdURGRkZdfFxcdUQ4MDVbXFx1RENEMC1cXHVEQ0Q5XFx1REU1MC1cXHVERTU5XFx1REVDMC1cXHVERUM5XFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDRTAtXFx1RENFOV18XFx1RDgwNFtcXHVEQzY2LVxcdURDNkZcXHVEQ0YwLVxcdURDRjlcXHVERDM2LVxcdUREM0ZcXHVEREQwLVxcdURERDlcXHVERUYwLVxcdURFRjldfFxcdUQ4MUFbXFx1REU2MC1cXHVERTY5XFx1REY1MC1cXHVERjU5XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ05sJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdMZXR0ZXJfTnVtYmVyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTZFRS1cXHUxNkYwXFx1MjE2MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg4XFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdUE2RTYtXFx1QTZFRicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXXxcXHVEODAwW1xcdURENDAtXFx1REQ3NFxcdURGNDFcXHVERjRBXFx1REZEMS1cXHVERkQ1XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ05vJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9OdW1iZXInLFxyXG4gICAgICAgICAgICBibXA6ICdcXHhCMlxceEIzXFx4QjlcXHhCQy1cXHhCRVxcdTA5RjQtXFx1MDlGOVxcdTBCNzItXFx1MEI3N1xcdTBCRjAtXFx1MEJGMlxcdTBDNzgtXFx1MEM3RVxcdTBENzAtXFx1MEQ3NVxcdTBGMkEtXFx1MEYzM1xcdTEzNjktXFx1MTM3Q1xcdTE3RjAtXFx1MTdGOVxcdTE5REFcXHUyMDcwXFx1MjA3NC1cXHUyMDc5XFx1MjA4MC1cXHUyMDg5XFx1MjE1MC1cXHUyMTVGXFx1MjE4OVxcdTI0NjAtXFx1MjQ5QlxcdTI0RUEtXFx1MjRGRlxcdTI3NzYtXFx1Mjc5M1xcdTJDRkRcXHUzMTkyLVxcdTMxOTVcXHUzMjIwLVxcdTMyMjlcXHUzMjQ4LVxcdTMyNEZcXHUzMjUxLVxcdTMyNUZcXHUzMjgwLVxcdTMyODlcXHUzMkIxLVxcdTMyQkZcXHVBODMwLVxcdUE4MzUnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDNTItXFx1REM2NVxcdURERTEtXFx1RERGNF18XFx1RDgwM1tcXHVEQ0ZBLVxcdURDRkZcXHVERTYwLVxcdURFN0VdfFxcdUQ4M0NbXFx1REQwMC1cXHVERDBDXXxcXHVEODA2W1xcdURDRUEtXFx1RENGMl18XFx1RDgzQVtcXHVEQ0M3LVxcdURDQ0ZdfFxcdUQ4MDJbXFx1REM1OC1cXHVEQzVGXFx1REM3OS1cXHVEQzdGXFx1RENBNy1cXHVEQ0FGXFx1RENGQi1cXHVEQ0ZGXFx1REQxNi1cXHVERDFCXFx1RERCQ1xcdUREQkRcXHVEREMwLVxcdUREQ0ZcXHVEREQyLVxcdURERkZcXHVERTQwLVxcdURFNDdcXHVERTdEXFx1REU3RVxcdURFOUQtXFx1REU5RlxcdURFRUItXFx1REVFRlxcdURGNTgtXFx1REY1RlxcdURGNzgtXFx1REY3RlxcdURGQTktXFx1REZBRl18XFx1RDgwNVtcXHVERjNBXFx1REYzQl18XFx1RDgxQVtcXHVERjVCLVxcdURGNjFdfFxcdUQ4MzRbXFx1REY2MC1cXHVERjcxXXxcXHVEODAwW1xcdUREMDctXFx1REQzM1xcdURENzUtXFx1REQ3OFxcdUREOEFcXHVERDhCXFx1REVFMS1cXHVERUZCXFx1REYyMC1cXHVERjIzXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1AnLFxyXG4gICAgICAgICAgICBhbGlhczogJ1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx4MjEtXFx4MjNcXHgyNS1cXFxceDJBXFx4MkMtXFx4MkZcXHgzQVxceDNCXFxcXHgzRlxceDQwXFxcXHg1Qi1cXFxceDVEXFx4NUZcXFxceDdCXFx4N0RcXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQyXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MDVbXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURGM0MtXFx1REYzRV18XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BjJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdDb25uZWN0b3JfUHVuY3R1YXRpb24nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHg1RlxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkYzRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BkJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdEYXNoX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyRFxcdTA1OEFcXHUwNUJFXFx1MTQwMFxcdTE4MDZcXHUyMDEwLVxcdTIwMTVcXHUyRTE3XFx1MkUxQVxcdTJFM0FcXHUyRTNCXFx1MkU0MFxcdTMwMUNcXHUzMDMwXFx1MzBBMFxcdUZFMzFcXHVGRTMyXFx1RkU1OFxcdUZFNjNcXHVGRjBEJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUGUnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0Nsb3NlX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyOVxcXFx4NURcXHg3RFxcdTBGM0JcXHUwRjNEXFx1MTY5Q1xcdTIwNDZcXHUyMDdFXFx1MjA4RVxcdTIzMDlcXHUyMzBCXFx1MjMyQVxcdTI3NjlcXHUyNzZCXFx1Mjc2RFxcdTI3NkZcXHUyNzcxXFx1Mjc3M1xcdTI3NzVcXHUyN0M2XFx1MjdFN1xcdTI3RTlcXHUyN0VCXFx1MjdFRFxcdTI3RUZcXHUyOTg0XFx1Mjk4NlxcdTI5ODhcXHUyOThBXFx1Mjk4Q1xcdTI5OEVcXHUyOTkwXFx1Mjk5MlxcdTI5OTRcXHUyOTk2XFx1Mjk5OFxcdTI5RDlcXHUyOURCXFx1MjlGRFxcdTJFMjNcXHUyRTI1XFx1MkUyN1xcdTJFMjlcXHUzMDA5XFx1MzAwQlxcdTMwMERcXHUzMDBGXFx1MzAxMVxcdTMwMTVcXHUzMDE3XFx1MzAxOVxcdTMwMUJcXHUzMDFFXFx1MzAxRlxcdUZEM0VcXHVGRTE4XFx1RkUzNlxcdUZFMzhcXHVGRTNBXFx1RkUzQ1xcdUZFM0VcXHVGRTQwXFx1RkU0MlxcdUZFNDRcXHVGRTQ4XFx1RkU1QVxcdUZFNUNcXHVGRTVFXFx1RkYwOVxcdUZGM0RcXHVGRjVEXFx1RkY2MFxcdUZGNjMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQZicsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnRmluYWxfUHVuY3R1YXRpb24nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHhCQlxcdTIwMTlcXHUyMDFEXFx1MjAzQVxcdTJFMDNcXHUyRTA1XFx1MkUwQVxcdTJFMERcXHUyRTFEXFx1MkUyMSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BpJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdJbml0aWFsX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx4QUJcXHUyMDE4XFx1MjAxQlxcdTIwMUNcXHUyMDFGXFx1MjAzOVxcdTJFMDJcXHUyRTA0XFx1MkUwOVxcdTJFMENcXHUyRTFDXFx1MkUyMCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BvJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9QdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceDIxLVxceDIzXFx4MjUtXFx4MjdcXFxceDJBXFx4MkNcXFxceDJFXFx4MkZcXHgzQVxceDNCXFxcXHgzRlxceDQwXFxcXHg1Q1xceEExXFx4QTdcXHhCNlxceEI3XFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNjZEXFx1MTY2RVxcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODA1XFx1MTgwNy1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTZcXHUyMDE3XFx1MjAyMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDM4XFx1MjAzQi1cXHUyMDNFXFx1MjA0MS1cXHUyMDQzXFx1MjA0Ny1cXHUyMDUxXFx1MjA1M1xcdTIwNTUtXFx1MjA1RVxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDBcXHUyRTAxXFx1MkUwNi1cXHUyRTA4XFx1MkUwQlxcdTJFMEUtXFx1MkUxNlxcdTJFMThcXHUyRTE5XFx1MkUxQlxcdTJFMUVcXHUyRTFGXFx1MkUyQS1cXHUyRTJFXFx1MkUzMC1cXHUyRTM5XFx1MkUzQy1cXHUyRTNGXFx1MkU0MVxcdTMwMDEtXFx1MzAwM1xcdTMwM0RcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRTEwLVxcdUZFMTZcXHVGRTE5XFx1RkUzMFxcdUZFNDVcXHVGRTQ2XFx1RkU0OS1cXHVGRTRDXFx1RkU1MC1cXHVGRTUyXFx1RkU1NC1cXHVGRTU3XFx1RkU1Ri1cXHVGRTYxXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjA3XFx1RkYwQVxcdUZGMENcXHVGRjBFXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNDXFx1RkY2MVxcdUZGNjRcXHVGRjY1JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REYzQy1cXHVERjNFXXxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgwMVxcdURENkZ8XFx1RDgyRlxcdURDOUZ8XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUHMnLFxyXG4gICAgICAgICAgICBhbGlhczogJ09wZW5fUHVuY3R1YXRpb24nLFxyXG4gICAgICAgICAgICBibXA6ICdcXFxceDI4XFxcXHg1QlxcXFx4N0JcXHUwRjNBXFx1MEYzQ1xcdTE2OUJcXHUyMDFBXFx1MjAxRVxcdTIwNDVcXHUyMDdEXFx1MjA4RFxcdTIzMDhcXHUyMzBBXFx1MjMyOVxcdTI3NjhcXHUyNzZBXFx1Mjc2Q1xcdTI3NkVcXHUyNzcwXFx1Mjc3MlxcdTI3NzRcXHUyN0M1XFx1MjdFNlxcdTI3RThcXHUyN0VBXFx1MjdFQ1xcdTI3RUVcXHUyOTgzXFx1Mjk4NVxcdTI5ODdcXHUyOTg5XFx1Mjk4QlxcdTI5OERcXHUyOThGXFx1Mjk5MVxcdTI5OTNcXHUyOTk1XFx1Mjk5N1xcdTI5RDhcXHUyOURBXFx1MjlGQ1xcdTJFMjJcXHUyRTI0XFx1MkUyNlxcdTJFMjhcXHUyRTQyXFx1MzAwOFxcdTMwMEFcXHUzMDBDXFx1MzAwRVxcdTMwMTBcXHUzMDE0XFx1MzAxNlxcdTMwMThcXHUzMDFBXFx1MzAxRFxcdUZEM0ZcXHVGRTE3XFx1RkUzNVxcdUZFMzdcXHVGRTM5XFx1RkUzQlxcdUZFM0RcXHVGRTNGXFx1RkU0MVxcdUZFNDNcXHVGRTQ3XFx1RkU1OVxcdUZFNUJcXHVGRTVEXFx1RkYwOFxcdUZGM0JcXHVGRjVCXFx1RkY1RlxcdUZGNjInXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdTeW1ib2wnLFxyXG4gICAgICAgICAgICBibXA6ICdcXFxceDI0XFxcXHgyQlxceDNDLVxceDNFXFxcXHg1RVxceDYwXFxcXHg3Q1xceDdFXFx4QTItXFx4QTZcXHhBOFxceEE5XFx4QUNcXHhBRS1cXHhCMVxceEI0XFx4QjhcXHhEN1xceEY3XFx1MDJDMi1cXHUwMkM1XFx1MDJEMi1cXHUwMkRGXFx1MDJFNS1cXHUwMkVCXFx1MDJFRFxcdTAyRUYtXFx1MDJGRlxcdTAzNzVcXHUwMzg0XFx1MDM4NVxcdTAzRjZcXHUwNDgyXFx1MDU4RC1cXHUwNThGXFx1MDYwNi1cXHUwNjA4XFx1MDYwQlxcdTA2MEVcXHUwNjBGXFx1MDZERVxcdTA2RTlcXHUwNkZEXFx1MDZGRVxcdTA3RjZcXHUwOUYyXFx1MDlGM1xcdTA5RkFcXHUwOUZCXFx1MEFGMVxcdTBCNzBcXHUwQkYzLVxcdTBCRkFcXHUwQzdGXFx1MEQ3OVxcdTBFM0ZcXHUwRjAxLVxcdTBGMDNcXHUwRjEzXFx1MEYxNS1cXHUwRjE3XFx1MEYxQS1cXHUwRjFGXFx1MEYzNFxcdTBGMzZcXHUwRjM4XFx1MEZCRS1cXHUwRkM1XFx1MEZDNy1cXHUwRkNDXFx1MEZDRVxcdTBGQ0ZcXHUwRkQ1LVxcdTBGRDhcXHUxMDlFXFx1MTA5RlxcdTEzOTAtXFx1MTM5OVxcdTE3REJcXHUxOTQwXFx1MTlERS1cXHUxOUZGXFx1MUI2MS1cXHUxQjZBXFx1MUI3NC1cXHUxQjdDXFx1MUZCRFxcdTFGQkYtXFx1MUZDMVxcdTFGQ0QtXFx1MUZDRlxcdTFGREQtXFx1MUZERlxcdTFGRUQtXFx1MUZFRlxcdTFGRkRcXHUxRkZFXFx1MjA0NFxcdTIwNTJcXHUyMDdBLVxcdTIwN0NcXHUyMDhBLVxcdTIwOENcXHUyMEEwLVxcdTIwQkVcXHUyMTAwXFx1MjEwMVxcdTIxMDMtXFx1MjEwNlxcdTIxMDhcXHUyMTA5XFx1MjExNFxcdTIxMTYtXFx1MjExOFxcdTIxMUUtXFx1MjEyM1xcdTIxMjVcXHUyMTI3XFx1MjEyOVxcdTIxMkVcXHUyMTNBXFx1MjEzQlxcdTIxNDAtXFx1MjE0NFxcdTIxNEEtXFx1MjE0RFxcdTIxNEZcXHUyMThBXFx1MjE4QlxcdTIxOTAtXFx1MjMwN1xcdTIzMEMtXFx1MjMyOFxcdTIzMkItXFx1MjNGQVxcdTI0MDAtXFx1MjQyNlxcdTI0NDAtXFx1MjQ0QVxcdTI0OUMtXFx1MjRFOVxcdTI1MDAtXFx1Mjc2N1xcdTI3OTQtXFx1MjdDNFxcdTI3QzctXFx1MjdFNVxcdTI3RjAtXFx1Mjk4MlxcdTI5OTktXFx1MjlEN1xcdTI5REMtXFx1MjlGQlxcdTI5RkUtXFx1MkI3M1xcdTJCNzYtXFx1MkI5NVxcdTJCOTgtXFx1MkJCOVxcdTJCQkQtXFx1MkJDOFxcdTJCQ0EtXFx1MkJEMVxcdTJCRUMtXFx1MkJFRlxcdTJDRTUtXFx1MkNFQVxcdTJFODAtXFx1MkU5OVxcdTJFOUItXFx1MkVGM1xcdTJGMDAtXFx1MkZENVxcdTJGRjAtXFx1MkZGQlxcdTMwMDRcXHUzMDEyXFx1MzAxM1xcdTMwMjBcXHUzMDM2XFx1MzAzN1xcdTMwM0VcXHUzMDNGXFx1MzA5QlxcdTMwOUNcXHUzMTkwXFx1MzE5MVxcdTMxOTYtXFx1MzE5RlxcdTMxQzAtXFx1MzFFM1xcdTMyMDAtXFx1MzIxRVxcdTMyMkEtXFx1MzI0N1xcdTMyNTBcXHUzMjYwLVxcdTMyN0ZcXHUzMjhBLVxcdTMyQjBcXHUzMkMwLVxcdTMyRkVcXHUzMzAwLVxcdTMzRkZcXHU0REMwLVxcdTRERkZcXHVBNDkwLVxcdUE0QzZcXHVBNzAwLVxcdUE3MTZcXHVBNzIwXFx1QTcyMVxcdUE3ODlcXHVBNzhBXFx1QTgyOC1cXHVBODJCXFx1QTgzNi1cXHVBODM5XFx1QUE3Ny1cXHVBQTc5XFx1QUI1QlxcdUZCMjlcXHVGQkIyLVxcdUZCQzFcXHVGREZDXFx1RkRGRFxcdUZFNjJcXHVGRTY0LVxcdUZFNjZcXHVGRTY5XFx1RkYwNFxcdUZGMEJcXHVGRjFDLVxcdUZGMUVcXHVGRjNFXFx1RkY0MFxcdUZGNUNcXHVGRjVFXFx1RkZFMC1cXHVGRkU2XFx1RkZFOC1cXHVGRkVFXFx1RkZGQ1xcdUZGRkQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNFW1xcdURDMDAtXFx1REMwQlxcdURDMTAtXFx1REM0N1xcdURDNTAtXFx1REM1OVxcdURDNjAtXFx1REM4N1xcdURDOTAtXFx1RENBRFxcdUREMTAtXFx1REQxOFxcdUREODAtXFx1REQ4NFxcdUREQzBdfFxcdUQ4M0NbXFx1REMwMC1cXHVEQzJCXFx1REMzMC1cXHVEQzkzXFx1RENBMC1cXHVEQ0FFXFx1RENCMS1cXHVEQ0JGXFx1RENDMS1cXHVEQ0NGXFx1RENEMS1cXHVEQ0Y1XFx1REQxMC1cXHVERDJFXFx1REQzMC1cXHVERDZCXFx1REQ3MC1cXHVERDlBXFx1RERFNi1cXHVERTAyXFx1REUxMC1cXHVERTNBXFx1REU0MC1cXHVERTQ4XFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDc5XFx1REQ3Qi1cXHVEREEzXFx1RERBNS1cXHVERUQwXFx1REVFMC1cXHVERUVDXFx1REVGMC1cXHVERUYzXFx1REYwMC1cXHVERjczXFx1REY4MC1cXHVERkQ0XXxcXHVEODM1W1xcdURFQzFcXHVERURCXFx1REVGQlxcdURGMTVcXHVERjM1XFx1REY0RlxcdURGNkZcXHVERjg5XFx1REZBOVxcdURGQzNdfFxcdUQ4MDBbXFx1REQzNy1cXHVERDNGXFx1REQ3OS1cXHVERDg5XFx1REQ4Q1xcdUREOTAtXFx1REQ5QlxcdUREQTBcXHVEREQwLVxcdURERkNdfFxcdUQ4MkZcXHVEQzlDfFxcdUQ4MDVcXHVERjNGfFxcdUQ4MDJbXFx1REM3N1xcdURDNzhcXHVERUM4XXxcXHVEODFBW1xcdURGM0MtXFx1REYzRlxcdURGNDVdfFxcdUQ4MzZbXFx1REMwMC1cXHVEREZGXFx1REUzNy1cXHVERTNBXFx1REU2RC1cXHVERTc0XFx1REU3Ni1cXHVERTgzXFx1REU4NVxcdURFODZdfFxcdUQ4MzRbXFx1REMwMC1cXHVEQ0Y1XFx1REQwMC1cXHVERDI2XFx1REQyOS1cXHVERDY0XFx1REQ2QS1cXHVERDZDXFx1REQ4M1xcdUREODRcXHVERDhDLVxcdUREQTlcXHVEREFFLVxcdURERThcXHVERTAwLVxcdURFNDFcXHVERTQ1XFx1REYwMC1cXHVERjU2XXxcXHVEODNCW1xcdURFRjBcXHVERUYxXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NjJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdDdXJyZW5jeV9TeW1ib2wnLFxyXG4gICAgICAgICAgICBibXA6ICdcXFxceDI0XFx4QTItXFx4QTVcXHUwNThGXFx1MDYwQlxcdTA5RjJcXHUwOUYzXFx1MDlGQlxcdTBBRjFcXHUwQkY5XFx1MEUzRlxcdTE3REJcXHUyMEEwLVxcdTIwQkVcXHVBODM4XFx1RkRGQ1xcdUZFNjlcXHVGRjA0XFx1RkZFMFxcdUZGRTFcXHVGRkU1XFx1RkZFNidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NrJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdNb2RpZmllcl9TeW1ib2wnLFxyXG4gICAgICAgICAgICBibXA6ICdcXFxceDVFXFx4NjBcXHhBOFxceEFGXFx4QjRcXHhCOFxcdTAyQzItXFx1MDJDNVxcdTAyRDItXFx1MDJERlxcdTAyRTUtXFx1MDJFQlxcdTAyRURcXHUwMkVGLVxcdTAyRkZcXHUwMzc1XFx1MDM4NFxcdTAzODVcXHUxRkJEXFx1MUZCRi1cXHUxRkMxXFx1MUZDRC1cXHUxRkNGXFx1MUZERC1cXHUxRkRGXFx1MUZFRC1cXHUxRkVGXFx1MUZGRFxcdTFGRkVcXHUzMDlCXFx1MzA5Q1xcdUE3MDAtXFx1QTcxNlxcdUE3MjBcXHVBNzIxXFx1QTc4OVxcdUE3OEFcXHVBQjVCXFx1RkJCMi1cXHVGQkMxXFx1RkYzRVxcdUZGNDBcXHVGRkUzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU20nLFxyXG4gICAgICAgICAgICBhbGlhczogJ01hdGhfU3ltYm9sJyxcclxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyQlxceDNDLVxceDNFXFxcXHg3Q1xceDdFXFx4QUNcXHhCMVxceEQ3XFx4RjdcXHUwM0Y2XFx1MDYwNi1cXHUwNjA4XFx1MjA0NFxcdTIwNTJcXHUyMDdBLVxcdTIwN0NcXHUyMDhBLVxcdTIwOENcXHUyMTE4XFx1MjE0MC1cXHUyMTQ0XFx1MjE0QlxcdTIxOTAtXFx1MjE5NFxcdTIxOUFcXHUyMTlCXFx1MjFBMFxcdTIxQTNcXHUyMUE2XFx1MjFBRVxcdTIxQ0VcXHUyMUNGXFx1MjFEMlxcdTIxRDRcXHUyMUY0LVxcdTIyRkZcXHUyMzIwXFx1MjMyMVxcdTIzN0NcXHUyMzlCLVxcdTIzQjNcXHUyM0RDLVxcdTIzRTFcXHUyNUI3XFx1MjVDMVxcdTI1RjgtXFx1MjVGRlxcdTI2NkZcXHUyN0MwLVxcdTI3QzRcXHUyN0M3LVxcdTI3RTVcXHUyN0YwLVxcdTI3RkZcXHUyOTAwLVxcdTI5ODJcXHUyOTk5LVxcdTI5RDdcXHUyOURDLVxcdTI5RkJcXHUyOUZFLVxcdTJBRkZcXHUyQjMwLVxcdTJCNDRcXHUyQjQ3LVxcdTJCNENcXHVGQjI5XFx1RkU2MlxcdUZFNjQtXFx1RkU2NlxcdUZGMEJcXHVGRjFDLVxcdUZGMUVcXHVGRjVDXFx1RkY1RVxcdUZGRTJcXHVGRkU5LVxcdUZGRUMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNCW1xcdURFRjBcXHVERUYxXXxcXHVEODM1W1xcdURFQzFcXHVERURCXFx1REVGQlxcdURGMTVcXHVERjM1XFx1REY0RlxcdURGNkZcXHVERjg5XFx1REZBOVxcdURGQzNdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU28nLFxyXG4gICAgICAgICAgICBhbGlhczogJ090aGVyX1N5bWJvbCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceEE2XFx4QTlcXHhBRVxceEIwXFx1MDQ4MlxcdTA1OERcXHUwNThFXFx1MDYwRVxcdTA2MEZcXHUwNkRFXFx1MDZFOVxcdTA2RkRcXHUwNkZFXFx1MDdGNlxcdTA5RkFcXHUwQjcwXFx1MEJGMy1cXHUwQkY4XFx1MEJGQVxcdTBDN0ZcXHUwRDc5XFx1MEYwMS1cXHUwRjAzXFx1MEYxM1xcdTBGMTUtXFx1MEYxN1xcdTBGMUEtXFx1MEYxRlxcdTBGMzRcXHUwRjM2XFx1MEYzOFxcdTBGQkUtXFx1MEZDNVxcdTBGQzctXFx1MEZDQ1xcdTBGQ0VcXHUwRkNGXFx1MEZENS1cXHUwRkQ4XFx1MTA5RVxcdTEwOUZcXHUxMzkwLVxcdTEzOTlcXHUxOTQwXFx1MTlERS1cXHUxOUZGXFx1MUI2MS1cXHUxQjZBXFx1MUI3NC1cXHUxQjdDXFx1MjEwMFxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2XFx1MjExN1xcdTIxMUUtXFx1MjEyM1xcdTIxMjVcXHUyMTI3XFx1MjEyOVxcdTIxMkVcXHUyMTNBXFx1MjEzQlxcdTIxNEFcXHUyMTRDXFx1MjE0RFxcdTIxNEZcXHUyMThBXFx1MjE4QlxcdTIxOTUtXFx1MjE5OVxcdTIxOUMtXFx1MjE5RlxcdTIxQTFcXHUyMUEyXFx1MjFBNFxcdTIxQTVcXHUyMUE3LVxcdTIxQURcXHUyMUFGLVxcdTIxQ0RcXHUyMUQwXFx1MjFEMVxcdTIxRDNcXHUyMUQ1LVxcdTIxRjNcXHUyMzAwLVxcdTIzMDdcXHUyMzBDLVxcdTIzMUZcXHUyMzIyLVxcdTIzMjhcXHUyMzJCLVxcdTIzN0JcXHUyMzdELVxcdTIzOUFcXHUyM0I0LVxcdTIzREJcXHUyM0UyLVxcdTIzRkFcXHUyNDAwLVxcdTI0MjZcXHUyNDQwLVxcdTI0NEFcXHUyNDlDLVxcdTI0RTlcXHUyNTAwLVxcdTI1QjZcXHUyNUI4LVxcdTI1QzBcXHUyNUMyLVxcdTI1RjdcXHUyNjAwLVxcdTI2NkVcXHUyNjcwLVxcdTI3NjdcXHUyNzk0LVxcdTI3QkZcXHUyODAwLVxcdTI4RkZcXHUyQjAwLVxcdTJCMkZcXHUyQjQ1XFx1MkI0NlxcdTJCNEQtXFx1MkI3M1xcdTJCNzYtXFx1MkI5NVxcdTJCOTgtXFx1MkJCOVxcdTJCQkQtXFx1MkJDOFxcdTJCQ0EtXFx1MkJEMVxcdTJCRUMtXFx1MkJFRlxcdTJDRTUtXFx1MkNFQVxcdTJFODAtXFx1MkU5OVxcdTJFOUItXFx1MkVGM1xcdTJGMDAtXFx1MkZENVxcdTJGRjAtXFx1MkZGQlxcdTMwMDRcXHUzMDEyXFx1MzAxM1xcdTMwMjBcXHUzMDM2XFx1MzAzN1xcdTMwM0VcXHUzMDNGXFx1MzE5MFxcdTMxOTFcXHUzMTk2LVxcdTMxOUZcXHUzMUMwLVxcdTMxRTNcXHUzMjAwLVxcdTMyMUVcXHUzMjJBLVxcdTMyNDdcXHUzMjUwXFx1MzI2MC1cXHUzMjdGXFx1MzI4QS1cXHUzMkIwXFx1MzJDMC1cXHUzMkZFXFx1MzMwMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ5MC1cXHVBNEM2XFx1QTgyOC1cXHVBODJCXFx1QTgzNlxcdUE4MzdcXHVBODM5XFx1QUE3Ny1cXHVBQTc5XFx1RkRGRFxcdUZGRTRcXHVGRkU4XFx1RkZFRFxcdUZGRUVcXHVGRkZDXFx1RkZGRCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0VbXFx1REMwMC1cXHVEQzBCXFx1REMxMC1cXHVEQzQ3XFx1REM1MC1cXHVEQzU5XFx1REM2MC1cXHVEQzg3XFx1REM5MC1cXHVEQ0FEXFx1REQxMC1cXHVERDE4XFx1REQ4MC1cXHVERDg0XFx1RERDMF18XFx1RDgzRFtcXHVEQzAwLVxcdURENzlcXHVERDdCLVxcdUREQTNcXHVEREE1LVxcdURFRDBcXHVERUUwLVxcdURFRUNcXHVERUYwLVxcdURFRjNcXHVERjAwLVxcdURGNzNcXHVERjgwLVxcdURGRDRdfFxcdUQ4M0NbXFx1REMwMC1cXHVEQzJCXFx1REMzMC1cXHVEQzkzXFx1RENBMC1cXHVEQ0FFXFx1RENCMS1cXHVEQ0JGXFx1RENDMS1cXHVEQ0NGXFx1RENEMS1cXHVEQ0Y1XFx1REQxMC1cXHVERDJFXFx1REQzMC1cXHVERDZCXFx1REQ3MC1cXHVERDlBXFx1RERFNi1cXHVERTAyXFx1REUxMC1cXHVERTNBXFx1REU0MC1cXHVERTQ4XFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGRkFdfFxcdUQ4MDBbXFx1REQzNy1cXHVERDNGXFx1REQ3OS1cXHVERDg5XFx1REQ4Q1xcdUREOTAtXFx1REQ5QlxcdUREQTBcXHVEREQwLVxcdURERkNdfFxcdUQ4MkZcXHVEQzlDfFxcdUQ4MDVcXHVERjNGfFxcdUQ4MDJbXFx1REM3N1xcdURDNzhcXHVERUM4XXxcXHVEODFBW1xcdURGM0MtXFx1REYzRlxcdURGNDVdfFxcdUQ4MzZbXFx1REMwMC1cXHVEREZGXFx1REUzNy1cXHVERTNBXFx1REU2RC1cXHVERTc0XFx1REU3Ni1cXHVERTgzXFx1REU4NVxcdURFODZdfFxcdUQ4MzRbXFx1REMwMC1cXHVEQ0Y1XFx1REQwMC1cXHVERDI2XFx1REQyOS1cXHVERDY0XFx1REQ2QS1cXHVERDZDXFx1REQ4M1xcdUREODRcXHVERDhDLVxcdUREQTlcXHVEREFFLVxcdURERThcXHVERTAwLVxcdURFNDFcXHVERTQ1XFx1REYwMC1cXHVERjU2XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1onLFxyXG4gICAgICAgICAgICBhbGlhczogJ1NlcGFyYXRvcicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceDIwXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDAnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdabCcsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnTGluZV9TZXBhcmF0b3InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMDI4J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnWnAnLFxyXG4gICAgICAgICAgICBhbGlhczogJ1BhcmFncmFwaF9TZXBhcmF0b3InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMDI5J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnWnMnLFxyXG4gICAgICAgICAgICBhbGlhczogJ1NwYWNlX1NlcGFyYXRvcicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceDIwXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwJ1xyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG5cclxufTtcclxuIiwiLyohXHJcbiAqIFhSZWdFeHAgVW5pY29kZSBQcm9wZXJ0aWVzIDMuMS4xXHJcbiAqIDx4cmVnZXhwLmNvbT5cclxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEyLTIwMTYgTUlUIExpY2Vuc2VcclxuICogVW5pY29kZSBkYXRhIGJ5IE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzYnluZW5zLmJlPlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oWFJlZ0V4cCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBwcm9wZXJ0aWVzIHRvIG1lZXQgdGhlIFVUUyAjMTggTGV2ZWwgMSBSTDEuMiByZXF1aXJlbWVudHMgZm9yIFVuaWNvZGUgcmVnZXggc3VwcG9ydC4gU2VlXHJcbiAgICAgKiA8aHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxOC8jUkwxLjI+LiBGb2xsb3dpbmcgYXJlIGRlZmluaXRpb25zIG9mIHRoZXNlIHByb3BlcnRpZXMgZnJvbVxyXG4gICAgICogVUFYICM0NCA8aHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0NC8+OlxyXG4gICAgICpcclxuICAgICAqIC0gQWxwaGFiZXRpY1xyXG4gICAgICogICBDaGFyYWN0ZXJzIHdpdGggdGhlIEFscGhhYmV0aWMgcHJvcGVydHkuIEdlbmVyYXRlZCBmcm9tOiBMb3dlcmNhc2UgKyBVcHBlcmNhc2UgKyBMdCArIExtICtcclxuICAgICAqICAgTG8gKyBObCArIE90aGVyX0FscGhhYmV0aWMuXHJcbiAgICAgKlxyXG4gICAgICogLSBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50XHJcbiAgICAgKiAgIEZvciBwcm9ncmFtbWF0aWMgZGV0ZXJtaW5hdGlvbiBvZiBkZWZhdWx0IGlnbm9yYWJsZSBjb2RlIHBvaW50cy4gTmV3IGNoYXJhY3RlcnMgdGhhdCBzaG91bGRcclxuICAgICAqICAgYmUgaWdub3JlZCBpbiByZW5kZXJpbmcgKHVubGVzcyBleHBsaWNpdGx5IHN1cHBvcnRlZCkgd2lsbCBiZSBhc3NpZ25lZCBpbiB0aGVzZSByYW5nZXMsXHJcbiAgICAgKiAgIHBlcm1pdHRpbmcgcHJvZ3JhbXMgdG8gY29ycmVjdGx5IGhhbmRsZSB0aGUgZGVmYXVsdCByZW5kZXJpbmcgb2Ygc3VjaCBjaGFyYWN0ZXJzIHdoZW4gbm90XHJcbiAgICAgKiAgIG90aGVyd2lzZSBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogLSBMb3dlcmNhc2VcclxuICAgICAqICAgQ2hhcmFjdGVycyB3aXRoIHRoZSBMb3dlcmNhc2UgcHJvcGVydHkuIEdlbmVyYXRlZCBmcm9tOiBMbCArIE90aGVyX0xvd2VyY2FzZS5cclxuICAgICAqXHJcbiAgICAgKiAtIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50XHJcbiAgICAgKiAgIENvZGUgcG9pbnRzIHBlcm1hbmVudGx5IHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2UuXHJcbiAgICAgKlxyXG4gICAgICogLSBVcHBlcmNhc2VcclxuICAgICAqICAgQ2hhcmFjdGVycyB3aXRoIHRoZSBVcHBlcmNhc2UgcHJvcGVydHkuIEdlbmVyYXRlZCBmcm9tOiBMdSArIE90aGVyX1VwcGVyY2FzZS5cclxuICAgICAqXHJcbiAgICAgKiAtIFdoaXRlX1NwYWNlXHJcbiAgICAgKiAgIFNwYWNlcywgc2VwYXJhdG9yIGNoYXJhY3RlcnMgYW5kIG90aGVyIGNvbnRyb2wgY2hhcmFjdGVycyB3aGljaCBzaG91bGQgYmUgdHJlYXRlZCBieVxyXG4gICAgICogICBwcm9ncmFtbWluZyBsYW5ndWFnZXMgYXMgXCJ3aGl0ZSBzcGFjZVwiIGZvciB0aGUgcHVycG9zZSBvZiBwYXJzaW5nIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcm9wZXJ0aWVzIEFTQ0lJLCBBbnksIGFuZCBBc3NpZ25lZCBhcmUgYWxzbyBpbmNsdWRlZCBidXQgYXJlIG5vdCBkZWZpbmVkIGluIFVBWCAjNDQuIFVUU1xyXG4gICAgICogIzE4IFJMMS4yIGFkZGl0aW9uYWxseSByZXF1aXJlcyBzdXBwb3J0IGZvciBVbmljb2RlIHNjcmlwdHMgYW5kIGdlbmVyYWwgY2F0ZWdvcmllcy4gVGhlc2UgYXJlXHJcbiAgICAgKiBpbmNsdWRlZCBpbiBYUmVnRXhwJ3MgVW5pY29kZSBDYXRlZ29yaWVzIGFuZCBVbmljb2RlIFNjcmlwdHMgYWRkb25zLlxyXG4gICAgICpcclxuICAgICAqIFRva2VuIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBhbmQgYW55IHNwYWNlcywgaHlwaGVucywgYW5kIHVuZGVyc2NvcmVzIGFyZSBpZ25vcmVkLlxyXG4gICAgICpcclxuICAgICAqIFVzZXMgVW5pY29kZSA4LjAuMC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVxdWlyZXMgWFJlZ0V4cCwgVW5pY29kZSBCYXNlXHJcbiAgICAgKi9cclxuXHJcbiAgICBpZiAoIVhSZWdFeHAuYWRkVW5pY29kZURhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuaWNvZGUgQmFzZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgVW5pY29kZSBQcm9wZXJ0aWVzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHVuaWNvZGVEYXRhID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FTQ0lJJyxcclxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQWxwaGFiZXRpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ0EtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzQ1XFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVCMC1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjU3XFx1MDY1OS1cXHUwNjVGXFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZFMS1cXHUwNkU4XFx1MDZFRC1cXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDczRlxcdTA3NEQtXFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxN1xcdTA4MUEtXFx1MDgyQ1xcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDhFOVxcdTA4RjAtXFx1MDkzQlxcdTA5M0QtXFx1MDk0Q1xcdTA5NEUtXFx1MDk1MFxcdTA5NTUtXFx1MDk2M1xcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkQtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQlxcdTA5Q0NcXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlGMFxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0QlxcdTBBNENcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzAtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRC1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNELVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQkQwXFx1MEJEN1xcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0Q1xcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRC1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NDXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0NlxcdTBFNERcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUNEXFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4MVxcdTBGODgtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTEwMDAtXFx1MTAzNlxcdTEwMzhcXHUxMDNCLVxcdTEwM0ZcXHUxMDUwLVxcdTEwNjJcXHUxMDY1LVxcdTEwNjhcXHUxMDZFLVxcdTEwODZcXHUxMDhFXFx1MTA5Q1xcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxM1xcdTE3MjAtXFx1MTczM1xcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0IzXFx1MTdCNi1cXHUxN0M4XFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5MzhcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYxLVxcdTFBNzRcXHUxQUE3XFx1MUIwMC1cXHUxQjMzXFx1MUIzNS1cXHUxQjQzXFx1MUI0NS1cXHUxQjRCXFx1MUI4MC1cXHUxQkE5XFx1MUJBQy1cXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUJFNy1cXHUxQkYxXFx1MUMwMC1cXHUxQzM1XFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YzXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxREU3LVxcdTFERjRcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MjRCNi1cXHUyNEU5XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjc0LVxcdUE2N0JcXHVBNjdGLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyQVxcdUE5MzAtXFx1QTk1MlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlCMlxcdUE5QjQtXFx1QTlCRlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUJFXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjVcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NVxcdURDODItXFx1RENCOFxcdURDRDAtXFx1RENFOFxcdUREMDAtXFx1REQzMlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgwLVxcdUREQkZcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzNFxcdURFMzdcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERUU4XFx1REYwMC1cXHVERjAzXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0QtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0QlxcdURGNENcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M118XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgzQ1tcXHVERDMwLVxcdURENDlcXHVERDUwLVxcdURENjlcXHVERDcwLVxcdUREODldfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOUVdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0MxXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREJFXFx1REREOC1cXHVEREREXFx1REUwMC1cXHVERTNFXFx1REU0MFxcdURFNDRcXHVERTgwLVxcdURFQjVcXHVERjAwLVxcdURGMTlcXHVERjFELVxcdURGMkFdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY5My1cXHVERjlGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBbnknLFxyXG4gICAgICAgICAgICBpc0JtcExhc3Q6IHRydWUsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcMC1cXHVGRkZGJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHhBRFxcdTAzNEZcXHUwNjFDXFx1MTE1RlxcdTExNjBcXHUxN0I0XFx1MTdCNVxcdTE4MEItXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2RlxcdTMxNjRcXHVGRTAwLVxcdUZFMEZcXHVGRUZGXFx1RkZBMFxcdUZGRjAtXFx1RkZGOCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEQjQwLVxcdURCNDNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xvd2VyY2FzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ2EtelxceEFBXFx4QjVcXHhCQVxceERGLVxceEY2XFx4RjgtXFx4RkZcXHUwMTAxXFx1MDEwM1xcdTAxMDVcXHUwMTA3XFx1MDEwOVxcdTAxMEJcXHUwMTBEXFx1MDEwRlxcdTAxMTFcXHUwMTEzXFx1MDExNVxcdTAxMTdcXHUwMTE5XFx1MDExQlxcdTAxMURcXHUwMTFGXFx1MDEyMVxcdTAxMjNcXHUwMTI1XFx1MDEyN1xcdTAxMjlcXHUwMTJCXFx1MDEyRFxcdTAxMkZcXHUwMTMxXFx1MDEzM1xcdTAxMzVcXHUwMTM3XFx1MDEzOFxcdTAxM0FcXHUwMTNDXFx1MDEzRVxcdTAxNDBcXHUwMTQyXFx1MDE0NFxcdTAxNDZcXHUwMTQ4XFx1MDE0OVxcdTAxNEJcXHUwMTREXFx1MDE0RlxcdTAxNTFcXHUwMTUzXFx1MDE1NVxcdTAxNTdcXHUwMTU5XFx1MDE1QlxcdTAxNURcXHUwMTVGXFx1MDE2MVxcdTAxNjNcXHUwMTY1XFx1MDE2N1xcdTAxNjlcXHUwMTZCXFx1MDE2RFxcdTAxNkZcXHUwMTcxXFx1MDE3M1xcdTAxNzVcXHUwMTc3XFx1MDE3QVxcdTAxN0NcXHUwMTdFLVxcdTAxODBcXHUwMTgzXFx1MDE4NVxcdTAxODhcXHUwMThDXFx1MDE4RFxcdTAxOTJcXHUwMTk1XFx1MDE5OS1cXHUwMTlCXFx1MDE5RVxcdTAxQTFcXHUwMUEzXFx1MDFBNVxcdTAxQThcXHUwMUFBXFx1MDFBQlxcdTAxQURcXHUwMUIwXFx1MDFCNFxcdTAxQjZcXHUwMUI5XFx1MDFCQVxcdTAxQkQtXFx1MDFCRlxcdTAxQzZcXHUwMUM5XFx1MDFDQ1xcdTAxQ0VcXHUwMUQwXFx1MDFEMlxcdTAxRDRcXHUwMUQ2XFx1MDFEOFxcdTAxREFcXHUwMURDXFx1MDFERFxcdTAxREZcXHUwMUUxXFx1MDFFM1xcdTAxRTVcXHUwMUU3XFx1MDFFOVxcdTAxRUJcXHUwMUVEXFx1MDFFRlxcdTAxRjBcXHUwMUYzXFx1MDFGNVxcdTAxRjlcXHUwMUZCXFx1MDFGRFxcdTAxRkZcXHUwMjAxXFx1MDIwM1xcdTAyMDVcXHUwMjA3XFx1MDIwOVxcdTAyMEJcXHUwMjBEXFx1MDIwRlxcdTAyMTFcXHUwMjEzXFx1MDIxNVxcdTAyMTdcXHUwMjE5XFx1MDIxQlxcdTAyMURcXHUwMjFGXFx1MDIyMVxcdTAyMjNcXHUwMjI1XFx1MDIyN1xcdTAyMjlcXHUwMjJCXFx1MDIyRFxcdTAyMkZcXHUwMjMxXFx1MDIzMy1cXHUwMjM5XFx1MDIzQ1xcdTAyM0ZcXHUwMjQwXFx1MDI0MlxcdTAyNDdcXHUwMjQ5XFx1MDI0QlxcdTAyNERcXHUwMjRGLVxcdTAyOTNcXHUwMjk1LVxcdTAyQjhcXHUwMkMwXFx1MDJDMVxcdTAyRTAtXFx1MDJFNFxcdTAzNDVcXHUwMzcxXFx1MDM3M1xcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzkwXFx1MDNBQy1cXHUwM0NFXFx1MDNEMFxcdTAzRDFcXHUwM0Q1LVxcdTAzRDdcXHUwM0Q5XFx1MDNEQlxcdTAzRERcXHUwM0RGXFx1MDNFMVxcdTAzRTNcXHUwM0U1XFx1MDNFN1xcdTAzRTlcXHUwM0VCXFx1MDNFRFxcdTAzRUYtXFx1MDNGM1xcdTAzRjVcXHUwM0Y4XFx1MDNGQlxcdTAzRkNcXHUwNDMwLVxcdTA0NUZcXHUwNDYxXFx1MDQ2M1xcdTA0NjVcXHUwNDY3XFx1MDQ2OVxcdTA0NkJcXHUwNDZEXFx1MDQ2RlxcdTA0NzFcXHUwNDczXFx1MDQ3NVxcdTA0NzdcXHUwNDc5XFx1MDQ3QlxcdTA0N0RcXHUwNDdGXFx1MDQ4MVxcdTA0OEJcXHUwNDhEXFx1MDQ4RlxcdTA0OTFcXHUwNDkzXFx1MDQ5NVxcdTA0OTdcXHUwNDk5XFx1MDQ5QlxcdTA0OURcXHUwNDlGXFx1MDRBMVxcdTA0QTNcXHUwNEE1XFx1MDRBN1xcdTA0QTlcXHUwNEFCXFx1MDRBRFxcdTA0QUZcXHUwNEIxXFx1MDRCM1xcdTA0QjVcXHUwNEI3XFx1MDRCOVxcdTA0QkJcXHUwNEJEXFx1MDRCRlxcdTA0QzJcXHUwNEM0XFx1MDRDNlxcdTA0QzhcXHUwNENBXFx1MDRDQ1xcdTA0Q0VcXHUwNENGXFx1MDREMVxcdTA0RDNcXHUwNEQ1XFx1MDREN1xcdTA0RDlcXHUwNERCXFx1MDRERFxcdTA0REZcXHUwNEUxXFx1MDRFM1xcdTA0RTVcXHUwNEU3XFx1MDRFOVxcdTA0RUJcXHUwNEVEXFx1MDRFRlxcdTA0RjFcXHUwNEYzXFx1MDRGNVxcdTA0RjdcXHUwNEY5XFx1MDRGQlxcdTA0RkRcXHUwNEZGXFx1MDUwMVxcdTA1MDNcXHUwNTA1XFx1MDUwN1xcdTA1MDlcXHUwNTBCXFx1MDUwRFxcdTA1MEZcXHUwNTExXFx1MDUxM1xcdTA1MTVcXHUwNTE3XFx1MDUxOVxcdTA1MUJcXHUwNTFEXFx1MDUxRlxcdTA1MjFcXHUwNTIzXFx1MDUyNVxcdTA1MjdcXHUwNTI5XFx1MDUyQlxcdTA1MkRcXHUwNTJGXFx1MDU2MS1cXHUwNTg3XFx1MTNGOC1cXHUxM0ZEXFx1MUQwMC1cXHUxREJGXFx1MUUwMVxcdTFFMDNcXHUxRTA1XFx1MUUwN1xcdTFFMDlcXHUxRTBCXFx1MUUwRFxcdTFFMEZcXHUxRTExXFx1MUUxM1xcdTFFMTVcXHUxRTE3XFx1MUUxOVxcdTFFMUJcXHUxRTFEXFx1MUUxRlxcdTFFMjFcXHUxRTIzXFx1MUUyNVxcdTFFMjdcXHUxRTI5XFx1MUUyQlxcdTFFMkRcXHUxRTJGXFx1MUUzMVxcdTFFMzNcXHUxRTM1XFx1MUUzN1xcdTFFMzlcXHUxRTNCXFx1MUUzRFxcdTFFM0ZcXHUxRTQxXFx1MUU0M1xcdTFFNDVcXHUxRTQ3XFx1MUU0OVxcdTFFNEJcXHUxRTREXFx1MUU0RlxcdTFFNTFcXHUxRTUzXFx1MUU1NVxcdTFFNTdcXHUxRTU5XFx1MUU1QlxcdTFFNURcXHUxRTVGXFx1MUU2MVxcdTFFNjNcXHUxRTY1XFx1MUU2N1xcdTFFNjlcXHUxRTZCXFx1MUU2RFxcdTFFNkZcXHUxRTcxXFx1MUU3M1xcdTFFNzVcXHUxRTc3XFx1MUU3OVxcdTFFN0JcXHUxRTdEXFx1MUU3RlxcdTFFODFcXHUxRTgzXFx1MUU4NVxcdTFFODdcXHUxRTg5XFx1MUU4QlxcdTFFOERcXHUxRThGXFx1MUU5MVxcdTFFOTNcXHUxRTk1LVxcdTFFOURcXHUxRTlGXFx1MUVBMVxcdTFFQTNcXHUxRUE1XFx1MUVBN1xcdTFFQTlcXHUxRUFCXFx1MUVBRFxcdTFFQUZcXHUxRUIxXFx1MUVCM1xcdTFFQjVcXHUxRUI3XFx1MUVCOVxcdTFFQkJcXHUxRUJEXFx1MUVCRlxcdTFFQzFcXHUxRUMzXFx1MUVDNVxcdTFFQzdcXHUxRUM5XFx1MUVDQlxcdTFFQ0RcXHUxRUNGXFx1MUVEMVxcdTFFRDNcXHUxRUQ1XFx1MUVEN1xcdTFFRDlcXHUxRURCXFx1MUVERFxcdTFFREZcXHUxRUUxXFx1MUVFM1xcdTFFRTVcXHUxRUU3XFx1MUVFOVxcdTFFRUJcXHUxRUVEXFx1MUVFRlxcdTFFRjFcXHUxRUYzXFx1MUVGNVxcdTFFRjdcXHUxRUY5XFx1MUVGQlxcdTFFRkRcXHUxRUZGLVxcdTFGMDdcXHUxRjEwLVxcdTFGMTVcXHUxRjIwLVxcdTFGMjdcXHUxRjMwLVxcdTFGMzdcXHUxRjQwLVxcdTFGNDVcXHUxRjUwLVxcdTFGNTdcXHUxRjYwLVxcdTFGNjdcXHUxRjcwLVxcdTFGN0RcXHUxRjgwLVxcdTFGODdcXHUxRjkwLVxcdTFGOTdcXHUxRkEwLVxcdTFGQTdcXHUxRkIwLVxcdTFGQjRcXHUxRkI2XFx1MUZCN1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2XFx1MUZDN1xcdTFGRDAtXFx1MUZEM1xcdTFGRDZcXHUxRkQ3XFx1MUZFMC1cXHUxRkU3XFx1MUZGMi1cXHUxRkY0XFx1MUZGNlxcdTFGRjdcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTcwLVxcdTIxN0ZcXHUyMTg0XFx1MjREMC1cXHUyNEU5XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdEXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCLVxcdUE2OURcXHVBNzIzXFx1QTcyNVxcdUE3MjdcXHVBNzI5XFx1QTcyQlxcdUE3MkRcXHVBNzJGLVxcdUE3MzFcXHVBNzMzXFx1QTczNVxcdUE3MzdcXHVBNzM5XFx1QTczQlxcdUE3M0RcXHVBNzNGXFx1QTc0MVxcdUE3NDNcXHVBNzQ1XFx1QTc0N1xcdUE3NDlcXHVBNzRCXFx1QTc0RFxcdUE3NEZcXHVBNzUxXFx1QTc1M1xcdUE3NTVcXHVBNzU3XFx1QTc1OVxcdUE3NUJcXHVBNzVEXFx1QTc1RlxcdUE3NjFcXHVBNzYzXFx1QTc2NVxcdUE3NjdcXHVBNzY5XFx1QTc2QlxcdUE3NkRcXHVBNzZGLVxcdUE3NzhcXHVBNzdBXFx1QTc3Q1xcdUE3N0ZcXHVBNzgxXFx1QTc4M1xcdUE3ODVcXHVBNzg3XFx1QTc4Q1xcdUE3OEVcXHVBNzkxXFx1QTc5My1cXHVBNzk1XFx1QTc5N1xcdUE3OTlcXHVBNzlCXFx1QTc5RFxcdUE3OUZcXHVBN0ExXFx1QTdBM1xcdUE3QTVcXHVBN0E3XFx1QTdBOVxcdUE3QjVcXHVBN0I3XFx1QTdGOC1cXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MzVbXFx1REMxQS1cXHVEQzMzXFx1REM0RS1cXHVEQzU0XFx1REM1Ni1cXHVEQzY3XFx1REM4Mi1cXHVEQzlCXFx1RENCNi1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1RENDRlxcdURDRUEtXFx1REQwM1xcdUREMUUtXFx1REQzN1xcdURENTItXFx1REQ2QlxcdUREODYtXFx1REQ5RlxcdUREQkEtXFx1REREM1xcdURERUUtXFx1REUwN1xcdURFMjItXFx1REUzQlxcdURFNTYtXFx1REU2RlxcdURFOEEtXFx1REVBNVxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVFMVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYxQlxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY1NVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REY4RlxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDOVxcdURGQ0JdfFxcdUQ4MDFbXFx1REMyOC1cXHVEQzRGXXxcXHVEODA2W1xcdURDQzAtXFx1RENERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZERDAtXFx1RkRFRlxcdUZGRkVcXHVGRkZGJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdURCM0ZcXHVEQjdGXFx1REJCRlxcdURCRkZcXHVEODNGXFx1RDg3RlxcdUQ4QkZcXHVEQUZGXFx1RDk3RlxcdUQ5QkZcXHVEOUZGXFx1REEzRlxcdUQ4RkZcXHVEQUJGXFx1REE3RlxcdUQ5M0ZdW1xcdURGRkVcXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1VwcGVyY2FzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ0EtWlxceEMwLVxceEQ2XFx4RDgtXFx4REVcXHUwMTAwXFx1MDEwMlxcdTAxMDRcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDEwRVxcdTAxMTBcXHUwMTEyXFx1MDExNFxcdTAxMTZcXHUwMTE4XFx1MDExQVxcdTAxMUNcXHUwMTFFXFx1MDEyMFxcdTAxMjJcXHUwMTI0XFx1MDEyNlxcdTAxMjhcXHUwMTJBXFx1MDEyQ1xcdTAxMkVcXHUwMTMwXFx1MDEzMlxcdTAxMzRcXHUwMTM2XFx1MDEzOVxcdTAxM0JcXHUwMTNEXFx1MDEzRlxcdTAxNDFcXHUwMTQzXFx1MDE0NVxcdTAxNDdcXHUwMTRBXFx1MDE0Q1xcdTAxNEVcXHUwMTUwXFx1MDE1MlxcdTAxNTRcXHUwMTU2XFx1MDE1OFxcdTAxNUFcXHUwMTVDXFx1MDE1RVxcdTAxNjBcXHUwMTYyXFx1MDE2NFxcdTAxNjZcXHUwMTY4XFx1MDE2QVxcdTAxNkNcXHUwMTZFXFx1MDE3MFxcdTAxNzJcXHUwMTc0XFx1MDE3NlxcdTAxNzhcXHUwMTc5XFx1MDE3QlxcdTAxN0RcXHUwMTgxXFx1MDE4MlxcdTAxODRcXHUwMTg2XFx1MDE4N1xcdTAxODktXFx1MDE4QlxcdTAxOEUtXFx1MDE5MVxcdTAxOTNcXHUwMTk0XFx1MDE5Ni1cXHUwMTk4XFx1MDE5Q1xcdTAxOURcXHUwMTlGXFx1MDFBMFxcdTAxQTJcXHUwMUE0XFx1MDFBNlxcdTAxQTdcXHUwMUE5XFx1MDFBQ1xcdTAxQUVcXHUwMUFGXFx1MDFCMS1cXHUwMUIzXFx1MDFCNVxcdTAxQjdcXHUwMUI4XFx1MDFCQ1xcdTAxQzRcXHUwMUM3XFx1MDFDQVxcdTAxQ0RcXHUwMUNGXFx1MDFEMVxcdTAxRDNcXHUwMUQ1XFx1MDFEN1xcdTAxRDlcXHUwMURCXFx1MDFERVxcdTAxRTBcXHUwMUUyXFx1MDFFNFxcdTAxRTZcXHUwMUU4XFx1MDFFQVxcdTAxRUNcXHUwMUVFXFx1MDFGMVxcdTAxRjRcXHUwMUY2LVxcdTAxRjhcXHUwMUZBXFx1MDFGQ1xcdTAxRkVcXHUwMjAwXFx1MDIwMlxcdTAyMDRcXHUwMjA2XFx1MDIwOFxcdTAyMEFcXHUwMjBDXFx1MDIwRVxcdTAyMTBcXHUwMjEyXFx1MDIxNFxcdTAyMTZcXHUwMjE4XFx1MDIxQVxcdTAyMUNcXHUwMjFFXFx1MDIyMFxcdTAyMjJcXHUwMjI0XFx1MDIyNlxcdTAyMjhcXHUwMjJBXFx1MDIyQ1xcdTAyMkVcXHUwMjMwXFx1MDIzMlxcdTAyM0FcXHUwMjNCXFx1MDIzRFxcdTAyM0VcXHUwMjQxXFx1MDI0My1cXHUwMjQ2XFx1MDI0OFxcdTAyNEFcXHUwMjRDXFx1MDI0RVxcdTAzNzBcXHUwMzcyXFx1MDM3NlxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEVcXHUwMzhGXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0FCXFx1MDNDRlxcdTAzRDItXFx1MDNENFxcdTAzRDhcXHUwM0RBXFx1MDNEQ1xcdTAzREVcXHUwM0UwXFx1MDNFMlxcdTAzRTRcXHUwM0U2XFx1MDNFOFxcdTAzRUFcXHUwM0VDXFx1MDNFRVxcdTAzRjRcXHUwM0Y3XFx1MDNGOVxcdTAzRkFcXHUwM0ZELVxcdTA0MkZcXHUwNDYwXFx1MDQ2MlxcdTA0NjRcXHUwNDY2XFx1MDQ2OFxcdTA0NkFcXHUwNDZDXFx1MDQ2RVxcdTA0NzBcXHUwNDcyXFx1MDQ3NFxcdTA0NzZcXHUwNDc4XFx1MDQ3QVxcdTA0N0NcXHUwNDdFXFx1MDQ4MFxcdTA0OEFcXHUwNDhDXFx1MDQ4RVxcdTA0OTBcXHUwNDkyXFx1MDQ5NFxcdTA0OTZcXHUwNDk4XFx1MDQ5QVxcdTA0OUNcXHUwNDlFXFx1MDRBMFxcdTA0QTJcXHUwNEE0XFx1MDRBNlxcdTA0QThcXHUwNEFBXFx1MDRBQ1xcdTA0QUVcXHUwNEIwXFx1MDRCMlxcdTA0QjRcXHUwNEI2XFx1MDRCOFxcdTA0QkFcXHUwNEJDXFx1MDRCRVxcdTA0QzBcXHUwNEMxXFx1MDRDM1xcdTA0QzVcXHUwNEM3XFx1MDRDOVxcdTA0Q0JcXHUwNENEXFx1MDREMFxcdTA0RDJcXHUwNEQ0XFx1MDRENlxcdTA0RDhcXHUwNERBXFx1MDREQ1xcdTA0REVcXHUwNEUwXFx1MDRFMlxcdTA0RTRcXHUwNEU2XFx1MDRFOFxcdTA0RUFcXHUwNEVDXFx1MDRFRVxcdTA0RjBcXHUwNEYyXFx1MDRGNFxcdTA0RjZcXHUwNEY4XFx1MDRGQVxcdTA0RkNcXHUwNEZFXFx1MDUwMFxcdTA1MDJcXHUwNTA0XFx1MDUwNlxcdTA1MDhcXHUwNTBBXFx1MDUwQ1xcdTA1MEVcXHUwNTEwXFx1MDUxMlxcdTA1MTRcXHUwNTE2XFx1MDUxOFxcdTA1MUFcXHUwNTFDXFx1MDUxRVxcdTA1MjBcXHUwNTIyXFx1MDUyNFxcdTA1MjZcXHUwNTI4XFx1MDUyQVxcdTA1MkNcXHUwNTJFXFx1MDUzMS1cXHUwNTU2XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxM0EwLVxcdTEzRjVcXHUxRTAwXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MUUwOFxcdTFFMEFcXHUxRTBDXFx1MUUwRVxcdTFFMTBcXHUxRTEyXFx1MUUxNFxcdTFFMTZcXHUxRTE4XFx1MUUxQVxcdTFFMUNcXHUxRTFFXFx1MUUyMFxcdTFFMjJcXHUxRTI0XFx1MUUyNlxcdTFFMjhcXHUxRTJBXFx1MUUyQ1xcdTFFMkVcXHUxRTMwXFx1MUUzMlxcdTFFMzRcXHUxRTM2XFx1MUUzOFxcdTFFM0FcXHUxRTNDXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MUU0NFxcdTFFNDZcXHUxRTQ4XFx1MUU0QVxcdTFFNENcXHUxRTRFXFx1MUU1MFxcdTFFNTJcXHUxRTU0XFx1MUU1NlxcdTFFNThcXHUxRTVBXFx1MUU1Q1xcdTFFNUVcXHUxRTYwXFx1MUU2MlxcdTFFNjRcXHUxRTY2XFx1MUU2OFxcdTFFNkFcXHUxRTZDXFx1MUU2RVxcdTFFNzBcXHUxRTcyXFx1MUU3NFxcdTFFNzZcXHUxRTc4XFx1MUU3QVxcdTFFN0NcXHUxRTdFXFx1MUU4MFxcdTFFODJcXHUxRTg0XFx1MUU4NlxcdTFFODhcXHUxRThBXFx1MUU4Q1xcdTFFOEVcXHUxRTkwXFx1MUU5MlxcdTFFOTRcXHUxRTlFXFx1MUVBMFxcdTFFQTJcXHUxRUE0XFx1MUVBNlxcdTFFQThcXHUxRUFBXFx1MUVBQ1xcdTFFQUVcXHUxRUIwXFx1MUVCMlxcdTFFQjRcXHUxRUI2XFx1MUVCOFxcdTFFQkFcXHUxRUJDXFx1MUVCRVxcdTFFQzBcXHUxRUMyXFx1MUVDNFxcdTFFQzZcXHUxRUM4XFx1MUVDQVxcdTFFQ0NcXHUxRUNFXFx1MUVEMFxcdTFFRDJcXHUxRUQ0XFx1MUVENlxcdTFFRDhcXHUxRURBXFx1MUVEQ1xcdTFFREVcXHUxRUUwXFx1MUVFMlxcdTFFRTRcXHUxRUU2XFx1MUVFOFxcdTFFRUFcXHUxRUVDXFx1MUVFRVxcdTFFRjBcXHUxRUYyXFx1MUVGNFxcdTFFRjZcXHUxRUY4XFx1MUVGQVxcdTFFRkNcXHUxRUZFXFx1MUYwOC1cXHUxRjBGXFx1MUYxOC1cXHUxRjFEXFx1MUYyOC1cXHUxRjJGXFx1MUYzOC1cXHUxRjNGXFx1MUY0OC1cXHUxRjREXFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1RlxcdTFGNjgtXFx1MUY2RlxcdTFGQjgtXFx1MUZCQlxcdTFGQzgtXFx1MUZDQlxcdTFGRDgtXFx1MUZEQlxcdTFGRTgtXFx1MUZFQ1xcdTFGRjgtXFx1MUZGQlxcdTIxMDJcXHUyMTA3XFx1MjEwQi1cXHUyMTBEXFx1MjExMC1cXHUyMTEyXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMzAtXFx1MjEzM1xcdTIxM0VcXHUyMTNGXFx1MjE0NVxcdTIxNjAtXFx1MjE2RlxcdTIxODNcXHUyNEI2LVxcdTI0Q0ZcXHUyQzAwLVxcdTJDMkVcXHUyQzYwXFx1MkM2Mi1cXHUyQzY0XFx1MkM2N1xcdTJDNjlcXHUyQzZCXFx1MkM2RC1cXHUyQzcwXFx1MkM3MlxcdTJDNzVcXHUyQzdFLVxcdTJDODBcXHUyQzgyXFx1MkM4NFxcdTJDODZcXHUyQzg4XFx1MkM4QVxcdTJDOENcXHUyQzhFXFx1MkM5MFxcdTJDOTJcXHUyQzk0XFx1MkM5NlxcdTJDOThcXHUyQzlBXFx1MkM5Q1xcdTJDOUVcXHUyQ0EwXFx1MkNBMlxcdTJDQTRcXHUyQ0E2XFx1MkNBOFxcdTJDQUFcXHUyQ0FDXFx1MkNBRVxcdTJDQjBcXHUyQ0IyXFx1MkNCNFxcdTJDQjZcXHUyQ0I4XFx1MkNCQVxcdTJDQkNcXHUyQ0JFXFx1MkNDMFxcdTJDQzJcXHUyQ0M0XFx1MkNDNlxcdTJDQzhcXHUyQ0NBXFx1MkNDQ1xcdTJDQ0VcXHUyQ0QwXFx1MkNEMlxcdTJDRDRcXHUyQ0Q2XFx1MkNEOFxcdTJDREFcXHUyQ0RDXFx1MkNERVxcdTJDRTBcXHUyQ0UyXFx1MkNFQlxcdTJDRURcXHUyQ0YyXFx1QTY0MFxcdUE2NDJcXHVBNjQ0XFx1QTY0NlxcdUE2NDhcXHVBNjRBXFx1QTY0Q1xcdUE2NEVcXHVBNjUwXFx1QTY1MlxcdUE2NTRcXHVBNjU2XFx1QTY1OFxcdUE2NUFcXHVBNjVDXFx1QTY1RVxcdUE2NjBcXHVBNjYyXFx1QTY2NFxcdUE2NjZcXHVBNjY4XFx1QTY2QVxcdUE2NkNcXHVBNjgwXFx1QTY4MlxcdUE2ODRcXHVBNjg2XFx1QTY4OFxcdUE2OEFcXHVBNjhDXFx1QTY4RVxcdUE2OTBcXHVBNjkyXFx1QTY5NFxcdUE2OTZcXHVBNjk4XFx1QTY5QVxcdUE3MjJcXHVBNzI0XFx1QTcyNlxcdUE3MjhcXHVBNzJBXFx1QTcyQ1xcdUE3MkVcXHVBNzMyXFx1QTczNFxcdUE3MzZcXHVBNzM4XFx1QTczQVxcdUE3M0NcXHVBNzNFXFx1QTc0MFxcdUE3NDJcXHVBNzQ0XFx1QTc0NlxcdUE3NDhcXHVBNzRBXFx1QTc0Q1xcdUE3NEVcXHVBNzUwXFx1QTc1MlxcdUE3NTRcXHVBNzU2XFx1QTc1OFxcdUE3NUFcXHVBNzVDXFx1QTc1RVxcdUE3NjBcXHVBNzYyXFx1QTc2NFxcdUE3NjZcXHVBNzY4XFx1QTc2QVxcdUE3NkNcXHVBNzZFXFx1QTc3OVxcdUE3N0JcXHVBNzdEXFx1QTc3RVxcdUE3ODBcXHVBNzgyXFx1QTc4NFxcdUE3ODZcXHVBNzhCXFx1QTc4RFxcdUE3OTBcXHVBNzkyXFx1QTc5NlxcdUE3OThcXHVBNzlBXFx1QTc5Q1xcdUE3OUVcXHVBN0EwXFx1QTdBMlxcdUE3QTRcXHVBN0E2XFx1QTdBOFxcdUE3QUEtXFx1QTdBRFxcdUE3QjAtXFx1QTdCNFxcdUE3QjZcXHVGRjIxLVxcdUZGM0EnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURDQTAtXFx1RENCRl18XFx1RDgwM1tcXHVEQzgwLVxcdURDQjJdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzE5XFx1REMzNC1cXHVEQzREXFx1REM2OC1cXHVEQzgxXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I1XFx1RENEMC1cXHVEQ0U5XFx1REQwNFxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDM4XFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDZDLVxcdUREODVcXHVEREEwLVxcdUREQjlcXHVEREQ0LVxcdURERURcXHVERTA4LVxcdURFMjFcXHVERTNDLVxcdURFNTVcXHVERTcwLVxcdURFODlcXHVERUE4LVxcdURFQzBcXHVERUUyLVxcdURFRkFcXHVERjFDLVxcdURGMzRcXHVERjU2LVxcdURGNkVcXHVERjkwLVxcdURGQThcXHVERkNBXXxcXHVEODAxW1xcdURDMDAtXFx1REMyN118XFx1RDgzQ1tcXHVERDMwLVxcdURENDlcXHVERDUwLVxcdURENjlcXHVERDcwLVxcdUREODldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnV2hpdGVfU3BhY2UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHgwOS1cXHgwRFxceDIwXFx4ODVcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMCdcclxuICAgICAgICB9XHJcbiAgICBdO1xyXG5cclxuICAgIC8vIEFkZCBub24tZ2VuZXJhdGVkIGRhdGFcclxuICAgIHVuaWNvZGVEYXRhLnB1c2goe1xyXG4gICAgICAgIG5hbWU6ICdBc3NpZ25lZCcsXHJcbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBkZWZpbmVkIGFzIHRoZSBpbnZlcnNlIG9mIFVuaWNvZGUgY2F0ZWdvcnkgQ24gKFVuYXNzaWduZWQpLCB0aGUgVW5pY29kZVxyXG4gICAgICAgIC8vIENhdGVnb3JpZXMgYWRkb24gaXMgcmVxdWlyZWQgdG8gdXNlIHRoaXMgcHJvcGVydHlcclxuICAgICAgICBpbnZlcnNlT2Y6ICdDbidcclxuICAgIH0pO1xyXG5cclxuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEodW5pY29kZURhdGEpO1xyXG5cclxufTtcclxuIiwiLyohXHJcbiAqIFhSZWdFeHAgVW5pY29kZSBTY3JpcHRzIDMuMS4xXHJcbiAqIDx4cmVnZXhwLmNvbT5cclxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEwLTIwMTYgTUlUIExpY2Vuc2VcclxuICogVW5pY29kZSBkYXRhIGJ5IE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzYnluZW5zLmJlPlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oWFJlZ0V4cCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBzdXBwb3J0IGZvciBhbGwgVW5pY29kZSBzY3JpcHRzLiBFLmcuLCBgXFxwe0xhdGlufWAuIFRva2VuIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLFxyXG4gICAgICogYW5kIGFueSBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBVc2VzIFVuaWNvZGUgOC4wLjAuXHJcbiAgICAgKlxyXG4gICAgICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKCFYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmljb2RlIEJhc2UgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIFVuaWNvZGUgU2NyaXB0cycpO1xyXG4gICAgfVxyXG5cclxuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Fob20nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBbmF0b2xpYW5fSGllcm9nbHlwaHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODExW1xcdURDMDAtXFx1REU0Nl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBcmFiaWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNjAwLVxcdTA2MDRcXHUwNjA2LVxcdTA2MEJcXHUwNjBELVxcdTA2MUFcXHUwNjFFXFx1MDYyMC1cXHUwNjNGXFx1MDY0MS1cXHUwNjRBXFx1MDY1Ni1cXHUwNjZGXFx1MDY3MS1cXHUwNkRDXFx1MDZERS1cXHUwNkZGXFx1MDc1MC1cXHUwNzdGXFx1MDhBMC1cXHUwOEI0XFx1MDhFMy1cXHUwOEZGXFx1RkI1MC1cXHVGQkMxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZEXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVERTYwLVxcdURFN0VdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQlxcdURFRjBcXHVERUYxXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FybWVuaWFuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDUzMS1cXHUwNTU2XFx1MDU1OS1cXHUwNTVGXFx1MDU2MS1cXHUwNTg3XFx1MDU4QVxcdTA1OEQtXFx1MDU4RlxcdUZCMTMtXFx1RkIxNydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0F2ZXN0YW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGMDAtXFx1REYzNVxcdURGMzktXFx1REYzRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdCYWxpbmVzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI3QydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0JhbXVtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTZBMC1cXHVBNkY3JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVEQzAwLVxcdURFMzhdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQmFzc2FfVmFoJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjVdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQmF0YWsnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQkMwLVxcdTFCRjNcXHUxQkZDLVxcdTFCRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdCZW5nYWxpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDk4MC1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RkInXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdCb3BvbW9mbycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAyRUFcXHUwMkVCXFx1MzEwNS1cXHUzMTJEXFx1MzFBMC1cXHUzMUJBJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQnJhaG1pJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzAwLVxcdURDNERcXHVEQzUyLVxcdURDNkZcXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0JyYWlsbGUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyODAwLVxcdTI4RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdCdWdpbmVzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBMDAtXFx1MUExQlxcdTFBMUVcXHUxQTFGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQnVoaWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzQwLVxcdTE3NTMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDYW5hZGlhbl9BYm9yaWdpbmFsJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTQwMC1cXHUxNjdGXFx1MThCMC1cXHUxOEY1J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ2FyaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERUEwLVxcdURFRDBdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ2F1Y2FzaWFuX0FsYmFuaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERDMwLVxcdURENjNcXHVERDZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NoYWttYScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDQzXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NoYW0nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTVDLVxcdUFBNUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDaGVyb2tlZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdUFCNzAtXFx1QUJCRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbW1vbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcMC1cXHg0MFxcXFx4NUItXFx4NjBcXFxceDdCLVxceEE5XFx4QUItXFx4QjlcXHhCQi1cXHhCRlxceEQ3XFx4RjdcXHUwMkI5LVxcdTAyREZcXHUwMkU1LVxcdTAyRTlcXHUwMkVDLVxcdTAyRkZcXHUwMzc0XFx1MDM3RVxcdTAzODVcXHUwMzg3XFx1MDU4OVxcdTA2MDVcXHUwNjBDXFx1MDYxQlxcdTA2MUNcXHUwNjFGXFx1MDY0MFxcdTA2RERcXHUwOTY0XFx1MDk2NVxcdTBFM0ZcXHUwRkQ1LVxcdTBGRDhcXHUxMEZCXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxODAyXFx1MTgwM1xcdTE4MDVcXHUxQ0QzXFx1MUNFMVxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MjAwMC1cXHUyMDBCXFx1MjAwRS1cXHUyMDY0XFx1MjA2Ni1cXHUyMDcwXFx1MjA3NC1cXHUyMDdFXFx1MjA4MC1cXHUyMDhFXFx1MjBBMC1cXHUyMEJFXFx1MjEwMC1cXHUyMTI1XFx1MjEyNy1cXHUyMTI5XFx1MjEyQy1cXHUyMTMxXFx1MjEzMy1cXHUyMTREXFx1MjE0Ri1cXHUyMTVGXFx1MjE4OS1cXHUyMThCXFx1MjE5MC1cXHUyM0ZBXFx1MjQwMC1cXHUyNDI2XFx1MjQ0MC1cXHUyNDRBXFx1MjQ2MC1cXHUyN0ZGXFx1MjkwMC1cXHUyQjczXFx1MkI3Ni1cXHUyQjk1XFx1MkI5OC1cXHUyQkI5XFx1MkJCRC1cXHUyQkM4XFx1MkJDQS1cXHUyQkQxXFx1MkJFQy1cXHUyQkVGXFx1MkUwMC1cXHUyRTQyXFx1MkZGMC1cXHUyRkZCXFx1MzAwMC1cXHUzMDA0XFx1MzAwNlxcdTMwMDgtXFx1MzAyMFxcdTMwMzAtXFx1MzAzN1xcdTMwM0MtXFx1MzAzRlxcdTMwOUJcXHUzMDlDXFx1MzBBMFxcdTMwRkJcXHUzMEZDXFx1MzE5MC1cXHUzMTlGXFx1MzFDMC1cXHUzMUUzXFx1MzIyMC1cXHUzMjVGXFx1MzI3Ri1cXHUzMkNGXFx1MzM1OC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTcwMC1cXHVBNzIxXFx1QTc4OC1cXHVBNzhBXFx1QTgzMC1cXHVBODM5XFx1QTkyRVxcdUE5Q0ZcXHVBQjVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjZcXHVGRTY4LVxcdUZFNkJcXHVGRUZGXFx1RkYwMS1cXHVGRjIwXFx1RkYzQi1cXHVGRjQwXFx1RkY1Qi1cXHVGRjY1XFx1RkY3MFxcdUZGOUVcXHVGRjlGXFx1RkZFMC1cXHVGRkU2XFx1RkZFOC1cXHVGRkVFXFx1RkZGOS1cXHVGRkZEJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRVtcXHVEQzAwLVxcdURDMEJcXHVEQzEwLVxcdURDNDdcXHVEQzUwLVxcdURDNTlcXHVEQzYwLVxcdURDODdcXHVEQzkwLVxcdURDQURcXHVERDEwLVxcdUREMThcXHVERDgwLVxcdUREODRcXHVEREMwXXxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDc5XFx1REQ3Qi1cXHVEREEzXFx1RERBNS1cXHVERUQwXFx1REVFMC1cXHVERUVDXFx1REVGMC1cXHVERUYzXFx1REYwMC1cXHVERjczXFx1REY4MC1cXHVERkQ0XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdUREMDctXFx1REQzM1xcdUREMzctXFx1REQzRlxcdUREOTAtXFx1REQ5QlxcdURERDAtXFx1RERGQ1xcdURFRTEtXFx1REVGQl18XFx1RDgzNFtcXHVEQzAwLVxcdURDRjVcXHVERDAwLVxcdUREMjZcXHVERDI5LVxcdURENjZcXHVERDZBLVxcdUREN0FcXHVERDgzXFx1REQ4NFxcdUREOEMtXFx1RERBOVxcdUREQUUtXFx1RERFOFxcdURGMDAtXFx1REY1NlxcdURGNjAtXFx1REY3MV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDMkJcXHVEQzMwLVxcdURDOTNcXHVEQ0EwLVxcdURDQUVcXHVEQ0IxLVxcdURDQkZcXHVEQ0MxLVxcdURDQ0ZcXHVEQ0QxLVxcdURDRjVcXHVERDAwLVxcdUREMENcXHVERDEwLVxcdUREMkVcXHVERDMwLVxcdURENkJcXHVERDcwLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMTAtXFx1REUzQVxcdURFNDAtXFx1REU0OFxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvcHRpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzRTItXFx1MDNFRlxcdTJDODAtXFx1MkNGM1xcdTJDRjktXFx1MkNGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0N1bmVpZm9ybScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM3MC1cXHVEQzc0XFx1REM4MC1cXHVERDQzXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDeXByaW90JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDeXJpbGxpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA0MDAtXFx1MDQ4NFxcdTA0ODctXFx1MDUyRlxcdTFEMkJcXHUxRDc4XFx1MkRFMC1cXHUyREZGXFx1QTY0MC1cXHVBNjlGXFx1RkUyRVxcdUZFMkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEZXNlcmV0JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzAwLVxcdURDNEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGV2YW5hZ2FyaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA5MDAtXFx1MDk1MFxcdTA5NTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk3RlxcdUE4RTAtXFx1QThGRCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0R1cGxveWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlDLVxcdURDOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRWd5cHRpYW5fSGllcm9nbHlwaHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODBDW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRWxiYXNhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REQwMC1cXHVERDI3XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0V0aGlvcGljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTIwMC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzN0NcXHUxMzgwLVxcdTEzOTlcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdHZW9yZ2lhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMEZGXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdHbGFnb2xpdGljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR290aGljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjMwLVxcdURGNEFdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR3JhbnRoYScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REYwMC1cXHVERjAzXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0MtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY1MFxcdURGNTdcXHVERjVELVxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR3JlZWsnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMzcwLVxcdTAzNzNcXHUwMzc1LVxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NFxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0UxXFx1MDNGMC1cXHUwM0ZGXFx1MUQyNi1cXHUxRDJBXFx1MUQ1RC1cXHUxRDYxXFx1MUQ2Ni1cXHUxRDZBXFx1MURCRlxcdTFGMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZDNFxcdTFGQzYtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGREQtXFx1MUZFRlxcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGRVxcdTIxMjZcXHVBQjY1JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDQwLVxcdUREOENcXHVEREEwXXxcXHVEODM0W1xcdURFMDAtXFx1REU0NV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdHdWphcmF0aScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFGMVxcdTBBRjknXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdHdXJtdWtoaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdIYW4nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyRTgwLVxcdTJFOTlcXHUyRTlCLVxcdTJFRjNcXHUyRjAwLVxcdTJGRDVcXHUzMDA1XFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxbXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0hhbmd1bCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTExMDAtXFx1MTFGRlxcdTMwMkVcXHUzMDJGXFx1MzEzMS1cXHUzMThFXFx1MzIwMC1cXHUzMjFFXFx1MzI2MC1cXHUzMjdFXFx1QTk2MC1cXHVBOTdDXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RkZBMC1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSGFudW5vbycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3MjAtXFx1MTczNCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0hhdHJhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVEQ0ZCLVxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSGVicmV3JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDU5MS1cXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUY0XFx1RkIxRC1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCNEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdIaXJhZ2FuYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkNcXHVEQzAxfFxcdUQ4M0NcXHVERTAwJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW1wZXJpYWxfQXJhbWFpYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM0MC1cXHVEQzU1XFx1REM1Ny1cXHVEQzVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luaGVyaXRlZCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzMDAtXFx1MDM2RlxcdTA0ODVcXHUwNDg2XFx1MDY0Qi1cXHUwNjU1XFx1MDY3MFxcdTA5NTFcXHUwOTUyXFx1MUFCMC1cXHUxQUJFXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGNVxcdTFERkMtXFx1MURGRlxcdTIwMENcXHUyMDBEXFx1MjBEMC1cXHUyMEYwXFx1MzAyQS1cXHUzMDJEXFx1MzA5OVxcdTMwOUFcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURENjctXFx1REQ2OVxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRF18XFx1RDgwMFtcXHVEREZEXFx1REVFMF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5zY3JpcHRpb25hbF9QYWhsYXZpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjYwLVxcdURGNzJcXHVERjc4LVxcdURGN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5zY3JpcHRpb25hbF9QYXJ0aGlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REY0MC1cXHVERjU1XFx1REY1OC1cXHVERjVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0phdmFuZXNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTk4MC1cXHVBOUNEXFx1QTlEMC1cXHVBOUQ5XFx1QTlERVxcdUE5REYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdLYWl0aGknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDODAtXFx1RENDMV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdLYW5uYWRhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjInXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdLYXRha2FuYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMwQTEtXFx1MzBGQVxcdTMwRkQtXFx1MzBGRlxcdTMxRjAtXFx1MzFGRlxcdTMyRDAtXFx1MzJGRVxcdTMzMDAtXFx1MzM1N1xcdUZGNjYtXFx1RkY2RlxcdUZGNzEtXFx1RkY5RCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkNcXHVEQzAwJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2F5YWhfTGknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBOTAwLVxcdUE5MkRcXHVBOTJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2hhcm9zaHRoaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTM4LVxcdURFM0FcXHVERTNGLVxcdURFNDdcXHVERTUwLVxcdURFNThdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2htZXInLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzgwLVxcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxOUUwLVxcdTE5RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdLaG9qa2knLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzRF0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdLaHVkYXdhZGknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYW8nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXRpbicsXHJcbiAgICAgICAgICAgIGJtcDogJ0EtWmEtelxceEFBXFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJCOFxcdTAyRTAtXFx1MDJFNFxcdTFEMDAtXFx1MUQyNVxcdTFEMkMtXFx1MUQ1Q1xcdTFENjItXFx1MUQ2NVxcdTFENkItXFx1MUQ3N1xcdTFENzktXFx1MURCRVxcdTFFMDAtXFx1MUVGRlxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEyQVxcdTIxMkJcXHUyMTMyXFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDNjAtXFx1MkM3RlxcdUE3MjItXFx1QTc4N1xcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTdGRlxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NFxcdUZCMDAtXFx1RkIwNlxcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xlcGNoYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDMDAtXFx1MUMzN1xcdTFDM0ItXFx1MUM0OVxcdTFDNEQtXFx1MUM0RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xpbWJ1JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0MFxcdTE5NDQtXFx1MTk0RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xpbmVhcl9BJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGluZWFyX0InLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xpc3UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBNEQwLVxcdUE0RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMeWNpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURFODAtXFx1REU5Q10nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMeWRpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREMjAtXFx1REQzOVxcdUREM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWFoYWphbmknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURENTAtXFx1REQ3Nl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNYWxheWFsYW0nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDc1XFx1MEQ3OS1cXHUwRDdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWFuZGFpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA4NDAtXFx1MDg1QlxcdTA4NUUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNYW5pY2hhZWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERUMwLVxcdURFRTZcXHVERUVCLVxcdURFRjZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWVldGVpX01heWVrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUFFMC1cXHVBQUY2XFx1QUJDMC1cXHVBQkVEXFx1QUJGMC1cXHVBQkY5J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWVuZGVfS2lrYWt1aScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENDNy1cXHVEQ0Q2XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01lcm9pdGljX0N1cnNpdmUnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREQTAtXFx1RERCN1xcdUREQkMtXFx1RERDRlxcdURERDItXFx1RERGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNZXJvaXRpY19IaWVyb2dseXBocycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQ4MC1cXHVERDlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01pYW8nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNb2RpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERTAwLVxcdURFNDRcXHVERTUwLVxcdURFNTldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTW9uZ29saWFuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTgwMFxcdTE4MDFcXHUxODA0XFx1MTgwNi1cXHUxODBFXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTXJvJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERTZFXFx1REU2Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNdWx0YW5pJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE5XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ015YW5tYXInLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxMDAwLVxcdTEwOUZcXHVBOUUwLVxcdUE5RkVcXHVBQTYwLVxcdUFBN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdOYWJhdGFlYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDODAtXFx1REM5RVxcdURDQTctXFx1RENBRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdOZXdfVGFpX0x1ZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTE5REVcXHUxOURGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTmtvJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDdDMC1cXHUwN0ZBJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT2doYW0nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNjgwLVxcdTE2OUMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPbF9DaGlraScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDNTAtXFx1MUM3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ09sZF9IdW5nYXJpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMlxcdURDRkEtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfSXRhbGljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjAwLVxcdURGMjNdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT2xkX05vcnRoX0FyYWJpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFODAtXFx1REU5Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfUGVybWljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjUwLVxcdURGN0FdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT2xkX1BlcnNpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZENV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfU291dGhfQXJhYmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REU2MC1cXHVERTdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ09sZF9UdXJraWMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURDMDAtXFx1REM0OF0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPcml5YScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNzcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPc21hbnlhJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzgwLVxcdURDOURcXHVEQ0EwLVxcdURDQTldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUGFoYXdoX0htb25nJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERjAwLVxcdURGNDVcXHVERjUwLVxcdURGNTlcXHVERjVCLVxcdURGNjFcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUGFsbXlyZW5lJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzYwLVxcdURDN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUGF1X0Npbl9IYXUnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURFQzAtXFx1REVGOF0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQaGFnc19QYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4NDAtXFx1QTg3NydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1Bob2VuaWNpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREMDAtXFx1REQxQlxcdUREMUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUHNhbHRlcl9QYWhsYXZpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjgwLVxcdURGOTFcXHVERjk5LVxcdURGOUNcXHVERkE5LVxcdURGQUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUmVqYW5nJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTkzMC1cXHVBOTUzXFx1QTk1RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1J1bmljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU2FtYXJpdGFuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDgwMC1cXHUwODJEXFx1MDgzMC1cXHUwODNFJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU2F1cmFzaHRyYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4ODAtXFx1QThDNFxcdUE4Q0UtXFx1QThEOSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NoYXJhZGEnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdUREODAtXFx1RERDRFxcdURERDAtXFx1RERERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTaGF2aWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzUwLVxcdURDN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU2lkZGhhbScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREREXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NpZ25Xcml0aW5nJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNltcXHVEQzAwLVxcdURFOEJcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU2luaGFsYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMi1cXHUwREY0JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEREUxLVxcdURERjRdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU29yYV9Tb21wZW5nJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU3VuZGFuZXNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUI4MC1cXHUxQkJGXFx1MUNDMC1cXHUxQ0M3J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU3lsb3RpX05hZ3JpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTgwMC1cXHVBODJCJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU3lyaWFjJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDcwMC1cXHUwNzBEXFx1MDcwRi1cXHUwNzRBXFx1MDc0RC1cXHUwNzRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGFnYWxvZycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1RhZ2JhbndhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUYWlfTGUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUYWlfVGhhbScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTAtXFx1MUFBRCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1RhaV9WaWV0JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUE4MC1cXHVBQUMyXFx1QUFEQi1cXHVBQURGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGFrcmknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURFODAtXFx1REVCN1xcdURFQzAtXFx1REVDOV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUYW1pbCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkZBJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGVsdWd1JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzc4LVxcdTBDN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUaGFhbmEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNzgwLVxcdTA3QjEnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUaGFpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTVCJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGliZXRhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBGMDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQkUtXFx1MEZDQ1xcdTBGQ0UtXFx1MEZENFxcdTBGRDlcXHUwRkRBJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGlmaW5hZ2gnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3MFxcdTJEN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUaXJodXRhJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVEQzgwLVxcdURDQzdcXHVEQ0QwLVxcdURDRDldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVWdhcml0aWMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGODAtXFx1REY5RFxcdURGOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVmFpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTUwMC1cXHVBNjJCJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnV2FyYW5nX0NpdGknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURDQTAtXFx1RENGMlxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnWWknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBMDAwLVxcdUE0OENcXHVBNDkwLVxcdUE0QzYnXHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcblxyXG59O1xyXG4iLCJ2YXIgWFJlZ0V4cCA9IHJlcXVpcmUoJy4veHJlZ2V4cCcpO1xyXG5cclxucmVxdWlyZSgnLi9hZGRvbnMvYnVpbGQnKShYUmVnRXhwKTtcclxucmVxdWlyZSgnLi9hZGRvbnMvbWF0Y2hyZWN1cnNpdmUnKShYUmVnRXhwKTtcclxucmVxdWlyZSgnLi9hZGRvbnMvdW5pY29kZS1iYXNlJykoWFJlZ0V4cCk7XHJcbnJlcXVpcmUoJy4vYWRkb25zL3VuaWNvZGUtYmxvY2tzJykoWFJlZ0V4cCk7XHJcbnJlcXVpcmUoJy4vYWRkb25zL3VuaWNvZGUtY2F0ZWdvcmllcycpKFhSZWdFeHApO1xyXG5yZXF1aXJlKCcuL2FkZG9ucy91bmljb2RlLXByb3BlcnRpZXMnKShYUmVnRXhwKTtcclxucmVxdWlyZSgnLi9hZGRvbnMvdW5pY29kZS1zY3JpcHRzJykoWFJlZ0V4cCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhSZWdFeHA7XHJcbiIsIi8qIVxyXG4gKiBYUmVnRXhwIDMuMS4xXHJcbiAqIDx4cmVnZXhwLmNvbT5cclxuICogU3RldmVuIExldml0aGFuIChjKSAyMDA3LTIwMTYgTUlUIExpY2Vuc2VcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogWFJlZ0V4cCBwcm92aWRlcyBhdWdtZW50ZWQsIGV4dGVuc2libGUgcmVndWxhciBleHByZXNzaW9ucy4gWW91IGdldCBhZGRpdGlvbmFsIHJlZ2V4IHN5bnRheCBhbmRcclxuICogZmxhZ3MsIGJleW9uZCB3aGF0IGJyb3dzZXJzIHN1cHBvcnQgbmF0aXZlbHkuIFhSZWdFeHAgaXMgYWxzbyBhIHJlZ2V4IHV0aWxpdHkgYmVsdCB3aXRoIHRvb2xzIHRvXHJcbiAqIG1ha2UgeW91ciBjbGllbnQtc2lkZSBncmVwcGluZyBzaW1wbGVyIGFuZCBtb3JlIHBvd2VyZnVsLCB3aGlsZSBmcmVlaW5nIHlvdSBmcm9tIHJlbGF0ZWRcclxuICogY3Jvc3MtYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMuXHJcbiAqL1xyXG5cclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcbi8vIFByaXZhdGUgc3R1ZmZcclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcblxyXG4vLyBQcm9wZXJ0eSBuYW1lIHVzZWQgZm9yIGV4dGVuZGVkIHJlZ2V4IGluc3RhbmNlIGRhdGFcclxudmFyIFJFR0VYX0RBVEEgPSAneHJlZ2V4cCc7XHJcbi8vIE9wdGlvbmFsIGZlYXR1cmVzIHRoYXQgY2FuIGJlIGluc3RhbGxlZCBhbmQgdW5pbnN0YWxsZWRcclxudmFyIGZlYXR1cmVzID0ge1xyXG4gICAgYXN0cmFsOiBmYWxzZSxcclxuICAgIG5hdGl2ZXM6IGZhbHNlXHJcbn07XHJcbi8vIE5hdGl2ZSBtZXRob2RzIHRvIHVzZSBhbmQgcmVzdG9yZSAoJ25hdGl2ZScgaXMgYW4gRVMzIHJlc2VydmVkIGtleXdvcmQpXHJcbnZhciBuYXRpdiA9IHtcclxuICAgIGV4ZWM6IFJlZ0V4cC5wcm90b3R5cGUuZXhlYyxcclxuICAgIHRlc3Q6IFJlZ0V4cC5wcm90b3R5cGUudGVzdCxcclxuICAgIG1hdGNoOiBTdHJpbmcucHJvdG90eXBlLm1hdGNoLFxyXG4gICAgcmVwbGFjZTogU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLFxyXG4gICAgc3BsaXQ6IFN0cmluZy5wcm90b3R5cGUuc3BsaXRcclxufTtcclxuLy8gU3RvcmFnZSBmb3IgZml4ZWQvZXh0ZW5kZWQgbmF0aXZlIG1ldGhvZHNcclxudmFyIGZpeGVkID0ge307XHJcbi8vIFN0b3JhZ2UgZm9yIHJlZ2V4ZXMgY2FjaGVkIGJ5IGBYUmVnRXhwLmNhY2hlYFxyXG52YXIgcmVnZXhDYWNoZSA9IHt9O1xyXG4vLyBTdG9yYWdlIGZvciBwYXR0ZXJuIGRldGFpbHMgY2FjaGVkIGJ5IHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3JcclxudmFyIHBhdHRlcm5DYWNoZSA9IHt9O1xyXG4vLyBTdG9yYWdlIGZvciByZWdleCBzeW50YXggdG9rZW5zIGFkZGVkIGludGVybmFsbHkgb3IgYnkgYFhSZWdFeHAuYWRkVG9rZW5gXHJcbnZhciB0b2tlbnMgPSBbXTtcclxuLy8gVG9rZW4gc2NvcGVzXHJcbnZhciBkZWZhdWx0U2NvcGUgPSAnZGVmYXVsdCc7XHJcbnZhciBjbGFzc1Njb3BlID0gJ2NsYXNzJztcclxuLy8gUmVnZXhlcyB0aGF0IG1hdGNoIG5hdGl2ZSByZWdleCBzeW50YXgsIGluY2x1ZGluZyBvY3RhbHNcclxudmFyIG5hdGl2ZVRva2VucyA9IHtcclxuICAgIC8vIEFueSBuYXRpdmUgbXVsdGljaGFyYWN0ZXIgdG9rZW4gaW4gZGVmYXVsdCBzY29wZSwgb3IgYW55IHNpbmdsZSBjaGFyYWN0ZXJcclxuICAgICdkZWZhdWx0JzogL1xcXFwoPzowKD86WzAtM11bMC03XXswLDJ9fFs0LTddWzAtN10/KT98WzEtOV1cXGQqfHhbXFxkQS1GYS1mXXsyfXx1KD86W1xcZEEtRmEtZl17NH18e1tcXGRBLUZhLWZdK30pfGNbQS1aYS16XXxbXFxzXFxTXSl8XFwoXFw/KD86Wzo9IV18PFs9IV0pfFs/KitdXFw/fHtcXGQrKD86LFxcZCopP31cXD8/fFtcXHNcXFNdLyxcclxuICAgIC8vIEFueSBuYXRpdmUgbXVsdGljaGFyYWN0ZXIgdG9rZW4gaW4gY2hhcmFjdGVyIGNsYXNzIHNjb3BlLCBvciBhbnkgc2luZ2xlIGNoYXJhY3RlclxyXG4gICAgJ2NsYXNzJzogL1xcXFwoPzpbMC0zXVswLTddezAsMn18WzQtN11bMC03XT98eFtcXGRBLUZhLWZdezJ9fHUoPzpbXFxkQS1GYS1mXXs0fXx7W1xcZEEtRmEtZl0rfSl8Y1tBLVphLXpdfFtcXHNcXFNdKXxbXFxzXFxTXS9cclxufTtcclxuLy8gQW55IGJhY2tyZWZlcmVuY2Ugb3IgZG9sbGFyLXByZWZpeGVkIGNoYXJhY3RlciBpbiByZXBsYWNlbWVudCBzdHJpbmdzXHJcbnZhciByZXBsYWNlbWVudFRva2VuID0gL1xcJCg/OnsoW1xcdyRdKyl9fChcXGRcXGQ/fFtcXHNcXFNdKSkvZztcclxuLy8gQ2hlY2sgZm9yIGNvcnJlY3QgYGV4ZWNgIGhhbmRsaW5nIG9mIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xyXG52YXIgY29ycmVjdEV4ZWNOcGNnID0gbmF0aXYuZXhlYy5jYWxsKC8oKT8/LywgJycpWzFdID09PSB1bmRlZmluZWQ7XHJcbi8vIENoZWNrIGZvciBFUzYgYGZsYWdzYCBwcm9wIHN1cHBvcnRcclxudmFyIGhhc0ZsYWdzUHJvcCA9IC94Ly5mbGFncyAhPT0gdW5kZWZpbmVkO1xyXG4vLyBTaG9ydGN1dCB0byBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcclxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XHJcblxyXG5mdW5jdGlvbiBoYXNOYXRpdmVGbGFnKGZsYWcpIHtcclxuICAgIC8vIENhbid0IGNoZWNrIGJhc2VkIG9uIHRoZSBwcmVzZW5zZSBvZiBwcm9wZXJ0aWVzL2dldHRlcnMgc2luY2UgYnJvd3NlcnMgbWlnaHQgc3VwcG9ydCBzdWNoXHJcbiAgICAvLyBwcm9wZXJ0aWVzIGV2ZW4gd2hlbiB0aGV5IGRvbid0IHN1cHBvcnQgdGhlIGNvcnJlc3BvbmRpbmcgZmxhZyBpbiByZWdleCBjb25zdHJ1Y3Rpb24gKHRlc3RlZFxyXG4gICAgLy8gaW4gQ2hyb21lIDQ4LCB3aGVyZSBgJ3VuaWNvZGUnIGluIC94L2AgaXMgdHJ1ZSBidXQgdHJ5aW5nIHRvIGNvbnN0cnVjdCBhIHJlZ2V4IHdpdGggZmxhZyBgdWBcclxuICAgIC8vIHRocm93cyBhbiBlcnJvcilcclxuICAgIHZhciBpc1N1cHBvcnRlZCA9IHRydWU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENhbid0IHVzZSByZWdleCBsaXRlcmFscyBmb3IgdGVzdGluZyBldmVuIGluIGEgYHRyeWAgYmVjYXVzZSByZWdleCBsaXRlcmFscyB3aXRoXHJcbiAgICAgICAgLy8gdW5zdXBwb3J0ZWQgZmxhZ3MgY2F1c2UgYSBjb21waWxhdGlvbiBlcnJvciBpbiBJRVxyXG4gICAgICAgIG5ldyBSZWdFeHAoJycsIGZsYWcpO1xyXG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpc1N1cHBvcnRlZCAmJiBmbGFnID09PSAneScpIHtcclxuICAgICAgICAvLyBXb3JrIGFyb3VuZCBTYWZhcmkgOS4xLjEgYnVnXHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ2FhfC4nLCAneScpLnRlc3QoJ2InKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcclxufVxyXG4vLyBDaGVjayBmb3IgRVM2IGB1YCBmbGFnIHN1cHBvcnRcclxudmFyIGhhc05hdGl2ZVUgPSBoYXNOYXRpdmVGbGFnKCd1Jyk7XHJcbi8vIENoZWNrIGZvciBFUzYgYHlgIGZsYWcgc3VwcG9ydFxyXG52YXIgaGFzTmF0aXZlWSA9IGhhc05hdGl2ZUZsYWcoJ3knKTtcclxuLy8gVHJhY2tlciBmb3Iga25vd24gZmxhZ3MsIGluY2x1ZGluZyBhZGRvbiBmbGFnc1xyXG52YXIgcmVnaXN0ZXJlZEZsYWdzID0ge1xyXG4gICAgZzogdHJ1ZSxcclxuICAgIGk6IHRydWUsXHJcbiAgICBtOiB0cnVlLFxyXG4gICAgdTogaGFzTmF0aXZlVSxcclxuICAgIHk6IGhhc05hdGl2ZVlcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBdHRhY2hlcyBleHRlbmRlZCBkYXRhIGFuZCBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMgdG8gYSByZWdleCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBhdWdtZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5fSBjYXB0dXJlTmFtZXMgQXJyYXkgd2l0aCBjYXB0dXJlIG5hbWVzLCBvciBgbnVsbGAuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB4U291cmNlIFhSZWdFeHAgcGF0dGVybiB1c2VkIHRvIGdlbmVyYXRlIGByZWdleGAsIG9yIGBudWxsYCBpZiBOL0EuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB4RmxhZ3MgWFJlZ0V4cCBmbGFncyB1c2VkIHRvIGdlbmVyYXRlIGByZWdleGAsIG9yIGBudWxsYCBpZiBOL0EuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzSW50ZXJuYWxPbmx5PWZhbHNlXSBXaGV0aGVyIHRoZSByZWdleCB3aWxsIGJlIHVzZWQgb25seSBmb3IgaW50ZXJuYWxcclxuICogICBvcGVyYXRpb25zLCBhbmQgbmV2ZXIgZXhwb3NlZCB0byB1c2Vycy4gRm9yIGludGVybmFsLW9ubHkgcmVnZXhlcywgd2UgY2FuIGltcHJvdmUgcGVyZiBieVxyXG4gKiAgIHNraXBwaW5nIHNvbWUgb3BlcmF0aW9ucyBsaWtlIGF0dGFjaGluZyBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMuXHJcbiAqIEByZXR1cm5zIHtSZWdFeHB9IEF1Z21lbnRlZCByZWdleC5cclxuICovXHJcbmZ1bmN0aW9uIGF1Z21lbnQocmVnZXgsIGNhcHR1cmVOYW1lcywgeFNvdXJjZSwgeEZsYWdzLCBpc0ludGVybmFsT25seSkge1xyXG4gICAgdmFyIHA7XHJcblxyXG4gICAgcmVnZXhbUkVHRVhfREFUQV0gPSB7XHJcbiAgICAgICAgY2FwdHVyZU5hbWVzOiBjYXB0dXJlTmFtZXNcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGlzSW50ZXJuYWxPbmx5KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2V4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbid0IGF1dG8taW5oZXJpdCB0aGVzZSBzaW5jZSB0aGUgWFJlZ0V4cCBjb25zdHJ1Y3RvciByZXR1cm5zIGEgbm9ucHJpbWl0aXZlIHZhbHVlXHJcbiAgICBpZiAocmVnZXguX19wcm90b19fKSB7XHJcbiAgICAgICAgcmVnZXguX19wcm90b19fID0gWFJlZ0V4cC5wcm90b3R5cGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAocCBpbiBYUmVnRXhwLnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICAvLyBBbiBgWFJlZ0V4cC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocClgIGNoZWNrIHdvdWxkbid0IGJlIHdvcnRoIGl0IGhlcmUsIHNpbmNlIHRoaXNcclxuICAgICAgICAgICAgLy8gaXMgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLCBhbmQgZW51bWVyYWJsZSBgT2JqZWN0LnByb3RvdHlwZWAgb3IgYFJlZ0V4cC5wcm90b3R5cGVgXHJcbiAgICAgICAgICAgIC8vIGV4dGVuc2lvbnMgZXhpc3Qgb24gYHJlZ2V4LnByb3RvdHlwZWAgYW55d2F5XHJcbiAgICAgICAgICAgIHJlZ2V4W3BdID0gWFJlZ0V4cC5wcm90b3R5cGVbcF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2V4W1JFR0VYX0RBVEFdLnNvdXJjZSA9IHhTb3VyY2U7XHJcbiAgICAvLyBFbXVsYXRlIHRoZSBFUzYgYGZsYWdzYCBwcm9wIGJ5IGVuc3VyaW5nIGZsYWdzIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcclxuICAgIHJlZ2V4W1JFR0VYX0RBVEFdLmZsYWdzID0geEZsYWdzID8geEZsYWdzLnNwbGl0KCcnKS5zb3J0KCkuam9pbignJykgOiB4RmxhZ3M7XHJcblxyXG4gICAgcmV0dXJuIHJlZ2V4O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbnkgZHVwbGljYXRlIGNoYXJhY3RlcnMgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byByZW1vdmUgZHVwbGljYXRlIGNoYXJhY3RlcnMgZnJvbS5cclxuICogQHJldHVybnMge1N0cmluZ30gU3RyaW5nIHdpdGggYW55IGR1cGxpY2F0ZSBjaGFyYWN0ZXJzIHJlbW92ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGlwRHVwbGljYXRlcyhzdHIpIHtcclxuICAgIHJldHVybiBuYXRpdi5yZXBsYWNlLmNhbGwoc3RyLCAvKFtcXHNcXFNdKSg/PVtcXHNcXFNdKlxcMSkvZywgJycpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29waWVzIGEgcmVnZXggb2JqZWN0IHdoaWxlIHByZXNlcnZpbmcgZXh0ZW5kZWQgZGF0YSBhbmQgYXVnbWVudGluZyB3aXRoIGBYUmVnRXhwLnByb3RvdHlwZWBcclxuICogcHJvcGVydGllcy4gVGhlIGNvcHkgaGFzIGEgZnJlc2ggYGxhc3RJbmRleGAgcHJvcGVydHkgKHNldCB0byB6ZXJvKS4gQWxsb3dzIGFkZGluZyBhbmQgcmVtb3ZpbmdcclxuICogZmxhZ3MgZyBhbmQgeSB3aGlsZSBjb3B5aW5nIHRoZSByZWdleC5cclxuICpcclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIGNvcHkuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzOlxyXG4gKiAgIDxsaT5gYWRkR2Age0Jvb2xlYW59IEFkZCBmbGFnIGcgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXHJcbiAqICAgPGxpPmBhZGRZYCB7Qm9vbGVhbn0gQWRkIGZsYWcgeSB3aGlsZSBjb3B5aW5nIHRoZSByZWdleC5cclxuICogICA8bGk+YHJlbW92ZUdgIHtCb29sZWFufSBSZW1vdmUgZmxhZyBnIHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxyXG4gKiAgIDxsaT5gcmVtb3ZlWWAge0Jvb2xlYW59IFJlbW92ZSBmbGFnIHkgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXHJcbiAqICAgPGxpPmBpc0ludGVybmFsT25seWAge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGNvcGllZCByZWdleCB3aWxsIGJlIHVzZWQgb25seSBmb3IgaW50ZXJuYWxcclxuICogICAgIG9wZXJhdGlvbnMsIGFuZCBuZXZlciBleHBvc2VkIHRvIHVzZXJzLiBGb3IgaW50ZXJuYWwtb25seSByZWdleGVzLCB3ZSBjYW4gaW1wcm92ZSBwZXJmIGJ5XHJcbiAqICAgICBza2lwcGluZyBzb21lIG9wZXJhdGlvbnMgbGlrZSBhdHRhY2hpbmcgYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLlxyXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBDb3B5IG9mIHRoZSBwcm92aWRlZCByZWdleCwgcG9zc2libHkgd2l0aCBtb2RpZmllZCBmbGFncy5cclxuICovXHJcbmZ1bmN0aW9uIGNvcHlSZWdleChyZWdleCwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFYUmVnRXhwLmlzUmVnRXhwKHJlZ2V4KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGUgUmVnRXhwIGV4cGVjdGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhEYXRhID0gcmVnZXhbUkVHRVhfREFUQV0gfHwge30sXHJcbiAgICAgICAgZmxhZ3MgPSBnZXROYXRpdmVGbGFncyhyZWdleCksXHJcbiAgICAgICAgZmxhZ3NUb0FkZCA9ICcnLFxyXG4gICAgICAgIGZsYWdzVG9SZW1vdmUgPSAnJyxcclxuICAgICAgICB4cmVnZXhwU291cmNlID0gbnVsbCxcclxuICAgICAgICB4cmVnZXhwRmxhZ3MgPSBudWxsO1xyXG5cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIGlmIChvcHRpb25zLnJlbW92ZUcpIHtmbGFnc1RvUmVtb3ZlICs9ICdnJzt9XHJcbiAgICBpZiAob3B0aW9ucy5yZW1vdmVZKSB7ZmxhZ3NUb1JlbW92ZSArPSAneSc7fVxyXG4gICAgaWYgKGZsYWdzVG9SZW1vdmUpIHtcclxuICAgICAgICBmbGFncyA9IG5hdGl2LnJlcGxhY2UuY2FsbChmbGFncywgbmV3IFJlZ0V4cCgnWycgKyBmbGFnc1RvUmVtb3ZlICsgJ10rJywgJ2cnKSwgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLmFkZEcpIHtmbGFnc1RvQWRkICs9ICdnJzt9XHJcbiAgICBpZiAob3B0aW9ucy5hZGRZKSB7ZmxhZ3NUb0FkZCArPSAneSc7fVxyXG4gICAgaWYgKGZsYWdzVG9BZGQpIHtcclxuICAgICAgICBmbGFncyA9IGNsaXBEdXBsaWNhdGVzKGZsYWdzICsgZmxhZ3NUb0FkZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLmlzSW50ZXJuYWxPbmx5KSB7XHJcbiAgICAgICAgaWYgKHhEYXRhLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHhyZWdleHBTb3VyY2UgPSB4RGF0YS5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG51bGwgb3IgdW5kZWZpbmVkOyBkb24ndCB3YW50IHRvIGFkZCB0byBgZmxhZ3NgIGlmIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgbnVsbCwgc2luY2VcclxuICAgICAgICAvLyB0aGF0IGluZGljYXRlcyB3ZSdyZSBub3QgdHJhY2tpbmcgb3JpZ2luYWwgcHJlY29tcGlsYXRpb24gZmxhZ3NcclxuICAgICAgICBpZiAoeERhdGEuZmxhZ3MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBGbGFncyBhcmUgb25seSBhZGRlZCBmb3Igbm9uLWludGVybmFsIHJlZ2V4ZXMgYnkgYFhSZWdFeHAuZ2xvYmFsaXplYC4gRmxhZ3MgYXJlIG5ldmVyXHJcbiAgICAgICAgICAgIC8vIHJlbW92ZWQgZm9yIG5vbi1pbnRlcm5hbCByZWdleGVzLCBzbyBkb24ndCBuZWVkIHRvIGhhbmRsZSBpdFxyXG4gICAgICAgICAgICB4cmVnZXhwRmxhZ3MgPSBmbGFnc1RvQWRkID8gY2xpcER1cGxpY2F0ZXMoeERhdGEuZmxhZ3MgKyBmbGFnc1RvQWRkKSA6IHhEYXRhLmZsYWdzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBdWdtZW50IHdpdGggYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLCBidXQgdXNlIHRoZSBuYXRpdmUgYFJlZ0V4cGAgY29uc3RydWN0b3IgdG8gYXZvaWRcclxuICAgIC8vIHNlYXJjaGluZyBmb3Igc3BlY2lhbCB0b2tlbnMuIFRoYXQgd291bGQgYmUgd3JvbmcgZm9yIHJlZ2V4ZXMgY29uc3RydWN0ZWQgYnkgYFJlZ0V4cGAsIGFuZFxyXG4gICAgLy8gdW5uZWNlc3NhcnkgZm9yIHJlZ2V4ZXMgY29uc3RydWN0ZWQgYnkgYFhSZWdFeHBgIGJlY2F1c2UgdGhlIHJlZ2V4IGhhcyBhbHJlYWR5IHVuZGVyZ29uZSB0aGVcclxuICAgIC8vIHRyYW5zbGF0aW9uIHRvIG5hdGl2ZSByZWdleCBzeW50YXhcclxuICAgIHJlZ2V4ID0gYXVnbWVudChcclxuICAgICAgICBuZXcgUmVnRXhwKHJlZ2V4LnNvdXJjZSwgZmxhZ3MpLFxyXG4gICAgICAgIGhhc05hbWVkQ2FwdHVyZShyZWdleCkgPyB4RGF0YS5jYXB0dXJlTmFtZXMuc2xpY2UoMCkgOiBudWxsLFxyXG4gICAgICAgIHhyZWdleHBTb3VyY2UsXHJcbiAgICAgICAgeHJlZ2V4cEZsYWdzLFxyXG4gICAgICAgIG9wdGlvbnMuaXNJbnRlcm5hbE9ubHlcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHJlZ2V4O1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgaGV4YWRlY2ltYWwgdG8gZGVjaW1hbC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZGVjKGhleCkge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KGhleCwgMTYpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBuYXRpdmUgYFJlZ0V4cGAgZmxhZ3MgdXNlZCBieSBhIHJlZ2V4IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBOYXRpdmUgZmxhZ3MgaW4gdXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmF0aXZlRmxhZ3MocmVnZXgpIHtcclxuICAgIHJldHVybiBoYXNGbGFnc1Byb3AgP1xyXG4gICAgICAgIHJlZ2V4LmZsYWdzIDpcclxuICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCAocmF0aGVyIHRoYW4gZS5nLiBgU3RyaW5nYCBvciBjb25jYXRlbmF0aW9uXHJcbiAgICAgICAgLy8gd2l0aCBhbiBlbXB0eSBzdHJpbmcpIGFsbG93cyB0aGlzIHRvIGNvbnRpbnVlIHdvcmtpbmcgcHJlZGljdGFibHkgd2hlblxyXG4gICAgICAgIC8vIGBYUmVnRXhwLnByb3B0b3R5cGUudG9TdHJpbmdgIGlzIG92ZXJyaWRlblxyXG4gICAgICAgIG5hdGl2LmV4ZWMuY2FsbCgvXFwvKFthLXpdKikkL2ksIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWdleCkpWzFdO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcmVnZXggaGFzIGV4dGVuZGVkIGluc3RhbmNlIGRhdGEgdXNlZCB0byB0cmFjayBjYXB0dXJlIG5hbWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZWdleCB1c2VzIG5hbWVkIGNhcHR1cmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNOYW1lZENhcHR1cmUocmVnZXgpIHtcclxuICAgIHJldHVybiAhIShyZWdleFtSRUdFWF9EQVRBXSAmJiByZWdleFtSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgZGVjaW1hbCB0byBoZXhhZGVjaW1hbC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBkZWNcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGhleChkZWMpIHtcclxuICAgIHJldHVybiBwYXJzZUludChkZWMsIDEwKS50b1N0cmluZygxNik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIHZhbHVlIGNhbiBiZSBmb3VuZCBpbiBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdGhlIGl0ZW0gaXMgZm91bmQsIG9yIC0xLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcclxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGgsIGk7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgaXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBieSByZXNvbHZpbmcgaXRzIGludGVybmFsIFtbQ2xhc3NdXS5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBPYmplY3QgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgdG8gY2hlY2sgZm9yLCBpbiBUaXRsZUNhc2UuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBvYmplY3QgbWF0Y2hlcyB0aGUgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBuZXh0IG5vbmlnbm9yYWJsZSB0b2tlbiBhZnRlciB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGlzIGEgcXVhbnRpZmllci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gUGF0dGVybiB0byBzZWFyY2ggd2l0aGluLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIEluZGV4IGluIGBwYXR0ZXJuYCB0byBzZWFyY2ggYXQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFncyBGbGFncyB1c2VkIGJ5IHRoZSBwYXR0ZXJuLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBhIHF1YW50aWZpZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1F1YW50aWZpZXJOZXh0KHBhdHRlcm4sIHBvcywgZmxhZ3MpIHtcclxuICAgIHJldHVybiBuYXRpdi50ZXN0LmNhbGwoXHJcbiAgICAgICAgZmxhZ3MuaW5kZXhPZigneCcpID4gLTEgP1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgYW55IGxlYWRpbmcgd2hpdGVzcGFjZSwgbGluZSBjb21tZW50cywgYW5kIGlubGluZSBjb21tZW50c1xyXG4gICAgICAgICAgICAvXig/Olxcc3wjW14jXFxuXSp8XFwoXFw/I1teKV0qXFwpKSooPzpbPyorXXx7XFxkKyg/OixcXGQqKT99KS8gOlxyXG4gICAgICAgICAgICAvLyBJZ25vcmUgYW55IGxlYWRpbmcgaW5saW5lIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIC9eKD86XFwoXFw/I1teKV0qXFwpKSooPzpbPyorXXx7XFxkKyg/OixcXGQqKT99KS8sXHJcbiAgICAgICAgcGF0dGVybi5zbGljZShwb3MpXHJcbiAgICApO1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBsZWFkaW5nIHplcm9zIGlmIHNob3J0ZXIgdGhhbiBmb3VyIGNoYXJhY3RlcnMuIFVzZWQgZm9yIGZpeGVkLWxlbmd0aCBoZXhhZGVjaW1hbCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHBhZDQoc3RyKSB7XHJcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICBzdHIgPSAnMCcgKyBzdHI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGZvciBmbGFnLXJlbGF0ZWQgZXJyb3JzLCBhbmQgc3RyaXBzL2FwcGxpZXMgZmxhZ3MgaW4gYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIuIE9mZmxvYWRzXHJcbiAqIHRoZSBmbGFnIHByZXBhcmF0aW9uIGxvZ2ljIGZyb20gdGhlIGBYUmVnRXhwYCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gUmVnZXggcGF0dGVybiwgcG9zc2libHkgd2l0aCBhIGxlYWRpbmcgbW9kZSBtb2RpZmllci5cclxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdzIEFueSBjb21iaW5hdGlvbiBvZiBmbGFncy5cclxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggcHJvcGVydGllcyBgcGF0dGVybmAgYW5kIGBmbGFnc2AuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmVwYXJlRmxhZ3MocGF0dGVybiwgZmxhZ3MpIHtcclxuICAgIHZhciBpO1xyXG5cclxuICAgIC8vIFJlY2VudCBicm93c2VycyB0aHJvdyBvbiBkdXBsaWNhdGUgZmxhZ3MsIHNvIGNvcHkgdGhpcyBiZWhhdmlvciBmb3Igbm9ubmF0aXZlIGZsYWdzXHJcbiAgICBpZiAoY2xpcER1cGxpY2F0ZXMoZmxhZ3MpICE9PSBmbGFncykge1xyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBkdXBsaWNhdGUgcmVnZXggZmxhZyAnICsgZmxhZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmlwIGFuZCBhcHBseSBhIGxlYWRpbmcgbW9kZSBtb2RpZmllciB3aXRoIGFueSBjb21iaW5hdGlvbiBvZiBmbGFncyBleGNlcHQgZyBvciB5XHJcbiAgICBwYXR0ZXJuID0gbmF0aXYucmVwbGFjZS5jYWxsKHBhdHRlcm4sIC9eXFwoXFw/KFtcXHckXSspXFwpLywgZnVuY3Rpb24oJDAsICQxKSB7XHJcbiAgICAgICAgaWYgKG5hdGl2LnRlc3QuY2FsbCgvW2d5XS8sICQxKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2UgZmxhZyBnIG9yIHkgaW4gbW9kZSBtb2RpZmllciAnICsgJDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbGxvdyBkdXBsaWNhdGUgZmxhZ3Mgd2l0aGluIHRoZSBtb2RlIG1vZGlmaWVyXHJcbiAgICAgICAgZmxhZ3MgPSBjbGlwRHVwbGljYXRlcyhmbGFncyArICQxKTtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUaHJvdyBvbiB1bmtub3duIG5hdGl2ZSBvciBub25uYXRpdmUgZmxhZ3NcclxuICAgIGZvciAoaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmICghcmVnaXN0ZXJlZEZsYWdzW2ZsYWdzLmNoYXJBdChpKV0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmtub3duIHJlZ2V4IGZsYWcgJyArIGZsYWdzLmNoYXJBdChpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF0dGVybjogcGF0dGVybixcclxuICAgICAgICBmbGFnczogZmxhZ3NcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcmVwYXJlcyBhbiBvcHRpb25zIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0IHRvIGFuIG9wdGlvbnMgb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBPcHRpb25zIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHByZXBhcmVPcHRpb25zKHZhbHVlKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIGlmIChpc1R5cGUodmFsdWUsICdTdHJpbmcnKSkge1xyXG4gICAgICAgIFhSZWdFeHAuZm9yRWFjaCh2YWx1ZSwgL1teXFxzLF0rLywgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAgICAgb3B0aW9uc1ttYXRjaF0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBmbGFnIHNvIGl0IGRvZXNuJ3QgdGhyb3cgYW4gJ3Vua25vd24gZmxhZycgZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnIFNpbmdsZS1jaGFyYWN0ZXIgZmxhZyB0byByZWdpc3Rlci5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRmxhZyhmbGFnKSB7XHJcbiAgICBpZiAoIS9eW1xcdyRdJC8udGVzdChmbGFnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhZyBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3RlciBBLVphLXowLTlfJCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyZWRGbGFnc1tmbGFnXSA9IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW5zIGJ1aWx0LWluIGFuZCBjdXN0b20gcmVnZXggc3ludGF4IHRva2VucyBpbiByZXZlcnNlIGluc2VydGlvbiBvcmRlciBhdCB0aGUgc3BlY2lmaWVkXHJcbiAqIHBvc2l0aW9uLCB1bnRpbCBhIG1hdGNoIGlzIGZvdW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBPcmlnaW5hbCBwYXR0ZXJuIGZyb20gd2hpY2ggYW4gWFJlZ0V4cCBvYmplY3QgaXMgYmVpbmcgYnVpbHQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFncyBGbGFncyBiZWluZyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcmVnZXguXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgUG9zaXRpb24gdG8gc2VhcmNoIGZvciB0b2tlbnMgd2l0aGluIGBwYXR0ZXJuYC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjb3BlIFJlZ2V4IHNjb3BlIHRvIGFwcGx5OiAnZGVmYXVsdCcgb3IgJ2NsYXNzJy5cclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCBvYmplY3QgdG8gdXNlIGZvciB0b2tlbiBoYW5kbGVyIGZ1bmN0aW9ucy5cclxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggcHJvcGVydGllcyBgbWF0Y2hMZW5ndGhgLCBgb3V0cHV0YCwgYW5kIGByZXBhcnNlYDsgb3IgYG51bGxgLlxyXG4gKi9cclxuZnVuY3Rpb24gcnVuVG9rZW5zKHBhdHRlcm4sIGZsYWdzLCBwb3MsIHNjb3BlLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgaSA9IHRva2Vucy5sZW5ndGgsXHJcbiAgICAgICAgbGVhZENoYXIgPSBwYXR0ZXJuLmNoYXJBdChwb3MpLFxyXG4gICAgICAgIHJlc3VsdCA9IG51bGwsXHJcbiAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgdDtcclxuXHJcbiAgICAvLyBSdW4gaW4gcmV2ZXJzZSBpbnNlcnRpb24gb3JkZXJcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB0ID0gdG9rZW5zW2ldO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgKHQubGVhZENoYXIgJiYgdC5sZWFkQ2hhciAhPT0gbGVhZENoYXIpIHx8XHJcbiAgICAgICAgICAgICh0LnNjb3BlICE9PSBzY29wZSAmJiB0LnNjb3BlICE9PSAnYWxsJykgfHxcclxuICAgICAgICAgICAgKHQuZmxhZyAmJiBmbGFncy5pbmRleE9mKHQuZmxhZykgPT09IC0xKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hdGNoID0gWFJlZ0V4cC5leGVjKHBhdHRlcm4sIHQucmVnZXgsIHBvcywgJ3N0aWNreScpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaExlbmd0aDogbWF0Y2hbMF0ubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0OiB0LmhhbmRsZXIuY2FsbChjb250ZXh0LCBtYXRjaCwgc2NvcGUsIGZsYWdzKSxcclxuICAgICAgICAgICAgICAgIHJlcGFyc2U6IHQucmVwYXJzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBGaW5pc2hlZCB3aXRoIHRva2VuIHRlc3RzXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBpbXBsaWNpdCBhc3RyYWwgbW9kZSBvcHQtaW4uIFdoZW4gZW5hYmxlZCwgZmxhZyBBIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG9cclxuICogYWxsIG5ldyByZWdleGVzIGNyZWF0ZWQgYnkgWFJlZ0V4cC4gVGhpcyBjYXVzZXMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gY3JlYXRpbmcgcmVnZXhlcyBpZlxyXG4gKiB0aGUgVW5pY29kZSBCYXNlIGFkZG9uIGlzIG5vdCBhdmFpbGFibGUsIHNpbmNlIGZsYWcgQSBpcyByZWdpc3RlcmVkIGJ5IHRoYXQgYWRkb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb24gYHRydWVgIHRvIGVuYWJsZTsgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0QXN0cmFsKG9uKSB7XHJcbiAgICBmZWF0dXJlcy5hc3RyYWwgPSBvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgbmF0aXZlIG1ldGhvZCBvdmVycmlkZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb24gYHRydWVgIHRvIGVuYWJsZTsgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0TmF0aXZlcyhvbikge1xyXG4gICAgUmVnRXhwLnByb3RvdHlwZS5leGVjID0gKG9uID8gZml4ZWQgOiBuYXRpdikuZXhlYztcclxuICAgIFJlZ0V4cC5wcm90b3R5cGUudGVzdCA9IChvbiA/IGZpeGVkIDogbmF0aXYpLnRlc3Q7XHJcbiAgICBTdHJpbmcucHJvdG90eXBlLm1hdGNoID0gKG9uID8gZml4ZWQgOiBuYXRpdikubWF0Y2g7XHJcbiAgICBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UgPSAob24gPyBmaXhlZCA6IG5hdGl2KS5yZXBsYWNlO1xyXG4gICAgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCA9IChvbiA/IGZpeGVkIDogbmF0aXYpLnNwbGl0O1xyXG5cclxuICAgIGZlYXR1cmVzLm5hdGl2ZXMgPSBvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG9iamVjdCwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC4gVGhpcyBpcyB1c2VkIHRvIGZvbGxvd1xyXG4gKiB0aGUgRVM1IGFic3RyYWN0IG9wZXJhdGlvbiBgVG9PYmplY3RgLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9iamVjdCB0byBjaGVjayBhbmQgcmV0dXJuLlxyXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHByb3ZpZGVkIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAvLyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBudWxsIG9yIHVuZGVmaW5lZCB0byBvYmplY3QnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG4vLyBDb25zdHJ1Y3RvclxyXG4vLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGV4dGVuZGVkIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIG1hdGNoaW5nIHRleHQgd2l0aCBhIHBhdHRlcm4uIERpZmZlcnMgZnJvbSBhXHJcbiAqIG5hdGl2ZSByZWd1bGFyIGV4cHJlc3Npb24gaW4gdGhhdCBhZGRpdGlvbmFsIHN5bnRheCBhbmQgZmxhZ3MgYXJlIHN1cHBvcnRlZC4gVGhlIHJldHVybmVkIG9iamVjdFxyXG4gKiBpcyBpbiBmYWN0IGEgbmF0aXZlIGBSZWdFeHBgIGFuZCB3b3JrcyB3aXRoIGFsbCBuYXRpdmUgbWV0aG9kcy5cclxuICpcclxuICogQGNsYXNzIFhSZWdFeHBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gcGF0dGVybiBSZWdleCBwYXR0ZXJuIHN0cmluZywgb3IgYW4gZXhpc3RpbmcgcmVnZXggb2JqZWN0IHRvIGNvcHkuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdIEFueSBjb21iaW5hdGlvbiBvZiBmbGFncy5cclxuICogICBOYXRpdmUgZmxhZ3M6XHJcbiAqICAgICA8bGk+YGdgIC0gZ2xvYmFsXHJcbiAqICAgICA8bGk+YGlgIC0gaWdub3JlIGNhc2VcclxuICogICAgIDxsaT5gbWAgLSBtdWx0aWxpbmUgYW5jaG9yc1xyXG4gKiAgICAgPGxpPmB1YCAtIHVuaWNvZGUgKEVTNilcclxuICogICAgIDxsaT5geWAgLSBzdGlja3kgKEZpcmVmb3ggMyssIEVTNilcclxuICogICBBZGRpdGlvbmFsIFhSZWdFeHAgZmxhZ3M6XHJcbiAqICAgICA8bGk+YG5gIC0gZXhwbGljaXQgY2FwdHVyZVxyXG4gKiAgICAgPGxpPmBzYCAtIGRvdCBtYXRjaGVzIGFsbCAoYWthIHNpbmdsZWxpbmUpXHJcbiAqICAgICA8bGk+YHhgIC0gZnJlZS1zcGFjaW5nIGFuZCBsaW5lIGNvbW1lbnRzIChha2EgZXh0ZW5kZWQpXHJcbiAqICAgICA8bGk+YEFgIC0gYXN0cmFsIChyZXF1aXJlcyB0aGUgVW5pY29kZSBCYXNlIGFkZG9uKVxyXG4gKiAgIEZsYWdzIGNhbm5vdCBiZSBwcm92aWRlZCB3aGVuIGNvbnN0cnVjdGluZyBvbmUgYFJlZ0V4cGAgZnJvbSBhbm90aGVyLlxyXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBFeHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0LlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBXaXRoIG5hbWVkIGNhcHR1cmUgYW5kIGZsYWcgeFxyXG4gKiBYUmVnRXhwKCcoPzx5ZWFyPiAgWzAtOV17NH0gKSAtPyAgIyB5ZWFyICBcXG5cXFxyXG4gKiAgICAgICAgICAoPzxtb250aD4gWzAtOV17Mn0gKSAtPyAgIyBtb250aCBcXG5cXFxyXG4gKiAgICAgICAgICAoPzxkYXk+ICAgWzAtOV17Mn0gKSAgICAgIyBkYXkgICAnLCAneCcpO1xyXG4gKlxyXG4gKiAvLyBQcm92aWRpbmcgYSByZWdleCBvYmplY3QgY29waWVzIGl0LiBOYXRpdmUgcmVnZXhlcyBhcmUgcmVjb21waWxlZCB1c2luZyBuYXRpdmUgKG5vdCBYUmVnRXhwKVxyXG4gKiAvLyBzeW50YXguIENvcGllcyBtYWludGFpbiBleHRlbmRlZCBkYXRhLCBhcmUgYXVnbWVudGVkIHdpdGggYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLCBhbmRcclxuICogLy8gaGF2ZSBmcmVzaCBgbGFzdEluZGV4YCBwcm9wZXJ0aWVzIChzZXQgdG8gemVybykuXHJcbiAqIFhSZWdFeHAoL3JlZ2V4Lyk7XHJcbiAqL1xyXG5mdW5jdGlvbiBYUmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XHJcbiAgICBpZiAoWFJlZ0V4cC5pc1JlZ0V4cChwYXR0ZXJuKSkge1xyXG4gICAgICAgIGlmIChmbGFncyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzdXBwbHkgZmxhZ3Mgd2hlbiBjb3B5aW5nIGEgUmVnRXhwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3B5UmVnZXgocGF0dGVybik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29weSB0aGUgYXJndW1lbnQgYmVoYXZpb3Igb2YgYFJlZ0V4cGBcclxuICAgIHBhdHRlcm4gPSBwYXR0ZXJuID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhwYXR0ZXJuKTtcclxuICAgIGZsYWdzID0gZmxhZ3MgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKGZsYWdzKTtcclxuXHJcbiAgICBpZiAoWFJlZ0V4cC5pc0luc3RhbGxlZCgnYXN0cmFsJykgJiYgZmxhZ3MuaW5kZXhPZignQScpID09PSAtMSkge1xyXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzIGFuIGVycm9yIHRvIGJlIHRocm93biBpZiB0aGUgVW5pY29kZSBCYXNlIGFkZG9uIGlzIG5vdCBhdmFpbGFibGVcclxuICAgICAgICBmbGFncyArPSAnQSc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFwYXR0ZXJuQ2FjaGVbcGF0dGVybl0pIHtcclxuICAgICAgICBwYXR0ZXJuQ2FjaGVbcGF0dGVybl0gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBhdHRlcm5DYWNoZVtwYXR0ZXJuXVtmbGFnc10pIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgaGFzTmFtZWRDYXB0dXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgY2FwdHVyZU5hbWVzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNjb3BlID0gZGVmYXVsdFNjb3BlO1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSAnJztcclxuICAgICAgICB2YXIgcG9zID0gMDtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgZmxhZy1yZWxhdGVkIGVycm9ycywgYW5kIHN0cmlwL2FwcGx5IGZsYWdzIGluIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyXHJcbiAgICAgICAgdmFyIGFwcGxpZWQgPSBwcmVwYXJlRmxhZ3MocGF0dGVybiwgZmxhZ3MpO1xyXG4gICAgICAgIHZhciBhcHBsaWVkUGF0dGVybiA9IGFwcGxpZWQucGF0dGVybjtcclxuICAgICAgICB2YXIgYXBwbGllZEZsYWdzID0gYXBwbGllZC5mbGFncztcclxuXHJcbiAgICAgICAgLy8gVXNlIFhSZWdFeHAncyB0b2tlbnMgdG8gdHJhbnNsYXRlIHRoZSBwYXR0ZXJuIHRvIGEgbmF0aXZlIHJlZ2V4IHBhdHRlcm4uXHJcbiAgICAgICAgLy8gYGFwcGxpZWRQYXR0ZXJuLmxlbmd0aGAgbWF5IGNoYW5nZSBvbiBlYWNoIGl0ZXJhdGlvbiBpZiB0b2tlbnMgdXNlIGByZXBhcnNlYFxyXG4gICAgICAgIHdoaWxlIChwb3MgPCBhcHBsaWVkUGF0dGVybi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN1c3RvbSB0b2tlbnMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJ1blRva2VucyhhcHBsaWVkUGF0dGVybiwgYXBwbGllZEZsYWdzLCBwb3MsIHNjb3BlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtYXRjaGVkIHRva2VuIHVzZWQgdGhlIGByZXBhcnNlYCBvcHRpb24sIHNwbGljZSBpdHMgb3V0cHV0IGludG8gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBwYXR0ZXJuIGJlZm9yZSBydW5uaW5nIHRva2VucyBhZ2FpbiBhdCB0aGUgc2FtZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQucmVwYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRQYXR0ZXJuID0gYXBwbGllZFBhdHRlcm4uc2xpY2UoMCwgcG9zKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5vdXRwdXQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkUGF0dGVybi5zbGljZShwb3MgKyByZXN1bHQubWF0Y2hMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChyZXN1bHQgJiYgcmVzdWx0LnJlcGFyc2UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHJlc3VsdC5vdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gKHJlc3VsdC5tYXRjaExlbmd0aCB8fCAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmF0aXZlIHRva2VuIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBYUmVnRXhwLmV4ZWMoYXBwbGllZFBhdHRlcm4sIG5hdGl2ZVRva2Vuc1tzY29wZV0sIHBvcywgJ3N0aWNreScpWzBdO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IHRva2VuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ1snICYmIHNjb3BlID09PSBkZWZhdWx0U2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IGNsYXNzU2NvcGU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnXScgJiYgc2NvcGUgPT09IGNsYXNzU2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IGRlZmF1bHRTY29wZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGF0dGVybkNhY2hlW3BhdHRlcm5dW2ZsYWdzXSA9IHtcclxuICAgICAgICAgICAgLy8gVXNlIGJhc2ljIGNsZWFudXAgdG8gY29sbGFwc2UgcmVwZWF0ZWQgZW1wdHkgZ3JvdXBzIGxpa2UgYCg/OikoPzopYCB0byBgKD86KWAuIEVtcHR5XHJcbiAgICAgICAgICAgIC8vIGdyb3VwcyBhcmUgc29tZXRpbWVzIGluc2VydGVkIGR1cmluZyByZWdleCB0cmFuc3BpbGF0aW9uIGluIG9yZGVyIHRvIGtlZXAgdG9rZW5zXHJcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlZC4gSG93ZXZlciwgbW9yZSB0aGFuIG9uZSBlbXB0eSBncm91cCBpbiBhIHJvdyBpcyBuZXZlciBuZWVkZWQuXHJcbiAgICAgICAgICAgIHBhdHRlcm46IG5hdGl2LnJlcGxhY2UuY2FsbChvdXRwdXQsIC8oPzpcXChcXD86XFwpKSsvZywgJyg/OiknKSxcclxuICAgICAgICAgICAgLy8gU3RyaXAgYWxsIGJ1dCBuYXRpdmUgZmxhZ3NcclxuICAgICAgICAgICAgZmxhZ3M6IG5hdGl2LnJlcGxhY2UuY2FsbChhcHBsaWVkRmxhZ3MsIC9bXmdpbXV5XSsvZywgJycpLFxyXG4gICAgICAgICAgICAvLyBgY29udGV4dC5jYXB0dXJlTmFtZXNgIGhhcyBhbiBpdGVtIGZvciBlYWNoIGNhcHR1cmluZyBncm91cCwgZXZlbiBpZiB1bm5hbWVkXHJcbiAgICAgICAgICAgIGNhcHR1cmVzOiBjb250ZXh0Lmhhc05hbWVkQ2FwdHVyZSA/IGNvbnRleHQuY2FwdHVyZU5hbWVzIDogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdlbmVyYXRlZCA9IHBhdHRlcm5DYWNoZVtwYXR0ZXJuXVtmbGFnc107XHJcbiAgICByZXR1cm4gYXVnbWVudChcclxuICAgICAgICBuZXcgUmVnRXhwKGdlbmVyYXRlZC5wYXR0ZXJuLCBnZW5lcmF0ZWQuZmxhZ3MpLFxyXG4gICAgICAgIGdlbmVyYXRlZC5jYXB0dXJlcyxcclxuICAgICAgICBwYXR0ZXJuLFxyXG4gICAgICAgIGZsYWdzXHJcbiAgICApO1xyXG59XHJcblxyXG4vLyBBZGQgYFJlZ0V4cC5wcm90b3R5cGVgIHRvIHRoZSBwcm90b3R5cGUgY2hhaW5cclxuWFJlZ0V4cC5wcm90b3R5cGUgPSBuZXcgUmVnRXhwKCk7XHJcblxyXG4vLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuLy8gUHVibGljIHByb3BlcnRpZXNcclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcblxyXG4vKipcclxuICogVGhlIFhSZWdFeHAgdmVyc2lvbiBudW1iZXIgYXMgYSBzdHJpbmcgY29udGFpbmluZyB0aHJlZSBkb3Qtc2VwYXJhdGVkIHBhcnRzLiBGb3IgZXhhbXBsZSxcclxuICogJzIuMC4wLWJldGEtMycuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHR5cGUgU3RyaW5nXHJcbiAqL1xyXG5YUmVnRXhwLnZlcnNpb24gPSAnMy4xLjEnO1xyXG5cclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcbi8vIFB1YmxpYyBtZXRob2RzXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG5cclxuLy8gSW50ZW50aW9uYWxseSB1bmRvY3VtZW50ZWQ7IHVzZWQgaW4gdGVzdHMgYW5kIGFkZG9uc1xyXG5YUmVnRXhwLl9oYXNOYXRpdmVGbGFnID0gaGFzTmF0aXZlRmxhZztcclxuWFJlZ0V4cC5fZGVjID0gZGVjO1xyXG5YUmVnRXhwLl9oZXggPSBoZXg7XHJcblhSZWdFeHAuX3BhZDQgPSBwYWQ0O1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuZHMgWFJlZ0V4cCBzeW50YXggYW5kIGFsbG93cyBjdXN0b20gZmxhZ3MuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGFuZCBjYW4gYmUgdXNlZCB0b1xyXG4gKiBjcmVhdGUgWFJlZ0V4cCBhZGRvbnMuIElmIG1vcmUgdGhhbiBvbmUgdG9rZW4gY2FuIG1hdGNoIHRoZSBzYW1lIHN0cmluZywgdGhlIGxhc3QgYWRkZWQgd2lucy5cclxuICpcclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIG5ldyB0b2tlbi5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBuZXcgcGF0dGVybiBzdHJpbmcgKHVzaW5nIG5hdGl2ZSByZWdleCBzeW50YXgpXHJcbiAqICAgdG8gcmVwbGFjZSB0aGUgbWF0Y2hlZCB0b2tlbiB3aXRoaW4gYWxsIGZ1dHVyZSBYUmVnRXhwIHJlZ2V4ZXMuIEhhcyBhY2Nlc3MgdG8gcGVyc2lzdGVudFxyXG4gKiAgIHByb3BlcnRpZXMgb2YgdGhlIHJlZ2V4IGJlaW5nIGJ1aWx0LCB0aHJvdWdoIGB0aGlzYC4gSW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcclxuICogICA8bGk+VGhlIG1hdGNoIGFycmF5LCB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcy5cclxuICogICA8bGk+VGhlIHJlZ2V4IHNjb3BlIHdoZXJlIHRoZSBtYXRjaCB3YXMgZm91bmQ6ICdkZWZhdWx0JyBvciAnY2xhc3MnLlxyXG4gKiAgIDxsaT5UaGUgZmxhZ3MgdXNlZCBieSB0aGUgcmVnZXgsIGluY2x1ZGluZyBhbnkgZmxhZ3MgaW4gYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIuXHJcbiAqICAgVGhlIGhhbmRsZXIgZnVuY3Rpb24gYmVjb21lcyBwYXJ0IG9mIHRoZSBYUmVnRXhwIGNvbnN0cnVjdGlvbiBwcm9jZXNzLCBzbyBiZSBjYXJlZnVsIG5vdCB0b1xyXG4gKiAgIGNvbnN0cnVjdCBYUmVnRXhwcyB3aXRoaW4gdGhlIGZ1bmN0aW9uIG9yIHlvdSB3aWxsIHRyaWdnZXIgaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllczpcclxuICogICA8bGk+YHNjb3BlYCB7U3RyaW5nfSBTY29wZSB3aGVyZSB0aGUgdG9rZW4gYXBwbGllczogJ2RlZmF1bHQnLCAnY2xhc3MnLCBvciAnYWxsJy5cclxuICogICA8bGk+YGZsYWdgIHtTdHJpbmd9IFNpbmdsZS1jaGFyYWN0ZXIgZmxhZyB0aGF0IHRyaWdnZXJzIHRoZSB0b2tlbi4gVGhpcyBhbHNvIHJlZ2lzdGVycyB0aGVcclxuICogICAgIGZsYWcsIHdoaWNoIHByZXZlbnRzIFhSZWdFeHAgZnJvbSB0aHJvd2luZyBhbiAndW5rbm93biBmbGFnJyBlcnJvciB3aGVuIHRoZSBmbGFnIGlzIHVzZWQuXHJcbiAqICAgPGxpPmBvcHRpb25hbEZsYWdzYCB7U3RyaW5nfSBBbnkgY3VzdG9tIGZsYWdzIGNoZWNrZWQgZm9yIHdpdGhpbiB0aGUgdG9rZW4gYGhhbmRsZXJgIHRoYXQgYXJlXHJcbiAqICAgICBub3QgcmVxdWlyZWQgdG8gdHJpZ2dlciB0aGUgdG9rZW4uIFRoaXMgcmVnaXN0ZXJzIHRoZSBmbGFncywgdG8gcHJldmVudCBYUmVnRXhwIGZyb21cclxuICogICAgIHRocm93aW5nIGFuICd1bmtub3duIGZsYWcnIGVycm9yIHdoZW4gYW55IG9mIHRoZSBmbGFncyBhcmUgdXNlZC5cclxuICogICA8bGk+YHJlcGFyc2VgIHtCb29sZWFufSBXaGV0aGVyIHRoZSBgaGFuZGxlcmAgZnVuY3Rpb24ncyBvdXRwdXQgc2hvdWxkIG5vdCBiZSB0cmVhdGVkIGFzXHJcbiAqICAgICBmaW5hbCwgYW5kIGluc3RlYWQgYmUgcmVwYXJzZWFibGUgYnkgb3RoZXIgdG9rZW5zIChpbmNsdWRpbmcgdGhlIGN1cnJlbnQgdG9rZW4pLiBBbGxvd3NcclxuICogICAgIHRva2VuIGNoYWluaW5nIG9yIGRlZmVycmluZy5cclxuICogICA8bGk+YGxlYWRDaGFyYCB7U3RyaW5nfSBTaW5nbGUgY2hhcmFjdGVyIHRoYXQgb2NjdXJzIGF0IHRoZSBiZWdpbm5pbmcgb2YgYW55IHN1Y2Nlc3NmdWwgbWF0Y2hcclxuICogICAgIG9mIHRoZSB0b2tlbiAobm90IGFsd2F5cyBhcHBsaWNhYmxlKS4gVGhpcyBkb2Vzbid0IGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHRva2VuIHVubGVzc1xyXG4gKiAgICAgeW91IHByb3ZpZGUgYW4gZXJyb25lb3VzIHZhbHVlLiBIb3dldmVyLCBwcm92aWRpbmcgaXQgY2FuIGluY3JlYXNlIHRoZSB0b2tlbidzIHBlcmZvcm1hbmNlXHJcbiAqICAgICBzaW5jZSB0aGUgdG9rZW4gY2FuIGJlIHNraXBwZWQgYXQgYW55IHBvc2l0aW9ucyB3aGVyZSB0aGlzIGNoYXJhY3RlciBkb2Vzbid0IGFwcGVhci5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQmFzaWMgdXNhZ2U6IEFkZCBcXGEgZm9yIHRoZSBBTEVSVCBjb250cm9sIGNvZGVcclxuICogWFJlZ0V4cC5hZGRUb2tlbihcclxuICogICAvXFxcXGEvLFxyXG4gKiAgIGZ1bmN0aW9uKCkge3JldHVybiAnXFxcXHgwNyc7fSxcclxuICogICB7c2NvcGU6ICdhbGwnfVxyXG4gKiApO1xyXG4gKiBYUmVnRXhwKCdcXFxcYVtcXFxcYS1cXFxcbl0rJykudGVzdCgnXFx4MDdcXG5cXHgwNycpOyAvLyAtPiB0cnVlXHJcbiAqXHJcbiAqIC8vIEFkZCB0aGUgVSAodW5ncmVlZHkpIGZsYWcgZnJvbSBQQ1JFIGFuZCBSRTIsIHdoaWNoIHJldmVyc2VzIGdyZWVkeSBhbmQgbGF6eSBxdWFudGlmaWVycy5cclxuICogLy8gU2luY2UgYHNjb3BlYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCB1c2VzICdkZWZhdWx0JyAoaS5lLiwgdHJhbnNmb3JtYXRpb25zIGFwcGx5IG91dHNpZGUgb2ZcclxuICogLy8gY2hhcmFjdGVyIGNsYXNzZXMgb25seSlcclxuICogWFJlZ0V4cC5hZGRUb2tlbihcclxuICogICAvKFs/KitdfHtcXGQrKD86LFxcZCopP30pKFxcPz8pLyxcclxuICogICBmdW5jdGlvbihtYXRjaCkge3JldHVybiBtYXRjaFsxXSArIChtYXRjaFsyXSA/ICcnIDogJz8nKTt9LFxyXG4gKiAgIHtmbGFnOiAnVSd9XHJcbiAqICk7XHJcbiAqIFhSZWdFeHAoJ2ErJywgJ1UnKS5leGVjKCdhYWEnKVswXTsgLy8gLT4gJ2EnXHJcbiAqIFhSZWdFeHAoJ2ErPycsICdVJykuZXhlYygnYWFhJylbMF07IC8vIC0+ICdhYWEnXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuID0gZnVuY3Rpb24ocmVnZXgsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIG9wdGlvbmFsRmxhZ3MgPSBvcHRpb25zLm9wdGlvbmFsRmxhZ3MsIGk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuZmxhZykge1xyXG4gICAgICAgIHJlZ2lzdGVyRmxhZyhvcHRpb25zLmZsYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25hbEZsYWdzKSB7XHJcbiAgICAgICAgb3B0aW9uYWxGbGFncyA9IG5hdGl2LnNwbGl0LmNhbGwob3B0aW9uYWxGbGFncywgJycpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25hbEZsYWdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyRmxhZyhvcHRpb25hbEZsYWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHRvIHRoZSBwcml2YXRlIGxpc3Qgb2Ygc3ludGF4IHRva2Vuc1xyXG4gICAgdG9rZW5zLnB1c2goe1xyXG4gICAgICAgIHJlZ2V4OiBjb3B5UmVnZXgocmVnZXgsIHtcclxuICAgICAgICAgICAgYWRkRzogdHJ1ZSxcclxuICAgICAgICAgICAgYWRkWTogaGFzTmF0aXZlWSxcclxuICAgICAgICAgICAgaXNJbnRlcm5hbE9ubHk6IHRydWVcclxuICAgICAgICB9KSxcclxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxyXG4gICAgICAgIHNjb3BlOiBvcHRpb25zLnNjb3BlIHx8IGRlZmF1bHRTY29wZSxcclxuICAgICAgICBmbGFnOiBvcHRpb25zLmZsYWcsXHJcbiAgICAgICAgcmVwYXJzZTogb3B0aW9ucy5yZXBhcnNlLFxyXG4gICAgICAgIGxlYWRDaGFyOiBvcHRpb25zLmxlYWRDaGFyXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZXNldCB0aGUgcGF0dGVybiBjYWNoZSB1c2VkIGJ5IHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3IsIHNpbmNlIHRoZSBzYW1lIHBhdHRlcm4gYW5kIGZsYWdzXHJcbiAgICAvLyBtaWdodCBub3cgcHJvZHVjZSBkaWZmZXJlbnQgcmVzdWx0c1xyXG4gICAgWFJlZ0V4cC5jYWNoZS5mbHVzaCgncGF0dGVybnMnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWNoZXMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBYUmVnRXhwKHBhdHRlcm4sIGZsYWdzKWAuIE9uIGFueSBzdWJzZXF1ZW50IGNhbGwgd2l0aFxyXG4gKiB0aGUgc2FtZSBwYXR0ZXJuIGFuZCBmbGFnIGNvbWJpbmF0aW9uLCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIHJlZ2V4IGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBSZWdleCBwYXR0ZXJuIHN0cmluZy5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtmbGFnc10gQW55IGNvbWJpbmF0aW9uIG9mIFhSZWdFeHAgZmxhZ3MuXHJcbiAqIEByZXR1cm5zIHtSZWdFeHB9IENhY2hlZCBYUmVnRXhwIG9iamVjdC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogd2hpbGUgKG1hdGNoID0gWFJlZ0V4cC5jYWNoZSgnLicsICdncycpLmV4ZWMoc3RyKSkge1xyXG4gKiAgIC8vIFRoZSByZWdleCBpcyBjb21waWxlZCBvbmNlIG9ubHlcclxuICogfVxyXG4gKi9cclxuWFJlZ0V4cC5jYWNoZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIGZsYWdzKSB7XHJcbiAgICBpZiAoIXJlZ2V4Q2FjaGVbcGF0dGVybl0pIHtcclxuICAgICAgICByZWdleENhY2hlW3BhdHRlcm5dID0ge307XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVnZXhDYWNoZVtwYXR0ZXJuXVtmbGFnc10gfHwgKFxyXG4gICAgICAgIHJlZ2V4Q2FjaGVbcGF0dGVybl1bZmxhZ3NdID0gWFJlZ0V4cChwYXR0ZXJuLCBmbGFncylcclxuICAgICk7XHJcbn07XHJcblxyXG4vLyBJbnRlbnRpb25hbGx5IHVuZG9jdW1lbnRlZDsgdXNlZCBpbiB0ZXN0c1xyXG5YUmVnRXhwLmNhY2hlLmZsdXNoID0gZnVuY3Rpb24oY2FjaGVOYW1lKSB7XHJcbiAgICBpZiAoY2FjaGVOYW1lID09PSAncGF0dGVybnMnKSB7XHJcbiAgICAgICAgLy8gRmx1c2ggdGhlIHBhdHRlcm4gY2FjaGUgdXNlZCBieSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgcGF0dGVybkNhY2hlID0ge307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZsdXNoIHRoZSByZWdleCBjYWNoZSBwb3B1bGF0ZWQgYnkgYFhSZWdFeHAuY2FjaGVgXHJcbiAgICAgICAgcmVnZXhDYWNoZSA9IHt9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVzY2FwZXMgYW55IHJlZ3VsYXIgZXhwcmVzc2lvbiBtZXRhY2hhcmFjdGVycywgZm9yIHVzZSB3aGVuIG1hdGNoaW5nIGxpdGVyYWwgc3RyaW5ncy4gVGhlIHJlc3VsdFxyXG4gKiBjYW4gc2FmZWx5IGJlIHVzZWQgYXQgYW55IHBvaW50IHdpdGhpbiBhIHJlZ2V4IHRoYXQgdXNlcyBhbnkgZmxhZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIGVzY2FwZS5cclxuICogQHJldHVybnMge1N0cmluZ30gU3RyaW5nIHdpdGggcmVnZXggbWV0YWNoYXJhY3RlcnMgZXNjYXBlZC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogWFJlZ0V4cC5lc2NhcGUoJ0VzY2FwZWQ/IDwuPicpO1xyXG4gKiAvLyAtPiAnRXNjYXBlZFxcP1xcIDxcXC4+J1xyXG4gKi9cclxuWFJlZ0V4cC5lc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuYXRpdi5yZXBsYWNlLmNhbGwodG9PYmplY3Qoc3RyKSwgL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhlY3V0ZXMgYSByZWdleCBzZWFyY2ggaW4gYSBzcGVjaWZpZWQgc3RyaW5nLiBSZXR1cm5zIGEgbWF0Y2ggYXJyYXkgb3IgYG51bGxgLiBJZiB0aGUgcHJvdmlkZWRcclxuICogcmVnZXggdXNlcyBuYW1lZCBjYXB0dXJlLCBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMgYXJlIGluY2x1ZGVkIG9uIHRoZSBtYXRjaCBhcnJheS5cclxuICogT3B0aW9uYWwgYHBvc2AgYW5kIGBzdGlja3lgIGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSBzZWFyY2ggc3RhcnQgcG9zaXRpb24sIGFuZCB3aGV0aGVyIHRoZSBtYXRjaFxyXG4gKiBtdXN0IHN0YXJ0IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb25seS4gVGhlIGBsYXN0SW5kZXhgIHByb3BlcnR5IG9mIHRoZSBwcm92aWRlZCByZWdleCBpcyBub3RcclxuICogdXNlZCwgYnV0IGlzIHVwZGF0ZWQgZm9yIGNvbXBhdGliaWxpdHkuIEFsc28gZml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmVcclxuICogYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5IGNyb3NzLWJyb3dzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIHNlYXJjaCB3aXRoLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvcz0wXSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2guXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtzdGlja3k9ZmFsc2VdIFdoZXRoZXIgdGhlIG1hdGNoIG11c3Qgc3RhcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gKiAgIG9ubHkuIFRoZSBzdHJpbmcgYCdzdGlja3knYCBpcyBhY2NlcHRlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBgdHJ1ZWAuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gTWF0Y2ggYXJyYXkgd2l0aCBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMsIG9yIGBudWxsYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQmFzaWMgdXNlLCB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2VcclxuICogdmFyIG1hdGNoID0gWFJlZ0V4cC5leGVjKCdVKzI2MjAnLCBYUmVnRXhwKCdVXFxcXCsoPzxoZXg+WzAtOUEtRl17NH0pJykpO1xyXG4gKiBtYXRjaC5oZXg7IC8vIC0+ICcyNjIwJ1xyXG4gKlxyXG4gKiAvLyBXaXRoIHBvcyBhbmQgc3RpY2t5LCBpbiBhIGxvb3BcclxuICogdmFyIHBvcyA9IDIsIHJlc3VsdCA9IFtdLCBtYXRjaDtcclxuICogd2hpbGUgKG1hdGNoID0gWFJlZ0V4cC5leGVjKCc8MT48Mj48Mz48ND41PDY+JywgLzwoXFxkKT4vLCBwb3MsICdzdGlja3knKSkge1xyXG4gKiAgIHJlc3VsdC5wdXNoKG1hdGNoWzFdKTtcclxuICogICBwb3MgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcclxuICogfVxyXG4gKiAvLyByZXN1bHQgLT4gWycyJywgJzMnLCAnNCddXHJcbiAqL1xyXG5YUmVnRXhwLmV4ZWMgPSBmdW5jdGlvbihzdHIsIHJlZ2V4LCBwb3MsIHN0aWNreSkge1xyXG4gICAgdmFyIGNhY2hlS2V5ID0gJ2cnLFxyXG4gICAgICAgIGFkZFkgPSBmYWxzZSxcclxuICAgICAgICBtYXRjaCxcclxuICAgICAgICByMjtcclxuXHJcbiAgICBhZGRZID0gaGFzTmF0aXZlWSAmJiAhIShzdGlja3kgfHwgKHJlZ2V4LnN0aWNreSAmJiBzdGlja3kgIT09IGZhbHNlKSk7XHJcbiAgICBpZiAoYWRkWSkge1xyXG4gICAgICAgIGNhY2hlS2V5ICs9ICd5JztcclxuICAgIH1cclxuXHJcbiAgICByZWdleFtSRUdFWF9EQVRBXSA9IHJlZ2V4W1JFR0VYX0RBVEFdIHx8IHt9O1xyXG5cclxuICAgIC8vIFNoYXJlcyBjYWNoZWQgY29waWVzIHdpdGggYFhSZWdFeHAubWF0Y2hgL2ByZXBsYWNlYFxyXG4gICAgcjIgPSByZWdleFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gfHwgKFxyXG4gICAgICAgIHJlZ2V4W1JFR0VYX0RBVEFdW2NhY2hlS2V5XSA9IGNvcHlSZWdleChyZWdleCwge1xyXG4gICAgICAgICAgICBhZGRHOiB0cnVlLFxyXG4gICAgICAgICAgICBhZGRZOiBhZGRZLFxyXG4gICAgICAgICAgICByZW1vdmVZOiBzdGlja3kgPT09IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0ludGVybmFsT25seTogdHJ1ZVxyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIHIyLmxhc3RJbmRleCA9IHBvcyA9IHBvcyB8fCAwO1xyXG5cclxuICAgIC8vIEZpeGVkIGBleGVjYCByZXF1aXJlZCBmb3IgYGxhc3RJbmRleGAgZml4LCBuYW1lZCBiYWNrcmVmZXJlbmNlcywgZXRjLlxyXG4gICAgbWF0Y2ggPSBmaXhlZC5leGVjLmNhbGwocjIsIHN0cik7XHJcblxyXG4gICAgaWYgKHN0aWNreSAmJiBtYXRjaCAmJiBtYXRjaC5pbmRleCAhPT0gcG9zKSB7XHJcbiAgICAgICAgbWF0Y2ggPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZWdleC5nbG9iYWwpIHtcclxuICAgICAgICByZWdleC5sYXN0SW5kZXggPSBtYXRjaCA/IHIyLmxhc3RJbmRleCA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1hdGNoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgcmVnZXggbWF0Y2guIFNlYXJjaGVzIGFsd2F5cyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxyXG4gKiBzdHJpbmcgYW5kIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mIHRoZSByZWdleCdzIGBnbG9iYWxgIHByb3BlcnR5IGFuZFxyXG4gKiBpbml0aWFsIGBsYXN0SW5kZXhgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBzZWFyY2ggd2l0aC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBtYXRjaC4gSW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxyXG4gKiAgIDxsaT5UaGUgbWF0Y2ggYXJyYXksIHdpdGggbmFtZWQgYmFja3JlZmVyZW5jZSBwcm9wZXJ0aWVzLlxyXG4gKiAgIDxsaT5UaGUgemVyby1iYXNlZCBtYXRjaCBpbmRleC5cclxuICogICA8bGk+VGhlIHN0cmluZyBiZWluZyB0cmF2ZXJzZWQuXHJcbiAqICAgPGxpPlRoZSByZWdleCBvYmplY3QgYmVpbmcgdXNlZCB0byB0cmF2ZXJzZSB0aGUgc3RyaW5nLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBFeHRyYWN0cyBldmVyeSBvdGhlciBkaWdpdCBmcm9tIGEgc3RyaW5nXHJcbiAqIHZhciBldmVucyA9IFtdO1xyXG4gKiBYUmVnRXhwLmZvckVhY2goJzFhMjM0NScsIC9cXGQvLCBmdW5jdGlvbihtYXRjaCwgaSkge1xyXG4gKiAgIGlmIChpICUgMikgZXZlbnMucHVzaCgrbWF0Y2hbMF0pO1xyXG4gKiB9KTtcclxuICogLy8gZXZlbnMgLT4gWzIsIDRdXHJcbiAqL1xyXG5YUmVnRXhwLmZvckVhY2ggPSBmdW5jdGlvbihzdHIsIHJlZ2V4LCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHBvcyA9IDAsXHJcbiAgICAgICAgaSA9IC0xLFxyXG4gICAgICAgIG1hdGNoO1xyXG5cclxuICAgIHdoaWxlICgobWF0Y2ggPSBYUmVnRXhwLmV4ZWMoc3RyLCByZWdleCwgcG9zKSkpIHtcclxuICAgICAgICAvLyBCZWNhdXNlIGByZWdleGAgaXMgcHJvdmlkZWQgdG8gYGNhbGxiYWNrYCwgdGhlIGZ1bmN0aW9uIGNvdWxkIHVzZSB0aGUgZGVwcmVjYXRlZC9cclxuICAgICAgICAvLyBub25zdGFuZGFyZCBgUmVnRXhwLnByb3RvdHlwZS5jb21waWxlYCB0byBtdXRhdGUgdGhlIHJlZ2V4LiBIb3dldmVyLCBzaW5jZSBgWFJlZ0V4cC5leGVjYFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgdXNlIGBsYXN0SW5kZXhgIHRvIHNldCB0aGUgc2VhcmNoIHBvc2l0aW9uLCB0aGlzIGNhbid0IGxlYWQgdG8gYW4gaW5maW5pdGUgbG9vcCxcclxuICAgICAgICAvLyBhdCBsZWFzdC4gQWN0dWFsbHksIGJlY2F1c2Ugb2YgdGhlIHdheSBgWFJlZ0V4cC5leGVjYCBjYWNoZXMgZ2xvYmFsaXplZCB2ZXJzaW9ucyBvZlxyXG4gICAgICAgIC8vIHJlZ2V4ZXMsIG11dGF0aW5nIHRoZSByZWdleCB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGl0ZXJhdGlvbiBvciBtYXRjaGVkIHN0cmluZ3MsXHJcbiAgICAgICAgLy8gd2hpY2ggaXMgYSBuaWNlIHNpZGUgZWZmZWN0IHRoYXQgYnJpbmdzIGV4dHJhIHNhZmV0eS5cclxuICAgICAgICBjYWxsYmFjayhtYXRjaCwgKytpLCBzdHIsIHJlZ2V4KTtcclxuXHJcbiAgICAgICAgcG9zID0gbWF0Y2guaW5kZXggKyAobWF0Y2hbMF0ubGVuZ3RoIHx8IDEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcGllcyBhIHJlZ2V4IG9iamVjdCBhbmQgYWRkcyBmbGFnIGBnYC4gVGhlIGNvcHkgbWFpbnRhaW5zIGV4dGVuZGVkIGRhdGEsIGlzIGF1Z21lbnRlZCB3aXRoXHJcbiAqIGBYUmVnRXhwLnByb3RvdHlwZWAgcHJvcGVydGllcywgYW5kIGhhcyBhIGZyZXNoIGBsYXN0SW5kZXhgIHByb3BlcnR5IChzZXQgdG8gemVybykuIE5hdGl2ZVxyXG4gKiByZWdleGVzIGFyZSBub3QgcmVjb21waWxlZCB1c2luZyBYUmVnRXhwIHN5bnRheC5cclxuICpcclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIGdsb2JhbGl6ZS5cclxuICogQHJldHVybnMge1JlZ0V4cH0gQ29weSBvZiB0aGUgcHJvdmlkZWQgcmVnZXggd2l0aCBmbGFnIGBnYCBhZGRlZC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogdmFyIGdsb2JhbENvcHkgPSBYUmVnRXhwLmdsb2JhbGl6ZSgvcmVnZXgvKTtcclxuICogZ2xvYmFsQ29weS5nbG9iYWw7IC8vIC0+IHRydWVcclxuICovXHJcblhSZWdFeHAuZ2xvYmFsaXplID0gZnVuY3Rpb24ocmVnZXgpIHtcclxuICAgIHJldHVybiBjb3B5UmVnZXgocmVnZXgsIHthZGRHOiB0cnVlfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zdGFsbHMgb3B0aW9uYWwgZmVhdHVyZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy4gQ2FuIGJlIHVuZG9uZSB1c2luZ1xyXG4gKiBgWFJlZ0V4cC51bmluc3RhbGxgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3Qgb3Igc3RyaW5nLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBXaXRoIGFuIG9wdGlvbnMgb2JqZWN0XHJcbiAqIFhSZWdFeHAuaW5zdGFsbCh7XHJcbiAqICAgLy8gRW5hYmxlcyBzdXBwb3J0IGZvciBhc3RyYWwgY29kZSBwb2ludHMgaW4gVW5pY29kZSBhZGRvbnMgKGltcGxpY2l0bHkgc2V0cyBmbGFnIEEpXHJcbiAqICAgYXN0cmFsOiB0cnVlLFxyXG4gKlxyXG4gKiAgIC8vIERFUFJFQ0FURUQ6IE92ZXJyaWRlcyBuYXRpdmUgcmVnZXggbWV0aG9kcyB3aXRoIGZpeGVkL2V4dGVuZGVkIHZlcnNpb25zXHJcbiAqICAgbmF0aXZlczogdHJ1ZVxyXG4gKiB9KTtcclxuICpcclxuICogLy8gV2l0aCBhbiBvcHRpb25zIHN0cmluZ1xyXG4gKiBYUmVnRXhwLmluc3RhbGwoJ2FzdHJhbCBuYXRpdmVzJyk7XHJcbiAqL1xyXG5YUmVnRXhwLmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gcHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKCFmZWF0dXJlcy5hc3RyYWwgJiYgb3B0aW9ucy5hc3RyYWwpIHtcclxuICAgICAgICBzZXRBc3RyYWwodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFmZWF0dXJlcy5uYXRpdmVzICYmIG9wdGlvbnMubmF0aXZlcykge1xyXG4gICAgICAgIHNldE5hdGl2ZXModHJ1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYW4gaW5kaXZpZHVhbCBvcHRpb25hbCBmZWF0dXJlIGlzIGluc3RhbGxlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGZlYXR1cmUgTmFtZSBvZiB0aGUgZmVhdHVyZSB0byBjaGVjay4gT25lIG9mOlxyXG4gKiAgIDxsaT5gYXN0cmFsYFxyXG4gKiAgIDxsaT5gbmF0aXZlc2BcclxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGZlYXR1cmUgaXMgaW5zdGFsbGVkLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBYUmVnRXhwLmlzSW5zdGFsbGVkKCdhc3RyYWwnKTtcclxuICovXHJcblhSZWdFeHAuaXNJbnN0YWxsZWQgPSBmdW5jdGlvbihmZWF0dXJlKSB7XHJcbiAgICByZXR1cm4gISEoZmVhdHVyZXNbZmVhdHVyZV0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYHRydWVgIGlmIGFuIG9iamVjdCBpcyBhIHJlZ2V4OyBgZmFsc2VgIGlmIGl0IGlzbid0LiBUaGlzIHdvcmtzIGNvcnJlY3RseSBmb3IgcmVnZXhlc1xyXG4gKiBjcmVhdGVkIGluIGFub3RoZXIgZnJhbWUsIHdoZW4gYGluc3RhbmNlb2ZgIGFuZCBgY29uc3RydWN0b3JgIGNoZWNrcyB3b3VsZCBmYWlsLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9iamVjdCB0byBjaGVjay5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIGBSZWdFeHBgIG9iamVjdC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogWFJlZ0V4cC5pc1JlZ0V4cCgnc3RyaW5nJyk7IC8vIC0+IGZhbHNlXHJcbiAqIFhSZWdFeHAuaXNSZWdFeHAoL3JlZ2V4L2kpOyAvLyAtPiB0cnVlXHJcbiAqIFhSZWdFeHAuaXNSZWdFeHAoUmVnRXhwKCdeJywgJ20nKSk7IC8vIC0+IHRydWVcclxuICogWFJlZ0V4cC5pc1JlZ0V4cChYUmVnRXhwKCcoP3MpLicpKTsgLy8gLT4gdHJ1ZVxyXG4gKi9cclxuWFJlZ0V4cC5pc1JlZ0V4cCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xyXG4gICAgLy9yZXR1cm4gaXNUeXBlKHZhbHVlLCAnUmVnRXhwJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hlZCBzdHJpbmcsIG9yIGluIGdsb2JhbCBtb2RlLCBhbiBhcnJheSBjb250YWluaW5nIGFsbCBtYXRjaGVkIHN0cmluZ3MuXHJcbiAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYSBtb3JlIGNvbnZlbmllbnQgcmUtaW1wbGVtZW50YXRpb24gb2YgYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIHRoYXQgZ2l2ZXNcclxuICogdGhlIHJlc3VsdCB0eXBlcyB5b3UgYWN0dWFsbHkgd2FudCAoc3RyaW5nIGluc3RlYWQgb2YgYGV4ZWNgLXN0eWxlIGFycmF5IGluIG1hdGNoLWZpcnN0IG1vZGUsXHJcbiAqIGFuZCBhbiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIGBudWxsYCB3aGVuIG5vIG1hdGNoZXMgYXJlIGZvdW5kIGluIG1hdGNoLWFsbCBtb2RlKS4gSXQgYWxzbyBsZXRzXHJcbiAqIHlvdSBvdmVycmlkZSBmbGFnIGcgYW5kIGlnbm9yZSBgbGFzdEluZGV4YCwgYW5kIGZpeGVzIGJyb3dzZXIgYnVncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gc2VhcmNoIHdpdGguXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2NvcGU9J29uZSddIFVzZSAnb25lJyB0byByZXR1cm4gdGhlIGZpcnN0IG1hdGNoIGFzIGEgc3RyaW5nLiBVc2UgJ2FsbCcgdG9cclxuICogICByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIG1hdGNoZWQgc3RyaW5ncy4gSWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGFuZCBgcmVnZXhgIHVzZXMgZmxhZyBnLFxyXG4gKiAgIGBzY29wZWAgaXMgJ2FsbCcuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd8QXJyYXl9IEluIG1hdGNoLWZpcnN0IG1vZGU6IEZpcnN0IG1hdGNoIGFzIGEgc3RyaW5nLCBvciBgbnVsbGAuIEluIG1hdGNoLWFsbFxyXG4gKiAgIG1vZGU6IEFycmF5IG9mIGFsbCBtYXRjaGVkIHN0cmluZ3MsIG9yIGFuIGVtcHR5IGFycmF5LlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBNYXRjaCBmaXJzdFxyXG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAvXFx3Lyk7IC8vIC0+ICdhJ1xyXG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAvXFx3L2csICdvbmUnKTsgLy8gLT4gJ2EnXHJcbiAqIFhSZWdFeHAubWF0Y2goJ2FiYycsIC94L2csICdvbmUnKTsgLy8gLT4gbnVsbFxyXG4gKlxyXG4gKiAvLyBNYXRjaCBhbGxcclxuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL1xcdy9nKTsgLy8gLT4gWydhJywgJ2InLCAnYyddXHJcbiAqIFhSZWdFeHAubWF0Y2goJ2FiYycsIC9cXHcvLCAnYWxsJyk7IC8vIC0+IFsnYScsICdiJywgJ2MnXVxyXG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAveC8sICdhbGwnKTsgLy8gLT4gW11cclxuICovXHJcblhSZWdFeHAubWF0Y2ggPSBmdW5jdGlvbihzdHIsIHJlZ2V4LCBzY29wZSkge1xyXG4gICAgdmFyIGdsb2JhbCA9IChyZWdleC5nbG9iYWwgJiYgc2NvcGUgIT09ICdvbmUnKSB8fCBzY29wZSA9PT0gJ2FsbCcsXHJcbiAgICAgICAgY2FjaGVLZXkgPSAoKGdsb2JhbCA/ICdnJyA6ICcnKSArIChyZWdleC5zdGlja3kgPyAneScgOiAnJykpIHx8ICdub0dZJyxcclxuICAgICAgICByZXN1bHQsXHJcbiAgICAgICAgcjI7XHJcblxyXG4gICAgcmVnZXhbUkVHRVhfREFUQV0gPSByZWdleFtSRUdFWF9EQVRBXSB8fCB7fTtcclxuXHJcbiAgICAvLyBTaGFyZXMgY2FjaGVkIGNvcGllcyB3aXRoIGBYUmVnRXhwLmV4ZWNgL2ByZXBsYWNlYFxyXG4gICAgcjIgPSByZWdleFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gfHwgKFxyXG4gICAgICAgIHJlZ2V4W1JFR0VYX0RBVEFdW2NhY2hlS2V5XSA9IGNvcHlSZWdleChyZWdleCwge1xyXG4gICAgICAgICAgICBhZGRHOiAhIWdsb2JhbCxcclxuICAgICAgICAgICAgcmVtb3ZlRzogc2NvcGUgPT09ICdvbmUnLFxyXG4gICAgICAgICAgICBpc0ludGVybmFsT25seTogdHJ1ZVxyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIHJlc3VsdCA9IG5hdGl2Lm1hdGNoLmNhbGwodG9PYmplY3Qoc3RyKSwgcjIpO1xyXG5cclxuICAgIGlmIChyZWdleC5nbG9iYWwpIHtcclxuICAgICAgICByZWdleC5sYXN0SW5kZXggPSAoXHJcbiAgICAgICAgICAgIChzY29wZSA9PT0gJ29uZScgJiYgcmVzdWx0KSA/XHJcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB1c2UgYHIyLmxhc3RJbmRleGAgc2luY2UgYHIyYCBpcyBub25nbG9iYWwgaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgICAgICAocmVzdWx0LmluZGV4ICsgcmVzdWx0WzBdLmxlbmd0aCkgOiAwXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2xvYmFsID8gKHJlc3VsdCB8fCBbXSkgOiAocmVzdWx0ICYmIHJlc3VsdFswXSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIHRoZSBtYXRjaGVzIGZyb20gc2VhcmNoaW5nIGEgc3RyaW5nIHVzaW5nIGEgY2hhaW4gb2YgcmVnZXhlcyB0aGF0IHN1Y2Nlc3NpdmVseSBzZWFyY2hcclxuICogd2l0aGluIHByZXZpb3VzIG1hdGNoZXMuIFRoZSBwcm92aWRlZCBgY2hhaW5gIGFycmF5IGNhbiBjb250YWluIHJlZ2V4ZXMgYW5kIG9yIG9iamVjdHMgd2l0aFxyXG4gKiBgcmVnZXhgIGFuZCBgYmFja3JlZmAgcHJvcGVydGllcy4gV2hlbiBhIGJhY2tyZWZlcmVuY2UgaXMgc3BlY2lmaWVkLCB0aGUgbmFtZWQgb3IgbnVtYmVyZWRcclxuICogYmFja3JlZmVyZW5jZSBpcyBwYXNzZWQgZm9yd2FyZCB0byB0aGUgbmV4dCByZWdleCBvciByZXR1cm5lZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFpbiBSZWdleGVzIHRoYXQgZWFjaCBzZWFyY2ggZm9yIG1hdGNoZXMgd2l0aGluIHByZWNlZGluZyByZXN1bHRzLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IE1hdGNoZXMgYnkgdGhlIGxhc3QgcmVnZXggaW4gdGhlIGNoYWluLCBvciBhbiBlbXB0eSBhcnJheS5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQmFzaWMgdXNhZ2U7IG1hdGNoZXMgbnVtYmVycyB3aXRoaW4gPGI+IHRhZ3NcclxuICogWFJlZ0V4cC5tYXRjaENoYWluKCcxIDxiPjI8L2I+IDMgPGI+NCBhIDU2PC9iPicsIFtcclxuICogICBYUmVnRXhwKCcoP2lzKTxiPi4qPzwvYj4nKSxcclxuICogICAvXFxkKy9cclxuICogXSk7XHJcbiAqIC8vIC0+IFsnMicsICc0JywgJzU2J11cclxuICpcclxuICogLy8gUGFzc2luZyBmb3J3YXJkIGFuZCByZXR1cm5pbmcgc3BlY2lmaWMgYmFja3JlZmVyZW5jZXNcclxuICogaHRtbCA9ICc8YSBocmVmPVwiaHR0cDovL3hyZWdleHAuY29tL2FwaS9cIj5YUmVnRXhwPC9hPlxcXHJcbiAqICAgICAgICAgPGEgaHJlZj1cImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS9cIj5Hb29nbGU8L2E+JztcclxuICogWFJlZ0V4cC5tYXRjaENoYWluKGh0bWwsIFtcclxuICogICB7cmVnZXg6IC88YSBocmVmPVwiKFteXCJdKylcIj4vaSwgYmFja3JlZjogMX0sXHJcbiAqICAge3JlZ2V4OiBYUmVnRXhwKCcoP2kpXmh0dHBzPzovLyg/PGRvbWFpbj5bXi8/I10rKScpLCBiYWNrcmVmOiAnZG9tYWluJ31cclxuICogXSk7XHJcbiAqIC8vIC0+IFsneHJlZ2V4cC5jb20nLCAnd3d3Lmdvb2dsZS5jb20nXVxyXG4gKi9cclxuWFJlZ0V4cC5tYXRjaENoYWluID0gZnVuY3Rpb24oc3RyLCBjaGFpbikge1xyXG4gICAgcmV0dXJuIChmdW5jdGlvbiByZWN1cnNlQ2hhaW4odmFsdWVzLCBsZXZlbCkge1xyXG4gICAgICAgIHZhciBpdGVtID0gY2hhaW5bbGV2ZWxdLnJlZ2V4ID8gY2hhaW5bbGV2ZWxdIDoge3JlZ2V4OiBjaGFpbltsZXZlbF19O1xyXG4gICAgICAgIHZhciBtYXRjaGVzID0gW107XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZE1hdGNoKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmJhY2tyZWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA0LjAuNSAoYnV0IG5vdCA1LjAuNSspIGluYXBwcm9wcmlhdGVseSB1c2VzIHNwYXJzZSBhcnJheXMgdG8gaG9sZCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGB1bmRlZmluZWRgcyBmb3IgYmFja3JlZmVyZW5jZXMgdG8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzLiBJbiBzdWNoXHJcbiAgICAgICAgICAgICAgICAvLyBjYXNlcywgYSBgaGFzT3duUHJvcGVydHlgIG9yIGBpbmAgY2hlY2sgb24gaXRzIG93biB3b3VsZCBpbmFwcHJvcHJpYXRlbHkgdGhyb3dcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBleGNlcHRpb24sIHNvIGFsc28gY2hlY2sgaWYgdGhlIGJhY2tyZWZlcmVuY2UgaXMgYSBudW1iZXIgdGhhdCBpcyB3aXRoaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBib3VuZHMgb2YgdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgaWYgKCEobWF0Y2guaGFzT3duUHJvcGVydHkoaXRlbS5iYWNrcmVmKSB8fCAraXRlbS5iYWNrcmVmIDwgbWF0Y2gubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQmFja3JlZmVyZW5jZSB0byB1bmRlZmluZWQgZ3JvdXA6ICcgKyBpdGVtLmJhY2tyZWYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChtYXRjaFtpdGVtLmJhY2tyZWZdIHx8ICcnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChtYXRjaFswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIFhSZWdFeHAuZm9yRWFjaCh2YWx1ZXNbaV0sIGl0ZW0ucmVnZXgsIGFkZE1hdGNoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKGxldmVsID09PSBjaGFpbi5sZW5ndGggLSAxKSB8fCAhbWF0Y2hlcy5sZW5ndGgpID9cclxuICAgICAgICAgICAgbWF0Y2hlcyA6XHJcbiAgICAgICAgICAgIHJlY3Vyc2VDaGFpbihtYXRjaGVzLCBsZXZlbCArIDEpO1xyXG4gICAgfShbc3RyXSwgMCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgc3RyaW5nIHdpdGggb25lIG9yIGFsbCBtYXRjaGVzIG9mIGEgcGF0dGVybiByZXBsYWNlZC4gVGhlIHBhdHRlcm4gY2FuIGJlIGEgc3RyaW5nXHJcbiAqIG9yIHJlZ2V4LCBhbmQgdGhlIHJlcGxhY2VtZW50IGNhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBtYXRjaC4gVG9cclxuICogcGVyZm9ybSBhIGdsb2JhbCBzZWFyY2ggYW5kIHJlcGxhY2UsIHVzZSB0aGUgb3B0aW9uYWwgYHNjb3BlYCBhcmd1bWVudCBvciBpbmNsdWRlIGZsYWcgZyBpZiB1c2luZ1xyXG4gKiBhIHJlZ2V4LiBSZXBsYWNlbWVudCBzdHJpbmdzIGNhbiB1c2UgYCR7bn1gIGZvciBuYW1lZCBhbmQgbnVtYmVyZWQgYmFja3JlZmVyZW5jZXMuIFJlcGxhY2VtZW50XHJcbiAqIGZ1bmN0aW9ucyBjYW4gdXNlIG5hbWVkIGJhY2tyZWZlcmVuY2VzIHZpYSBgYXJndW1lbnRzWzBdLm5hbWVgLiBBbHNvIGZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZFxyXG4gKiB0byB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseSBjcm9zcy1icm93c2VyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXHJcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VhcmNoIFNlYXJjaCBwYXR0ZXJuIHRvIGJlIHJlcGxhY2VkLlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcmVwbGFjZW1lbnQgUmVwbGFjZW1lbnQgc3RyaW5nIG9yIGEgZnVuY3Rpb24gaW52b2tlZCB0byBjcmVhdGUgaXQuXHJcbiAqICAgUmVwbGFjZW1lbnQgc3RyaW5ncyBjYW4gaW5jbHVkZSBzcGVjaWFsIHJlcGxhY2VtZW50IHN5bnRheDpcclxuICogICAgIDxsaT4kJCAtIEluc2VydHMgYSBsaXRlcmFsICQgY2hhcmFjdGVyLlxyXG4gKiAgICAgPGxpPiQmLCAkMCAtIEluc2VydHMgdGhlIG1hdGNoZWQgc3Vic3RyaW5nLlxyXG4gKiAgICAgPGxpPiRgIC0gSW5zZXJ0cyB0aGUgc3RyaW5nIHRoYXQgcHJlY2VkZXMgdGhlIG1hdGNoZWQgc3Vic3RyaW5nIChsZWZ0IGNvbnRleHQpLlxyXG4gKiAgICAgPGxpPiQnIC0gSW5zZXJ0cyB0aGUgc3RyaW5nIHRoYXQgZm9sbG93cyB0aGUgbWF0Y2hlZCBzdWJzdHJpbmcgKHJpZ2h0IGNvbnRleHQpLlxyXG4gKiAgICAgPGxpPiRuLCAkbm4gLSBXaGVyZSBuL25uIGFyZSBkaWdpdHMgcmVmZXJlbmNpbmcgYW4gZXhpc3RlbnQgY2FwdHVyaW5nIGdyb3VwLCBpbnNlcnRzXHJcbiAqICAgICAgIGJhY2tyZWZlcmVuY2Ugbi9ubi5cclxuICogICAgIDxsaT4ke259IC0gV2hlcmUgbiBpcyBhIG5hbWUgb3IgYW55IG51bWJlciBvZiBkaWdpdHMgdGhhdCByZWZlcmVuY2UgYW4gZXhpc3RlbnQgY2FwdHVyaW5nXHJcbiAqICAgICAgIGdyb3VwLCBpbnNlcnRzIGJhY2tyZWZlcmVuY2Ugbi5cclxuICogICBSZXBsYWNlbWVudCBmdW5jdGlvbnMgYXJlIGludm9rZWQgd2l0aCB0aHJlZSBvciBtb3JlIGFyZ3VtZW50czpcclxuICogICAgIDxsaT5UaGUgbWF0Y2hlZCBzdWJzdHJpbmcgKGNvcnJlc3BvbmRzIHRvICQmIGFib3ZlKS4gTmFtZWQgYmFja3JlZmVyZW5jZXMgYXJlIGFjY2Vzc2libGUgYXNcclxuICogICAgICAgcHJvcGVydGllcyBvZiB0aGlzIGZpcnN0IGFyZ3VtZW50LlxyXG4gKiAgICAgPGxpPjAuLm4gYXJndW1lbnRzLCBvbmUgZm9yIGVhY2ggYmFja3JlZmVyZW5jZSAoY29ycmVzcG9uZGluZyB0byAkMSwgJDIsIGV0Yy4gYWJvdmUpLlxyXG4gKiAgICAgPGxpPlRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBtYXRjaCB3aXRoaW4gdGhlIHRvdGFsIHNlYXJjaCBzdHJpbmcuXHJcbiAqICAgICA8bGk+VGhlIHRvdGFsIHN0cmluZyBiZWluZyBzZWFyY2hlZC5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtzY29wZT0nb25lJ10gVXNlICdvbmUnIHRvIHJlcGxhY2UgdGhlIGZpcnN0IG1hdGNoIG9ubHksIG9yICdhbGwnLiBJZiBub3RcclxuICogICBleHBsaWNpdGx5IHNwZWNpZmllZCBhbmQgdXNpbmcgYSByZWdleCB3aXRoIGZsYWcgZywgYHNjb3BlYCBpcyAnYWxsJy5cclxuICogQHJldHVybnMge1N0cmluZ30gTmV3IHN0cmluZyB3aXRoIG9uZSBvciBhbGwgbWF0Y2hlcyByZXBsYWNlZC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gUmVnZXggc2VhcmNoLCB1c2luZyBuYW1lZCBiYWNrcmVmZXJlbmNlcyBpbiByZXBsYWNlbWVudCBzdHJpbmdcclxuICogdmFyIG5hbWUgPSBYUmVnRXhwKCcoPzxmaXJzdD5cXFxcdyspICg/PGxhc3Q+XFxcXHcrKScpO1xyXG4gKiBYUmVnRXhwLnJlcGxhY2UoJ0pvaG4gU21pdGgnLCBuYW1lLCAnJHtsYXN0fSwgJHtmaXJzdH0nKTtcclxuICogLy8gLT4gJ1NtaXRoLCBKb2huJ1xyXG4gKlxyXG4gKiAvLyBSZWdleCBzZWFyY2gsIHVzaW5nIG5hbWVkIGJhY2tyZWZlcmVuY2VzIGluIHJlcGxhY2VtZW50IGZ1bmN0aW9uXHJcbiAqIFhSZWdFeHAucmVwbGFjZSgnSm9obiBTbWl0aCcsIG5hbWUsIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAqICAgcmV0dXJuIG1hdGNoLmxhc3QgKyAnLCAnICsgbWF0Y2guZmlyc3Q7XHJcbiAqIH0pO1xyXG4gKiAvLyAtPiAnU21pdGgsIEpvaG4nXHJcbiAqXHJcbiAqIC8vIFN0cmluZyBzZWFyY2gsIHdpdGggcmVwbGFjZS1hbGxcclxuICogWFJlZ0V4cC5yZXBsYWNlKCdSZWdFeHAgYnVpbGRzIFJlZ0V4cHMnLCAnUmVnRXhwJywgJ1hSZWdFeHAnLCAnYWxsJyk7XHJcbiAqIC8vIC0+ICdYUmVnRXhwIGJ1aWxkcyBYUmVnRXhwcydcclxuICovXHJcblhSZWdFeHAucmVwbGFjZSA9IGZ1bmN0aW9uKHN0ciwgc2VhcmNoLCByZXBsYWNlbWVudCwgc2NvcGUpIHtcclxuICAgIHZhciBpc1JlZ2V4ID0gWFJlZ0V4cC5pc1JlZ0V4cChzZWFyY2gpLFxyXG4gICAgICAgIGdsb2JhbCA9IChzZWFyY2guZ2xvYmFsICYmIHNjb3BlICE9PSAnb25lJykgfHwgc2NvcGUgPT09ICdhbGwnLFxyXG4gICAgICAgIGNhY2hlS2V5ID0gKChnbG9iYWwgPyAnZycgOiAnJykgKyAoc2VhcmNoLnN0aWNreSA/ICd5JyA6ICcnKSkgfHwgJ25vR1knLFxyXG4gICAgICAgIHMyID0gc2VhcmNoLFxyXG4gICAgICAgIHJlc3VsdDtcclxuXHJcbiAgICBpZiAoaXNSZWdleCkge1xyXG4gICAgICAgIHNlYXJjaFtSRUdFWF9EQVRBXSA9IHNlYXJjaFtSRUdFWF9EQVRBXSB8fCB7fTtcclxuXHJcbiAgICAgICAgLy8gU2hhcmVzIGNhY2hlZCBjb3BpZXMgd2l0aCBgWFJlZ0V4cC5leGVjYC9gbWF0Y2hgLiBTaW5jZSBhIGNvcHkgaXMgdXNlZCwgYHNlYXJjaGAnc1xyXG4gICAgICAgIC8vIGBsYXN0SW5kZXhgIGlzbid0IHVwZGF0ZWQgKmR1cmluZyogcmVwbGFjZW1lbnQgaXRlcmF0aW9uc1xyXG4gICAgICAgIHMyID0gc2VhcmNoW1JFR0VYX0RBVEFdW2NhY2hlS2V5XSB8fCAoXHJcbiAgICAgICAgICAgIHNlYXJjaFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gPSBjb3B5UmVnZXgoc2VhcmNoLCB7XHJcbiAgICAgICAgICAgICAgICBhZGRHOiAhIWdsb2JhbCxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUc6IHNjb3BlID09PSAnb25lJyxcclxuICAgICAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsKSB7XHJcbiAgICAgICAgczIgPSBuZXcgUmVnRXhwKFhSZWdFeHAuZXNjYXBlKFN0cmluZyhzZWFyY2gpKSwgJ2cnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaXhlZCBgcmVwbGFjZWAgcmVxdWlyZWQgZm9yIG5hbWVkIGJhY2tyZWZlcmVuY2VzLCBldGMuXHJcbiAgICByZXN1bHQgPSBmaXhlZC5yZXBsYWNlLmNhbGwodG9PYmplY3Qoc3RyKSwgczIsIHJlcGxhY2VtZW50KTtcclxuXHJcbiAgICBpZiAoaXNSZWdleCAmJiBzZWFyY2guZ2xvYmFsKSB7XHJcbiAgICAgICAgLy8gRml4ZXMgSUUsIFNhZmFyaSBidWcgKGxhc3QgdGVzdGVkIElFIDksIFNhZmFyaSA1LjEpXHJcbiAgICAgICAgc2VhcmNoLmxhc3RJbmRleCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBiYXRjaCBwcm9jZXNzaW5nIG9mIHN0cmluZyByZXBsYWNlbWVudHMuIFVzZWQgbGlrZSBgWFJlZ0V4cC5yZXBsYWNlYCwgYnV0IGFjY2VwdHMgYW5cclxuICogYXJyYXkgb2YgcmVwbGFjZW1lbnQgZGV0YWlscy4gTGF0ZXIgcmVwbGFjZW1lbnRzIG9wZXJhdGUgb24gdGhlIG91dHB1dCBvZiBlYXJsaWVyIHJlcGxhY2VtZW50cy5cclxuICogUmVwbGFjZW1lbnQgZGV0YWlscyBhcmUgYWNjZXB0ZWQgYXMgYW4gYXJyYXkgd2l0aCBhIHJlZ2V4IG9yIHN0cmluZyB0byBzZWFyY2ggZm9yLCB0aGVcclxuICogcmVwbGFjZW1lbnQgc3RyaW5nIG9yIGZ1bmN0aW9uLCBhbmQgYW4gb3B0aW9uYWwgc2NvcGUgb2YgJ29uZScgb3IgJ2FsbCcuIFVzZXMgdGhlIFhSZWdFeHBcclxuICogcmVwbGFjZW1lbnQgdGV4dCBzeW50YXgsIHdoaWNoIHN1cHBvcnRzIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcyB2aWEgYCR7bmFtZX1gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJlcGxhY2VtZW50cyBBcnJheSBvZiByZXBsYWNlbWVudCBkZXRhaWwgYXJyYXlzLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBOZXcgc3RyaW5nIHdpdGggYWxsIHJlcGxhY2VtZW50cy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogc3RyID0gWFJlZ0V4cC5yZXBsYWNlRWFjaChzdHIsIFtcclxuICogICBbWFJlZ0V4cCgnKD88bmFtZT5hKScpLCAneiR7bmFtZX0nXSxcclxuICogICBbL2IvZ2ksICd5J10sXHJcbiAqICAgWy9jL2csICd4JywgJ29uZSddLCAvLyBzY29wZSAnb25lJyBvdmVycmlkZXMgL2dcclxuICogICBbL2QvLCAndycsICdhbGwnXSwgIC8vIHNjb3BlICdhbGwnIG92ZXJyaWRlcyBsYWNrIG9mIC9nXHJcbiAqICAgWydlJywgJ3YnLCAnYWxsJ10sICAvLyBzY29wZSAnYWxsJyBhbGxvd3MgcmVwbGFjZS1hbGwgZm9yIHN0cmluZ3NcclxuICogICBbL2YvZywgZnVuY3Rpb24oJDApIHtcclxuICogICAgIHJldHVybiAkMC50b1VwcGVyQ2FzZSgpO1xyXG4gKiAgIH1dXHJcbiAqIF0pO1xyXG4gKi9cclxuWFJlZ0V4cC5yZXBsYWNlRWFjaCA9IGZ1bmN0aW9uKHN0ciwgcmVwbGFjZW1lbnRzKSB7XHJcbiAgICB2YXIgaSwgcjtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVwbGFjZW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgciA9IHJlcGxhY2VtZW50c1tpXTtcclxuICAgICAgICBzdHIgPSBYUmVnRXhwLnJlcGxhY2Uoc3RyLCByWzBdLCByWzFdLCByWzJdKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxyXG4gKiBzZXBhcmF0b3IgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LiBIb3dldmVyLCBpZiBgc2VwYXJhdG9yYCBpcyBhIHJlZ2V4IHRoYXQgY29udGFpbnNcclxuICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxyXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XHJcbiAqIGNyb3NzLWJyb3dzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxyXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdCBhcnJheS5cclxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBCYXNpYyB1c2VcclxuICogWFJlZ0V4cC5zcGxpdCgnYSBiIGMnLCAnICcpO1xyXG4gKiAvLyAtPiBbJ2EnLCAnYicsICdjJ11cclxuICpcclxuICogLy8gV2l0aCBsaW1pdFxyXG4gKiBYUmVnRXhwLnNwbGl0KCdhIGIgYycsICcgJywgMik7XHJcbiAqIC8vIC0+IFsnYScsICdiJ11cclxuICpcclxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XHJcbiAqIFhSZWdFeHAuc3BsaXQoJy4ud29yZDEuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcclxuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnLi4nXVxyXG4gKi9cclxuWFJlZ0V4cC5zcGxpdCA9IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xyXG4gICAgcmV0dXJuIGZpeGVkLnNwbGl0LmNhbGwodG9PYmplY3Qoc3RyKSwgc2VwYXJhdG9yLCBsaW1pdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhlY3V0ZXMgYSByZWdleCBzZWFyY2ggaW4gYSBzcGVjaWZpZWQgc3RyaW5nLiBSZXR1cm5zIGB0cnVlYCBvciBgZmFsc2VgLiBPcHRpb25hbCBgcG9zYCBhbmRcclxuICogYHN0aWNreWAgYXJndW1lbnRzIHNwZWNpZnkgdGhlIHNlYXJjaCBzdGFydCBwb3NpdGlvbiwgYW5kIHdoZXRoZXIgdGhlIG1hdGNoIG11c3Qgc3RhcnQgYXQgdGhlXHJcbiAqIHNwZWNpZmllZCBwb3NpdGlvbiBvbmx5LiBUaGUgYGxhc3RJbmRleGAgcHJvcGVydHkgb2YgdGhlIHByb3ZpZGVkIHJlZ2V4IGlzIG5vdCB1c2VkLCBidXQgaXNcclxuICogdXBkYXRlZCBmb3IgY29tcGF0aWJpbGl0eS4gQWxzbyBmaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZVxyXG4gKiBgUmVnRXhwLnByb3RvdHlwZS50ZXN0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHkgY3Jvc3MtYnJvd3Nlci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gc2VhcmNoIHdpdGguXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zPTBdIFplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgdGhlIHNlYXJjaC5cclxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW3N0aWNreT1mYWxzZV0gV2hldGhlciB0aGUgbWF0Y2ggbXVzdCBzdGFydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcbiAqICAgb25seS4gVGhlIHN0cmluZyBgJ3N0aWNreSdgIGlzIGFjY2VwdGVkIGFzIGFuIGFsdGVybmF0aXZlIHRvIGB0cnVlYC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlZ2V4IG1hdGNoZWQgdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBCYXNpYyB1c2VcclxuICogWFJlZ0V4cC50ZXN0KCdhYmMnLCAvYy8pOyAvLyAtPiB0cnVlXHJcbiAqXHJcbiAqIC8vIFdpdGggcG9zIGFuZCBzdGlja3lcclxuICogWFJlZ0V4cC50ZXN0KCdhYmMnLCAvYy8sIDAsICdzdGlja3knKTsgLy8gLT4gZmFsc2VcclxuICogWFJlZ0V4cC50ZXN0KCdhYmMnLCAvYy8sIDIsICdzdGlja3knKTsgLy8gLT4gdHJ1ZVxyXG4gKi9cclxuWFJlZ0V4cC50ZXN0ID0gZnVuY3Rpb24oc3RyLCByZWdleCwgcG9zLCBzdGlja3kpIHtcclxuICAgIC8vIERvIHRoaXMgdGhlIGVhc3kgd2F5IDotKVxyXG4gICAgcmV0dXJuICEhWFJlZ0V4cC5leGVjKHN0ciwgcmVnZXgsIHBvcywgc3RpY2t5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVbmluc3RhbGxzIG9wdGlvbmFsIGZlYXR1cmVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuIEFsbCBvcHRpb25hbCBmZWF0dXJlcyBzdGFydCBvdXRcclxuICogdW5pbnN0YWxsZWQsIHNvIHRoaXMgaXMgdXNlZCB0byB1bmRvIHRoZSBhY3Rpb25zIG9mIGBYUmVnRXhwLmluc3RhbGxgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3Qgb3Igc3RyaW5nLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBXaXRoIGFuIG9wdGlvbnMgb2JqZWN0XHJcbiAqIFhSZWdFeHAudW5pbnN0YWxsKHtcclxuICogICAvLyBEaXNhYmxlcyBzdXBwb3J0IGZvciBhc3RyYWwgY29kZSBwb2ludHMgaW4gVW5pY29kZSBhZGRvbnNcclxuICogICBhc3RyYWw6IHRydWUsXHJcbiAqXHJcbiAqICAgLy8gREVQUkVDQVRFRDogUmVzdG9yZXMgbmF0aXZlIHJlZ2V4IG1ldGhvZHNcclxuICogICBuYXRpdmVzOiB0cnVlXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiAvLyBXaXRoIGFuIG9wdGlvbnMgc3RyaW5nXHJcbiAqIFhSZWdFeHAudW5pbnN0YWxsKCdhc3RyYWwgbmF0aXZlcycpO1xyXG4gKi9cclxuWFJlZ0V4cC51bmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gcHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKGZlYXR1cmVzLmFzdHJhbCAmJiBvcHRpb25zLmFzdHJhbCkge1xyXG4gICAgICAgIHNldEFzdHJhbChmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZlYXR1cmVzLm5hdGl2ZXMgJiYgb3B0aW9ucy5uYXRpdmVzKSB7XHJcbiAgICAgICAgc2V0TmF0aXZlcyhmYWxzZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBYUmVnRXhwIG9iamVjdCB0aGF0IGlzIHRoZSB1bmlvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybnMuIFBhdHRlcm5zIGNhbiBiZSBwcm92aWRlZCBhc1xyXG4gKiByZWdleCBvYmplY3RzIG9yIHN0cmluZ3MuIE1ldGFjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIGluIHBhdHRlcm5zIHByb3ZpZGVkIGFzIHN0cmluZ3MuXHJcbiAqIEJhY2tyZWZlcmVuY2VzIGluIHByb3ZpZGVkIHJlZ2V4IG9iamVjdHMgYXJlIGF1dG9tYXRpY2FsbHkgcmVudW1iZXJlZCB0byB3b3JrIGNvcnJlY3RseSB3aXRoaW5cclxuICogdGhlIGxhcmdlciBjb21iaW5lZCBwYXR0ZXJuLiBOYXRpdmUgZmxhZ3MgdXNlZCBieSBwcm92aWRlZCByZWdleGVzIGFyZSBpZ25vcmVkIGluIGZhdm9yIG9mIHRoZVxyXG4gKiBgZmxhZ3NgIGFyZ3VtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBSZWdleGVzIGFuZCBzdHJpbmdzIHRvIGNvbWJpbmUuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdIEFueSBjb21iaW5hdGlvbiBvZiBYUmVnRXhwIGZsYWdzLlxyXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBVbmlvbiBvZiB0aGUgcHJvdmlkZWQgcmVnZXhlcyBhbmQgc3RyaW5ncy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogWFJlZ0V4cC51bmlvbihbJ2ErYipjJywgLyhkb2dzKVxcMS8sIC8oY2F0cylcXDEvXSwgJ2knKTtcclxuICogLy8gLT4gL2FcXCtiXFwqY3woZG9ncylcXDF8KGNhdHMpXFwyL2lcclxuICovXHJcblhSZWdFeHAudW5pb24gPSBmdW5jdGlvbihwYXR0ZXJucywgZmxhZ3MpIHtcclxuICAgIHZhciBudW1DYXB0dXJlcyA9IDA7XHJcbiAgICB2YXIgbnVtUHJpb3JDYXB0dXJlcztcclxuICAgIHZhciBjYXB0dXJlTmFtZXM7XHJcblxyXG4gICAgZnVuY3Rpb24gcmV3cml0ZShtYXRjaCwgcGFyZW4sIGJhY2tyZWYpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IGNhcHR1cmVOYW1lc1tudW1DYXB0dXJlcyAtIG51bVByaW9yQ2FwdHVyZXNdO1xyXG5cclxuICAgICAgICAvLyBDYXB0dXJpbmcgZ3JvdXBcclxuICAgICAgICBpZiAocGFyZW4pIHtcclxuICAgICAgICAgICAgKytudW1DYXB0dXJlcztcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2FwdHVyZSBoYXMgYSBuYW1lLCBwcmVzZXJ2ZSB0aGUgbmFtZVxyXG4gICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcoPzwnICsgbmFtZSArICc+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vIEJhY2tyZWZlcmVuY2VcclxuICAgICAgICB9IGVsc2UgaWYgKGJhY2tyZWYpIHtcclxuICAgICAgICAgICAgLy8gUmV3cml0ZSB0aGUgYmFja3JlZmVyZW5jZVxyXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgKCtiYWNrcmVmICsgbnVtUHJpb3JDYXB0dXJlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoaXNUeXBlKHBhdHRlcm5zLCAnQXJyYXknKSAmJiBwYXR0ZXJucy5sZW5ndGgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgbm9uZW1wdHkgYXJyYXkgb2YgcGF0dGVybnMgdG8gbWVyZ2UnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFydHMgPSAvKFxcKCkoPyFcXD8pfFxcXFwoWzEtOV1cXGQqKXxcXFxcW1xcc1xcU118XFxbKD86W15cXFxcXFxdXXxcXFxcW1xcc1xcU10pKl0vZztcclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgIHZhciBwYXR0ZXJuO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcclxuXHJcbiAgICAgICAgaWYgKFhSZWdFeHAuaXNSZWdFeHAocGF0dGVybikpIHtcclxuICAgICAgICAgICAgbnVtUHJpb3JDYXB0dXJlcyA9IG51bUNhcHR1cmVzO1xyXG4gICAgICAgICAgICBjYXB0dXJlTmFtZXMgPSAocGF0dGVybltSRUdFWF9EQVRBXSAmJiBwYXR0ZXJuW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcykgfHwgW107XHJcblxyXG4gICAgICAgICAgICAvLyBSZXdyaXRlIGJhY2tyZWZlcmVuY2VzLiBQYXNzaW5nIHRvIFhSZWdFeHAgZGllcyBvbiBvY3RhbHMgYW5kIGVuc3VyZXMgcGF0dGVybnMgYXJlXHJcbiAgICAgICAgICAgIC8vIGluZGVwZW5kZW50bHkgdmFsaWQ7IGhlbHBzIGtlZXAgdGhpcyBzaW1wbGUuIE5hbWVkIGNhcHR1cmVzIGFyZSBwdXQgYmFja1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChuYXRpdi5yZXBsYWNlLmNhbGwoWFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSkuc291cmNlLCBwYXJ0cywgcmV3cml0ZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFhSZWdFeHAuZXNjYXBlKHBhdHRlcm4pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFhSZWdFeHAob3V0cHV0LmpvaW4oJ3wnKSwgZmxhZ3MpO1xyXG59O1xyXG5cclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcbi8vIEZpeGVkL2V4dGVuZGVkIG5hdGl2ZSBtZXRob2RzXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgbmFtZWQgY2FwdHVyZSBzdXBwb3J0ICh3aXRoIGJhY2tyZWZlcmVuY2VzIHJldHVybmVkIGFzIGByZXN1bHQubmFtZWApLCBhbmQgZml4ZXMgYnJvd3NlclxyXG4gKiBidWdzIGluIHRoZSBuYXRpdmUgYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AuIENhbGxpbmcgYFhSZWdFeHAuaW5zdGFsbCgnbmF0aXZlcycpYCB1c2VzIHRoaXMgdG9cclxuICogb3ZlcnJpZGUgdGhlIG5hdGl2ZSBtZXRob2QuIFVzZSB2aWEgYFhSZWdFeHAuZXhlY2Agd2l0aG91dCBvdmVycmlkaW5nIG5hdGl2ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cclxuICogQHJldHVybnMge0FycmF5fSBNYXRjaCBhcnJheSB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcywgb3IgYG51bGxgLlxyXG4gKi9cclxuZml4ZWQuZXhlYyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgdmFyIG9yaWdMYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleCxcclxuICAgICAgICBtYXRjaCA9IG5hdGl2LmV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHIyLFxyXG4gICAgICAgIGk7XHJcblxyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IHJldHVybiBgdW5kZWZpbmVkYCBmb3Igbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmdcclxuICAgICAgICAvLyBncm91cHMuIFRoaXMgZml4ZXMgSUUgNS41LTgsIGJ1dCBub3QgSUUgOSdzIHF1aXJrcyBtb2RlIG9yIGVtdWxhdGlvbiBvZiBvbGRlciBJRXMuIElFIDlcclxuICAgICAgICAvLyBpbiBzdGFuZGFyZHMgbW9kZSBmb2xsb3dzIHRoZSBzcGVjLlxyXG4gICAgICAgIGlmICghY29ycmVjdEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgaW5kZXhPZihtYXRjaCwgJycpID4gLTEpIHtcclxuICAgICAgICAgICAgcjIgPSBjb3B5UmVnZXgodGhpcywge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlRzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBVc2luZyBgc3RyLnNsaWNlKG1hdGNoLmluZGV4KWAgcmF0aGVyIHRoYW4gYG1hdGNoWzBdYCBpbiBjYXNlIGxvb2thaGVhZCBhbGxvd2VkXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGR1ZSB0byBjaGFyYWN0ZXJzIG91dHNpZGUgdGhlIG1hdGNoXHJcbiAgICAgICAgICAgIG5hdGl2LnJlcGxhY2UuY2FsbChTdHJpbmcoc3RyKS5zbGljZShtYXRjaC5pbmRleCksIHIyLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCAwIGFuZCB0aGUgbGFzdCAyXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuIC0gMjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdHRhY2ggbmFtZWQgY2FwdHVyZSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHRoaXNbUkVHRVhfREFUQV0gJiYgdGhpc1tSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMpIHtcclxuICAgICAgICAgICAgLy8gU2tpcCBpbmRleCAwXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXNbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbbmFtZV0gPSBtYXRjaFtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHRoYXQgaW5jcmVtZW50IGBsYXN0SW5kZXhgIGFmdGVyIHplcm8tbGVuZ3RoIG1hdGNoZXNcclxuICAgICAgICBpZiAodGhpcy5nbG9iYWwgJiYgIW1hdGNoWzBdLmxlbmd0aCAmJiAodGhpcy5sYXN0SW5kZXggPiBtYXRjaC5pbmRleCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmdsb2JhbCkge1xyXG4gICAgICAgIC8vIEZpeGVzIElFLCBPcGVyYSBidWcgKGxhc3QgdGVzdGVkIElFIDksIE9wZXJhIDExLjYpXHJcbiAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBvcmlnTGFzdEluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtYXRjaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgaW4gdGhlIG5hdGl2ZSBgUmVnRXhwLnByb3RvdHlwZS50ZXN0YC4gQ2FsbGluZyBgWFJlZ0V4cC5pbnN0YWxsKCduYXRpdmVzJylgXHJcbiAqIHVzZXMgdGhpcyB0byBvdmVycmlkZSB0aGUgbmF0aXZlIG1ldGhvZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcmVnZXggbWF0Y2hlZCB0aGUgcHJvdmlkZWQgdmFsdWUuXHJcbiAqL1xyXG5maXhlZC50ZXN0ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAvLyBEbyB0aGlzIHRoZSBlYXN5IHdheSA6LSlcclxuICAgIHJldHVybiAhIWZpeGVkLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgbmFtZWQgY2FwdHVyZSBzdXBwb3J0ICh3aXRoIGJhY2tyZWZlcmVuY2VzIHJldHVybmVkIGFzIGByZXN1bHQubmFtZWApLCBhbmQgZml4ZXMgYnJvd3NlclxyXG4gKiBidWdzIGluIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWAgdXNlcyB0aGlzIHRvXHJcbiAqIG92ZXJyaWRlIHRoZSBuYXRpdmUgbWV0aG9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlZ0V4cHwqfSByZWdleCBSZWdleCB0byBzZWFyY2ggd2l0aC4gSWYgbm90IGEgcmVnZXggb2JqZWN0LCBpdCBpcyBwYXNzZWQgdG8gYFJlZ0V4cGAuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gSWYgYHJlZ2V4YCB1c2VzIGZsYWcgZywgYW4gYXJyYXkgb2YgbWF0Y2ggc3RyaW5ncyBvciBgbnVsbGAuIFdpdGhvdXQgZmxhZyBnLFxyXG4gKiAgIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgcmVnZXguZXhlYyh0aGlzKWAuXHJcbiAqL1xyXG5maXhlZC5tYXRjaCA9IGZ1bmN0aW9uKHJlZ2V4KSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgIGlmICghWFJlZ0V4cC5pc1JlZ0V4cChyZWdleCkpIHtcclxuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBgUmVnRXhwYCByYXRoZXIgdGhhbiBgWFJlZ0V4cGBcclxuICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXgpO1xyXG4gICAgfSBlbHNlIGlmIChyZWdleC5nbG9iYWwpIHtcclxuICAgICAgICByZXN1bHQgPSBuYXRpdi5tYXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIC8vIEZpeGVzIElFIGJ1Z1xyXG4gICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZpeGVkLmV4ZWMuY2FsbChyZWdleCwgdG9PYmplY3QodGhpcykpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgc3VwcG9ydCBmb3IgYCR7bn1gIHRva2VucyBmb3IgbmFtZWQgYW5kIG51bWJlcmVkIGJhY2tyZWZlcmVuY2VzIGluIHJlcGxhY2VtZW50IHRleHQsIGFuZFxyXG4gKiBwcm92aWRlcyBuYW1lZCBiYWNrcmVmZXJlbmNlcyB0byByZXBsYWNlbWVudCBmdW5jdGlvbnMgYXMgYGFyZ3VtZW50c1swXS5uYW1lYC4gQWxzbyBmaXhlcyBicm93c2VyXHJcbiAqIGJ1Z3MgaW4gcmVwbGFjZW1lbnQgdGV4dCBzeW50YXggd2hlbiBwZXJmb3JtaW5nIGEgcmVwbGFjZW1lbnQgdXNpbmcgYSBub25yZWdleCBzZWFyY2ggdmFsdWUsIGFuZFxyXG4gKiB0aGUgdmFsdWUgb2YgYSByZXBsYWNlbWVudCByZWdleCdzIGBsYXN0SW5kZXhgIHByb3BlcnR5IGR1cmluZyByZXBsYWNlbWVudCBpdGVyYXRpb25zIGFuZCB1cG9uXHJcbiAqIGNvbXBsZXRpb24uIENhbGxpbmcgYFhSZWdFeHAuaW5zdGFsbCgnbmF0aXZlcycpYCB1c2VzIHRoaXMgdG8gb3ZlcnJpZGUgdGhlIG5hdGl2ZSBtZXRob2QuIE5vdGVcclxuICogdGhhdCB0aGlzIGRvZXNuJ3Qgc3VwcG9ydCBTcGlkZXJNb25rZXkncyBwcm9wcmlldGFyeSB0aGlyZCAoYGZsYWdzYCkgYXJndW1lbnQuIFVzZSB2aWFcclxuICogYFhSZWdFeHAucmVwbGFjZWAgd2l0aG91dCBvdmVycmlkaW5nIG5hdGl2ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VhcmNoIFNlYXJjaCBwYXR0ZXJuIHRvIGJlIHJlcGxhY2VkLlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcmVwbGFjZW1lbnQgUmVwbGFjZW1lbnQgc3RyaW5nIG9yIGEgZnVuY3Rpb24gaW52b2tlZCB0byBjcmVhdGUgaXQuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IE5ldyBzdHJpbmcgd2l0aCBvbmUgb3IgYWxsIG1hdGNoZXMgcmVwbGFjZWQuXHJcbiAqL1xyXG5maXhlZC5yZXBsYWNlID0gZnVuY3Rpb24oc2VhcmNoLCByZXBsYWNlbWVudCkge1xyXG4gICAgdmFyIGlzUmVnZXggPSBYUmVnRXhwLmlzUmVnRXhwKHNlYXJjaCksXHJcbiAgICAgICAgb3JpZ0xhc3RJbmRleCxcclxuICAgICAgICBjYXB0dXJlTmFtZXMsXHJcbiAgICAgICAgcmVzdWx0O1xyXG5cclxuICAgIGlmIChpc1JlZ2V4KSB7XHJcbiAgICAgICAgaWYgKHNlYXJjaFtSRUdFWF9EQVRBXSkge1xyXG4gICAgICAgICAgICBjYXB0dXJlTmFtZXMgPSBzZWFyY2hbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPbmx5IG5lZWRlZCBpZiBgc2VhcmNoYCBpcyBub25nbG9iYWxcclxuICAgICAgICBvcmlnTGFzdEluZGV4ID0gc2VhcmNoLmxhc3RJbmRleDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VhcmNoICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcclxuICAgIH1cclxuXHJcbiAgICAvLyBEb24ndCB1c2UgYHR5cGVvZmA7IHNvbWUgb2xkZXIgYnJvd3NlcnMgcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4IG9iamVjdHNcclxuICAgIGlmIChpc1R5cGUocmVwbGFjZW1lbnQsICdGdW5jdGlvbicpKSB7XHJcbiAgICAgICAgLy8gU3RyaW5naWZ5aW5nIGB0aGlzYCBmaXhlcyBhIGJ1ZyBpbiBJRSA8IDkgd2hlcmUgdGhlIGxhc3QgYXJndW1lbnQgaW4gcmVwbGFjZW1lbnRcclxuICAgICAgICAvLyBmdW5jdGlvbnMgaXNuJ3QgdHlwZS1jb252ZXJ0ZWQgdG8gYSBzdHJpbmdcclxuICAgICAgICByZXN1bHQgPSBuYXRpdi5yZXBsYWNlLmNhbGwoU3RyaW5nKHRoaXMpLCBzZWFyY2gsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cywgaTtcclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBgYXJndW1lbnRzWzBdYCBzdHJpbmcgcHJpbWl0aXZlIHRvIGEgYFN0cmluZ2Agb2JqZWN0IHRoYXQgY2FuIHN0b3JlXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzLiBUaGlzIHJlYWxseSBkb2VzIG5lZWQgdG8gdXNlIGBTdHJpbmdgIGFzIGEgY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBuZXcgU3RyaW5nKGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgbmFtZWQgYmFja3JlZmVyZW5jZXMgb24gdGhlIGZpcnN0IGFyZ3VtZW50XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FwdHVyZU5hbWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVOYW1lc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdW2NhcHR1cmVOYW1lc1tpXV0gPSBhcmdzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBjYWxsaW5nIGByZXBsYWNlbWVudGAuIEZpeGVzIElFLCBDaHJvbWUsIEZpcmVmb3gsIFNhZmFyaVxyXG4gICAgICAgICAgICAvLyBidWcgKGxhc3QgdGVzdGVkIElFIDksIENocm9tZSAxNywgRmlyZWZveCAxMSwgU2FmYXJpIDUuMSlcclxuICAgICAgICAgICAgaWYgKGlzUmVnZXggJiYgc2VhcmNoLmdsb2JhbCkge1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoLmxhc3RJbmRleCA9IGFyZ3NbYXJncy5sZW5ndGggLSAyXSArIGFyZ3NbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEVTNiBzcGVjcyB0aGUgY29udGV4dCBmb3IgcmVwbGFjZW1lbnQgZnVuY3Rpb25zIGFzIGB1bmRlZmluZWRgXHJcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgbGFzdCB2YWx1ZSBvZiBgYXJnc2Agd2lsbCBiZSBhIHN0cmluZyB3aGVuIGdpdmVuIG5vbnN0cmluZyBgdGhpc2AsXHJcbiAgICAgICAgLy8gd2hpbGUgc3RpbGwgdGhyb3dpbmcgb24gbnVsbCBvciB1bmRlZmluZWQgY29udGV4dFxyXG4gICAgICAgIHJlc3VsdCA9IG5hdGl2LnJlcGxhY2UuY2FsbCh0aGlzID09IG51bGwgPyB0aGlzIDogU3RyaW5nKHRoaXMpLCBzZWFyY2gsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBLZWVwIHRoaXMgZnVuY3Rpb24ncyBgYXJndW1lbnRzYCBhdmFpbGFibGUgdGhyb3VnaCBjbG9zdXJlXHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmF0aXYucmVwbGFjZS5jYWxsKFN0cmluZyhyZXBsYWNlbWVudCksIHJlcGxhY2VtZW50VG9rZW4sIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuO1xyXG4gICAgICAgICAgICAgICAgLy8gTmFtZWQgb3IgbnVtYmVyZWQgYmFja3JlZmVyZW5jZSB3aXRoIGN1cmx5IGJyYWNlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWFJlZ0V4cCBiZWhhdmlvciBmb3IgYCR7bn1gOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIEJhY2tyZWZlcmVuY2UgdG8gbnVtYmVyZWQgY2FwdHVyZSwgaWYgYG5gIGlzIGFuIGludGVnZXIuIFVzZSBgMGAgZm9yIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIGVudGlyZSBtYXRjaC4gQW55IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG1heSBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIEJhY2tyZWZlcmVuY2UgdG8gbmFtZWQgY2FwdHVyZSBgbmAsIGlmIGl0IGV4aXN0cyBhbmQgaXMgbm90IGFuIGludGVnZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBvdmVycmlkZGVuIGJ5IG51bWJlcmVkIGNhcHR1cmUuIEluIHByYWN0aWNlLCB0aGlzIGRvZXMgbm90IG92ZXJsYXAgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIG51bWJlcmVkIGNhcHR1cmUgc2luY2UgWFJlZ0V4cCBkb2VzIG5vdCBhbGxvdyBuYW1lZCBjYXB0dXJlIHRvIHVzZSBhIGJhcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBpbnRlZ2VyIGFzIHRoZSBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIElmIHRoZSBuYW1lIG9yIG51bWJlciBkb2VzIG5vdCByZWZlciB0byBhbiBleGlzdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGl0J3NcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICBuID0gKyQxOyAvLyBUeXBlLWNvbnZlcnQ7IGRyb3AgbGVhZGluZyB6ZXJvc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuIDw9IGFyZ3MubGVuZ3RoIC0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tuXSB8fCAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR3JvdXBzIHdpdGggdGhlIHNhbWUgbmFtZSBpcyBhbiBlcnJvciwgZWxzZSB3b3VsZCBuZWVkIGBsYXN0SW5kZXhPZmBcclxuICAgICAgICAgICAgICAgICAgICBuID0gY2FwdHVyZU5hbWVzID8gaW5kZXhPZihjYXB0dXJlTmFtZXMsICQxKSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0JhY2tyZWZlcmVuY2UgdG8gdW5kZWZpbmVkIGdyb3VwICcgKyAkMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW24gKyAxXSB8fCAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEVsc2UsIHNwZWNpYWwgdmFyaWFibGUgb3IgbnVtYmVyZWQgYmFja3JlZmVyZW5jZSB3aXRob3V0IGN1cmx5IGJyYWNlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCQyID09PSAnJCcpIHsgLy8gJCRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCQyID09PSAnJicgfHwgKyQyID09PSAwKSB7IC8vICQmLCAkMCAobm90IGZvbGxvd2VkIGJ5IDEtOSksICQwMFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCQyID09PSAnYCcpIHsgLy8gJGAgKGxlZnQgY29udGV4dClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1thcmdzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIGFyZ3NbYXJncy5sZW5ndGggLSAyXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoJDIgPT09IFwiJ1wiKSB7IC8vICQnIChyaWdodCBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0uc2xpY2UoYXJnc1thcmdzLmxlbmd0aCAtIDJdICsgYXJnc1swXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRWxzZSwgbnVtYmVyZWQgYmFja3JlZmVyZW5jZSB3aXRob3V0IGN1cmx5IGJyYWNlc1xyXG4gICAgICAgICAgICAgICAgJDIgPSArJDI7IC8vIFR5cGUtY29udmVydDsgZHJvcCBsZWFkaW5nIHplcm9cclxuICAgICAgICAgICAgICAgIC8vIFhSZWdFeHAgYmVoYXZpb3IgZm9yIGAkbmAgYW5kIGAkbm5gOlxyXG4gICAgICAgICAgICAgICAgLy8gLSBCYWNrcmVmcyBlbmQgYWZ0ZXIgMSBvciAyIGRpZ2l0cy4gVXNlIGAkey4ufWAgZm9yIG1vcmUgZGlnaXRzLlxyXG4gICAgICAgICAgICAgICAgLy8gLSBgJDFgIGlzIGFuIGVycm9yIGlmIG5vIGNhcHR1cmluZyBncm91cHMuXHJcbiAgICAgICAgICAgICAgICAvLyAtIGAkMTBgIGlzIGFuIGVycm9yIGlmIGxlc3MgdGhhbiAxMCBjYXB0dXJpbmcgZ3JvdXBzLiBVc2UgYCR7MX0wYCBpbnN0ZWFkLlxyXG4gICAgICAgICAgICAgICAgLy8gLSBgJDAxYCBpcyBgJDFgIGlmIGF0IGxlYXN0IG9uZSBjYXB0dXJpbmcgZ3JvdXAsIGVsc2UgaXQncyBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vIC0gYCQwYCAobm90IGZvbGxvd2VkIGJ5IDEtOSkgYW5kIGAkMDBgIGFyZSB0aGUgZW50aXJlIG1hdGNoLlxyXG4gICAgICAgICAgICAgICAgLy8gTmF0aXZlIGJlaGF2aW9yLCBmb3IgY29tcGFyaXNvbjpcclxuICAgICAgICAgICAgICAgIC8vIC0gQmFja3JlZnMgZW5kIGFmdGVyIDEgb3IgMiBkaWdpdHMuIENhbm5vdCByZWZlcmVuY2UgY2FwdHVyaW5nIGdyb3VwIDEwMCsuXHJcbiAgICAgICAgICAgICAgICAvLyAtIGAkMWAgaXMgYSBsaXRlcmFsIGAkMWAgaWYgbm8gY2FwdHVyaW5nIGdyb3Vwcy5cclxuICAgICAgICAgICAgICAgIC8vIC0gYCQxMGAgaXMgYCQxYCBmb2xsb3dlZCBieSBhIGxpdGVyYWwgYDBgIGlmIGxlc3MgdGhhbiAxMCBjYXB0dXJpbmcgZ3JvdXBzLlxyXG4gICAgICAgICAgICAgICAgLy8gLSBgJDAxYCBpcyBgJDFgIGlmIGF0IGxlYXN0IG9uZSBjYXB0dXJpbmcgZ3JvdXAsIGVsc2UgaXQncyBhIGxpdGVyYWwgYCQwMWAuXHJcbiAgICAgICAgICAgICAgICAvLyAtIGAkMGAgaXMgYSBsaXRlcmFsIGAkMGAuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKCQyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkMiA+IGFyZ3MubGVuZ3RoIC0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0JhY2tyZWZlcmVuY2UgdG8gdW5kZWZpbmVkIGdyb3VwICcgKyAkMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWyQyXSB8fCAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGAkYCBmb2xsb3dlZCBieSBhbiB1bnN1cHBvcnRlZCBjaGFyIGlzIGFuIGVycm9yLCB1bmxpa2UgbmF0aXZlIEpTXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgdG9rZW4gJyArICQwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzUmVnZXgpIHtcclxuICAgICAgICBpZiAoc2VhcmNoLmdsb2JhbCkge1xyXG4gICAgICAgICAgICAvLyBGaXhlcyBJRSwgU2FmYXJpIGJ1ZyAobGFzdCB0ZXN0ZWQgSUUgOSwgU2FmYXJpIDUuMSlcclxuICAgICAgICAgICAgc2VhcmNoLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRml4ZXMgSUUsIE9wZXJhIGJ1ZyAobGFzdCB0ZXN0ZWQgSUUgOSwgT3BlcmEgMTEuNilcclxuICAgICAgICAgICAgc2VhcmNoLmxhc3RJbmRleCA9IG9yaWdMYXN0SW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRml4ZXMgYnJvd3NlciBidWdzIGluIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWBcclxuICogdXNlcyB0aGlzIHRvIG92ZXJyaWRlIHRoZSBuYXRpdmUgbWV0aG9kLiBVc2UgdmlhIGBYUmVnRXhwLnNwbGl0YCB3aXRob3V0IG92ZXJyaWRpbmcgbmF0aXZlcy5cclxuICpcclxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3Vic3RyaW5ncy5cclxuICovXHJcbmZpeGVkLnNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCkge1xyXG4gICAgaWYgKCFYUmVnRXhwLmlzUmVnRXhwKHNlcGFyYXRvcikpIHtcclxuICAgICAgICAvLyBCcm93c2VycyBoYW5kbGUgbm9ucmVnZXggc3BsaXQgY29ycmVjdGx5LCBzbyB1c2UgdGhlIGZhc3RlciBuYXRpdmUgbWV0aG9kXHJcbiAgICAgICAgcmV0dXJuIG5hdGl2LnNwbGl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKSxcclxuICAgICAgICBvdXRwdXQgPSBbXSxcclxuICAgICAgICBvcmlnTGFzdEluZGV4ID0gc2VwYXJhdG9yLmxhc3RJbmRleCxcclxuICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcclxuICAgICAgICBsYXN0TGVuZ3RoO1xyXG5cclxuICAgIC8vIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxyXG4gICAgLy8gSWYgdW5kZWZpbmVkOiBwb3coMiwzMikgLSAxXHJcbiAgICAvLyBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXHJcbiAgICAvLyBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gZmxvb3IobGltaXQpOyBpZiAobGltaXQgPj0gcG93KDIsMzIpKSBsaW1pdCAtPSBwb3coMiwzMik7XHJcbiAgICAvLyBJZiBuZWdhdGl2ZSBudW1iZXI6IHBvdygyLDMyKSAtIGZsb29yKGFicyhsaW1pdCkpXHJcbiAgICAvLyBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcclxuICAgIC8vIFRoaXMgbGluZSBmYWlscyBpbiB2ZXJ5IHN0cmFuZ2Ugd2F5cyBmb3Igc29tZSB2YWx1ZXMgb2YgYGxpbWl0YCBpbiBPcGVyYSAxMC41LTEwLjYzLCB1bmxlc3NcclxuICAgIC8vIE9wZXJhIERyYWdvbmZseSBpcyBvcGVuIChnbyBmaWd1cmUpLiBJdCB3b3JrcyBpbiBhdCBsZWFzdCBPcGVyYSA5LjUtMTAuMSBhbmQgMTErXHJcbiAgICBsaW1pdCA9IChsaW1pdCA9PT0gdW5kZWZpbmVkID8gLTEgOiBsaW1pdCkgPj4+IDA7XHJcblxyXG4gICAgWFJlZ0V4cC5mb3JFYWNoKHN0ciwgc2VwYXJhdG9yLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgIC8vIFRoaXMgY29uZGl0aW9uIGlzIG5vdCB0aGUgc2FtZSBhcyBgaWYgKG1hdGNoWzBdLmxlbmd0aClgXHJcbiAgICAgICAgaWYgKChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkgPiBsYXN0TGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0ci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIGxhc3RMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW5hdGl2LnRlc3QuY2FsbChzZXBhcmF0b3IsICcnKSB8fCBsYXN0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IG9yaWdMYXN0SW5kZXg7XHJcbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcclxufTtcclxuXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG4vLyBCdWlsdC1pbiBzeW50YXgvZmxhZyB0b2tlbnNcclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcblxyXG4vKlxyXG4gKiBMZXR0ZXIgZXNjYXBlcyB0aGF0IG5hdGl2ZWx5IG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyczogYFxcYWAsIGBcXEFgLCBldGMuIFRoZXNlIHNob3VsZCBiZVxyXG4gKiBTeW50YXhFcnJvcnMgYnV0IGFyZSBhbGxvd2VkIGluIHdlYiByZWFsaXR5LiBYUmVnRXhwIG1ha2VzIHRoZW0gZXJyb3JzIGZvciBjcm9zcy1icm93c2VyXHJcbiAqIGNvbnNpc3RlbmN5IGFuZCB0byByZXNlcnZlIHRoZWlyIHN5bnRheCwgYnV0IGxldHMgdGhlbSBiZSBzdXBlcnNlZGVkIGJ5IGFkZG9ucy5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFxcXChbQUJDRS1SVFVWWFlaYWVnLW1vcHF5el18Yyg/IVtBLVphLXpdKXx1KD8hW1xcZEEtRmEtZl17NH18e1tcXGRBLUZhLWZdK30pfHgoPyFbXFxkQS1GYS1mXXsyfSkpLyxcclxuICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSkge1xyXG4gICAgICAgIC8vIFxcQiBpcyBhbGxvd2VkIGluIGRlZmF1bHQgc2NvcGUgb25seVxyXG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ0InICYmIHNjb3BlID09PSBkZWZhdWx0U2NvcGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgZXNjYXBlICcgKyBtYXRjaFswXSk7XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHNjb3BlOiAnYWxsJyxcclxuICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXHJcbiAgICB9XHJcbik7XHJcblxyXG4vKlxyXG4gKiBVbmljb2RlIGNvZGUgcG9pbnQgZXNjYXBlIHdpdGggY3VybHkgYnJhY2VzOiBgXFx1e04uLn1gLiBgTi4uYCBpcyBhbnkgb25lIG9yIG1vcmUgZGlnaXRcclxuICogaGV4YWRlY2ltYWwgbnVtYmVyIGZyb20gMC0xMEZGRkYsIGFuZCBjYW4gaW5jbHVkZSBsZWFkaW5nIHplcm9zLiBSZXF1aXJlcyB0aGUgbmF0aXZlIEVTNiBgdWAgZmxhZ1xyXG4gKiB0byBzdXBwb3J0IGNvZGUgcG9pbnRzIGdyZWF0ZXIgdGhhbiBVK0ZGRkYuIEF2b2lkcyBjb252ZXJ0aW5nIGNvZGUgcG9pbnRzIGFib3ZlIFUrRkZGRiB0b1xyXG4gKiBzdXJyb2dhdGUgcGFpcnMgKHdoaWNoIGNvdWxkIGJlIGRvbmUgd2l0aG91dCBmbGFnIGB1YCksIHNpbmNlIHRoYXQgY291bGQgbGVhZCB0byBicm9rZW4gYmVoYXZpb3JcclxuICogaWYgeW91IGZvbGxvdyBhIGBcXHV7Ti4ufWAgdG9rZW4gdGhhdCByZWZlcmVuY2VzIGEgY29kZSBwb2ludCBhYm92ZSBVK0ZGRkYgd2l0aCBhIHF1YW50aWZpZXIsIG9yXHJcbiAqIGlmIHlvdSB1c2UgdGhlIHNhbWUgaW4gYSBjaGFyYWN0ZXIgY2xhc3MuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xcXFx1eyhbXFxkQS1GYS1mXSspfS8sXHJcbiAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUsIGZsYWdzKSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBkZWMobWF0Y2hbMV0pO1xyXG4gICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludCAnICsgbWF0Y2hbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29kZSA8PSAweEZGRkYpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydGluZyB0byBcXHVOTk5OIGF2b2lkcyBuZWVkaW5nIHRvIGVzY2FwZSB0aGUgbGl0ZXJhbCBjaGFyYWN0ZXIgYW5kIGtlZXAgaXRcclxuICAgICAgICAgICAgLy8gc2VwYXJhdGUgZnJvbSBwcmVjZWRpbmcgdG9rZW5zXHJcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICsgcGFkNChoZXgoY29kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBgY29kZWAgaXMgYmV0d2VlbiAweEZGRkYgYW5kIDB4MTBGRkZGLCByZXF1aXJlIGFuZCBkZWZlciB0byBuYXRpdmUgaGFuZGxpbmdcclxuICAgICAgICBpZiAoaGFzTmF0aXZlVSAmJiBmbGFncy5pbmRleE9mKCd1JykgPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHVzZSBVbmljb2RlIGNvZGUgcG9pbnQgYWJvdmUgXFxcXHV7RkZGRn0gd2l0aG91dCBmbGFnIHUnKTtcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgc2NvcGU6ICdhbGwnLFxyXG4gICAgICAgIGxlYWRDaGFyOiAnXFxcXCdcclxuICAgIH1cclxuKTtcclxuXHJcbi8qXHJcbiAqIEVtcHR5IGNoYXJhY3RlciBjbGFzczogYFtdYCBvciBgW15dYC4gVGhpcyBmaXhlcyBhIGNyaXRpY2FsIGNyb3NzLWJyb3dzZXIgc3ludGF4IGluY29uc2lzdGVuY3kuXHJcbiAqIFVubGVzcyB0aGlzIGlzIHN0YW5kYXJkaXplZCAocGVyIHRoZSBFUyBzcGVjKSwgcmVnZXggc3ludGF4IGNhbid0IGJlIGFjY3VyYXRlbHkgcGFyc2VkIGJlY2F1c2VcclxuICogY2hhcmFjdGVyIGNsYXNzIGVuZGluZ3MgY2FuJ3QgYmUgZGV0ZXJtaW5lZC5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFxbKFxcXj8pXS8sXHJcbiAgICBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgIC8vIEZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkgd2l0aCBFUzMsIGNvbnZlcnQgW10gdG8gXFxiXFxCIGFuZCBbXl0gdG8gW1xcc1xcU10uXHJcbiAgICAgICAgLy8gKD8hKSBzaG91bGQgd29yayBsaWtlIFxcYlxcQiwgYnV0IGlzIHVucmVsaWFibGUgaW4gc29tZSB2ZXJzaW9ucyBvZiBGaXJlZm94XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdID8gJ1tcXFxcc1xcXFxTXScgOiAnXFxcXGJcXFxcQic7XHJcbiAgICB9LFxyXG4gICAge2xlYWRDaGFyOiAnWyd9XHJcbik7XHJcblxyXG4vKlxyXG4gKiBDb21tZW50IHBhdHRlcm46IGAoPyMgKWAuIElubGluZSBjb21tZW50cyBhcmUgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIGxpbmUgY29tbWVudHMgYWxsb3dlZCBpblxyXG4gKiBmcmVlLXNwYWNpbmcgbW9kZSAoZmxhZyB4KS5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFwoXFw/I1teKV0qXFwpLyxcclxuICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSwgZmxhZ3MpIHtcclxuICAgICAgICAvLyBLZWVwIHRva2VucyBzZXBhcmF0ZWQgdW5sZXNzIHRoZSBmb2xsb3dpbmcgdG9rZW4gaXMgYSBxdWFudGlmaWVyLiBUaGlzIGF2b2lkcyBlLmcuXHJcbiAgICAgICAgLy8gaW5hZHZlcnRlZGx5IGNoYW5naW5nIGBcXDEoPyMpMWAgdG8gYFxcMTFgLlxyXG4gICAgICAgIHJldHVybiBpc1F1YW50aWZpZXJOZXh0KG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCwgZmxhZ3MpID9cclxuICAgICAgICAgICAgJycgOiAnKD86KSc7XHJcbiAgICB9LFxyXG4gICAge2xlYWRDaGFyOiAnKCd9XHJcbik7XHJcblxyXG4vKlxyXG4gKiBXaGl0ZXNwYWNlIGFuZCBsaW5lIGNvbW1lbnRzLCBpbiBmcmVlLXNwYWNpbmcgbW9kZSAoYWthIGV4dGVuZGVkIG1vZGUsIGZsYWcgeCkgb25seS5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFxzK3wjW15cXG5dKlxcbj8vLFxyXG4gICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xyXG4gICAgICAgIC8vIEtlZXAgdG9rZW5zIHNlcGFyYXRlZCB1bmxlc3MgdGhlIGZvbGxvd2luZyB0b2tlbiBpcyBhIHF1YW50aWZpZXIuIFRoaXMgYXZvaWRzIGUuZy5cclxuICAgICAgICAvLyBpbmFkdmVydGVkbHkgY2hhbmdpbmcgYFxcMSAxYCB0byBgXFwxMWAuXHJcbiAgICAgICAgcmV0dXJuIGlzUXVhbnRpZmllck5leHQobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLCBmbGFncykgP1xyXG4gICAgICAgICAgICAnJyA6ICcoPzopJztcclxuICAgIH0sXHJcbiAgICB7ZmxhZzogJ3gnfVxyXG4pO1xyXG5cclxuLypcclxuICogRG90LCBpbiBkb3RhbGwgbW9kZSAoYWthIHNpbmdsZWxpbmUgbW9kZSwgZmxhZyBzKSBvbmx5LlxyXG4gKi9cclxuWFJlZ0V4cC5hZGRUb2tlbihcclxuICAgIC9cXC4vLFxyXG4gICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICdbXFxcXHNcXFxcU10nO1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBmbGFnOiAncycsXHJcbiAgICAgICAgbGVhZENoYXI6ICcuJ1xyXG4gICAgfVxyXG4pO1xyXG5cclxuLypcclxuICogTmFtZWQgYmFja3JlZmVyZW5jZTogYFxcazxuYW1lPmAuIEJhY2tyZWZlcmVuY2UgbmFtZXMgY2FuIHVzZSB0aGUgY2hhcmFjdGVycyBBLVosIGEteiwgMC05LCBfLFxyXG4gKiBhbmQgJCBvbmx5LiBBbHNvIGFsbG93cyBudW1iZXJlZCBiYWNrcmVmZXJlbmNlcyBhcyBgXFxrPG4+YC5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFxcXGs8KFtcXHckXSspPi8sXHJcbiAgICBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgIC8vIEdyb3VwcyB3aXRoIHRoZSBzYW1lIG5hbWUgaXMgYW4gZXJyb3IsIGVsc2Ugd291bGQgbmVlZCBgbGFzdEluZGV4T2ZgXHJcbiAgICAgICAgdmFyIGluZGV4ID0gaXNOYU4obWF0Y2hbMV0pID8gKGluZGV4T2YodGhpcy5jYXB0dXJlTmFtZXMsIG1hdGNoWzFdKSArIDEpIDogK21hdGNoWzFdLFxyXG4gICAgICAgICAgICBlbmRJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgIGlmICghaW5kZXggfHwgaW5kZXggPiB0aGlzLmNhcHR1cmVOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdCYWNrcmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBncm91cCAnICsgbWF0Y2hbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBLZWVwIGJhY2tyZWZlcmVuY2VzIHNlcGFyYXRlIGZyb20gc3Vic2VxdWVudCBsaXRlcmFsIG51bWJlcnMuIFRoaXMgYXZvaWRzIGUuZy5cclxuICAgICAgICAvLyBpbmFkdmVydGVkbHkgY2hhbmdpbmcgYCg/PG4+KVxcazxuPjFgIHRvIGAoKVxcMTFgLlxyXG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBpbmRleCArIChcclxuICAgICAgICAgICAgZW5kSW5kZXggPT09IG1hdGNoLmlucHV0Lmxlbmd0aCB8fCBpc05hTihtYXRjaC5pbnB1dC5jaGFyQXQoZW5kSW5kZXgpKSA/XHJcbiAgICAgICAgICAgICAgICAnJyA6ICcoPzopJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG4gICAge2xlYWRDaGFyOiAnXFxcXCd9XHJcbik7XHJcblxyXG4vKlxyXG4gKiBOdW1iZXJlZCBiYWNrcmVmZXJlbmNlIG9yIG9jdGFsLCBwbHVzIGFueSBmb2xsb3dpbmcgZGlnaXRzOiBgXFwwYCwgYFxcMTFgLCBldGMuIE9jdGFscyBleGNlcHQgYFxcMGBcclxuICogbm90IGZvbGxvd2VkIGJ5IDAtOSBhbmQgYmFja3JlZmVyZW5jZXMgdG8gdW5vcGVuZWQgY2FwdHVyZSBncm91cHMgdGhyb3cgYW4gZXJyb3IuIE90aGVyIG1hdGNoZXNcclxuICogYXJlIHJldHVybmVkIHVuYWx0ZXJlZC4gSUUgPCA5IGRvZXNuJ3Qgc3VwcG9ydCBiYWNrcmVmZXJlbmNlcyBhYm92ZSBgXFw5OWAgaW4gcmVnZXggc3ludGF4LlxyXG4gKi9cclxuWFJlZ0V4cC5hZGRUb2tlbihcclxuICAgIC9cXFxcKFxcZCspLyxcclxuICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgIShcclxuICAgICAgICAgICAgICAgIHNjb3BlID09PSBkZWZhdWx0U2NvcGUgJiZcclxuICAgICAgICAgICAgICAgIC9eWzEtOV0vLnRlc3QobWF0Y2hbMV0pICYmXHJcbiAgICAgICAgICAgICAgICArbWF0Y2hbMV0gPD0gdGhpcy5jYXB0dXJlTmFtZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICkgJiZcclxuICAgICAgICAgICAgbWF0Y2hbMV0gIT09ICcwJ1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2Ugb2N0YWwgZXNjYXBlIG9yIGJhY2tyZWZlcmVuY2UgdG8gdW5kZWZpbmVkIGdyb3VwICcgK1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hbMF07XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHNjb3BlOiAnYWxsJyxcclxuICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXHJcbiAgICB9XHJcbik7XHJcblxyXG4vKlxyXG4gKiBOYW1lZCBjYXB0dXJpbmcgZ3JvdXA7IG1hdGNoIHRoZSBvcGVuaW5nIGRlbGltaXRlciBvbmx5OiBgKD88bmFtZT5gLiBDYXB0dXJlIG5hbWVzIGNhbiB1c2UgdGhlXHJcbiAqIGNoYXJhY3RlcnMgQS1aLCBhLXosIDAtOSwgXywgYW5kICQgb25seS4gTmFtZXMgY2FuJ3QgYmUgaW50ZWdlcnMuIFN1cHBvcnRzIFB5dGhvbi1zdHlsZVxyXG4gKiBgKD9QPG5hbWU+YCBhcyBhbiBhbHRlcm5hdGUgc3ludGF4IHRvIGF2b2lkIGlzc3VlcyBpbiBzb21lIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhIHdoaWNoIG5hdGl2ZWx5XHJcbiAqIHN1cHBvcnRlZCB0aGUgUHl0aG9uLXN0eWxlIHN5bnRheC4gT3RoZXJ3aXNlLCBYUmVnRXhwIG1pZ2h0IHRyZWF0IG51bWJlcmVkIGJhY2tyZWZlcmVuY2VzIHRvXHJcbiAqIFB5dGhvbi1zdHlsZSBuYW1lZCBjYXB0dXJlIGFzIG9jdGFscy5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFwoXFw/UD88KFtcXHckXSspPi8sXHJcbiAgICBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgIC8vIERpc2FsbG93IGJhcmUgaW50ZWdlcnMgYXMgbmFtZXMgYmVjYXVzZSBuYW1lZCBiYWNrcmVmZXJlbmNlcyBhcmUgYWRkZWQgdG8gbWF0Y2ggYXJyYXlzXHJcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBudW1lcmljIHByb3BlcnRpZXMgbWF5IGxlYWQgdG8gaW5jb3JyZWN0IGxvb2t1cHNcclxuICAgICAgICBpZiAoIWlzTmFOKG1hdGNoWzFdKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2UgaW50ZWdlciBhcyBjYXB0dXJlIG5hbWUgJyArIG1hdGNoWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnbGVuZ3RoJyB8fCBtYXRjaFsxXSA9PT0gJ19fcHJvdG9fXycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIHJlc2VydmVkIHdvcmQgYXMgY2FwdHVyZSBuYW1lICcgKyBtYXRjaFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleE9mKHRoaXMuY2FwdHVyZU5hbWVzLCBtYXRjaFsxXSkgPiAtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2Ugc2FtZSBuYW1lIGZvciBtdWx0aXBsZSBncm91cHMgJyArIG1hdGNoWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlTmFtZXMucHVzaChtYXRjaFsxXSk7XHJcbiAgICAgICAgdGhpcy5oYXNOYW1lZENhcHR1cmUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiAnKCc7XHJcbiAgICB9LFxyXG4gICAge2xlYWRDaGFyOiAnKCd9XHJcbik7XHJcblxyXG4vKlxyXG4gKiBDYXB0dXJpbmcgZ3JvdXA7IG1hdGNoIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9ubHkuIFJlcXVpcmVkIGZvciBzdXBwb3J0IG9mIG5hbWVkIGNhcHR1cmluZ1xyXG4gKiBncm91cHMuIEFsc28gYWRkcyBleHBsaWNpdCBjYXB0dXJlIG1vZGUgKGZsYWcgbikuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xcKCg/IVxcPykvLFxyXG4gICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xyXG4gICAgICAgIGlmIChmbGFncy5pbmRleE9mKCduJykgPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyg/Oic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FwdHVyZU5hbWVzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgcmV0dXJuICcoJztcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgb3B0aW9uYWxGbGFnczogJ24nLFxyXG4gICAgICAgIGxlYWRDaGFyOiAnKCdcclxuICAgIH1cclxuKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWFJlZ0V4cDtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcbmltcG9ydCB0aGVtZSBmcm9tICdzb3VyY2UvdXRpbC90aGVtZSc7XHJcblxyXG5pbXBvcnQgQ3VzdG9tRXZlbnRzIGZyb20gXCJzb3VyY2UvY29tcG9uZW50L0N1c3RvbUV2ZW50c1wiO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1idXR0b25cIjoge1xyXG4gICAgICAgIGRpc3BsYXk6IFsnLXdlYmtpdC1pbmxpbmUtZmxleCcsICdpbmxpbmUtZmxleCddLFxyXG4gICAgICAgIGNvbG9yOiB0aGVtZS5idXR0b24udGV4dC5jb2xvcixcclxuICAgICAgICBwYWRkaW5nOiAnMC43ZW0gMC41ZW0nLFxyXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxyXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxyXG4gICAgICAgIGJvcmRlcldpZHRoOiAwLFxyXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuICAgICAgICBtYXJnaW5MZWZ0OiA1LFxyXG4gICAgICAgIG1hcmdpblJpZ2h0OiA1XHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1idXR0b246YWZ0ZXJcIjoge1xyXG4gICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgMjUwbXMgbGluZWFyJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtYnV0dG9uW3ByZXNzZWRdOmFmdGVyXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJyxcclxuICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcclxuICAgIH0sXHJcblxyXG4gICAgXCJkb3JpYy1idXR0b25bZGlzYWJsZWRdXCI6IHtcclxuICAgICAgICBib3hTaGFkb3c6ICdub25lJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtYnV0dG9uW3JhaXNlZF1cIjoge1xyXG4gICAgICAgIGJveFNoYWRvdzogdGhlbWUuZ2VuZXJhbC5ib3hTaGFkb3dcclxuICAgIH0sXHJcbn0pO1xyXG5jb25zdCBCdXR0b24gPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdGV4dCA9IG51bGwsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIixcclxuICAgICAgICAuLi5wYXNzVGhyb3VnaFxyXG4gICAgfSA9IHByb3BzO1xyXG5cclxuICAgIHJldHVybiA8Q3VzdG9tRXZlbnRzIGNvbXBvbmVudD1cImRvcmljLWJ1dHRvblwiIHsuLi5wYXNzVGhyb3VnaH0gY2xhc3M9e2NsYXNzTmFtZX0+e3RleHR9e2NoaWxkcmVufTwvQ3VzdG9tRXZlbnRzPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbjtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcbmltcG9ydCB0aGVtZSBmcm9tICdzb3VyY2UvdXRpbC90aGVtZSc7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLWNhcmRcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgYm94U2hhZG93OiB0aGVtZS5nZW5lcmFsLmJveFNoYWRvdyxcclxuICAgICAgICBtYXJnaW46IDUsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxyXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWNhcmQgLmNvbnRlbnRcIjoge1xyXG4gICAgICAgIHBhZGRpbmc6IDVcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWNhcmQgLnRpdGxlXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgV2Via2l0Rm9udFNtb290aGluZzogJ2FudGlhbGlhc2VkJyxcclxuICAgICAgICBmb250V2VpZ2h0OiA5MDAsXHJcbiAgICAgICAgZm9udFNpemU6IDE4LFxyXG4gICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkIGxpZ2h0Z3JheSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWNhcmQgLmFjdGlvbnNcIjoge1xyXG4gICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgYm9yZGVyVG9wOiAnMXB4IHNvbGlkIGxpZ2h0Z3JheSdcclxuICAgIH1cclxufSk7XHJcbmNvbnN0IENhcmQgPSBwcm9wcyA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIHRpdGxlID0gbnVsbCxcclxuICAgICAgICBhY3Rpb25zID0gbnVsbCxcclxuICAgICAgICAuLi5wYXNzVGhyb3VnaFxyXG4gICAgfSA9IHByb3BzO1xyXG4gICAgbGV0IHRpdGxlRWxlbWVudCA9IG51bGw7XHJcbiAgICBsZXQgYWN0aW9uRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRpdGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGl0bGVFbGVtZW50ID0gPGRpdiBjbGFzc05hbWU9XCJ0aXRsZVwiPnt0aXRsZX08L2Rpdj47XHJcbiAgICB9XHJcbiAgICBpZiAoYWN0aW9ucyAhPT0gbnVsbCkge1xyXG4gICAgICAgIGFjdGlvbkVsZW1lbnQgPSA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj57YWN0aW9uc308L2Rpdj47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZG9yaWMtY2FyZCB7Li4ucGFzc1Rocm91Z2h9PlxyXG4gICAgICAgICAgICB7dGl0bGVFbGVtZW50fVxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57Y2hpbGRyZW59PC9kaXY+XHJcbiAgICAgICAgICAgIHthY3Rpb25FbGVtZW50fVxyXG4gICAgICAgIDwvZG9yaWMtY2FyZD5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IGNvbnN0cyBmcm9tICdzb3VyY2UvdXRpbC9jb25zdHMnO1xyXG5pbXBvcnQge0NTU30gZnJvbSAnc291cmNlL3V0aWwvc3R5bGVzaGVldCc7XHJcblxyXG5pbXBvcnQge0NlbnRlckNvbnRlbnR9IGZyb20gJ3NvdXJjZS9jb21wb25lbnQvQ29udGVudEFsaWduZXJzJztcclxuaW1wb3J0IEN1c3RvbUV2ZW50cyBmcm9tIFwic291cmNlL2NvbXBvbmVudC9DdXN0b21FdmVudHNcIjtcclxuaW1wb3J0IHtJY29ufSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0ljb24nO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1jaGVja2JveFwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWNoZWNrYm94W2Rpc2FibGVkPSd0cnVlJ11cIjoge1xyXG4gICAgICAgIGNvbG9yOiAnZ3JheScsXHJcbiAgICAgICAgb3BhY2l0eTogMC42XHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jaGVja2JveDphZnRlclwiOiB7XHJcbiAgICAgICAgY29udGVudDogXCInJ1wiLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICB0cmFuc2l0aW9uOiBjb25zdHMuY3NzLmJhY2tncm91bmRUcmFuc2l0aW9uXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jaGVja2JveFtwcmVzc2VkXTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pOmFmdGVyXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENTUy5yZ2JhKDAsIDAsIDAsIDAuMjUpLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtY2hlY2tib3ggZG9yaWMtaWNvblwiOiB7XHJcbiAgICAgICAgdHJhbnNpdGlvbjogJ2NvbG9yIDI1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWNoZWNrYm94W2NoZWNrZWQ9J3RydWUnXTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pIGRvcmljLWljb25cIjoge1xyXG4gICAgICAgIGNvbG9yOiBjb25zdHMudGhlbWUuYmx1aXNoXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBDaGVja2JveCA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjaGVja2VkID0gZmFsc2UsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgb25DaGFuZ2UgPSB3YXJuaW5nRnVuYyhcIkNoZWNrYm94IGhhcyBubyBvbkNoYW5nZSBmdW5jdGlvblwiKSxcclxuICAgICAgICBvbkljb24gPSBcImlvbi1hbmRyb2lkLWNoZWNrYm94XCIsXHJcbiAgICAgICAgb2ZmSWNvbiA9IFwiaW9uLWFuZHJvaWQtY2hlY2tib3gtb3V0bGluZS1ibGFua1wiLFxyXG4gICAgICAgIHNpZGUgPSAnbGVmdCcsXHJcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIixcclxuICAgICAgICBzdHlsZSA9IHt9LFxyXG4gICAgICAgIC4uLnBhc3NUaHJvdWdoXHJcbiAgICB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHByb3BzLmRpc2FibGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlKGNoZWNrZWQgPT09IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBpY29uTmFtZSA9IChjaGVja2VkID09PSB0cnVlKSA/IG9uSWNvbiA6IG9mZkljb247XHJcbiAgICBjb25zdCBwYWRkaW5nID0ge1xyXG4gICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgW2BwYWRkaW5nJHtzaWRlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7c2lkZS5zbGljZSgxKX1gXTogMzBcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q3VzdG9tRXZlbnRzIGNvbXBvbmVudD1cImRvcmljLWNoZWNrYm94XCIgY2xhc3M9e2NsYXNzTmFtZX0gb25UYXA9e2NoYW5nZX0gey4uLnBhc3NUaHJvdWdofSBzdHlsZT17ey4uLnN0eWxlLCAuLi5wYWRkaW5nfX0gY2hlY2tlZD17Y2hlY2tlZH0+XHJcbiAgICAgICAgICAgIDxDZW50ZXJDb250ZW50IGRhdGEtbm8tcHJlc3Mgc3R5bGU9e3tbc2lkZV06IDAsIHRvcDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZSd9fSB3aWR0aD17MzB9IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgIDxJY29uIGljb249e2ljb25OYW1lfSBkYXRhLW5vLXByZXNzIHN0eWxlPXt7Zm9udFNpemU6IDI2fX0gLz5cclxuICAgICAgICAgICAgPC9DZW50ZXJDb250ZW50PlxyXG4gICAgICAgICAgICB7bGFiZWx9e2NoaWxkcmVufVxyXG4gICAgICAgIDwvQ3VzdG9tRXZlbnRzPlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94O1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtY2VudGVyLWNvbnRlbnRcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6IFsnLXdlYmtpdC1pbmxpbmUtZmxleCcsICdpbmxpbmUtZmxleCddLFxyXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxyXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtYWxpZ24tY29udGVudFwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogWyctd2Via2l0LWlubGluZS1mbGV4JywgJ2lubGluZS1mbGV4J10sXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jZW50ZXItY29udGVudC5ibG9jaywgZG9yaWMtYWxpZ24tY29udGVudC5ibG9ja1wiOiB7XHJcbiAgICAgICAgZGlzcGxheTogWyctd2Via2l0LWZsZXgnLCAnZmxleCddXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBDZW50ZXJDb250ZW50ID0gKHt3aWR0aCwgaGVpZ2h0LCBjbGFzc05hbWUgPSBcIlwiLCBibG9jaywgc3R5bGUgPSB7fSwgLi4ucGFzc1Rocm91Z2h9KSA9PlxyXG4gICAgPGRvcmljLWNlbnRlci1jb250ZW50IGNsYXNzPXtgJHtibG9jayA/IFwiYmxvY2tcIiA6IFwiXCJ9ICR7Y2xhc3NOYW1lfWAudHJpbSgpfSB7Li4ucGFzc1Rocm91Z2h9IHN0eWxlPXt7Li4uc3R5bGUsIHdpZHRoLCBoZWlnaHR9fSAvPjtcclxuY29uc3QgQWxpZ25Db250ZW50ID0gKHt3aWR0aCwgaGVpZ2h0LCBjbGFzc05hbWUgPSBcIlwiLCBibG9jaywgaG9yaXpvbnRhbCA9IFwiY2VudGVyXCIsIHZlcnRpY2FsID0gXCJjZW50ZXJcIiwgc3R5bGUgPSB7fSwgLi4ucGFzc1Rocm91Z2h9KSA9PlxyXG4gICAgPGRvcmljLWFsaWduLWNvbnRlbnRcclxuICAgICAgICBjbGFzcz17YCR7YmxvY2sgPyBcImJsb2NrXCIgOiBcIlwifSAke2NsYXNzTmFtZX1gLnRyaW0oKX1cclxuICAgICAgICB7Li4ucGFzc1Rocm91Z2h9XHJcbiAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgLi4uc3R5bGUsXHJcbiAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICAgIFdlYmtpdEFsaWduSXRlbXM6IHZlcnRpY2FsLFxyXG4gICAgICAgICAgICBXZWJraXRKdXN0aWZ5Q29udGVudDogaG9yaXpvbnRhbCxcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogdmVydGljYWwsXHJcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBob3Jpem9udGFsXHJcbiAgICAgICAgfX0gLz47XHJcblxyXG5leHBvcnQge1xyXG4gICAgQ2VudGVyQ29udGVudCxcclxuICAgIEFsaWduQ29udGVudFxyXG59O1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuXHJcbmNvbnN0IHRyYXZlcnNlID0gKG5vZGUsIGV2dCwgaGFuZGxlcnMpID0+IHtcclxuICAgIGNvbnN0IHRyaWdnZXJzID0gW107XHJcbiAgICBsZXQgY3VycmVudCA9IG5vZGU7XHJcbiAgICBsZXQgY29udCA9IHRydWU7XHJcblxyXG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbiA9ICgpID0+IGNvbnQgPSBmYWxzZTtcclxuICAgIHdoaWxlIChjb250ID09IHRydWUgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChoYW5kbGVycy5oYXMoY3VycmVudC5kYXRhc2V0LnN5bnRoSWQpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLmdldChjdXJyZW50LmRhdGFzZXQuc3ludGhJZCkoZXZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcclxuICAgIH1cclxufTtcclxuY29uc3QgaGFuZGxlcnMgPSB7fTtcclxubGV0IG5leHRJRCA9IDA7XHJcbmNvbnN0IGdlbklEID0gKCkgPT4ge1xyXG4gICAgbmV4dElEICs9IDE7XHJcbiAgICByZXR1cm4gbmV4dElELnRvU3RyaW5nKCk7XHJcbn07XHJcbmNvbnN0IHJlZ2lzdGVySGFuZGxlciA9ICh0eXBlLCBpZCwgaGFuZGxlcikgPT4ge1xyXG4gICAgaWYgKGhhbmRsZXJzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgZXZ0ID0+IHRyYXZlcnNlKGV2dC50YXJnZXQsIGV2dCwgaGFuZGxlcnNbZXZ0LnR5cGUudG9Mb3dlckNhc2UoKV0pLFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKTtcclxuICAgICAgICBoYW5kbGVyc1t0eXBlXSA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGhhbmRsZXJzW3R5cGVdLnNldChpZCwgaGFuZGxlcik7XHJcbn07XHJcbmNvbnN0IHVucmVnaXN0ZXJIYW5kbGVycyA9IGlkID0+IHtcclxuICAgIGZvciAoY29uc3QgbWFwcGluZyBvZiBPYmplY3QudmFsdWVzKGhhbmRsZXJzKSkge1xyXG4gICAgICAgIG1hcHBpbmcuZGVsZXRlKGlkKTtcclxuICAgIH1cclxufTtcclxud2luZG93LnNob3dIYW5kbGVycyA9ICgpID0+IGNibG9nKGhhbmRsZXJzKTtcclxuXHJcbmNvbnN0IG5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoW1xyXG4gICAgJ29uQ3V0JywgJ29uQ29weScsICdvblBhc3RlJyxcclxuICAgICdvbkNvbXBvc2l0aW9uRW5kJywgJ29uQ29tcG9zaXRpb25TdGFydCcsICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcclxuICAgICdvbktleURvd24nLCAnb25LZXlQcmVzcycsICdvbktleVVwJyxcclxuICAgICdvbkZvY3VzJywgJ29uQmx1cicsXHJcbiAgICAnb25DaGFuZ2UnLCAnb25JbnB1dCcsICdvblN1Ym1pdCcsXHJcbiAgICAnb25DbGljaycsICdvbkNvbnRleHRNZW51JywgJ29uRG91YmxlQ2xpY2snLCAnb25EcmFnJywgJ29uRHJhZ0VuZCcsICdvbkRyYWdFbnRlcicsICdvbkRyYWdFeGl0JywgJ29uRHJhZ0xlYXZlJywgJ29uRHJhZ092ZXInLCAnb25EcmFnU3RhcnQnLCAnb25Ecm9wJywgJ29uTW91c2VEb3duJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnLCAnb25Nb3VzZU1vdmUnLCAnb25Nb3VzZU91dCcsICdvbk1vdXNlT3ZlcicsICdvbk1vdXNlVXAnLFxyXG4gICAgJ29uU2VsZWN0JyxcclxuICAgICdvblRvdWNoQ2FuY2VsJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaE1vdmUnLCAnb25Ub3VjaFN0YXJ0JyxcclxuICAgICdvblNjcm9sbCcsXHJcbiAgICAnb25XaGVlbCcsXHJcbiAgICAnb25BYm9ydCcsICdvbkNhblBsYXknLCAnb25DYW5QbGF5VGhyb3VnaCcsICdvbkR1cmF0aW9uQ2hhbmdlJywgJ29uRW1wdGllZCcsICdvbkVuY3J5cHRlZCcsICdvbkVuZGVkJywgJ29uRXJyb3InLCAnb25Mb2FkZWREYXRhJywgJ29uTG9hZGVkTWV0YWRhdGEnLCAnb25Mb2FkU3RhcnQnLCAnb25QYXVzZScsICdvblBsYXknLCAnb25QbGF5aW5nJywgJ29uUHJvZ3Jlc3MnLCAnb25SYXRlQ2hhbmdlJywgJ29uU2Vla2VkJywgJ29uU2Vla2luZycsICdvblN0YWxsZWQnLCAnb25TdXNwZW5kJywgJ29uVGltZVVwZGF0ZScsICdvblZvbHVtZUNoYW5nZScsICdvbldhaXRpbmcnLFxyXG4gICAgJ29uQW5pbWF0aW9uU3RhcnQnLCAnb25BbmltYXRpb25FbmQnLCAnb25BbmltYXRpb25JdGVyYXRpb24nLFxyXG4gICAgJ29uVHJhbnNpdGlvbkVuZCdcclxuXSk7XHJcbmNsYXNzIEN1c3RvbUV2ZW50cyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLmlkID0gZ2VuSUQoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVDYWxsYmFja3MgPSAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5wcm9wcykpIHtcclxuICAgICAgICAgICAgaWYgKGtleS5zbGljZSgwLCAyKSA9PT0gJ29uJyAmJiBuYXRpdmVFdmVudHMuaGFzKGtleSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZWdpc3RlckhhbmRsZXIoa2V5LnNsaWNlKDIpLnRvTG93ZXJDYXNlKCksIHRoaXMuaWQsIHRoaXMucHJvcHNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFja3MoKTtcclxuICAgICAgICBpZiAoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykuZGF0YXNldC5zeW50aElkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3RoaXMucHJvcHMuY29tcG9uZW50Lm5hbWV9IG11c3QgcGFzcyB0aGUgZGF0YS1zeW50aC1pZCBwcm9wIGludG8gdGhlIERPTSBlbGVtZW50cyByZW5kZXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgICB1bnJlZ2lzdGVySGFuZGxlcnModGhpcy5pZCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFja3MoKTtcclxuICAgIH1cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xyXG4gICAgICAgIHVucmVnaXN0ZXJIYW5kbGVycyh0aGlzLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCh0aGlzLnByb3BzLmNvbXBvbmVudCB8fCBudWxsKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wb25lbnQgbXVzdCBiZSBwYXNzZWQgaW50byBDdXN0b21FdmVudHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMucHJvcHMuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModGhpcy5wcm9wcykucmVkdWNlKFxyXG4gICAgICAgICAgICAocCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGtleSAhPT0gJ2NvbXBvbmVudCcgJiYga2V5LnNsaWNlKDAsIDIpICE9PSAnb24nKSB8fCBuYXRpdmVFdmVudHMuaGFzKGtleSkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwW2tleV0gPSB0aGlzLnByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge31cclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiA8Q29tcG9uZW50IGRhdGEtc3ludGgtaWQ9e3RoaXMuaWR9IHsuLi5wcm9wc30gLz47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUV2ZW50cztcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLWdyaWRcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtZ3JpZC1pdGVtXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBib3JkZXJXaWR0aDogMCxcclxuICAgICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcclxuICAgICAgICBib3JkZXJDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgZmxvYXQ6ICdsZWZ0J1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmNvbnN0IEdyaWQgPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgLy8gY2VsbFNwYWNpbmdIID0gMCxcclxuICAgICAgICAvLyBjZWxsU3BhY2luZ1YgPSAwLFxyXG4gICAgICAgIGNlbGxTcGFjaW5nID0gWzAsIDBdLFxyXG4gICAgICAgIGNlbGxIZWlnaHQgPSAzMCxcclxuICAgICAgICBjb2xDb3VudCA9IDEyLFxyXG4gICAgICAgIHN0eWxlID0ge31cclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IFtjZWxsU3BhY2luZ0gsIGNlbGxTcGFjaW5nVl0gPSAodHlwZW9mIGNlbGxTcGFjaW5nID09PSAnbnVtYmVyJykgPyBbY2VsbFNwYWNpbmcsIGNlbGxTcGFjaW5nXSA6IGNlbGxTcGFjaW5nO1xyXG4gICAgY29uc3QgZ3JpZFN0eWxlID0ge1xyXG4gICAgICAgIC4uLnN0eWxlLFxyXG4gICAgICAgIHBhZGRpbmdMZWZ0OiBjZWxsU3BhY2luZ0gsXHJcbiAgICAgICAgcGFkZGluZ1RvcDogY2VsbFNwYWNpbmdWXHJcbiAgICB9O1xyXG4gICAgY29uc3QgYmFzZUl0ZW1TdHlsZSA9IHtcclxuICAgICAgICBib3JkZXJXaWR0aDogYCR7Y2VsbFNwYWNpbmdWfXB4ICR7Y2VsbFNwYWNpbmdIfXB4YFxyXG4gICAgfTtcclxuICAgIGxldCB7Y2hpbGRyZW59ID0gcHJvcHM7XHJcblxyXG4gICAgaWYgKGNlbGxIZWlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICBiYXNlSXRlbVN0eWxlLmhlaWdodCA9IGNlbGxIZWlnaHQgKyBjZWxsU3BhY2luZ1YgKiAyO1xyXG4gICAgfVxyXG5cclxuICAgIGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XHJcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLm1hcChcclxuICAgICAgICBjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtjb2xTcGFuID0gMSwgLi4uY2hpbGRQcm9wc30gPSBjaGlsZC5wcm9wcztcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBgY2FsYygkeyhjb2xTcGFuICogMTAwKSAvIGNvbENvdW50fSUgKyAke2NlbGxTcGFjaW5nSH1weClgO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJnaW5MZWZ0ID0gLWNlbGxTcGFjaW5nSDtcclxuICAgICAgICAgICAgY29uc3QgbWFyZ2luVG9wID0gLWNlbGxTcGFjaW5nVjtcclxuICAgICAgICAgICAgcmV0dXJuIDxkb3JpYy1ncmlkLWl0ZW0gc3R5bGU9e3suLi5iYXNlSXRlbVN0eWxlLCB3aWR0aCwgbWFyZ2luVG9wLCBtYXJnaW5MZWZ0fX0+PGNoaWxkLnR5cGUgey4uLmNoaWxkUHJvcHN9IC8+PC9kb3JpYy1ncmlkLWl0ZW0+O1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZG9yaWMtZ3JpZCBzdHlsZT17Z3JpZFN0eWxlfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvZG9yaWMtZ3JpZD5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcmlkO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IGljb25zIGZyb20gJ3NvdXJjZS91dGlsL2ljb25zJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtaWNvblwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2lubGluZScsXHJcbiAgICAgICAgZm9udFNpemU6IDE4LFxyXG4gICAgICAgIGZvbnRGYW1pbHk6IFwiSW9uaWNcIlxyXG4gICAgfVxyXG59KTtcclxuY29uc3QgSWNvbiA9ICh7aWNvbiwgY2xhc3NOYW1lLCAuLi5wYXNzVGhyb3VnaH0pID0+IDxkb3JpYy1pY29uIHsuLi5wYXNzVGhyb3VnaH0gY2xhc3M9e2NsYXNzTmFtZX0+e2ljb25zW2ljb25dfTwvZG9yaWMtaWNvbj47XHJcbmNvbnN0IEljb25CdXR0b24gPSAoe2ljb24sIHRleHQgPSBcIlwiLCBjaGlsZHJlbiwgLi4ucHJvcHN9KSA9PiA8QnV0dG9uIHsuLi5wcm9wc30gdGV4dD17PEljb24gaWNvbj17aWNvbn0gLz59Pnt0ZXh0fXtjaGlsZHJlbn08L0J1dHRvbj47XHJcblxyXG5leHBvcnQge0ljb24sIEljb25CdXR0b259O1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtaW1hZ2VcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICduby1yZXBlYXQnLFxyXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogJ2NlbnRlciBjZW50ZXInXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBJbWFnZSA9ICh7c291cmNlLCBjb3ZlciA9IGZhbHNlLCBjb250YWluID0gZmFsc2UsIHdpZHRoID0gbnVsbCwgaGVpZ2h0ID0gbnVsbCwgc3R5bGUgPSB7fSwgLi4ucGFzc1Rocm91Z2h9KSA9PiB7XHJcbiAgICBsZXQgYmdTaXplID0gJ2NvbnRhaW4nO1xyXG5cclxuICAgIGlmIChjb3ZlciA9PT0gdHJ1ZSAmJiBjb250YWluID09PSBmYWxzZSkge1xyXG4gICAgICAgIGJnU2l6ZSA9ICdjb3Zlcic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDxkb3JpYy1pbWFnZSBzdHlsZT17ey4uLnN0eWxlLCBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke3NvdXJjZX1cIilgLCB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kU2l6ZTogYmdTaXplfX0gey4uLnBhc3NUaHJvdWdofSAvPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IGNvbnN0cyBmcm9tICdzb3VyY2UvdXRpbC9jb25zdHMnO1xyXG5cclxuaW1wb3J0IEN1c3RvbUV2ZW50cyBmcm9tIFwic291cmNlL2NvbXBvbmVudC9DdXN0b21FdmVudHNcIjtcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtaW5wdXRcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgbWFyZ2luOiAzLFxyXG4gICAgICAgIHBhZGRpbmdUb3A6IDIyLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQgPiBpbnB1dFwiOiB7XHJcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICBib3JkZXJXaWR0aDogMCxcclxuICAgICAgICBwYWRkaW5nOiA1LFxyXG4gICAgICAgIGJvcmRlckJvdHRvbTogYDJweCBzb2xpZCAke2NvbnN0cy50aGVtZS5ncmF5Qkd9YCxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgekluZGV4OiBcIisxXCJcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWlucHV0ID4gaW5wdXQ6Zm9jdXNcIjoge1xyXG4gICAgICAgIG91dGxpbmU6ICdub25lJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQgPiBkb3JpYy1pbnB1dC1sYWJlbFwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICBoZWlnaHQ6IDIyLFxyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQgdG9wJyxcclxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgM3B4KSBzY2FsZSgwLjg1KScsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAxNTBtcyBsaW5lYXInXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1pbnB1dCA+IGlucHV0OmZvY3VzIH4gZG9yaWMtaW5wdXQtbGFiZWw6bm90KFtwbGFjZWhvbGRlcl0pXCI6IHtcclxuICAgICAgICBjb2xvcjogJyM0MzVkZWMnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1pbnB1dCA+IGRvcmljLWlucHV0LWxhYmVsW3BsYWNlaG9sZGVyXVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDVweCwgMTAwJSknLFxyXG4gICAgICAgIGNvbG9yOiAnZ3JheSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWlucHV0ID4gaW5wdXQgKyBkb3JpYy1pbnB1dC1mbG91cmlzaFwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgaGVpZ2h0OiAyLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uc3RzLnRoZW1lLmJsdWlzaCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMCknLFxyXG4gICAgICAgIHpJbmRleDogXCIrMlwiXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1pbnB1dCA+IGlucHV0OmZvY3VzICsgZG9yaWMtaW5wdXQtZmxvdXJpc2hcIjoge1xyXG4gICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMTAwbXMgbGluZWFyJyxcclxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMSknXHJcbiAgICB9XHJcbn0pO1xyXG5jbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdmFsdWUgPSBcIlwiLFxyXG4gICAgICAgICAgICB0eXBlID0gXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgIGxhYmVsID0gbnVsbFxyXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsUHJvcHMgPSB7XHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IG51bGwpID8gXCJcIiA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHBvYyA9IHRoaXMucHJvcHMub25DaGFuZ2UgfHwgKCgpID0+IHt9KTtcclxuICAgICAgICBjb25zdCBvbkNoYW5nZSA9IGV2dCA9PiBwb2MoZXZ0LnRhcmdldC52YWx1ZSwgZXZ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPEN1c3RvbUV2ZW50cyBjb21wb25lbnQ9XCJkb3JpYy1pbnB1dFwiIG9uVGFwPXsoKSA9PiB0aGlzLnJlZnMudGV4dElucHV0LmZvY3VzKCl9PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHsuLi57dHlwZSwgb25DaGFuZ2UsIHZhbHVlfX0gcmVmPVwidGV4dElucHV0XCIgLz5cclxuICAgICAgICAgICAgICAgIDxkb3JpYy1pbnB1dC1mbG91cmlzaCAvPlxyXG4gICAgICAgICAgICAgICAgPGRvcmljLWlucHV0LWxhYmVsIHsuLi5sYWJlbFByb3BzfT57bGFiZWx9PC9kb3JpYy1pbnB1dC1sYWJlbD5cclxuICAgICAgICAgICAgPC9DdXN0b21FdmVudHM+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgSW5wdXQgPSB7XHJcbiAgICBUZXh0OiBwcm9wcyA9PiA8VGV4dElucHV0IHsuLi5wcm9wc30gdHlwZT1cInRleHRcIiAvPixcclxuICAgIFBhc3N3b3JkOiBwcm9wcyA9PiA8VGV4dElucHV0IHsuLi5wcm9wc30gdHlwZT1cInBhc3N3b3JkXCIgLz4sXHJcbiAgICBTZWFyY2g6IHByb3BzID0+IDxUZXh0SW5wdXQgey4uLnByb3BzfSB0eXBlPVwic2VhcmNoXCIgLz4sXHJcbiAgICBVUkw6IHByb3BzID0+IDxUZXh0SW5wdXQgey4uLnByb3BzfSB0eXBlPVwidXJsXCIgLz4sXHJcbiAgICBFbWFpbDogcHJvcHMgPT4gPFRleHRJbnB1dCB7Li4ucHJvcHN9IHR5cGU9XCJlbWFpbFwiIC8+LFxyXG4gICAgTnVtYmVyOiBwcm9wcyA9PiA8VGV4dElucHV0IHsuLi5wcm9wc30gdHlwZT1cIm51bWJlclwiIC8+XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dDtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLXBpbmJvYXJkXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICBvdmVyZmxvdzogJ2F1dG8nXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1waW5cIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBQaW5ib2FyZCA9ICh7c3R5bGUgPSB7fSwgd2lkdGggPSBcIjEwMCVcIiwgaGVpZ2h0ID0gXCIxMDAlXCIsIGNsYXNzTmFtZSA9IFwiXCIsIGNoaWxkcmVuLCAuLi5wYXNzVGhyb3VnaH0pID0+IHtcclxuICAgIGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XHJcblxyXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgKGNoaWxkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7cGluU3R5bGUsIC4uLmNoaWxkUHJvcHN9ID0gY2hpbGQucHJvcHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbENoaWxkID0gPGNoaWxkLnR5cGUgey4uLmNoaWxkUHJvcHN9IC8+O1xyXG4gICAgICAgICAgICByZXR1cm4gPGRvcmljLXBpbiBrZXk9e2luZGV4fSBzdHlsZT17cGluU3R5bGV9PnthY3R1YWxDaGlsZH08L2RvcmljLXBpbj47XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gPGRvcmljLXBpbmJvYXJkIGNsYXNzPXtjbGFzc05hbWV9IHN0eWxlPXt7Li4uc3R5bGUsIHdpZHRoLCBoZWlnaHR9fT57Y2hpbGRyZW59PC9kb3JpYy1waW5ib2FyZD47XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQaW5ib2FyZDtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLXByb2dyZXNzXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIGhlaWdodDogMTAsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMGUwZTBcIixcclxuICAgICAgICBtYXJnaW5Ub3A6IDEwLFxyXG4gICAgICAgIG1hcmdpbkJvdHRvbTogMTAsXHJcbiAgICAgICAgbWFyZ2luTGVmdDogNSxcclxuICAgICAgICBtYXJnaW5SaWdodDogNSxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtcHJvZ3Jlc3MtYmFyXCI6IHtcclxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQgY2VudGVyJyxcclxuICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDIwMG1zIGVhc2Utb3V0JyxcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXByb2dyZXNzLWJhci5wcmltYXJ5XCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNDI4NWY0JyxcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXByb2dyZXNzLWJhci5zZWNvbmRhcnlcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNiM2NlZmInLFxyXG4gICAgfVxyXG59KTtcclxuY29uc3QgUHJvZ3Jlc3MgPSAoe3Byb2dyZXNzLCBzZWNvbmRhcnlQcm9ncmVzcyA9IG51bGwsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIC4uLnBhc3NUaHJvdWdofSkgPT4ge1xyXG4gICAgY29uc3Qgc2NhbGUgPSBgc2NhbGVYKCR7cHJvZ3Jlc3N9KWA7XHJcbiAgICBsZXQgc2Vjb25kYXJ5UHJvZ3Jlc3NCYXIgPSBudWxsO1xyXG5cclxuICAgIGlmIChzZWNvbmRhcnlQcm9ncmVzcyAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHNjYWxlMiA9IGBzY2FsZVgoJHtzZWNvbmRhcnlQcm9ncmVzc30pYDtcclxuICAgICAgICBzZWNvbmRhcnlQcm9ncmVzc0JhciA9IDxkb3JpYy1wcm9ncmVzcy1iYXIgY2xhc3M9XCJzZWNvbmRhcnlcIiBzdHlsZT17e1dlYmtpdFRyYW5zZm9ybTogc2NhbGUyLCB0cmFuc2Zvcm06IHNjYWxlMn19IC8+XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZG9yaWMtcHJvZ3Jlc3MgY2xhc3M9e2NsYXNzTmFtZX0gey4uLnBhc3NUaHJvdWdofT5cclxuICAgICAgICAgICAge3NlY29uZGFyeVByb2dyZXNzQmFyfVxyXG4gICAgICAgICAgICA8ZG9yaWMtcHJvZ3Jlc3MtYmFyIGNsYXNzPVwicHJpbWFyeVwiIHN0eWxlPXt7V2Via2l0VHJhbnNmb3JtOiBzY2FsZSwgdHJhbnNmb3JtOiBzY2FsZX19IC8+XHJcbiAgICAgICAgPC9kb3JpYy1wcm9ncmVzcz5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcm9ncmVzcztcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcbmltcG9ydCBjb25zdHMgZnJvbSAnc291cmNlL3V0aWwvY29uc3RzJztcclxuXHJcbmltcG9ydCBDdXN0b21FdmVudHMgZnJvbSBcInNvdXJjZS9jb21wb25lbnQvQ3VzdG9tRXZlbnRzXCI7XHJcblxyXG5jb25zdCBmaW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQ7XHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtc2xpZGVyXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGhlaWdodDogMzBcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXNsaWRlci10cmFja1wiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAxMyxcclxuICAgICAgICBsZWZ0OiAxMixcclxuICAgICAgICByaWdodDogMTIsXHJcbiAgICAgICAgaGVpZ2h0OiA0LFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uc3RzLnRoZW1lLmdyYXlCRyxcclxuICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zbGlkZXItdHJhY2stZmlsbFwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnN0cy50aGVtZS5ibHVpc2gsXHJcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCBjZW50ZXInLFxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtc2xpZGVyLXRodW1iXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IDIsXHJcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXNsaWRlci10cmFjay1jaXJjbGVcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgd2lkdGg6IDIwLFxyXG4gICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAxNSxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnN0cy50aGVtZS5ibHVpc2gsXHJcbiAgICAgICAgYm94U2hhZG93OiAnMXB4IDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjI1KScsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJyxcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXNsaWRlci12YWx1ZVwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgd2lkdGg6IDMwLFxyXG4gICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgZm9udFNpemU6IDEwLFxyXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgbGluZUhlaWdodDogJzIwcHgnLFxyXG4gICAgICAgIHRvcDogLTM1LFxyXG4gICAgICAgIGxlZnQ6IC0xNSxcclxuICAgICAgICBkaXNwbGF5OiAnbm9uZScsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxyXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnN0cy50aGVtZS5ibHVpc2gsXHJcbiAgICAgICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgekluZGV4OiAnKzEwMDAnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zbGlkZXItdGh1bWJbcHJlc3NlZF0gPiBkb3JpYy1zbGlkZXItdmFsdWVcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcclxuICAgIH1cclxufSk7XHJcbmNvbnN0IGNsYW1wTm9ybWFsID0gdmFsdWUgPT4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdmFsdWUpKTtcclxuY2xhc3MgU2xpZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMudG91Y2hJRCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdG91Y2hTdGFydCA9IChldnQpID0+IHtcclxuICAgICAgICBpZiAodGhpcy50b3VjaElEICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW3RvdWNoXSA9IGV2dC5jaGFuZ2VkVG91Y2hlcztcclxuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMucmVmcy50cmFjay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCB0aHVtYiA9IHRoaXMucmVmcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB0aGlzLnJhbmdlID0gdHJhY2sud2lkdGg7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvcyA9IHRyYWNrLmxlZnQ7XHJcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gdGh1bWIubGVmdCAtIHRyYWNrLmxlZnQ7XHJcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0UG9zID0gdG91Y2guY2xpZW50WDtcclxuICAgICAgICB0aGlzLnRvdWNoSUQgPSB0b3VjaC5pZGVudGlmaWVyO1xyXG4gICAgfVxyXG4gICAgdG91Y2hNb3ZlID0gKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZ0LmNoYW5nZWRUb3VjaGVzOjpmaW5kKHRvdWNoID0+IHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMudG91Y2hJRCk7XHJcbiAgICAgICAgaWYgKHRvdWNoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qge21pbiA9IDAsIG1heCA9IDEwLCBzdGVwID0gMSwgb25DaGFuZ2UgPSAoKSA9PiB7fSwgdmFsdWV9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0b3VjaC5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0UG9zO1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhcnRWYWx1ZSArIG9mZnNldDtcclxuXHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XHJcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gcmFuZ2UgKiBjbGFtcE5vcm1hbChwb3MgLyB0aGlzLnJhbmdlKSArIG1pbjtcclxuXHJcbiAgICAgICAgbmV3VmFsdWUgPSBNYXRoLnJvdW5kKG5ld1ZhbHVlIC8gc3RlcCkgKiBzdGVwO1xyXG5cclxuICAgICAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZWZzLnRodW1iLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICd0b3VjaG1vdmUnLFxyXG4gICAgICAgICAgICBldnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtwYXNzaXZlOiBmYWxzZSwgY2FwdHVyZTogdHJ1ZX1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7bWluID0gMCwgbWF4ID0gMTAsIHZhbHVlLCBjb2xvciwgZGlzcGxheUZ1bmMgPSBpID0+IGl9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBwb3MgPSAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XHJcbiAgICAgICAgY29uc3QgdGh1bWJTdHlsZSA9IHtcclxuICAgICAgICAgICAgbGVmdDogYCR7cG9zICogMTAwfSVgXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlWCgke3Bvc30pYCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLnRvdWNoU3RhcnQsXHJcbiAgICAgICAgICAgIG9uVG91Y2hNb3ZlOiB0aGlzLnRvdWNoTW92ZSxcclxuICAgICAgICAgICAgb25Ub3VjaEVuZDogKCkgPT4gdGhpcy50b3VjaElEID0gbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdGh1bWIgPSA8ZG9yaWMtc2xpZGVyLXRyYWNrLWNpcmNsZSBkYXRhLW5vLXByZXNzIHN0eWxlPXt7YmFja2dyb3VuZENvbG9yOiBjb2xvcn19IC8+O1xyXG4gICAgICAgIGNvbnN0IHZhbHVlRGlzcGxheSA9IDxkb3JpYy1zbGlkZXItdmFsdWUgc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yfX0+e2Rpc3BsYXlGdW5jKHZhbHVlKX08L2RvcmljLXNsaWRlci12YWx1ZT47XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkb3JpYy1zbGlkZXI+XHJcbiAgICAgICAgICAgICAgICA8ZG9yaWMtc2xpZGVyLXRyYWNrIHJlZj1cInRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRvcmljLXNsaWRlci10cmFjay1maWxsIHN0eWxlPXtmaWxsU3R5bGV9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRvcmljLXNsaWRlci10aHVtYiByZWY9XCJ0aHVtYlwiIHN0eWxlPXt0aHVtYlN0eWxlfSB7Li4uZXZlbnRzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3RodW1ifVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWVEaXNwbGF5fVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZG9yaWMtc2xpZGVyLXRodW1iPlxyXG4gICAgICAgICAgICAgICAgPC9kb3JpYy1zbGlkZXItdHJhY2s+XHJcbiAgICAgICAgICAgIDwvZG9yaWMtc2xpZGVyPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNsaWRlcjtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcbmltcG9ydCBjb25zdHMgZnJvbSAnc291cmNlL3V0aWwvY29uc3RzJztcclxuaW1wb3J0IHtDZW50ZXJDb250ZW50fSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NvbnRlbnRBbGlnbmVycyc7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcIkBrZXlmcmFtZXMgc3Bpbm5lci1yb3RhdGVcIjoge1xyXG4gICAgICAgIGZyb206IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDApJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG86IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDM2MGRlZyknXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiZGl2LnNwaW5uZXJcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgfSxcclxuICAgIFwiZGl2LnNwaW5uZXIgLmhleFwiOiB7XHJcbiAgICAgICAgd2lkdGg6IDIyLFxyXG4gICAgICAgIGhlaWdodDogMzgsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgbGVmdDogLTExLFxyXG4gICAgICAgIHRvcDogLTE5LFxyXG4gICAgfSxcclxuICAgIFwiZGl2LnNwaW5uZXIgPiBkaXZcIjoge1xyXG4gICAgICAgIGFuaW1hdGlvbk5hbWU6ICdzcGlubmVyLXJvdGF0ZScsXHJcbiAgICAgICAgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCcsXHJcbiAgICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ICdpbmZpbml0ZScsXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246ICcyMDAwbXMnLFxyXG4gICAgfSxcclxuICAgIFwiZGl2LnNwaW5uZXIgPiAub3V0ZXJcIjoge1xyXG4gICAgICAgIGFuaW1hdGlvbkRpcmVjdGlvbjogJ3JldmVyc2UnXHJcbiAgICB9LFxyXG4gICAgXCJkaXYuc3Bpbm5lciA+IC5pbm5lciA+IC5oZXhcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJ1xyXG4gICAgfSxcclxuICAgIFwiZGl2LnNwaW5uZXIgPiAub3V0ZXIgPiAuaGV4XCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnN0cy50aGVtZS5ibHVpc2hcclxuICAgIH1cclxufSk7XHJcbmNvbnN0IFNwaW5uZXIgPSAoKSA9PiAoXHJcbiAgICA8ZG9yaWMtc3Bpbm5lcj5cclxuICAgICAgICA8Q2VudGVyQ29udGVudCB3aWR0aD17NDV9IGhlaWdodD17NDV9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXJcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwib3V0ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhleFwiIHN0eWxlPXt7dHJhbnNmb3JtOiBcInJvdGF0ZSgzMGRlZylcIn19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZXhcIiBzdHlsZT17e3RyYW5zZm9ybTogXCJyb3RhdGUoOTBkZWcpXCJ9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGV4XCIgc3R5bGU9e3t0cmFuc2Zvcm06IFwicm90YXRlKDE1MGRlZylcIn19IC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5uZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhleFwiIHN0eWxlPXt7dHJhbnNmb3JtOiBcInJvdGF0ZSgzMGRlZykgc2NhbGUoMC41KVwifX0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhleFwiIHN0eWxlPXt7dHJhbnNmb3JtOiBcInJvdGF0ZSg5MGRlZykgc2NhbGUoMC41KVwifX0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhleFwiIHN0eWxlPXt7dHJhbnNmb3JtOiBcInJvdGF0ZSgxNTBkZWcpIHNjYWxlKDAuNSlcIn19IC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9DZW50ZXJDb250ZW50PlxyXG4gICAgPC9kb3JpYy1zcGlubmVyPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3Bpbm5lcjtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcbmltcG9ydCBjb25zdHMgZnJvbSAnc291cmNlL3V0aWwvY29uc3RzJztcclxuaW1wb3J0IHtDU1N9IGZyb20gJ3NvdXJjZS91dGlsL3N0eWxlc2hlZXQnO1xyXG5cclxuaW1wb3J0IEN1c3RvbUV2ZW50cyBmcm9tIFwic291cmNlL2NvbXBvbmVudC9DdXN0b21FdmVudHNcIjtcclxuaW1wb3J0IHtDZW50ZXJDb250ZW50fSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NvbnRlbnRBbGlnbmVycyc7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLXRvZ2dsZVwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZVtkaXNhYmxlZD0ndHJ1ZSddXCI6IHtcclxuICAgICAgICBjb2xvcjogJ2dyYXknLFxyXG4gICAgICAgIG9wYWNpdHk6IDAuNlxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtdG9nZ2xlOmFmdGVyXCI6IHtcclxuICAgICAgICBjb250ZW50OiBcIicnXCIsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIHRyYW5zaXRpb246IGNvbnN0cy5jc3MuYmFja2dyb3VuZFRyYW5zaXRpb25cclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZVtwcmVzc2VkXTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pOmFmdGVyXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENTUy5yZ2JhKDAsIDAsIDAsIDAuMjUpLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtdG9nZ2xlLXN3aXRjaFwiOiB7XHJcbiAgICAgICAgd2lkdGg6IDM2LFxyXG4gICAgICAgIGhlaWdodDogMTQsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiA3LFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uc3RzLnRoZW1lLmdyYXlCRyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciA1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pIGRvcmljLXRvZ2dsZS1zd2l0Y2hbb249J3RydWUnXVwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2IzY2VmYidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZS1zd2l0Y2g6YWZ0ZXJcIjoge1xyXG4gICAgICAgIGNvbnRlbnQ6IFwiJydcIixcclxuICAgICAgICBib3hTaGFkb3c6ICcycHggMnB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMjUpJyxcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IC0zLFxyXG4gICAgICAgIGxlZnQ6IC0xLFxyXG4gICAgICAgIHdpZHRoOiAyMCxcclxuICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICAgIGJvcmRlclJhZGl1czogMTEsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnZ3JheScsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSA1MG1zIGxpbmVhciwgYmFja2dyb3VuZC1jb2xvciA1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZS1zd2l0Y2hbb249J3RydWUnXTphZnRlclwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxOHB4KSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pIGRvcmljLXRvZ2dsZS1zd2l0Y2hbb249J3RydWUnXTphZnRlclwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb25zdHMudGhlbWUuYmx1aXNoXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBUb2dnbGUgPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgb24gPSBmYWxzZSxcclxuICAgICAgICBsYWJlbCxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBzaWRlID0gJ2xlZnQnLFxyXG4gICAgICAgIHN0eWxlID0ge30sXHJcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIixcclxuICAgICAgICBvbkNoYW5nZSA9IHdhcm5pbmdGdW5jKFwiVG9nZ2xlIGhhcyBubyBjaGFuZ2UgZnVuY3Rpb25cIiksXHJcbiAgICAgICAgLi4ucGFzc1Rocm91Z2hcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAocHJvcHMuZGlzYWJsZWQgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgb25DaGFuZ2Uob24gPT09IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWRkaW5nID0ge1xyXG4gICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgW2BwYWRkaW5nJHtzaWRlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7c2lkZS5zbGljZSgxKX1gXTogNDVcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q3VzdG9tRXZlbnRzIGNvbXBvbmVudD1cImRvcmljLXRvZ2dsZVwiIG9uPXtvbn0gc3R5bGU9e3suLi5zdHlsZSwgLi4ucGFkZGluZ319IG9uVGFwPXtjaGFuZ2V9IGNsYXNzPXtjbGFzc05hbWV9IHsuLi5wYXNzVGhyb3VnaH0+XHJcbiAgICAgICAgICAgIDxDZW50ZXJDb250ZW50IGRhdGEtbm8tcHJlc3Mgc3R5bGU9e3tbc2lkZV06IDAsIHRvcDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZSd9fSB3aWR0aD17NDV9IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgIDxkb3JpYy10b2dnbGUtc3dpdGNoIG9uPXtvbn0gZGF0YS1uby1wcmVzcyAvPlxyXG4gICAgICAgICAgICA8L0NlbnRlckNvbnRlbnQ+XHJcbiAgICAgICAgICAgIHtsYWJlbH17Y2hpbGRyZW59XHJcbiAgICAgICAgPC9DdXN0b21FdmVudHM+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9nZ2xlO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFRbEFBQTBBQUFBQjF1UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUVKSkFBQUFCc0FBQUFjYllvSjlrOVRMeklBQUFHZ0FBQUFTZ0FBQUdCQk9XSFRZMjFoY0FBQUJGd0FBQURPQUFBQittMENiaDlqZG5RZ0FBQUZMQUFBQUFRQUFBQUVBQkVCUkdkaGMzQUFBUWtjQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQ3ZRQUFQR0JBQUdpY1BraUpoQm9aV0ZrQUFBQk1BQUFBQzRBQUFBMkFtdW5wV2hvWldFQUFBRmdBQUFBSFFBQUFDUUQ4QVNnYUcxMGVBQUFBZXdBQUFKdkFBQUxma0VLQUVsc2IyTmhBQUFGTUFBQUJjSUFBQVhDbExncDFtMWhlSEFBQUFHQUFBQUFJQUFBQUNBRFBBR2pibUZ0WlFBQS9IZ0FBQUZiQUFBQ2hhSVAzRzV3YjNOMEFBRDkxQUFBQzBZQUFCekttY0xWMm5qYVkyQmtZR0FBWWhOVk9mZDRmcHV2RE54TURDQndZWm54RkFUOS93QVRBK01CSUplREFTd05BUGJIQ1hNQUFIamFZMkJrWUdBODhQOEFneDRUQXdnQVNVWUdGTUIwSHdCUmN3T1dBQUFBQUFFQUFBTGdBWElBR2dBQUFBQUFBZ0FBQUFFQUFRQUFBRUFBTGdBQUFBQjQybU5nWWF4aC9NTEF5c0RBNk1PWXhzREE0QTZsdnpKSU1yUXdNREF4c0RFendJRUFnc2tRa09hYXduRGdJOE9YNzR3SC9oOWcwR004d09BQUZHWkVVcUxBd0FnQWZSUU5wQUFBZU5xTlZqdHlGREVRYlkzM0FMQVI0Y1NjUWhFaFJiUWhwUU00NGdMb0FBUUVEb2hBUlVCUkxtNUFNcHdBUW9kYlpKUURIOEhXcHlVOTliU01YWDZsWGtrdDllZDFhK2duUGFmMGQwMWtOakxrODBnbWpUYmlXR1JLYzI0dnR6M2JJNGovZVF6OE8weXdEZkpGMUV1NkYxbDJZQmZhbU1hMVlDRzJKN1IxMDJRTHVoNXN4ejBFWnpKeVBFSTVQL2xOWjc3blc3UXB4ZUtPZFY1SCtYdTNod0l0K1R6TlpyaWZBdCs3Q1orc29pdGo2Q2RuTzRhTnZpWElNMFFjc2w5YTNtUzhmakhrUERGdUdMTnpiRUdLMzBMS0hRN3loUG9wdisvR3VFUjdUWXVSaEpacjMvVEcrRzVLN0owNGkzbEJIdlRTK0lwamwrUzNDbjltTXZMcnJOelpjMjFxekhaNkhDOUM3dEkrRGd2TVpmazkxTWhKOENmTnZZVGYxYmJQa2N0ZXhDUkFuQVBibXVRcm1DdDNtbWJEYVl6SHdBTUxmUUw1RFRGZDZycUhkU2Y0YnlGbjY1NTdLbC9TV1QvQXB4UExWTWJhQTFvdm9MS0hib2U4bW54ZnpXVVFkaUp3N1F6d1NyMWdIdVY2QUp2UkY5ZlhtaDdXeENmdVBXOTRQdTIvRkxIY2hFM3JMdC9qWFYvQXJ5dUdFL1Y0RFRWKzdqMjEyZlZzOUhlUmZDNzJkQzdXZTdiZDI5RnIzZmIreGxncUY2cE05ejNYS21TLy9GdlE1cjR5TE5RRzZxMkNpeG9mWUQvOW50dENpcC9UZm52czcvY09INVQ3MTBuTk9MMlhOcTRuZkdTUWdKLzB2cGtQczdkS3ZzZEJyUDNoUGh5ZUVQOFYrRnhyNngvWHdDWG92eEMraExGbTZhWUErS1RuWDhaVHZwdWVEaG5ZWCsyOFo2VTNJNzhibW0weXJtZ3pmQ3NOUGNlTE03UThTTnNuYnp2MFgvTW9OenUzRGhuMTdxUDRucFQrekRoYUFiVkkrRzJET2NHMzdYODFOUE43Ry90eDVOQ2h4VlRhckh6LzVEelNBL1pXaENNQWVOcGpZR0JnWm9CZ0dRWkdCaEQ0QXVReGd2a3NERGVBdEJHREFwQWw5Tkg4bzlWSGw0L2VuMm8vN2ZwMDlOUHhUNmMrWGZsMDg5UGRUdzgrUGZuMDh0T2JUeDgrL2ZqMDl6UGJaNTdQL0o5bHYzei8vNStCNFNQRFI4dVB0aC9kUC83OE5QWFRQcUNlazU4dWZyb08xdk1ZcU9jMVVNK1hUMzgrczM3bUF1b1IvbXovL3o4L016OFRQd1BmUDc1QVBpcytjejR6UGxNK2ZUNWRQaTArRFQ0MVBpVStSVDQ1UG1rK0NUNUJQajQrSGo1TzNoZFFONU1JR05rWTRCb1ptWUFFRTdvQ2htRVBBQU5uVnI0QUFBQVJBVVFBQUFBcUFDb0FLZ0JTQUdRQW1BQ29BTWdBOEFFQUFTQUJTQUZZQVhZQm5nR3VBYzRCOWdLc0F2WURIQU5JQTJZRGtnTzhCQ1FFY2dTMEJQZ0ZPZ1ZhQlpvRjRnWUtCbG9HbEFhOEJ1b0hEQWN1QjFBSGNnZmNDQ1FJVWdpT0NMWUk4Z2ttQ1lZSnVnblVDZndLV0FxVUNzNExDZ3QwQzRRTHVndlNEQ1FNYmd6d0RXWU5oQTNXRGlJT05nNThEdndQTGc5S0Q1d1B5aEFBRUVJUVpoQ3FFUUlSS0JGZ0Vhd1I2aEswRXZ3VFpCT2FFN0lUeWhQV0ZBNFVOaFJ5RktvVXhCVU1GVEFWaWhZY0ZtZ1dyQmJLRnVvWEVoY21GMVlYbmhld0dBUVlLQmhDR0hBWW9oajBHU2daV2hvZUdwb2JIaHRjRy9RY1dCeTJIT1FkVGgyK0hnZ2VOaDUySHBRZmFCL0NJRElncGlESUlPSWhPQ0YrSWtBaTBpTWtJMG9rSENTMkpSd2xVaVh1SmpBbThpZEtKNEFubmlnY0tLb280aWtBS1c0cG5pbTBLY29xRGlwU0txQXE3Q3NpSzFJcmxDdklLK1FzREN4YUxKWXM0QzBtTFZZdGJDMkNMWmd0cmkzU0xlb3VCaTRrTGxndWVpN09MOVF2N2pBc01KWXhGakYrTWNReCtqSmlNcTR5eWpMbU5HQTBkRFNnTk5ZMUdEVnNOY1EyQmpZeU5wUTJ0RGNNTjVBM3lqaFVPUVE1c0RubU9obzZlanFrT3VZNjlqc3dPMWc3bWp2UVBDbzhmRHkwUFJ3OW1ENCtQeHcva2ovOFFGcEE2RUZFUVhSQmtFRytRZ3hDbWtNOFEzaEVMa1JVUkxaRitrYkNSdDVIMGtuVVNlaEtIRW95U21KS2tFckNTdTVMQ0VzMFM0aExza3ZRVENaTVRFeUlUSzVNMkUwQ1RRNU5PazFLVGJKTnhrM2NUZzVPWGs2NFQwNVAwRkFxVUQ1UWpsQ3dVV0pTSmxMRVV5SlRabE9XVThoVU1GU1VWT3hWVWxXcVZnQldhRlorVnQ1WEdsYytWNEpYd2xneVdMNVpNRm1LV2V4YVVscWlXdnBjTGx5OFhPaGRKRjJBWGFwZDRGNEFYalplVkY2S1hxQmV1RjdFWHR4ZTZGOEFYd3hmSkY4d1gwUmZlbCtZWC9CZ1NHQmVZS3hnL21Fa1lXaGhxbUhHWWVwaUVtSTZZbVppb0dMS1l2UmpMbU5PWTV4andHUGtaQUJrSUdSS1pHaGtpR1NhWkx4azdtVVVaVnBsZkdXOFplWm1BR2E2WnVKbkhtY3laMnhubW1mVWFBUm9IbWhzYUpSb3ZHak9hUkJwUm1sdWFacHA4R29zYWxacWNtcVVhclpxM0dyK2F5UnJRbXRxYTVKcnFtdlliQlJzVEd4MGJLaHM2RzA2YldwdGttMjRiZVp1SEc1R2JtQnVjRzZ5YnQ1dkRtOG1iMHB2cm5BQWNJUndwSERnY1d4eHdISkVjcmh6TW5PR2M2aHp4SFJpZE5aMWFIWFNkZVIxOW5ZSWRocDJLblpPZG5KMmxuYThkczUzckhpTWVNSjQ3SG5xZXNoN1ZIdlNmQjU4Vm56NmZWSjljSDJBZmRoK0RuNXdmclIrN0g4S2YwcC9oSCtvZjc2QVBvQ0tnTHlBNElGVWdhU0I5SUl5Z2xxQ2RJTE9nd0NERklOQWcyQ0RpSU9tZzh5RDVvUUFoREtFV0lTMmhQQ0ZRb1dnaGRxR0JJYUFoczZIRm9jMmlDNkl4SWxjaWZTS05vcHlpcWFLMElzb2kzcUxwb3ZLaSs2TUVvdzJqRmFNY0l5WWpMaU5HbzFZalhhTmlJM0FqZTZPUUk2TWp0S1BBSTljajR5UC9KQldrbktUZkpQSWsvcVVoSlRjbFZDVnNKWmtsdHFYc3BnT21HS1lvSmpLbVB5WlhKbUltYmFaL0pvNG1tcWFpcHJXbXlDYk9KdG1tNDZjQXB6YW5VNmRzcDMwbml5ZVdwNmFucjZlK3A4d240Q2YwcUFNb0N5Z2VLQzhvUWloU3FGOG9ZcWhycUhHb2VTaUNLSStvbUtpcktMVW92cWpLcU5PbzJha0hLUnNwS3lrM3FUNHBRcWxpcVhrcGdhbUdLY3NwN3FwU3FvMnF2eXJTS3djckhhc21xeXlyUWF0TEsyU3JjeXQ0SzN1cmdLdUxxNU9ybml1bXE3WXJ3YXZTcTk4cjdpdjhMQm1zTGF4R3JGb3NaaXh0TEhTc2dpeU1ySmVzdUt6T3JOYXMyeTBITFJ3dEp5MHhMVDZ0WGExNHJaT3RuQzJncmFtdHJpM2lyZ2N1TVM0NUxrS3VTQzVkcm0rdWc2NlVycmN1eWk3Z0x2VXZDYThXcnpzdlk2OXpMNE92b0srMXI4a3YyUy9rcit1ditqQUhNQkF3RjdBbXNDOHdQREJBTUZNd1lEQ01zTDB3OHpFRE1RMHhMREUzc1VBeFVyRnJzWk94dUxIRk1jK3g3Ykg2c2dheUVMSTBNa1F5VWJKMHNwc3l1REwvTTA4emdMT0xzNU96czdQTXM5NHo1N1FJTkNRME9MUkhORTRBQUI0MnF5OUNaUmtSM1VtL0NMZUVtL2ZsOXp6WldabFp1MUxydFZMVldXM3VxWGUxS3FXV28xMmxWcXRIVUZMSUpERlZpQWRJMk00Tk5nQ0dRdFRad3hHV0lBYmJJTXdZMU0yeGdac3o4Z3lHUEJhd0RtL1BmeGpXOE40UEl6SGsvcHZ4TXVzeW1xRURHZitxc3g0OGJaWWJrVGMrOTBiTnlJNXpEa2N4LzBDdXBiak9jTE5mZ3B4Yy9zL1RRVHVIeHFma3NTLzJ2OXBIa09VK3hSUEw0djA4cWVKaFA1dC82Y1J2ZDUwbWs2OTZWU2N4MTkvNTUzbzJ2NHpEbXBDYWp5SE9BNTlBYTF6QnFRZWNGdzFKRktsVks3WHVsNm5FWG50U3RDRkwvcHRTUkNWL2kyS0tFai9XWFJGdDlmclpUUWl5MFJETnl0Sy8zUHo4NnNYTGtCNm1PTmUzT0xXMFFZckl4ZFYyczE2aFcrdXI2L2JhL1o2dk5aRE1YMkdpOUVtV3VNa0x1YTRicjNaYmdiTktMUVF6WGtPMVZaUWt6UWJSZFRzZHZhaGVuTnJmWFZ0OVpUTEszeTYvNDQwSEp3ams4c05BYnRQdTVodkxrKys4N1ZyYS9lbzRXVytmMW1vZHBmNW1SbCtHYktnTllOZ0hlb21jVnd6eVdWejgvekcrYzNOemVIOU5VUkxCSFQxYXUxV3AxbHFoSUZ2WVFsS3dmTXFRUVdpOHZoeHhWY2VSNFNYaUtJUWtlZWZVcFNuaHUvYnlFWG51UlRRRGNoR3k5N3FRTUVocVVhWVIxMElmYVRjbzVpR2NxL2k1cFNHbC9FYVNzNTkwemxGT2Fla1hXWCtXNGJyR3QrYVY5ejBKZVZ0ZDRObVVBazI2UjhVZVpoZnpGRzYwZkoybWxCV3g2ZTU0bHByQlgwMEtaL0VZMW8rZERNVXYvK2Q3ZUlQMysraU5YU1VsdGVqWmJNUUpPSkxVeWlDa0phKzNlcmVyMlJjWldHblhGQlFCZlZHU3c5MU1VemxrdkpXU1J2YXVvM1dkMHE4cTd4ZEtHaXQ3UUNORzBWTWMwN3ZvbWRsTjdVdktXdEVXd1ZKWlZwUFNLWkZ1d1dsOUgrL2hJNExpcHRCdlIrbTl5Vmw5YUpLVUdsWFdERlpnUy9wQzFYSWpuWkZJTWNLcHUySmxuWlQ4NmRldmk5NFhWcExsTkFVa2lyWGxoQ2hwWCtKcm9ENGw2akRZQnpCR05uZ2J1UFdvVVFtMUx0ZW8vL1F0N29kbWtFQkJ6NlI2RCtsYkNWNUFocHdjRHNLbzJhM1NXOEhmdGhzZER2dFZwSkFwWnk4RmZqd0NQelRlOTM2Nk1VQ1l0YzZPKytnWHhrN3U5aVltU29VYldjc3pzOU16VTJlM0QrbWFyWUx6NmNLdkZMTFRrU1JvbGhtS3NyNHJpMGlzWlBDQ010YXlySjFMUXFLaGNwNG9SaWxOTU13bzNSY3FzL1Y0dElIYmNXUUpGRkFTQlJzelRKVVJjRThRcEpJNUlucW1HTVhpdU5UYy9OWEYzS2VrNW8vc2xETDVCMVBVVk9PbGNubXBqS3B0T2NhdXFxYXFRZDBZb3FhbWNsT2pPWFNvYThvaHBIT0ZNcVZ5VUljUnJwdUc0WFB5cHFtdW9halNqS1JWRm15VE4zU0RZbW9SQlNCVXcxcGJYQVJCMXdSZVNXdjJhYTlqSTdpZWdEeDJoUXFTM3lKcndRaGExQ2djM3RYSEczRS9WN2NPOXFVbTBlM05qczF1ZGE1Q1QyY3J0aHV6clUzV1ZoQmNYOFQ5WVRtMGFOTkFmNXFuVTcvTTRnYlUxM1RoWTg2dGhOalBMSUhaZXB4SGdlc29WdGVRaTNnVG5sb21UenlwNkJYVmVxa1Nib1ZWVlhSbTlTcUNwOWZPYmVVUGJmVVUvK3JxbmJVVjhKMzY5V25YcDN3NU8yMGlsQzc3UlJLMjZsRzdTbTBoRXBCYVFrMTBXZG9ZdjFIV2NLV0ZmZC9EWjJLRWNkU1pHbXY5ZUo0TTQ1Wm54K20rNUtwN2twcE5JV2ZvRXlWcVBrU1pUb1ZMN3hra1M1Tjl5WHB4cExjaHlENTlnajF3aitOUHhWRDBxUDBneVI3TVpXUklOUCtEL1NQT1c0dmQ1anl6aUphS0tBdVRadU9NeXE1QWhqdlZJQ1ZsM0JOSWdHUjZpREdPbTA2ZUxwQjJJRjRDL2dybENHSnpTTGQ1Zy94SXRaRjRTRlJKcWNGNFRTUkh4RkVIWXR3M1RiNUd3VGhlc1IvQUU0TFBGOVFWUnJ5SXBxM2hRTUM1cC9DcXZDQVFNZ3BRWkJQRWZLUW9PS25lSjZIM21XYndobGVsSzlGUXUwcWVMREF5L0QySDE0bHFTd0dHSUVUdHZ1N0J2Mjl4UzF5bkV0WlZDSzAvSEFrM20yQWlJRTJBY2E5RDJnWE5qclFHSXlmUU1SelNzNmJjeTUwN2YvRXdpT3kzRitWNWNWOExiOWU4Tnk4M2Q5QVBkZU1hWjhlRFdibC9ubFpSaGZrQ1R1SzdJa2s3RjlBM0l1c2JJQU5Oa0JtcEVCMmpISFR0Ry9Ra2pCK1RNdTFEMUZVMElnV0lxblJhZFhLa3Q5cHRNb1NsV1BBWWRHYlRkODMreCttNGVHNllwODIxSW4zbk9oMFRuVCtKWmY3N042SmliMFRhTVl6djBydmY5WDB4alYxNGkrN0o3cmRFNi9PRlNmb2JjaGYyc1luRG95OUVsZmxKcmdaVmc0bWI2bGNXSEFXUUpKRlpSS1UycldLMCtpMlMwSFk3QUxDSUJSbHdCZDlXTGR0dmY4d0RSME5vM1dzYWJnUG9iZTV1YmJSUTJ0dzh3ZjBKcEoxTzlaOVgzK1IwMS83V3IxbjI3RnR6ODl6U1R1OUFMUzR3UGxjTHFGRk42RUJ4U21VSnRDZloxR2xBelFJQjdRWVBaNklwNmRqSk5OUXVNbzByMmVOOU9CSU9EOVIrTlBDNUNRRUU3Mk8rcHpMTG81OEVybTJYWWFYenYyU1hIYW55ZVJZOG42S200VVVJaE1CSjdWUXV6SnNUZWhOMEp6ZWRwSjF5bXByU3hqeStaY01YL0J1SUZMYjluTlpEOWN5RHltdnlWU3JHZWU0WU55UnFSWXlWN3VXdzgvTVIrNWJ2Y3dkNlRMYVUway9uYTcwOWd1VjlObkxNK1ZkTktUOWFad0R1a1lVUUZDY1Iwd1VTRUhFSkdMWnIwZy9pbzdQblhua2tZOC9Va0pZQ0U4TE1pOGpWRDM0UTdSRUQvM0s2MTUzemI0RmhKRk1yaXRpakt4dnZ3UkIwVWg1Zm5SSlhpTEhsMGlmRytEdEpMME0xd1g2MWhiYVZCNE5aRDZ3bzNvRkVyVlF0K1UxRWhBMXpBaWlDWEpvZFpkUkdxVVdoRHVQUk1ITTVka2lFZ1JlV3RULy9NaWRPWVI0NTdBRXAxaTJnK2pJSGJ5K3RnZmh5bVJ2TXRRUDN5NjFkWXpERlJIZGRQdmh1U2tFa2xzNmxvR1M4WUowOXJEcjdEa3hpbU1JOUdET0hReFRFWkFGc0VOYUNvWklBSElIUG5EUUtHeDBILzJ0UitHRHJrR29pSGlNWGowTlVCenhhVWdlbjRTa2ViVEJubkFSWUlVVVF1K2VoUHR3Rng1Rnh5R2FZREVFTkhrTGxVdGNBWkM3aWVxemlJSHpzSWk4RG5vMEk2bi9XUzBhOHFGQ1VVdkYydTIvb2FLMytTV3ovN3docWRMUmNsa3ZwNUJ4SHlMR2poNnhBZGd4QzhmUUIwMkFnVzVBaDZpVFFEMkt4aVAwU3hqL0w0a1h4WGZ4R09PY0xXRkJXdjB5Rm5nQlhRM2l2cjhwaVkvekFrWUNMdGlTZEJMcWd5RnRIdVRWYjZNbGhwRVh1cDFFakNSYVVDZmErcVFzRjJYNTY3ektmNTNGM3ZkUldTN0k4aC96L0IrenlLQjhMMzRYNU5NSFdScE1HdEc2d3Zzc3NUTTdyeEFGSWgvZEhFbVUwRnVmcEdud0wzNFhjWU0wRnBqd29nZzJTYXY3cXpRTmhXeG5TNU1veUdTblhFazVlTzR5cUV1UHBVR2twQTZOcEVaejZJZnE4c252WFZLWmozSlVaNFQrc2diOXhRSFp0TXdkNUM3bmpuRW5xY3lGdExibFV0UU1vM3JaYnpaYUF5MW9DaWZhQmVVbndFWEtjQTNZRkZ4aHpBU1JBV2V1RDc2cjBHT0NiQzBiNEJTL0JwRDA3WnB0YTAvOHZPWTQybEZOcnVvYVVqUzlLdXVmUDM5K1krT3RiMzBPeFNXQ1JDdndzbGt2c0VWU1dzdmxnSUUveVJqNDNZQXdaYzNvZjA3WDBSV0dKaHNiREl6MDJHY3dSdjhXeHNDSG9IWXpJMk9nM3UwTXhzQmdQQlpCUzZDam9MR0NLQ3luK0tFMUdBMG5qcCtRcEpEbk1YL2lCQVI4SUVrblRtQWNZQmtmVHk3dzZFUHMyYWVQSDVla2dPZVBIV05QSFQrQlpCeGlmT0k0bkVKZjNLVVhaNm11dzdRVWtpaFg5VVIvN1NiS0lYcWQ2aGUwUngvVmNxSDJ0cmRwWVk3R0M3NzY2QklMSHgzYzNZbVBwbDFsYVROSVJKTlBsR09hQTFTcnlmSm9KbDBEdlJHZ3NDQkt3cU9QMHJBbUNJODlCb0JNRXVnVkdnSThlMnhKMElXcVFCK0JneTQ4K2paVmhRZmY5alo0VlZYZWx1UTdEelJlWmJwNFkwZUI2d0IzZzdGSmd6QkFyeXJQejVmNy83WGFMbWVGVXFpYjVwN3kvR1hmV0tpVUZ6clZ3cHdTNWttaGVuaUIyVVZvUGQ2QTNnQnRwdE82MEpKQ2cwVWtzdEFLSGliUGVoeXBETHNiZW9OaHhOMmlvUi9zZnFwblBoOGJhdjgvcVlhaGZpVitRbE9Sb2FDYmRLUFlqUTFqb3ZzSkV6ckhWK2hOMUZDTldPMy9zNnB5bzlpTWNCYU1nT0pPZnhtS3BOb2w1OCt1N3RtenV1ZXFzVXhtTExQQWVzc243anh5NU00anFMU0gzam1kb1hlK3ovckdONC9RTzl3QTQzQW9obmJ5UVM1T0F3WTh4QjJsdFV5azhMQnFnRzZoVXdZK3hHRHN3WFc0dlIyUDJqdFh1aVB4ZXJNZStLaUFEZVcvSzZhcGJFakF0RS8vdi93VlBQMjhBZU0zOEJ2NEYzbitGM0dNUDgvem44ZHorNjlBa1NUOEQ5VTBWYlNxbWhqek45a3FEM3ppVVJaZU9SSS9lZktnem0yM0R5MS9BQzFlK2hFbEQwRjNJODBFYTFSQW5PaFFJc3VpSlpMUU5mek5lLzl5NnpMTmVTdUtlT21mVmR0VzBWV0tDVUxsSnI2ejh2M25IZTNxUVQ2cndLYm5tVDFMNHpnSGtKNDQrR0t1enlWZlpNZnhHdnNNOUswWUFjUURmUkowdHlyQTU5YUFFWUtvcDNySVFNdEJjLzN2T1B3N0ZGOTVCNi9yZXYrYnVyNXVDOElYRk9WM1FDR085WEVkUGtPZEJyQTA1M0pMMUZKVnIzWDI0VWFZYU96VVZOZEpLbzhacG9vS09DSlNSSFVPSms4N1hWRG9nZE1zWTAvbHNhaDg0UXVLaUhuMUk0S2NrWVV0Z2l6eXVjL0p0c0pQSC9DdkFTRXFvTE9CQkxlazRDeElLdjVxdnplTnBrUkpFZ1JRMVcvQWdvRFBnTDcrSjhRMHlaOG9BczVQR3pkVDBZdXVNWG5BRFNhSWJTemNiRXpuRTlvbHVoanR5WFVvZVNNeWhVcDVGdGVYMGJEM2RobFFZWG8wYlRacDYxVVBacTI5WS92eVkvdjNsOHNIN2dpT3RkdkgyamU0Sm1oQTA0VkNDSXBENzYxWmM5NzEzZWxpNWNES1gzYU9kVHJIRHBzdUlXR3hPRjFVRTV0bWpONEM5RmNCQVl4UjVGNUFlVlNpQnI0dWNJRktDN2pCaUxrUkNBVXdIaTBSSXZhM0ZPMHJtcndwRXZuZlhONFIvUDdYZk1IQmttYWhBMmdGS1dvdVowb2x5VkJrZkV3clBCc0VuL05Nb3NhSlRUUEJDQm1hWTNXWHp0S3RVUmxhcFFLVmlGRzlDNnA3SlNKZGRJRWFrZnJyUkRGNHBQQTJldEFVRk1IdS8rcFgvT2F5NzYwMHZjWUxpdlM4cEVCZ1lDek9tTUl4d1o0MWhVTy90M2RzTDN6R3VCSGJSWWJyZ2F6a29sbHFmYVJxYVlOWmNpaW5naTVDalVjOFJZVlVYVzBNekQ3MWJnUVNoaGw0eWdQTEVQQzNicVZMbXE5cHJUeDZjNldFZU9UWjdXRTBwUlhpaFFrYjBCaUNQdXQyWmxwajNiZ3hvVXVEQzkyWjlsaTFkdTNQMXE0Vjh2Y3MzL3lvQm9oUUdjWmtDWTNQZE9aWFEwQ3pBT053M0I3dnpIUVdUZ1VTVHM1YkU3Lyt3QzgrTU1Beld6QitOamlSNDlvZWFmTGRyZWJQYlRVM0VMZjVJcmM1R0YvcjBMNFdHL2tOYUVvVFUxb0RtWnZWcUFTSUZsUGJEVlFmRHVoVk9rRTZ3cXJjLzZJdUl3UDc2RHJjZjFvQy9Lc2Q5eVZOMDkxM1c0aVQxZDhpUkZMVlovMkZrdDVVQ09KMVF4aklsWFdRS3pyVmZ5U3lMRFRiRWRtNjd2WXFKcVdaYTFzYkcrK3I5ZVQ4RmQyWjFRcy96UTM2QVpWL1U5U1NOT1pIRXFuQmFJU3dUR3IxVG8wRzdWYTkwdzI3SFJvMnVtRUVnNVdHZ3hHQmJxeUtXam1YVmtJN1BCRzZnVEpmVTZWcWxTamxYRW9KM09SYUtsZld4TDlmM2J0M2RlOTNEc0dEY2k1ZDFjUnFWVkpyOC9TaFdqa01iVG1YWXEvQ3hWUk9EdTBQN0tVdmpKU3h6czFCWDYxSTBPeDFpUVNWZHExTzZ0MWF2ZEp1ZGxqdm9CcHRHSFVqRWtiTjdmS3RUMHRhM0NtWnFSTVp2ZFNKTldsNkN1QmJKKytrVDZTZGZLZWdpVk4vUGgzSDAvRUhQRC91eERLWm5aVUpSSHp2Uk5hRTUxUXlNVUZVZU5BUGJvcnBnMUFjWlp0blVwdEVCY3Exajd1Q3U0YTdsYnNQK0lZUGZCM0dFVFJtRVAySXVQai8wek05MGlEd1dkOTFlSkg3OGEraU9ra2lPNTlQL3hoWFdMOUgwTy9mQXYzK0pNVk9FcUVtM1VUamJrQlRkRUNIcWRNdXZtUEVwVHFjQ2VBS09ucVJvcXFFNlpScjhHUml2d1VnbHhoNTBWdXdUTXc0a3lvWHc1eXRZVUVSTTZJZ2dFRHd6V3lwbk5WQ0VBbUNBQmNWQVVrOGIrZkNZam1WaVUwaVk2SGxpWVpkdTY0R3d0eHVQVisvUFRVZlYxTDNwc3NwWXBXS2pnV3lRZVdSSXhtRzZDSklSWklzSjQ2SmhuRUtIa3RWNHZuVTdmWHJGMzFlbFgyZmFNUmVITldwTEtaVFVRemM2ZzZ3SjNwenVmekpUNWJMaFZjVXNybkNHYlJXdWFQeW03OEpRUnpuY3ZFSXp5TWdFYnM3Q0NucUFGMGtacDFLVE5lVVNrR1RwaHNPYmVXRUloUnFKUWVKbkdEcmYwYU9vYnUyYnJnTGVqcFZ5M201QlVFcDJ6S1dNOERtaFRvSVM4WDBCbHJuN3h1dW5YR3NkemxleVhNTmJ5R1FyRkNYZFVHeUxDTW5DSnFzeUlvNXdQei9EUnIwM2R3NEIzalNZL2t6bFR1Z25hMU5ZU25USHJlTFdXbFJSTXdYa0lsbTBUTDZWdDFUaW9FbDhtU1pZSVBrTkUwVGRNM0twQzF5NVhSK2R1bGdrTUc1OFF6T290Y1Uyc1dNbGpaMVcvRWxjZFpYVTRRb2ttT0ZwcHZTNHF2eWZ2OExLRE9aeHVuSnpDZytWK25JcDlNZzlOdEY2L05yYTJ2em14c2I2K3NiVzBOOHRRblBFUmlQczhESkVsdUYzeDJ4Z3RIWkhERnlXbkJDbkc0eXM5Tmc4QjZkRzgvbHhuTmpPell3VkxyZDZIOUF3MitXRlUzcUNKSktYQ0xKV3puNjNHUHcwTFBzb1NPNi9RZjNJZ0d3MEw4OUtaTjkwQ0Z0a2RrRWs3S2t1UWxBcWRmQTJVQ3JyODRDRllsRVIwVUhCQ3hBUHBIS2RtQmd0WW9JY0RUcWlvQk1LM080VEFJTEJZbnFnUlBkaXFvZmRWb3JOZ2VHZmxVMWdQU20ydjhNUkxDbEdDaEFtb0xHSVNMMlgwQ0crcGQwUHFQL3YxWGJSZGVxMnQ3OEg2dVlKOUtka3F5SVU3d0FrTklSSlpuUE9wWWZtUEJGTFdRcS9mK2w2c2hHdWpxTGtDYi9WOWxBS1RoMlZNWFFpa2dPRmZUcDlKMS9nR0FVS2dwYVdTZmtmb2tzQUZyV0JiRjB3QWYrbUF1NFVSbXZBWjdKSjd4Qm9pZ1FnTi9RU09XMWFWUFNLVU40OHEwMzMvd1ladUZ6elBLa2h3ZkQ4SXZEYXhET00zTlUvMzlxSDljM3RHMDdFcmVPTGdBbkJ1MGQxR2c2bXdmZjJxRGQxK0oxd0xjNmExYmJmc0dlWnkzSHlwYllueHpvNTIwNmxnZFlqdklzcW5QNUdJcEpwNUVHeGlZS05oalQ4b0ZyVVh4YWF6Vjg5UEQ0SXg5LzVKRXpoenV5YW5nckxjdXlWRTBtaGljNHdkakpzUXE5WUxVcUVIMW1FKzNySEdiMnNYSFJBd1hyTDlubHdCRThnOGlhT255T3ZYS0tUZlR1NkFvYThJc0NZSGc2SlRBd2JIZUFHY0FBNUIzR0Y1aTlRSUdHVS9yZlY5NldVMFR6clBSbmhQeVpoRjRQbDk0THJXUktNcXIwLzBHU2tFZDV0a2pUNWpZWkg0dEFueTZDN09LOGdVMWlvSXcwUTVvMnBEeUovSWJiYUpXN1RzVjVtbW83RjJpd0tLUUVJYVhMc2d3RUJvNElYZkRpVUJXSzRXci8yZGpldG8xejNOWmdUQllCWVhDZEFlZTdORWQzaUs1Qm9sZWtSQzA3eTdyQ2E2bU40MmthZFBaUFR1NmZmQktyait2bW84YlBlQm5QeXlCMWRDajJOeWJwTXovM09tRGx4b1BXVU8rS1FkOVpZOW9RbmZkeFNveWNCUFFoK2pXaENHaXIzMVBSeDlXNHY5N0RYUGZjVjgraE0vMS9SWkw2d25QUHRVWFIxalRvYjlSUTl5dm9MWUJieDZGSEY1QlVoMy9vR0V5OGdhSU5XZ3dNOHBCMDJyUDhIQ29JNkNsWlVFa3dhVWR1NS9xeFkxa1RobC8xcmp2eUU5T3lPSzNPWEx0bldsTUZ1OW0rNmpBS1hJUU1UNVBsTUw3c1EyZDhnYTluN1ZUcFZRdXlycHJXMUdSVjF5Uy9QVHMvck04YThNT1l6VlVmNExnVk5MUkVBeVJPSmp1QWR0VHlWSnRDMUlnWXdlM0tZRUtRenBic1ExVDRicHV6RytIbStkTGNYT2w4TXlUenJubWVUbm5ZdkEzSVV0cDFPczhlU2syOE1EOVhpa3R6ODQ0VkQrZEl6SlFvemxNUk9uTE9Ic29POENYM1Q5QUhUQzVra2crR200Vm1oZmEyUGVEeXMxZnNMeFJFZTZLWVdac3RsMmRMYVAzeVJ2T3hpWEVwWEZsYWpSdXZMTkdyUTE4TnRNNTBoMGxtaldaVndGUi9XS0JVR0FJS0ZOQ0xkZUNwQzhCSHBWQXhESVgzeml3dm4ySFIvdjkwZnRITlpjZkhzN25ZVUw2bUdNWEROOTEwdU1paXFGZ3NVdTByandxRC9FNUNmaEcxdzNlRFpjVG1sd0g3UWo2VUpaQmdEblZCT1FUZzBpNGlDM1ZOeENha0NWVlMyczlXRjFRWldnQ1gwTkpDWkovSVRMOFpyU3o0RGtUMkliZ244WE1ZbFg1K3I3U25Ia1FXbmtMODlLTFFQdTNJYU05bFVmMzJ6bW1Ic0ZoenI3UzNGa1lHUHcxNnkyeUhsZXM3M05NTVQweXh1VERHOFlLazl0UjBBRU9yVm0vVDJVTUp4bGNsWUZkcGE1K0xneUFPL0t4dGkwR0FvTHNDSHJDemZoVmRHOUk3aGJ6M29Lb282ajM5N3hpNmFuM2tJNmFtbWFod0Q3MzJvQWVjbkVwaEp0dmVESHk5QkJyREVlNDBZTjQ3dVB1NTEzT1BNbTdxK0dSZ1FxUGZPaDNmekRZTFE0UnZrNkFidFFrallic09TSjBBbUlpNmNCbGdQSkFSN2dYTnFFd2RQT0IycHdGQUhtZ013NnhPc1NGb0hCRU5TVDJvdDJrRVVpRzBpNE51VXFmd0h4NkhGTkhuQ0tFekFMZmRKcFBiYnFNK1AvZEE1S3hNdm5mRlhVY0YwUUlXZFZUREttaDE5eHhGa2k1aEFZdEhDWThsaEM1ZWdVVWtpQ0wrQVNHYURJbUlDSDNVd0pxcy9Za2xpQVovcXlocFdNYThqcjZtcWFxbWFqVFVVRmRVK24rbkNoZ2ZQQ2dJOUNzcUtLMklWeVFuL1c5L3YvSDl4c0piTmFRWUluLy93aDBTTWhENitNTDlvRzFxRWlKWWZQM0NlUXM5K1AyRjZ4RElYb1IrNWpFc1FyRXdobkVpWTEwVzAwaEV1cXhRZzRhT0ZjeHJTTlJWVlFkTmtJYURmaHBEZjZoVEhhNDluQmR0N05pZkpWS2hsRXhjT3dCOVZFRHI3Zzd2QVEvV2JXMzV6TEptNjB0ekdDdThidXU4Z3ZIYzBtVXp2ZG5aM3N6enNxYko1c1R5OG9USllndkhkUURPZTJWZGwvY0NsTmFQTDF5SXAyZUtGNHJUMDBYS28vQ0xXOXd2UVhsaTdpQjNqSTM2S0xIKzBNa2lRZzAvTUl6S3JjcVFkemJ5ZzhtZE9kUUNwYUVObWswRWc3bEpsZjRHblVFbDdSWTExZ0hIbUpSbGlkY0VBc1FUZkE5QkZ4ZWc0WWlnOFpJczM2Y0RvTThiTnNKRXdhRERJeVFnSmZRVk9DQ1U4MzIwRVdkVFJjT1NlSVNSS0VMQVM1WlJUR1YvUnNjdjZJWWs4T0t0Yjh4aG5VNTFJSFNxcEdrbGJhamZBL3FubzQxTi9DWEFKZm15U2NCS1lyTmpDR1R3QmFiMGxTamV4LzdpcUhDbUVNVlBzcjg0UWh1Rk1GZWRndi9Kc0hEbGxZVndrcDNrd3NLdStTZHR4UFlPa21wZ1dWOTdrUnRnKy9zSFBnMVVLOW1pVDFmcDB4VHBRdDdvTnVxZDAvOGRHbTR4V2VrTjU0YVM1MEdTVUE4S3RMN1I2NDNpWncyUVFZVmFLYlpuMHBzSWNvOHE1VzVyR2JlNyt5aGlva2lJb04vVXRQNFo2UDlQOU5mLzhhWUtraDBGemN3Z3hSSDBDSzFyL1grQlc2cjJJcmUxdFU0d0FHaCtaa0xnaVFvOUs4bnZBdVQyd3NCdXpIVUdYQ3k4NUhqRlpENC9tWDlnSkx6QWtOem9aOXNHczg3R3dHRG1tekI0UWJrZWNCVTJaYmx6eFdIYURMcFhNWFNqVUEyS3hXRC9jNENpc1JWVmcwSWhXRUtXOWhjODJ0Q1YvcC9XN1NBN21kMnMvWDBFZlF0aEYwNVFRZlg0RXRyR0Y4eTJrOWdCZHJYQnJ2YjRFVzJERHI1MGZOQm02OG5oUlc3UWhEUy9xMUFQelEzdHU3UU5xd1A3THVwUmZ4MzYvVFZtMjJVZUpnTWRDbHI5WWE1Rit5K01JemJXcUtHdkU0VUI4YVZ0dFIzdVVWY3FPS25YaUxUTlJKN1FVbEVwbnM4WHNubmsycVl2QzVyR0M2TGpPazU1dG95cStoZnJxV2h1NG5zMTIzSGNzVy83cVNqNGhDRHJud2dFb240N3JhaXFrdjVlc1JRWHZ6akU3c3g0c001b3huV1pndWt3YXdiejMwaE9tMnY2RVIwK1AwOEQrb2Z1cG1IL1NSYmJTU2Zwcy91cGRzaEdYcE9PU3pLRkVzY3lLcktweVpDYUlqcHRxb013TzdRZlVrZy9rTmIwSDcxcnN0bUVqN0c1aVlVcmRTZVNYUkdEQkJDQkRVL2ZOQTJoeUFzeUZsMEp6MkgrU3VGaCt2RGtNeG5Uend1Z1VZVUMxcU84cXJ1S2pXMG5hcmNqQnlLS3E2djVTQzhJMkVFbzcrOHVjNHM3UnpVamdHS3QraXltQlZ6bTk2T2RzclpxYlZaWW4xcEJkMG83cU5reWVybGE1UkFkb1BRL1FEL1R4UGdzUW53bXpSdWc5Z2xJNTVISVl4NmozUDQ4Z2lNdkl0NFE4ZGd2L3djc0hCaFhiUUZVVlhvYlYwL1dJQlF3THlQQmxuU0R0dzhJK0EyZWVjTVZrcXlHS2dnbERDS1NWNURpZVpLcWl5QVRUTkVlcTFxaUNRb2kwVlhKOCtWQVFJOGYwTjIwcGVWVkx5M3J0bXhnVURmbjVqM0x4THBpNjNMYVUyM1pCRzRzcFYyOXNtdStEMUJYNlNkdXlmVWZzd2wvNHJhalBPWTVhTHVMekxNRkJsRVlGSEdkMUVrWEVFNnJRNTBaYXhVTHQ5ZzhLRFhoMEFrVTBQVC9WVUpTazBlSGRQMFF3aTA0QWFTd3ZLNThWblI4Ui95c3NyNHNQMzRzaHdWVWtsMDdqbTBvWHdrSk9IZU01NUd4a0pZZVhXa0VlL1lFRHp3cXBSY012RTJmWG1LTHFvWStFWGQ4VlNQVUJxYjhQVW1rc2xrU3Y2SGtsRi9oZFJsZEorczh4KzMyYi9CRzVRc3pyQVRVRjJnb1o4N0g1OC9IMjZMbVBEMjlkQzQyY2NZZHdJcUJvK3NBZmlRODdxM0FzOTQ2akd5Tm5pU1JrZlNvL0FxWWNZY05ZaXFYTmpaNld6VFkyQmdwZDViNXljRkQ3TnNrN0Fzam5uNHJYZmg2Y09ubW0rOHdicjh2N0lYM2hpdmh6WGZxRUY4SjRYdXZmcSsrMWpuZFdZZS81SURVMDZlNTRUeitKcXNYMVlucklPdm5tRy9sdHFQUGxMRGpCQVRNbGdlQ1VYZHpJRjB3bks2blgvUjRWQ3FINDdLOHBZbmpZYmtValNQTzN0cmFRcmJ6VDh6WEdQWHltVWVqNHZuemxld2JzcmxlcjMveDRrVzBPai9mcyswTHRqM1BQaU4rTjFBeVlTQUxVZTNqMUk1Z1U5UER4NGR0UWNzTWVtQzEzcHhGQTJ2aUNvb1loNiszNmxEY2hUcmpKVXRTQ3hEZkV1b3U4WjMyTWdLTktkcEhKOXlpSmxxNys1aDR2TkUrZnJ3OVdaS21TR2Zsc25zc2xHQWdaTjF6bVcxaGZQMjB6eDlZT3ovZk8zN3Y4WlE0SzAyY1BnRG9pZjdEUnljVU5BUGYwT2s1OEJvYUhEak4yNnVWeVFIUG00ZTYwRGtKbDgxdTRTS29wcFdnM2hXN0FZbEFFWm5xRlYyRXh3N3VlZkxKL29zWHJyNGFjVk5MUzBGNG9IclRUMSs0OFBpZXF3N3Q1YmpkY3h2VkpJRUFFb01oWDczOXVvMk4xcld6UlhHK1Y0TjNWdW5yTy96MlRVQWpML0VlR0V6d1M1VnRYNmFoUlFxOWlaQXBYaFQ0MDdYSkE3ZmM4cmFiZzl2b2ZQVGlFaUhUUEg4bXV2bXhtMjgrT0RuMmEyeVdtdHVlTjZXeTM2UHJBcXJ0THZNSHJUSEx2QW5xWUNXZ016Q3RaWjVPd2FDNDV2VzNaTTE3MkFoRVllOWZMQjBvODI3eHdOVDYrdVg3aXZlRDl2OFhudXlKMG05OFlIeVJoSXZUbGYxcmE5d29Mc3R4NDlSMmpNb21KaVkvaGRyTnhqTHVMdlBRR1NOQ2RTb1lEbzJJV2lRaWVxRlNybE9lMlEyYjZHcXZXSEs5TURYVHpNL05lY1V4SXd6UzA0MUMvdFNwZjZuVTUrYVdtNnFMeVQrZk9wWHZ0Y1VzY1BXeFNhUVpjWkRKNTZlOEZhUHE1SFA1Q2JkejZ2Ujh0WUpXNXZVVXJ6NDRkL3BVcHkyT2djNVVIL2pOTXpwVUFWOVFFTkZOYlB2MFFGRms0bFdlSEJMaHJzdjY1M2xSVWwrSEpjdml4ZGVCTGl4K0hpNmlOZjJCUjNpVnJKekVEcDFyUHRrRHZQaklBeUR5eC9XUmZJYjRsRTJEMEs2ZWhCUTFzTlVNZ3hDOVZxY1ppYnoxZXZoYUVuNjlKZktmcDVuUXFXdkl5T21kNUIxVWNQREpGWWRtTTlSdjE0RGVSY0FVaDdoVjdqcVEwdzl3NytCK25udUtZb3c4Mm9lb0pyS0U5K0hFc1djZldxQm5vRkFOUEhhSHRwaktObU5jd2pGVFgwRDNHcXBjMEVtRWw3aldaWDV1VFdvZ3JpelVteEh6RElCR2pBajA4OG95VDlYY2dRMDQ4QnZsTnZNblF2Wm15cmFkQll1blk1WTRvYTNtRFJYSlJGa3dmVE9uSTl1MlhkK0VlUCtGWWV6WDdGQ3RLTCtsVkZRM3VBSjVVUmFsMHo0TVppL01FclNGQkMzbGVEZ1NGUkFpOHRtTUljb3Y3TC9lYXNseXk3SmFQSS9oZVAySkV6ZFlUZFVVaWQ1c1VnTmcwN3JoaEx3bXkyc3BVMTJqRjlaVWZNbjVtaVJZRStPMklCVWlSWWtRSDZxMWpDNTd1VFFKOFRGWlZSVFJNRXhGSFBwN3JBMzZmWXRaMFc4Q3Z0OXUva2dpdHpzamRCd2JwU2tsWGFkYkI4Rk1UYnhSRjNvSFNjeW95ZVFMalFWK2IwdkxtU29pQ2RYeVdqK2gyTit3dzk4eHNnZ3QwQUc4ZENZaDFSc01XUVQ4Y0pkSWkvMGJRQTJ6eGFqUmF0SEt0c3pQYkZkN0o3aERyV2YwWGhRQ2cyUVV3RWNNZUYyVm9lNm13ZnhwMEVDMjE3bkxvZmRkRHlPcVROaVVlREtGUmpFTzlWK2hFMlZzMWNOQWg0WmpJektCb1V1SmxsTXBNd3JOSm1NUktsbFAxa3RRS0JYU1IrQ2RmN1JDM3pKU29lN2FudTZLUWpFWElzbjA1MzFUREF1SzdHa09Bb2htaGVtSlFzSE5GVFZqTEkrMGl1TldORlFveDJwUW1MZG1OSFZhY2pSWnhLNnErVUlZbFpBWXBWRW93eDljeURhYTh6T1Nxa3J6cHFNNTZXd2hjblhmcmp1OS9YckdYN1R0ZHVOOEVjVGQ1YktwR2hMbzRtWTlMaFR5UmFvSEQrbFFHSHBpdkV6ZGRtcjA4aVZWdHd0WSs2RXkzRERJZWRqMzFobStTbk1MM0JKM0xYY2I5V01aZXNXd3RUMzFMb25vN0ZHOVZvNlNLOVJoakVKVjZoRkhqeEhwMWdselZtTXVEUC8rTTRTUWowbSs5TEhrUUo1NkNwdjRxYWNFOVhmZ2dtekxjRDByU2VRTmNPK25CRkY0MTFQZUc5U00rZ1lQbnZpTjdUZXpNRjVIbjVBTE1uc0M1WGlGdjVxSER6dDgrUGh4aEk0ZngwL3pLbjlLRUU3QkFiUURZVC9QN3dPZ2ZPNjRzazhVOXluSHNiWHpsc256d2o2ZTN3djNieit1N0llSDRmNk9iMU5DcnpxMzhzT1UraEYxSDk3L1lacnNvc05YWHJMMmxaZXM4U1cxeEM5WnU0ZGVzazZqZnZUVTJoOUN5Ky9qRGtMTmdqcXBSa0dsRGgyTmVnRkhRYk1lZ1VSdjE5dDVQSVhwaFNtOGhOandta0pSSGJqVFlQbFNnNHE3TnVJUC9CNmFlUDhQdnJ4U21iVDQ2Z1JlR1h2NzY2MnFJcFNRUFdFRHYzQ2R3UDdRenlGZTBDUXBxbzk3YUxaOTE0Yy8vUHF2UERWVExRUjgvcjZ6WjA5dmZmb21OSGVOSXpjbWJUdXZFcE9RTi83ckhvbFllWHRtK3ZvZE8wUlM5b0NqanRzUlNJOGZLalR4R1hBQW1OYTdjN3RFNDdnMzlvZmpuamVPNXRwM3Z1NnJIeHhrZS92dDEyQ1dPTmx1MzhSV1UyRCtkNzBkN2FFcWtURHFSTFY2bVI2N05hQUVVS0JHUUNmck1NNGtrWEl0YWpCV1Jja1Uwb3Z3YUhoKzR6eGQwclkzdlY4aWl4MytnMDVZaUR2cG1iZjJ2UFNCeGZ3ajQ3WFRvaUlKKzA4Sy9sUEZqS2dLdWk0ZWo2ZmZlWkRzRzllUWd0YlorNmxxMW5CRnZyMG1GdmFFcGFwYnV0eHBuWk9YWnE2b1lHekxIa1pQcTVOVkorYjVjcStjbVRvcUNFVlM0ZVJMNmxRRTdETEw3YUdyWlM3MVg0UmlBNE9KeWxCMGlEVWJoUEtoRG55Wkp4TGxxeUJrT29sYkRQeExESGwxa3FxOStiRmJibm5zbHVlSk5CNmwrV2t4S25tZXFFN2Q3SVh0L2M3ZlMrTUVJMjNzbHQ1NDVzUmVRVko4UmVKSk9qdGJLZTBSQm5WNzRSYWF3SEhYY0lPNGNwMW5sTk5JRGNkdHRQanFab3hqaFJSNUs5c2NteVRZazIyY1NxZjBzcGFmeWVDa3pReW8zMnVZblNqTnJQVjBYUWpuUmFSZVJOMDZkWk1rOVRiQUNWSVBxQW1lc3FCdU13S0FRU2hyNjlZZnVPckJrOW5XbWZidm5UejU0SVB3dmNvN2U5YTc2b0hXdGUxTys5cldWWENoZGFaMUxYck53U3RXOEdSNzlxR1ZadjN3SVJDeVZ4elUvWDM3ZlAxZ2U3bzdQYjA0dFFwWERyWW1GOW5jNDA2WnRNVHVSOHNUUUNHb3pqTEltWllyb3JsREZoQSs4QUE5cnBZZmZMRE1NbnZUOHVVSEQxNitmT3dQSWQyL1BoaW1EeDFLaDRONXBrMkc4Nm4vUXBNTVZVbm1ZdzBTQXlwSjEyZTE2R3FjTnBXbE1IaFJRTUVjWGJDMTNwTVhyNW1abVZ4WUxIdmFwRERqS0ZyR0haKzJMYXRRc0pvTzRucWJtNzJweWFtZWJwNkpuYXF2NnJGclY2YnMyTDU0MGQ2MnNTWDV2MlR1dXpJWVRXN1VoM1lGWlA0cDdoZUg4MlFFUUUyTE1oSTI4ZFNwUTZtcFY5WVVraUxtR2ljbHdLQmVwcDV6bUxrbDBqbS9kc3NyMThNSVZMMWFmYkJlc2hXTkxJNGNYVHBKTDFUYU5VcVVCVGlqODkwcnVKRk1oaThrTStKTjZnWklGYVV3ajZrTHlwbkxCRUNVczNzaVZSZWpjcjZUTDBlaXJrYUxzeHF2bTJuVG9NczJWQ1JsUFZQV2hFUFh2dGQzdmJSWThqU3NXcEtFdnBEeHhtMnptQmtmdjNwOFBCTWI5cmpsSzRLc1lGOFVmZVFaMVlEb1BFRVNueWxuc2xrSWVBa1JYaWZCVFdJT2JiejkxdU1QUnpxYWN2T21OTGQvTEpPUFU3S2Npdk9ac2Yxemt1Wkw2UkNiY2tiUVhGelhvdGVmdUxYL2Q0cXBTUEpSMmRaRUJ5TnhyNS9aYzNpMk5oWm5YY2R4czZWS2JmYnduc0JSZFY5RXVtMGh2WFNnbGlzV1pZeENTUW9SSnNVNFY3dkhONXltcEExc3pFazcvZCsyMEU5T3g1Kzg4aHpIamZpaTFFRjd2Snk3ZXVqYlE1ZXZGSmhmZURsWmhFdkQ4dkJzSDJpdjVjVFBoeUZrYW5qck1NUThYSjQ3YXF2WkhKdXlUTmN5emFQTDdUM2orY08yeUd1NFBodVg5OTViT29RSm53ZDFjMktzSHJsR3BSQVpXcmtRQUpnNzZhNnV1dWhWaFZxOVpDbUdZdXBXenE3dG1TelVVbzRVR0tLRjVvdjFYTTdkUXJJOWxxMFVVMjc2OVVZcTNtOGJxZUkrODVCNzZwUjc4dVJvL1NhQWV4OEZwTVoxZjZoYXc0WEcxUFVkS204QzY2Tzl2KzVIMnd1TmFjVWlxT1JvcGJ2Tm5UbytiMW5Xc1FPTCt5ZUxIUmtKaytsVXBicm5wL2Nia1cyWm1ucWZhYWNkVGJXY3lGT1ZuL0lMU01UcGRHMTZyRmo1OE1tVDVkWFY4c2QxcytDTTc1c3RqcWM5d2RRSm4wbVZKdlA1VXJib0ZVSGwwQ1FpUDVKSlp6WFZ6MlJ6aHZZRE0vU1JiT2FpWE9wZnlxZE9sVStPWWl6S080SGpvSkpUb2dzYW95YjFnd1JaajlhbzRUL3VyLytYbWQ3NHdibHhkcjdXaDFkdWZmaklrWWRQai9wNjh0U0NBaStYVmxDRjFDc0FEdEI2Zi8zUGV6TzE4Ym1ENHpUK3NZZFBuMzc0eU1CZlpQQ094Wlc1QnJlY1dOL3FDMnkxQWhzRlVTUHhNV0JjRlNKTjBESXVjYnRpdmlwd1JoY2V2TDdielJpMms3R2Q5K2NxM1p3djQyN1hmek9iK3RnMGZNOUVTeGozZngvenZXY3lqbTQ0anFFN1lhMTY3cGFxTDZpM1BaUEt2Y2N4K2w4d2ZOOUFCd3ludjRIUmZuaitTL3lnTHlRNGxQb2R6ZTllQTBtTFFRMTJIZGFkZ1NYN1l0S2pxUjlTbTNtekRjMldTVG5PZE8yTUF4L0VWWElGdjl2RnNwOUQ2N3N5MzN6bW1TOE55dmpuNTZxMVhPcVoyMVRCcjk0eXdCZS9DMlVSUWRJdGNpZTRHN2lIdURkemozTmN0UVc0c0Z4bllkVW40WFpuWmZRRVJ0M3NSb21QRjcxY3A1QXFXYlc3cytZOTBmeG9OVVFLc2FoQ1JLamxSK3dzTVgrVVdieTlZbzZDc0VFdnAzVU5DUU1vWGJpRStGN3ZzVjRQSGN5aTExNTl6V3RSdGpCdWRJK1IvQms5NzJZeXJwYzVuRHJSTm4zVjFDVnlUSlI0VVFBOHBVR0t2R0QzTDVoYVJsR0pKQWwwaGRpcEJoS1VBRXNpYmw5NXNtMEZpZ0R0ZmZMSzE1aXVvU21aaDR6QzNIekJTRTJNYnhTTGNRemZ3MFZUVlBhdXJ1NVJSYlBvRjR3YWY5YkpaV3FRcTNrbFh6T0lwSnUvQk55YUxxL1JiSjRuc3FUWkg3TzFRaVRSMVdtUzlFUjVRWkgwdElza0FWV3J1cHZXSldXaFhIMVNjVTFYaWw2bEZ3cDZhb2hiZjVmNU5yZTQvWXo3M2NUZEFTMlFVSDJiNk0waDFmZWh4S0pOSjZJVHVvZGlRdDdBSHh1c3NTVDB5RG9RSU5wNk1tbE53cDFPdFUxcDlMdFo5TkNIS1YxOTErb2V3OFViekRUeTBta1BPUmwwV1hoaXdmTDhmUDgyT1NDeWF0R2xIS3BxdnVCbFBEZm4zZ2JrU28rN01TRkc0UTUyNVNuTjFHUVNmSWtTYnMrcGhIQkJIZ2gzbDVzQ3drV09lVXlzR1BtSnlCVXQxZnBsbXBiNis5UWZCN3J6bTRBYXVpVHBoVlYyYXBnRlVMY3QwZVYyNmJvSkRxNHdXbTM3YVEweGNKMHRRNmhWb21UK3BSNFVVTVFQcjRWUkV5NEdZV20yQkoveE9KV0tVL1k5NzE5ZFczMkJ0OTFEazlYeFkyZUZ6UTk5ZS9YaStuZGZJYzFMZi9UdU41MW56NjZrNkxQZmZQODlxMnNiRTJPVGgxeUxueFBPSGtQbnYvMmg5WXNuWHZHbWQvOFJQRDNLKzRaenhZUFN0UWNsR0I2VEFyQ2NXVzVKTHAraTZUOUhrOXlscTQ2QkJ2TithbDFob25Bd3FwS0ZiRXhqR3NvRjZ1bGJIL29HRGtacmZXVEVla01aWDB0NFNETHpOcnFCeGZEZVlKY0xPaXZuRDk4Wk9OUDZDVDVJWnJEb0lvaDdpMU9xaFBuclZreFRVMnkvT0NXTFBEODkxWE5sWGZXQ1FrWU5UOXduYU12VHVkQjJJV1l0ZjBmTFJKVjZ4dE4wbWVncUJFVFdyZENpUG9aQ0lST0dxcVlia1YvT1dyNm0wdzByTklVUVFTRnE0QnE2QUFNWFBxS2Z0a0pWdDlIYVZNRjFOZDJ5bHE2akMzQ21DcmF0YXBhek5EMkZNZEZpRzk5elBMTEQxUFNTenQ5N1hFOWxNOU5ML2I4SEFXaHFsdTBva0wrcnlJSkluVVlsbVllVUZkVUFpV2JiaWd3Wks1cWlxd1JpeEpTb2tRaUdNNmFMWVVVUkxzazUxeCtSVTFudS91SHVKcnRvdnUyclNZYnJRUWFPNW9PbEpFa0xYTEtEeVBZTUlXdUFJZjNwcE1ud0htMDA5TkFvVmFlTEdUVTRjZC8xT2pTRGIyWjkwZUtKRUFhUlRCU0JFRVcxSmFMcHJwVXIrWkdoYTJvWVpnb0NqTk5NeXRJVnVsTUl0QVMwZytabFFNaG0zcitiWkl5TUszYkt5OUNta0VRRVFCZjRuVWtrVU85RlcxRTFUVkVrVVZaczJ3OU5RMVZFNkJEQUNVMVhGR2o3UWNxS1kxdWFxV3JEZGRVY3VnQWorQXFRMElBMHBaMCt0Z1JDT2ZHdlo3UGpBMHEwQi9jVHY1Vks0bTVPUFZwMjlsbjUzVktoYkVaaFBraVpBTjduZzhEU1pHbDViVTNnTmYxZ09nUzJRNFMxdFZoUURjZDE1d1hlTWgwdjY0VjJ5ejlnOFNKUmdHNVcvcDE3aWFOSDl0VDUzaDAxUlpYa1NsNVZGVnNmZnlnK253L1NsaVVYbjhyb2lnRXNTdVM1N1RYOFNWMStySnE4WENsZnRpUkRUUFJONkd1VDNDc2h4cHlrSUROYWUyQnF5V0VKaFUzYTlaaUN4RVMwUkRwa0dYWEpKS3JVT3l2SXBEQXFFUk5GeEFxYTlDaElpRHBiUXZHcEJaK1pQb1k3MVN5aE92cW1XM2ovbTFZUDJlU3lkckdoNkpKcWwyYkNjTXE0OGhHOGVIVytFS3VsWWdrcFNJRE9FWmdDS0ZCWWxsSjBLYmNZTHUycFZmRll5VmpVZGFrY0xpMnBXcm8rVThtV1FqSTV1ZFNjclJSOEI2R3JjNkYrenpQVGVCSlY4MWdBbklQMFhEc2QzU29SYTJLeEtIb1ZqMDlEcjBPaUlXZ0lZeWt6WDVMMEFQRjVyNnFUcVhRazhVRlJVQU8rakhLQlRwQ1pDdXFsNXV5c0xnL25IaE82L1NSVSszSHEvT09VZTJkdTc3ZWhERXVKNytGZ3hjUjJaMG5HUGxzSDJ4MnloU2pjMlN1b1J2VzFBVnNtblcxT1FUMWtJNThrUzFXMjJRUTlUTkgxSzVoRXkyaUhsNDhtaVg1YmpieTRVU25IdXBYMlhOV0tSSlZYQURtSnVlRHFnaXRuTFYxeWlFZ2tXWUNoSHR1OHFSSExNY2Z6TmNNcys3NGlwaFVEVkVWYmtwMFFDWFlGeWJ4aTJOQ1ppWTU0SkttYUl4bFpGSlYxREFxV0tpdUtMbWhpUmxkdDAxRzFWTFhVS0tLVHM4M0ptY054U1JPenFYcjNLdE1URlo1M3MxZWtjZWpWYmt2Ymhpb0tVbTFLZ2NJaDBpbjRndjdHMlltMHdqdE9FVVZPcUU5T0llaG1ydUZGUjBSUHJKb1dEcEJmVUhsTWtFZzA0cm5Yell4RnZpQ1hDb2NuQm5ZUEVkcmdMUlExN0xUQUR2MFQ2bmVHbE5vaGZZM1ErY2tvM0tIWmRIWklNYUl5ZXNXdUxnR3pVelJ6UUN3M01NZURQWFo1cDVaMmJWaExVV1MxRkxOZTdSNUhkeHg5dTVwSTdoUXNrRXEwdThqYk92elFCdVVOL09EcDZwS29HOVRiWkhDc0FpL3NnbTVsb2VTSUxuN3ptL1lQNGllZnRKOGRpWDcwaWZoTDN4ajdkZnZoOEpjK2xYM2ZONHBQZnVWYm53bkNOL3p5ci8vQ2lGMW5tQmRYaFhRck5HMUlqK3B0YVBNSGtCb05QZ3VKUUFMLzVWdWY0ZUhWRWIzTGdCSVdFczNXSGV5OXdTYjNXNUVmUm5VSmhoV0FGUXZSUGhnbG1JTVpuV2hYYm9SMC9haFVrU3BSZHc1QWJhYzV2REF3QjdFZE5zNXZuTWZLVFQxYldUM3ZkYWF2c2I2WTBsQzc1QVU1MlY1MkRCTW9pUnNIYjI1aUdjMEtnTDVWZGFXV2RTRWk1SnhaUVlRTDdhTWFEcEZSUit2blYxVzdkNU9NejIrc05rNEgzNDcvVkJBUWZzOWFsL1IvYTIrY2lsSVpTM2RucmtRQTZOSG5IemlHWkVLeFBmcC9KcSt4NWVtNnBPZExEK3llVDdDaDVtZnBIaEYrVkI2T2JORFF1d0JIbTFFNUdaWHRWblZJbFRKaGV5N00waFh1akFIVDZ0VzdqVTROU0ZBdlM5U2hOQ0tEQzFOb0NNZ29ZdnRpV3dGTzZPdTJra25CVUV1L2g1ZUZtMEdQbjE4UkVYcVZpOG1lS2JnYzFnM2t1Qmg2bDJrNHk3NEFJenZuemxDcUtFcTJ0dUl6cXJobFVkOXpjNlhjcU1BYjhxZmVpMXdNU1dNSkgvMDhlaEVqLzlxMlpGU242NU9xUFgrVmo5Q0JCMHA1ejhraVY3Y3lRS0o0NzI4TjZYTHNnYzhEdzhlS2ZjVHdacEdJdEcyZWwvaitzRm53TGdsQUoyblhROXI4SWFHMkRndk5JYWhlRWRHNTZpV0VTcTZ4cms2cjlMdTJwbDczYW1RcE41am05WXFOWG8xdEc3MVIrUG96Z3ZETTF3VmhZMFA0OHJQNGZWSDBQdnlzSUw3Ly9lSWx2a2FYNW5aSnlydFRHclFqNXBpdjIybnVGZkErYUZhRXJVUEFVckRnUjNUK1BOeUg2UXc2OUY0MnE3bUVPKzBGNXJaU204SVVkME9YcDgwTDRvVzVEUU1FcERJRllCNzBjYjRkSVVWUkRwMUR5RW56dkFuUUZkMjlyR243NzBYSTFrMmVUNE1RUEhycmE3ckZLWjZmS2g2OVZkTnVQUXB4WWJKNHpTdVVoZmVnTlNFUExkRHN0SnZRTHJZaENJYnRJOXhzZDVvSSszays1dWZLblU2N1U1NFRCSWkxSzBmSzgzei9iNzUwKzZBZFdOMnlkSVVPM1dXRkZuRjNBVEV0dnRpdG8vOURzNy95ajY5TThqNTZtNkxjQnVYb1AvK2U5NkNwenIyajZkUFlQNTI5ZmNUV3FOQzlDcU02NmRaQlEwV2JQOXQ5NXp1N1AvdnhWdnNIZDE4OGYvN2kzVTgvdmR1SGFwZmY3a09hMW4rZnBsRm5YSHE0bC9tS2N3SjdkcEx0YnpSQTFOMWttejRvTHJYblZkb01MdE0xVzNScFg1c0I3N0d5MzBpNXZ1U0x0dGMrcW5hMTgrZnoycmlnamtrOHhzSmRwby9XNHZpTGloL0tzZ1pmd0hNQUswajhnbzMxeVlNRlFjMEVlc2JKU0w2WitYQzhZNHQ2WTFLTzZrQzNZdm9WaUE4WTVFRmlSK3BRelltT1VaTk9xOEZ0b2RFcW83dGZyaUQ5alRqKzdSK3pJT0sybjBHSjdacVZyQWtERWtnV3BsNDI1Vms4eHh6bTI4TU45Z0ptTFlJN2ZCTkFQYlVkZFNzZ0cyOVVnQlY2SUdzTTQ4dUdJU1BrSVY1V2J2U3NPeXovaVhYdlJsZjIxZUNXOExUcWE2Z1hJMTc1YjREb01RYlY2UHNTejhkNXVnb3ZuN2Y2WDJNK1lwczcrR2FaK2FKUVd4WXpZd0dIbytzd2x3VW9TNEZubTBZQWVFbVdsQ2VHQzJEemFGbmcrOC9MMUQvVGJoUFE0VER3cUx2b2ZnY2k1a25iNW5GSmw2Q0VtSkRuTkFGN1NOTFJQZzByaGt4Tjd5SWdjVkQwZ0dvU2tuaFpiSW5xOTRuSVE2aEkzS1crMXBlc3dxR2d0N2E5OGlhUEJsdHZWWGJXNEV6bDFiWnNzOVUzaU81OHFHeXZ3Wmt0dEFvT1czclRTQmJqY0tQN3BCU0grNlRRR2N3NmRmZjdFZHVsdkdwK2RYWCt6a3UzVENsWEZsWlBuMTY5Wk5zVVJtTWIwajhQbzdoQjUzcTdkQU5GdHVFRjM2TE9qRFUyWWNvV0Y1R0JNU1NxRFBiYTJvZlJWUTg4b1BTL3FDalBFZjdpcDdPMWxuSy9GUVNGUUR1a1FSaFkrcTJJSEt4Y2YxM2xBR0MxN2pOS2pTZnp0VXo4a2FEZyt3Vk5LOUJuUjJ6WUlrajdnSzZZN0ZKdnJtNVU3N1RxM2RBZkhubjRFb2ovNGExMzMzM3JvcC9OK3FWeU1EVVZ6SXYreW9xL2QveTY5ZXYremE3ZFZMTm5YM21UdmVlOWUreURHd2hacjNqK0ZkWlZ2eitvNnppSzBYVXNuMHZ5R0tTWnkvbWxKSjN4NjhZaG5hRThIa2NQRHQ0TGZsVHBSbEpJU2pXYXpyQTgzSzcxb1dLeWYrVUtDaURGYm1Ib0pUYmNFc0liYXZkMG80ZEtmYmdkQk4wSm9yMDFOM2ZnRTNTbmh6MU5SUGQrMk5Nb2xwb1RKbCtJT3pOSFQ0eXhmUjhLeGU2TS8zZk4zMmllL0NEYjFTR0wyQ0hYLzlac2UrRlVRSkFXSDZzTTlualFZdi9LYmYvWUhsdGpOc1p4WG9GUHpMT0o3c25BSzNWdGlIaG1YUURRRWY2YVA5Nk9iems0ZVVWQU54ZGU4ZXV1Z0dSZE5pZjJ5Y2F4aFJEOVF0QTRlY3RNNy9wcWJOalpuSEQ2OXVLc0x5Qko2cjk1MzBUZ0xWekJ0dEVabWIrblZ2WlppdldLeU1MMUdxZ3ZjN2dyUmp0eDBHVVdHb1JHcUp1YmhjNzk0QVpWalZYbDhIODhyTUJSUmJkcmFrbFJ4OCtOcTBwSjFmWWNWMDZkVWx1YVhpeFVzcHJhUm11blZRVWU3L1hnYVVVOUFlOHFjcVVpd3pXMXlmKzUybEpWMzFmVkZoTnZMMzZiK3dMUW9rcjNnZkpBNjJsU2RUYWs2NWNyMFdCWjJmQUFYTkNrTGpqSmFscmdUYUV6YjRkQ250ZHNQcVBNVHRtV2F0dVRNeVRMMnhyL1dGZ0l3d0thMGtLRUF2MXV6UkRVdFkrOVJWTVU3UzFKK0xFMVZUQzBMN1BsYXNONXJHUy9CUW42b0U5OU9WZFF2UmtBMkFFa0VnQWtoQjdTamxZUXFaTjJrM3k2MTFodjlISTVlamczRXY5SEZ1L2xrc05PZkdSdlVJV3VxWWdnVVVncFducjB2aWVldU8rVzVkN0cwcnZPci8vUmZXZVhCenhwKzlrcTVGeW5qd2NvWHI2RlB2M29VbS81N0gxL3RINytYVXNidTUvMUNEeElIY2JiRzhOSDBZOTZGbVFRY3kyUHVpamVHQlFEYlJkakJCOUV5VjdHVVpQVW0yM21FZ3VIYmtTbEZOcGN1eCtkV0ZzNzhjcTF0VmV5NCtaSW5CNEhQcFhKUGhhY3graVowSEZ6dmFGOEZpaXpEdmUybzZPK25pNDhIelIzZGdlaXMrcEJmZjBIc3R4L1RwWi9zQW5QOU9RWFpIbGVYdSt0N1g0UHNTbVhYYStpOWZYTjRhdUlXK3V0dzN2d2RtOW5EalBaQzNuUTlvaTFkdGRMV2hzZ0ZxVVduL1FFdEg0MUZQYnFYSTRlK3MrUG5LQno3S1QvRkR1N21nWG9IRHZaa2JmSlhnTUJYVWVYdU5aV3l1MHFkVG1rbEcwRThnL1dvWTVvUFRrK0xQZldvSnFieVNGWlh6MlFqWVRwbHROMFpRclFsZm05ZGdlcjJHcDBUWFZqdUkzaXpqcm9XcDF1VU5CcWxzcUVUbHV4aGJ6dDFSZnM1K3h2MnZUdkR1cFliZFF5ejJWcVNsU293Tmp2L3hPUEJOZDgzbkFRdDJYYlIrWXB2VmZ0TGVhQmpUSm0vMkttVnN1Z1prcmx6Y3k4amFSYS8wL29yTUNJSGp6RmRiaEQzQnIzTFBkNzNCOXdYeDMxZUUrYWgyNXVPYkRnTkxlL0RLY0ZoTzZzVldZd25xMlpINmhkd0tDWk9URXgybEl3UjBFZEFSbmFhZ0JjR2s0a2s4ckFQcE5ZdzRIckR5d3c1VUZLQVAycGp0QmN3Z1A3eXREU1F0VzJZTnZLM3RuSE55SW1xYUdCT21PdGh0K2dTL1RYYWRWaiswWE85bk4ycmVVN0djLzFvcXhISjB4OGZWRzJCYVFpbms0b0NSQjR2aWo3bGZGQVVSd0xzZVdCK3FxOVhrU3VhYWlpSm12QXhuUURjSjRrZ2k2SEJFbFZiREVsbXJicElsNjNMWUJ5a2hUS1JPY0ZHVW1DUmxQUW8wQ1RCUUJjOC9vaDE2VExvL3RiOWdVYnhiWE1XcWEyYXR0L20vYzZpQlhITjAzYnJtV2NIRzlmb0QxL1hzVG9CR2pjU0tZcmNZN0VwcEl1OGFwQWpVQXlzR3Y1RmJ4a3VxcUlNSzhwQkVHcGFKRUZ5WllrMnpWQlZiU2tjc1hPUkxHR0JSV0Jjb294alNBQ1dnN3dXbUZyelhRMzNGK2lmV3JZNzdsazd3dzlXU0ZXYWJlYVBOMkIvMW5vMi9JbTRHTjVjVkh1cjZQNS9uTnJITGQ3dldDSjdzcERkOTVKK2tzejZMSVVLSUtuUTJnWnNiMk5ndnB3RVRyZmJML3dITjE2OTdtL2w1K0xuNU1mUnJud2hqQ0hZcDNjUVBUMWkvSkZHVDdyekhWWUxnYTVYRkRNSWFMclVORnNsdUsxYlJrOWFyL1pXYlBSNWZaeEs5eGwxQTQrcWcxRndCSEo0QnNOZmlkZytQMzN6dEc4YlVQajJUSDdnOEhPamttNGZkeENHM1ovRFRUcURmdmljRHZGdFdHa043TEhJbzJ2cmEyenlPcnE2bTVNUktEY1ozYTgwSVRCeGtaMGF3dTYyZEVzU3JZOFlrcGFSQ2dFWVpzaEFSNW1HeDhWVUxMOUVWT2U2b3dqRGlaTzJOWklnOFU5MThWcVZzNkN5SXBSQUJFMWRtelRIcCt3SjhiaDZMemN6WW1IVk1kMDdaaUlnNlZCLytQSGYvZVNtNStLTGJwNStLRkRnc0w2MHlMVS93aFhnL1k3QWpMTkVxWVFtVUwxS2JvUjZrSzVUWjJjZC8xVVFSUktnejBhazkwZm8yVFI2UGFta0d4SHlLbVZ3U0lWak5sU0ZZUlhORTAweFlwaUtoVTRhaC8yeVhrQ0g5OGt0OTVLL2tOeU1KT0xIMTVCMjM4cnVpYUs1ZGNSVlNXdks0dWk5akI5Qjc3d0tMeEFmY1NUWTNLWjZaVkpmUkxiWDQ0aXFNNkFOZEh2djEvMjlma1UvSC95WmNyMzlEejdPLy95UldIak95bUxUZmNmNi95N09iLzNaZkpjZlBuTWRtVG9FdDJmc1VveC9jQ0luamh2RDM0U1lGOEM4cnVnUmNFRFRlRGlnL01ndWRBb1lKOGtma2RzMmdTdDVLcEJWRE4wUVZORG90K3BrNGtnSjZsMzRJcWo4WFcwaUhPNXJLL3MwVTlJZ29qY0tCczZ4QlJrK1F2aVRMNlF5b0NRTkh4Q3hocVhUWnVTbExiMFFORGRXSmVBcFZwaDFnL0d4SmkzMnI0ZGdNNXVQMGJOY1h4Y1ZteGgxRGZQQVkyQUlYTXZHWmtqVTVGazZJVEJEUlJEajg0ZFdJZ3R3Tm02bVk2NGJCWmtrZDk4dStGbFZDb3piT29kZXY1aXg1WDNaeklzVElZVHFETituS2xsc3oxYnpYaUcyMy92d0VlMjk3WlFiUVhCWTc3U0NyYng4QnJncVczYk11Vzh6Y0Z1M3ZUWFUzcng0TCszdnI2MVJkY0ZYN0wrejlqaE1yVGdGV2ZBSE9iUG4xOGRETzcrZHlIdi9qcnpFeGk4NXdMSHBmdDdmd09oeE9KUEc3UmVrZHFkTGlBQWFwQVlHMjd5c20zeUJ6S3dEeVZZdlNXQnFKZW83Ty9TQlV6c1ZnZEVlVlJBUUVzUS9kU3FTK2dFRER6UlhCWWgrYUdsdDlsbzBuMTVnTG84WFFBS3ZDRWs1UnI5UUNjSjJXcG0zMFQxOGl3YXpONUFuNVJtNmZMUXFJQ0pCSjJ4Z05oY0JIQkphdlVkUEZSbUswanAyb282ZFltRW9WRWJUaDEzT3dES0lLeXovQ1NvWGRCa3I2UERFbzhWdWhXZ1JIY1hFT1QwdnY0TGpIN3ZraVhCUzgzVXNqWlB4YklzWXJvZE5jS2FnZldBRitqZUJOUU1BNEVqRUl1SE0wSGlSU1VVaVlBTU9rVU9tRVFDVE1LMkhTUjBOd3FjamdXQkFNS0FFeDZMU09LSkpTZ0NKdGhBV0pWTVRVU0NnQ0JObkpVY3JDRTZhUytwTG84TW5sQ21aMHFpVXBld0pxQUEwaEd4anJHSkJFQU1xaGlKZkFrVE93MW4xTDlINFdWWEJGSWd1a1FZY295Vk9vTHNNRnc0YUxBVnREeVBKY3BLQVFYdHlYd2s2U1QvQW9VbHZHZ29HdmF4VkpJbDFSQjVYNkpyaTRIeEJuekVoeHBHQ3VPL3ZFYXhLU1NkQnR5bEl3SHJDay9aTXcrNUE0eWgwNUVHc1dVZHVMWWk4S0lrdVFKZEd3ekFSMUlBOU1pQ0traUVyakNFTWhFZ3U0bVFwaUhrcUpnSE1rc2FJaklRS1pCd0NnUHBKVU5BR1VpYjd2Vmc4blpPajdDa3B0c3BxQnNVQVN1eWs1RkRhQitlN2dVaGVIejdqWE9BdWVoZUlMdjJkVlNHL3A1MDJML3EzS3RlOGQ1WG9JMlAzbkRqdVhNMzNqQWNVM1IvaU1SMkUrejREYzZpb1k5Y2JXQTgydWpSdjhuTzhYdVBkKzQ3T0RkM2NPN0RoK2lWUTlyaGFib0NjL3B3YVk1ZTNyWGZUY0QyamV4MHFjWUFZNk84QUdNak1kaUc5WkVWOCtoZVhWV3l0M2VQVGlOc2FaNTUrOElVNkZTMkxDTVZDNjY3c0pTcGFORE1YOUo5M3IzcDFFZllyeCtnaXpLMzYzZVFPTWJqSXBwVkhpV2VLZ3ZVZjdMTFpwWmd4QUxPb3dDL0M0QUtSaTF3bmZCa295cEt0aUpicHF6YVdwVnRrcUxJUUYwVitycWNRbFBPaEFOZEhuM1pzQUM3cXViWEpkR1pzR3JaR2VVaFRVVVBQWVJVN2FIN1J1bTliL3NYTmdCUHNzRWRSR3hMa3lKS2RxTUR0V01Gc1VsRU9tN3JnL2xZOWpzd2ROM2ZYa2xxU2JycTZwSk1mL1JHT2kxcGhDaEdORzVXb0Z5b1ZtbzFRbHUwUlVXUjBBYmNsVXlWRjMxMUVick01Wk4zNVBPU2RPK3RsOVB1WHdCSkFiaFVjdXltR2ZMSVVTUnBsQmRTVDB5Nm0rOGt0V0p0cjZXbUVJMnRCQmh1Z0F4QWphb3ZkUWJPS0ZzSjRZU0t0U0VjZTYvZHFudUI0OGtmWEYxY1hGMDBXL2FTNG5pZWQrL3crbmVIVndaOE9hZ05Manl4U04vNDZ1Q3hwWDhkWHI5L2VHV1hUUXRURk5JdEVZL1pVZm5CRHdaMTJ3TkJSdGl1R0lsakRkdmVQa2JjK3M4WnJpNzhHOGhMaytvUGVEcFdUSUZ5aDhMYytLSUlHc3JtRm1yS2xtNDdtZ2tqWENSSTB1TnBvUWppVjZndGpsc1dERnlRRkxSdE45SGxhSlB1ZDkybGtKWCtBMG1ZTVJ1eURZdjgzK0MyZTh6MWpycHRmRGYvWUFaVEJtQ0l1UWY1VldOdlZ1bDJsZXhlbzlLKzZ4T2VteFZGYTN6enJ2YXczeVkrMmRUdlpkdXZyOE1XTzdmb0R6T3NvRFo4T3RDRDI2MDV2c2I2RHR2aW9nMUFpSzBJYURaRzIrdkNQQkIxbm9nYVpaN0FHQVg0QnhZaUFJL2xGY1cwTFdCZlhiWTUyYy9sTytPTGkrT0xPVHVOQ2U4RHQ1Vmx4cmpoU1dCdmxDdERUQ1FpdkkxVGd6UFhFM2piUDdYOEQ2Ty9XYkZGZDB4bWF3Y2F6R0UxOGE3dHRsaFZsakgxNTdOUTNCR2d1L2JQNmE2cmkyZXo1cGoveEFGaGFCKzVoYzNSRlVFRG9pdXdRcDg0UGpDRkd1QitVTG9CNVVHTDBzSDAwdWZ1enFrRHA4NnM2OGFtR2E5WlZ1dzQ4UnI3alkvNFBBdlJ6ZktrM1A4SFVITkNOVlpEMi82NldsYXZ0ZTNUOHJqOE5kdStSaDFUdjA0dmpxblhnTTcwM1RFMXNPMEF6cEFIcC8rd3N3Y0I1WmQ1T3JzN25OVm1XMm9GRENPMjJTWkFEQ2w2ekZXYnpRSHV4S2kvYXlYWlM3b09jR0dLL1JCWXU4UDIvTnFKTGFIOXFNTzJxd0ZtQzAwcHpjaThjNFBEeXpOMEM5L2ZBVWtHTWdPcmlEZDRMRXV5cjRpZ2JSczhvcUtFM1JMNEJ3bmFPTnBVUkY3bGNYQmpGK2s2NnQ0WTBHVmxvdExzL3pXaUV5dlFxQmdDMXQ1WXBudEx5eXJyT3J5TWFjY0IyVUovUkFFNkEyWXh6RGJWU0h3UkdGWWUrZ2ZzYUxLY0N4cUNBRitxTWRRU3R0S2g1OUxnUy9jZ3ZMRGVmMkh0bS9hZkZRcVRCVUEyOFN2bVA5WjdkaFhGNitzWDF0YWV0TzE5OVBwazRkZmorS2ZtNTd1OTNqalZOT1ZkdjZVenVtOHROMXd1UytVVkhsMCtPL1NKQlI1UkdZbFhreTM0cVJvQjRHdjc5ODQ2dzk5bW94YWora2djY2NuUGlzeXljSXVhb2Rab3NMa2RReGtsNnlxSGFQQzF3ZkV5NVFYRnpVSWNncmZUM3lHN2pNWlF2UDNPaTl3Z3NtWStPUHJqSmNiMncwKzRXZld5SkpFcnQ5Ti8rM2FNRzdHbHZvYjVCalB2bFczZlRXcXlHUDRFMmNDTjBBOTN1N09NL0xjNjdYRG4yVXVkWWRoQzNjN0lMNTRsN3A2UXQyeUpGRlRaZmpZekZzY0NBQkJaZC94aUp1VzZFbFZnWlQvSUZpcGo0OVV4MDdWMFFSWWtYWlRwejNZQXlJTE9SU1JOc1pWMHRWeXYxdUpTUGdCeEo0R2drMGhBclVDMU1kVXpVNVZTbkk0TVFmOGJpYmNWZ0s0S244K1h3MEJYYUUvVm82QllxbXFSSnNJSXFPVmpQOVJVbm5ja2c1cm1SZFhYYklVSGFRNndRaGRFMWRZOXpaVURDeUNob1VaQjNyWWNPMTNNRmNybFRDbzBBWGdLeEhNTHVZSkt0MHJtOUI5YWF6Y0I4bklKK3QwcDdrYnVEdTdWZEdhUHl2VldzOHdPTUdhcDlBZCtaQStPREpTekxkQUpEWVkvOThGK3N3UEFlVFNNdmRSek96Y3ArZGxiZFhUZXRsZHQreUlOVmxlcDhlWmEyVHhzRVJxOFp6djJqbkhadEFnTjNyb2QreWxUSGljV0RXN2RqbjNEbElsMW1BYi9lenYySERNTXNmUlJ6QTZQSndsQWNIQTd0akRJaWNoL3ZSMjdaNURDWWZOdDJ6RWp5UWlDVjI3SFJuUzVpTzQvNFEyV0ROU3BHM0hpcWc1Y2NobDViTGxHTnlKVUU3MzVpZ2RUWlRPOVNKWEt4YlJaVGowWXRyNzczVlo0NDQwTVdhejJpdWxGVVBrVzA4WGVhdit2V25FcnV2SEczZnZHeUd5dmkyR2FVYmRwSmp1L1VCbGFxUS9YMUtPckJzbGllYUo0MnlMTmVmRzI0b1M4ZU5VcWFKZFh2VEZKZVVhZXBpdWhXdFB5NHVBM0kvbHR6TnZrOXRKOVRZYlN3VUpVTklENFp2eTlPNWlKRFprOHNJUUt5SXhFWE5RbzlxSUdNN3BCK0QyZnZNY2l2aVFKZERlOUJyRGZuR0pjZHZZeVE4a0I1MjVncWxHbGJQUCtqRHFwUjFQUFpkUXBMWVUyN3IreDE4dnZNUTJxaXZpZzNvR3VjV0NzZSsvaHcvZDJ4dzRnZHNHbmVzcmN3ZjJIYnV6L2FYZEtYK2c2enRLVVB0ZEVJM1NpeUpDalNIQm5mOWx1dllrSEZnSzB1WEo0N0s3MzNuWFgwVDBMaDFjMi91ckVpYnRQbkVEY3l1R0ZQVWZ2Z3V0amgxZjY1K20xdTArTTJGcERya3BYTjZMUlh6bWo5bFhNN0t0QkU4Qk9iUXJUZlQ2amtRMTkwTFBKRDUxUk8rdk1USmhERytzNm1aa2hlcUtMb0htNXZ3V0tRRHl3dFdheldaU1lXLytZM2UvdHpQa252bXdjNHAwUzJ0eWtHOUgxZThuS1I1SDU3RzZpQzB5V09TREh5b205cXd6ZmJyS1hkYjNUcnBkSm5TSE5HdkhwM28zdGkydHJheGN0SzUyTnJ5cjFYR3UxczI5Lys1UjFxblJWYTNsOWplN3dQRjZyWnd2dTQyNnRwN3lqV1BoWnBWZHpIeStjVzk3ZEozWDJtNE90Qk1hR3pUeWlDeFdhN2FHak4wS1BuQUdsOXdzekU4TGY5aG9uSHpseit5YWNubmtFeFY5NGI2UDN0OExFeXUxbkhobmlzQzFJYjJhQUpLY1FxZFFUNjJtRFR2elNkUUdWMnRBUnhLZWJLdWFadS85L0hKT1VVN3FzbjFLa01ZdzEzbFVSMG1YMUpsWFdFUUpOWE1OLzVWWU4rZUpGUmErNldESmVKOG9pRW5XVEVGT0hpQ3krenBEd3Bmc3pGVWZ0TTkxNm05bCtLOHppR3pCVm9qblVIN3BucFpVVjZld1ZvT3Rkc1JNZDJuQytkK2tORmgzT1ZkSGZMbEk1bDFtMzlqS0xEbzhwbzJ3MnBFdCtXNnd6WEJDZC9EQlhKWm04R2Z3TUs5MUVlNThsL2Z5N1JjbGFPbm5pQTB3SVh6MFMvclFLK3JnaUhicnF4QlVTSUMya1hubjlkV2haTXZ1ZlFUM05rSEkzTUxuOUViYlAzUnFMdjVOS09FL0JoUUpXUE13clltbVVQblJWRmQwMWNPZTMvd3BvQVA2WmRFMTJVUGZaSWloV2haMmxHSEQzSDFtWmJweWpDMW83YzdKQ25lcEJrdHBrN3BiSGJwa2pOc1h2b21zcW0vOGZhMjhDSjlkVjNvbld1ZnUrMzdxMXIxMUw3OVZWWFZWcUxhMXlTNVpsTGFZdFdTM1psdTMyZ214c01NMW1qQU4yRTlzUWJERENnQ0hBUUNkREFzRWtDUEtJQ1dIcEpQTVNFZ2lZelNISjc4MG95eENHa0l6ek1pUWtZY3J6ZmVmZXFxNXVpWVJmM3BPNmJ0MjZ5N24zYk4vNTF2L25HQnZJWFd3WXY1Sy9iVGVTc2QyMzVmR0VoRHdrMGNSWkROQ2VSZVFqUnNCaXR2VWh0bW1ZVmNoQTBsVnIxMmhtbFQwa2FPYVpzVUYrZ21kaytaZWtwTXgrRlpac1VaL1RYTzRPUjJPKzBmOGxDbS80VzNKUy9vaEVKUGJydkdJd3QzR2VQZ2VMT1BQTkt3ZlFoNVJtL25XRWpiV0hhbDN4aVZEaE9SeXRPSURGTG4xbTBNb1RFYysxVFVZSTN3ZUZJVFo4SVRLU2VSVjZGcWxHVnBLK1FJaWgzOEJaU2tZenVSdUFLcEl2VEVuU1MxT01ibnZzWjNrWnhMMHBRbFI2amxuM2swNWdpQ2xIK2JvVXdOMkI5RVdpc1VwYTQxVHl4VWtwSWIyTXBPRkdpLzBjcjJqTUdSQ290V2xDWkZZbGMwYmdKSDBRMlZPaDcydm9DOEVDSmNsRFB4OFBhVWtWR0MreFNvSDN1NEVRbncraGVEMUtXaW9VZDVkMmNJZ1hGMFRjRnplQTdBMEdtUHExVG5kai9VTEtDMHkyVW1ITndQdTlrZjMrOTIyekVHaDgwakpOSzhscmdXWkltc1R6WkgzME9LY0hCWE45ZmYyRytZYWVCSWJwMVZVV3Z1L1k5dXRJdlZKS0poUWhWYXRjVjZtbEJDV2gyRXJjQ09LN2x3Y25xdU1UY0laWEU4bFNDSWxJY3d3OEZMczM4cVV1MGJ5YzVTcXE2U2s3VTZQcTFpZ3RGZFZ5Q2tHOFhCcm1Ud0NHdEQxZ2ptZ1NzeEpGaktFNlQrQ1Q1dWs1OUtlREFlRGwrWGh6UDBPZXRCZ21JRXl0aXdMMzJEMGMxK1RZcWJtemFsRlZ0VnMxRUZ6ZHVKbjJnWnl3UEMrTGlwUFROTTVqVVJ6T3MzQXRiaVdkRXptMnlDTzZZSlVueEI1akVsa3B3VFlZQ2lNMnpsSjlJVU02U2lvZkVGS3hZYkxVVmxtdXhiTGQrZHMwb21vbDVTYU41M2tQeGxmYW14QUVwVkdlenFGcWtPVlZqbVB6WFBna1ZsWk1SeW5DNUdTMENpZHpaS0dHaWo1WmJPQWpZRUdmb0padk50TFJvRXg5TFBabzdDMnh0OFdlaW4wWWVLUnlsaUJZQjM2aHRUaWdVTTRvV29yb0VTeEdjQUFJN1lTb0FCR3JIb1lYYmUzanIzYlhqMlNBTUs1anVFZnprb1JKQ2tKak5RWFRyRkUvTXFxZFI5dG9BT2U3Z3hIcGp3ek9Vdmt6RW9qWjFPZFhrRGtXYWd6cmhNNGVnRU1GU3pMemljQlFvZlZFUXpSbUpnVUJtNXlSVk05S3dxajBranFjNDNsVmttVExsMFNHTWF4c29sd3ZqSitXTXJ5QW9pbkl0R2JtOURneXA0Y0ZTY0FNTW93bVNvcW1vaGI3UEtMUHdZZmxaTUg0bENNUWhXUERJNDA1aTZCcFBCM29wc1J4cXNzS25LYXFLUldXTUVMTS9mdUpKRHRtenRKMEJZaTJwTHAyT3U5NXFrS3VBQVlDaGdIUG1wK2ljblVEZnQ5MzVNZ0ROOXh3SDZQSW1pN0piQWNFR0ZreGJGbmxTR3pvUTRGOTE0NHRnSnh3SlVhdGoxMm1kUmZKenJadDdlZ1V6SVdNQ2JXNmZnanFId3hpd253TTlXcGFJeTBrcDJRRVpvemFwdzRrQVJzYXhDRnN6QStHRFFiTkpTY1VTZFJaaWVYMHoxV1RSUWZyMktOMTFOUmZOYmlvaHIxQmMyZ3FOc2Z0UjQ1ODY0YjdsbGhaU3NqcWIwSXpLckQ4TXljWWZ0dDZmMlM3UFNia2IrZUI3WWo0R2hxNUxrVGgrSkdyQlhVaHFRMHZvUHgvR0dlMFpjd0JkdDdKTVNRcnBSekRFbFdHODUxOGZXNXFiaC9LbkJ3cnphd2NXVncrMEhIeWdzYnlUSkFZdGYyQWxPQllyTUkrWVBySm9tZklxWkxpSks5c1ZtZjNUNlVjUVdBTUVDUGRBKzNUeCtjUHJGamF2R0p5d2dpdnVCVFZDQ0ZSOXBQdGI5NmRwN05wOU0yN2k4emdmRHlQNjNZUVFTVThmRk1wNS9DV1dlc2NXRjQ4c2pJanN5eGhlSFBmM0ZTem5uZmlIS09LbHVFa09ZWWtnZFhmZTRUV1FDNVlpNW1WQS9QSFQ3Y1B1SndDcnlvSVRtcHEvMnkxZVdYU1VVb3AyZkNLU1JrVy9ydWNSRHA5NzhHYnR0bmgvZGdLeGdxN1hsQ0NkYlNFVnFrU3pUMksySDZWa0FWQ0FZdjZLNGJnV2dIYUxxbk9lcEZGUk5CdUp6UmJkYnA3Z09vMk82MVE2UGN3U2NEOFZ1Um5zOVpFK3pSSlZYbE41V2R5VXJwRUhqTk5WalpkazFVMHhUMFNWeENkbkNQeWNhQUdvc2l5OE11STg3UEYxSVM3Y2h4ZFRUVFhzU1FtYnBxd3V1cW1hZVNJc2pzRDA3MldzUXltTUttMjlsV2JyWXJzR1M3aGVja2pucEl1bFdjSlQyVGdrYVpLR1ZraFBrWm5jcG5kdVpiS3pUQ0NaYmxFK0ZSbHZsWEpaaXV0K1VveHdqdmNwTDVpd0lCWEFuR1lCcTBhc3NNLzJVMkJhcnVIZmdySVE1TmRVZy9aUElPNzliTVB4OGVTQTY4QUkrR1B1QXo0R25BZVVvYjZEQ1RINHB2U2RaeEIxVWNQMzlTY21acUNpMHpkOGhQR3FGK0JvVm5ZQ0ZERTFOUk04NmFJcjBlWk1nZjlHUTR3NnNmb2g5NUtjOGp5SURyY0ltbXZqMlhTRmVLYlJMRVVkRTZHTDJKQnljMXJybW02VlpHSTdPK3JGc0xoVzk5ZzRWZkZ1N3d0dG11MzdISjd5eDY3MnR2b3JhTXhGczJ3cTZzYkd4Y3ZScmJsMkFhOGx3bWpMVWx0UjBQOXRVMzFjTlRYdkRUd1Jua0lUVVBGZEQyOW1NdmxMY3RhQzhZeEs4TUVMS21ZNkxQWk5OQkZoUXBzVytNWStZb3VSamQxTWFrY3hRajFxZjlWYUppdm92bzNTcEM5ZFZJUWNkVGlLWExtK1o4Ny9UbzI1OFp6dVhpRGM5eDBxbEp3ZE1NaGVROFBlVG5tZGFjTEcvOVRlT1I2elN1Z1YrZjBtOU9PVzAxWmx1NDZ4cHVjREI0cmVNNlpod1JDM1kwaStoNmo3M1pqN0piWTdiRTcwWnNUUVVsQ2d5eDFLQXZpL2tBQnVTT1NPc3FPaEJFa2FQSEJOYURjM2pxT2RxSnVtSk1odWxwb3pwY3c2WFljUHRiekJzdUl5bTVSVlJqSnlFNWtFN0lpSnZNeVNQVXNacjNYT0JHRVU0a2xKdnd3R0paWGFtakd4VlBQRDNJbS90VlpTeVZDMFU3VkRiZVUwQVFpV1k2Znpmb2tiWXFxYmlpV256UVRFcXM0S0RuWXdON0NYazc3TDRRbDZEc0RSMldHZmFzSUswQkJkdU5Fb05mZERBV3ZGa2JhWmk1MlJleDA3TGJZR293S2c0bWFCQm9GNUs3NVFRanBmQmlXT0VBM2FRNjRpRnFUc25tMXNoQ3BLY05rVHFYWlFiYVNiaXZ1eHlOUWZYU2pvem5lcWdONjlCRkpsRFZlbWVZNTQ4UXF4MDlMZ2lwS29pYzRSbDRTRTU5S2lGTGVjSVE5dFF4QzVDaWZsQmtTNTlqTWZSeXY4TUZTWEZCNGhtcTVmNTZCRG1jSkp4RlVqTlBOejdPY29kNXN5UnlqODJoTWhvM09jSko5c3dwTHA4aXA1bGhySlpOTVprNDN4MHlWY3pKQ1lueHBmR2F4bmhDWTFPMjJac0lEb0h4VGpLc1RMcXNwZmowbFNTbFl4YnF3YmpQVW1ZOGgyN0NDaXhFbmpYYlRVRU1OUXlOVXd3Wmluc1E2aUhOT2ZzMWoyS3pmeTZqS0grcTFqUEUxaTA4MTA5V0V0NkIwKzc4VlYrRWZPZTRseHJLK3FZbktIeHVabXY0N2xyRjNQc3N5M3E1ZFN2KzdjY3pGTUtLbmtXTzkyUDAwTHBhYUtEcE5GTmQ5WEpuUlh3Sk5ib2lWSmtTSXlTQ3RoakNPTkRVbXJPbXcrTUgxaTRTUDFzNXFHWGtaZE01Qmx3Z3NwZzNqbTE2Qy9SemVKSlJEbGdjdUk2ZGx0L0xTaWl2UG52OEQrNHJhdmttRjFRMXJ6R0lad1lkRjBtVGlDRWJKYW9ZS0N3Y0xraXdEWEV6Z1VnTzlnUEM5Ui9COEhDN2trajRlZ0hzTm5WVW05OVd1c0VuSXpJUFk1Z2FLNnFIWXkyckF3aHNhdVNMaFZpcHVZditMU2xQTW43TXRTVFF0cCtDd3hMTW1aOW5BOERDTXN5aXhnczRvZ2FmQ3ZaZ29HMWpTbDhPcGdKMmR0RHpDd2cyV0tVb3Q5cytacVJJREt6cGNBczBNVndjS293dXNWQ3h3d29DKy9UYjVCZGpUS1I2T1dBTU9ROEI0djBVU2tFQWtiL2lYRy8vMTNUSlJwbStjVmxKeS83Mm5Ya1BZZjczeFgxUTVSUThSdWYvNVU0WFlNSWR0NkUvWXB2eG1qSXlnRzRrdEdwT0VsR2xJbmJmSURUQ1dpMHdMTndOVkNUT1E2M3VOWGdPWlFTdnVkeHhMTTZ2ejFVSUJONnJGS3pwYmtBU2UvZGtSa3doWncrc2JqUTIrTk9rNDZJM2hCT2pET3VaK3d4MExkelo0ekdUQmlMemcvVzZZRXV2SjBJcUlXQ2NXRXlOck1UZFdpYjA3OXJIWWI4ZStHZnN1MFAwczR5RmREZTFxbmFEWnhYakplS3NUK0pFNzFqNm00dEZvTHlBdFZiRUU0d2dYQUlxeWlhNjdjS2hHVGY4UmhnWDhMMVZMd2dCVENUTWZrUXlzTE1FaXM4MndrV09DYnJVekJGdkFXMEpvakFxbWowVDNQZlN0R2NDUlViczRsVlZ6ekc1WWlCSFdjeEVIT1BYOENSTncwZXl3N1dyb1dwVW56VTRUeUQrdzhmOGJ2VlhFU1lVVVBKM3RBMitvZXdXaVRJcklKZjF2R0VENFcwd0p0czR4eTUxckdVNjNoYVNJMThMWUU5Z0FTRHpJSjR6QUJ5Q0FzZ2tKQkNxWlNBcHYydHhVb3pFM084WFpKcTlJQkE2Q1NNc3JBUzh3NkhsckJxelFYOUZaUm05OHY2RXpiRW8zNnExclduVkRDMVE3WDAvQnNBV1dFeVJWanVmeUNObnd0N290RzFxMnZGVE9hb1pzNi80dnZoOVdrQVFQNTN3K2oraVZsckVnSVJVakRrSVh3dFFpaW9KaXJXUXhyQzJ5NUp6VEFGYVhIc0pYeHRlZ0Z3RlQzM0M2TWcrWENjQWRnbXd1aUJ4MVlzWklMc0ttRW5KS1FJUU5uZ2dwR2YzaFBMUk1pZ0p3OXF6QUtCWXYzNW9Ca1FSYWhKZDJ5U0lLYXFMNGZzYVNOY1pTWlN5SnhlUzYxekMrWXFMa3ovR200alBzMlRTamNUb0hyeUZRU3lmTml6a1M4MXlLdFdJSFkxZkZqc1plRFJKNHJBS3pxZGh1QmQxdGFWN0xveGxnV2NUVUdVMzcycjBrNDJ1dGhjNnR0UkJ5aXRybmdDZ09GSHQrQ1ZNQjVIRXB4TkdFYTJJNXZBaWxpeHBpeGNBWmZCZzViUFYvZEVQamxlMnR4TEZrSzRuczJlNzAzNDNranYzQWFOcll6dlR2VGt3VXJMcGx3VUxJSm1RUjJwVkpwVFZHMWl3SHN3MG9BbWV4aFE2Y3RuUG95QVVkeWlTclBDdllTVU0rank2Yi8rdlNmTE5DL3kyRnY1dnViaVdjdldwYnR0bi9hd0p1dTFGTUUyS0Q2S25aY0kyYWpzY3R4dEJzZ1lVaGFVakNlRWt6Skk0UmJjRzJjcVlWTjBkMWtZaERGV3RYV0F4WGNmbWdLNUxOdGJWbDY0dkwvUytjM0Z5LzhIeS9COExlcmVUQXIrYmZkMkZBWDErQSt4NkpuWS85WjF4RlE1OUdMKzRaakNpRVMxU3hVNXRoS0tNVjRpQzFnTWxIVm5JL2N2K0JDQ1FCMHpNaEFnTlFBeVRPUVNkY3E2ajNYWmVpVmMyd1ZHTzNuOHhRWjBDRGc3dW9WWlQyL0N5Sjg1Z21FZFpwSUFHZG9CT241Y1REQkJoSUZzZy9HVnBjeThrdzcyVUh4QnNGZUFTdS83d1pCeTRQS0tXcjUrMkNKTTBJNkNjbVdSeWZNSzBhRUN5Y2x5RHQ4OEN0R0Jub1pZYXhCVFVPVEJtdytBSmpDcEljQ0FrZ0FiSWNzT2kxUVpqcE9RWmRRZ1RPckRzemFjTXhNeExIamZYL1FsQVpwcWp5dVJ3Uk9seWVZVFJSRkMwems3UmtseWZITTN0OHpZYVo2cXVlNFNzT0RocFhNQnlRcjRCYmdyZHpGVVhpWVpxeWJKeXJLS1pET01NQ1lzSUpVNHhjOEdRYm1TcUcwMlJGeHJWWjRIamRralJXbFRSQkw4R3lOZ0ZMdXBxOXdtT2t1QnRIR0g3Q0pnMlJrNUtZREZSOEJPblBIcDUxcGpONVZSUnRLeU1LRE1kVk03a3l5K1NNS08vQm41TUg2Zmk0SmZaR0VBRzZ3Rk9jQXprSjRUcm1vVXlESFZpeFlTbkFya2RHSlF3TXJzM0RhZ2FySHdMUmQ2cWRhc2gxNDZZMlA3Q1NCSjRRUnRoVG5VeWNhaXc2MEszWTdhTGdVU1VuemVIaGd5VFJvc01DK1JrYTlJdUtXeHhBRVZkYjNSSUQ0QW1sR1FaeEszTzRNSVE2YTFRT1Vmdyt6RHdyQ25uRXY4U3lmQmhUMUZJZnArOFBOY0RId0h0M20ySUlIRENMVG1ieDBMeVAramgwSXExMllaU3l5TEYxWVBSR0t4OE1QZ3Ird2ZyTkRsS1ZlQmZJVUJPYXhzV1ZDb1VtMkRkWUpHMVFNS3l6T05LaFJUN1BNVHp6cXdGMG9hQ1F2R0pyY1ZWankxT0Nva0YzSnkybUtLbm84b2x1amJBTTZLS01Qa1JBT0RBSExSTndDc1BrMDBhbURPU2VseW9JbkFSRUFhazArUllqS0Fxc0NicGdvNGJBdFdHWWlDQ2RNV0pObFIvbEJWNWp4VUNHS3FKdFEwcHpBZzlTSzlwVk9BMFZVd1FZZTFhU2RFYkFUQ2trcnNHaUl6TG9nY3BhdkNSeDZKRXBBZjJYQlpFdzFwZ0hMRHhEWkpVNENtWUk0eGxIc0luT0VKTkpJWVlaOGlhRVVSa1d5Q2JNcUVDV0ZEYUl1MFNIWnBjWTBaTlRuZ0FMRGlFYVRFYkNuS1BLWVlidm91Y3ArMlpQbGhtSjVmRThpNEV2Q3E5Q24wZzhqbnNvT2Fzd0pYSWpUa1dtLzZlNnpJb3dKMjBKV0ZRTkpoemhaZWhaQmR0RTFSd1F5RGdSSFE0SkQvVVFYRllwaUdtRlNZcE9SU3JLcVZJOXkyYmp1dGxRZ0wyQytzTnNpNnVISGRzME9WY3pXTm5nTEFaZnhSY3dzU2tVeWVpRXJLUWxFZG9JSGdQY1FjbkppMEp1QXBkb2xwT3pTVVBoVk1OUmJZT0Z4WmMxZVZHeVJGZ0dPQmttSzQvWW9nYTBwV1JhQXNkQ1d6T0tUZ1IwQ3ZNd3h4d2xSQmpuQTBzdHd3blFmTkFGYUdFT2lNaUJNTXBhdWtuOEhDK29PaENmOGJ6T21iYmppbWtEaEM4T2xpVDB6MkJVeGNlTXhqQzIwQWtXVm1JUlptMS9VNVlsZ2o1SHNGN0RhUTZ1RS9rRUp5bEN3TWhsR1lnY1NjUmkyMk1BSzF1TWI0djBIcDk0SFA2ZXhzM2pJN2xUM1ZncVJEMFlBVmRFejhGaU0yQzdWRDliSzlhSzVDa2w3ZlkvNTZhVm9tS1J1S1g4MGtQWG5yMjJRUGJGKzM5RHppcHUvNytoMW9JVVhhV202LzB2UERRejg0dkJJRitWVDFiSVBlaXRWUEdMQ05rQi9QeEsvOGV2elQzOWRQNytiMC9jRDkrNSs3ZGpoYkFSaWd0cTFsc1VLbUFFK0hFUHdmcTRtQ09yc2RwckpLeEV3dW8vaTl0RVkrTncvOWtMcTZ2UEZ1RFE4M2dJcE5aRW9kRC8wcmUrTlpydkprUGp6Nk9FMVVNVE1OcGxRdnNLdVVmV05QazkzOUxrbzdLbWMvSnM0NlpaMGFpOWh2NysxbnZ3NVBpWUpzL2UxSmlWT1cxN0RCVkx2V0tvamF1Nzg4VzdyV0FnVWZ6Q2c2K2pMMzRldDJjSzY0VW56aTR0blYxNnlZTVAvdE9PZC8vT0VwNFp4alNHZWF0elE2OWFNY3BrMCtMRDMzNE4xZW43Q0RramlyOTF3d0lMSytjVGtyUnd3OC9XUHAwazY5Sno4dlhYQyt4ejBuNFo5MnFwajRUdGdnbGlUMUhNaWRDZms0WWJrWW5YdmpZMytDUGRrUjhqZllVNWV3TWFIUklVTVVkSms5bkNHK3lXNDBTZFhsVDY2OHJpZE9uRTZyM0hqOTk3L01XTFRmVXo2cjNHN21wMXQrR1I2bkU4K3I1eUpoTWI1TFNONUc0c3Q0UVlEdDFoMmRWdFpRY1V6YnVGYWV4ckZNNDdVazkzS2VMcjE0clRjdjlQNWVsaWR2SEl5djc5Sy91dmJkYmxkOGxmVDVWTTNmZnoyUVBlcityTndzTGsvdjJUSmhCYzFValc1YnVVUGVYeUhzVjZmdkhNNHVLWk4yVGo4YnZydWhaSWxuZnNNM3N5YzNDVXQyUXVFNC8wcHhkcERHd3lpbzBKT3pxQ01ZaUw1UUNuRDNtNDF0a3ozdjl4ODlEaXRIdlZaT2ZFUncvZWNjZkIzbDh6Qy9YeFBZZWFNd2Y1eXRTVmQ5NXh4N0hCM0VXZHJJMWUyNE1NcU1Vb29kdW5Kejl0cDFKMi95bmNrdFZHeXY0czduM2ZUdEY1eGdDUDl5NVkrMUUvR0EveGRkQW9QTit1VlJkSlBNOTBvaDNTYklYeWJoQkhMU21zYVNZUmNMOUQzcEZPck9hbXUrTTlqZXptbExqSGxRaUpNM3JjWTVMQXFzWnRrR2NDeGxGVm9HRXNiOWdUaVY5TEorNTBTbzBLcmhXZlYrT1NxcDZCaGU0WFZJOHoxTWMraVlsK1A4R3hiNGJyR1ZmOWVCNmtzSW5FdHRoY00rYWhsOTRXcG1zUjNvc1hpeldSckVOTm42TTFuYkJUL1I4ZUlST3JSeVlIdjFQMnAxZlhWM2ZHMnVVUncyTG91ZDN5eStpRFdrYi9VNkNCTUh5QWJBQmZGODIvTDFKL2ZXSVdpK0xxZ1lrRHErSmc1eDlmZi9yMDYwOFRpM3J1YTZObjZNN2Zuc2J6STFnVHFPKzlCSnVXYnlNU08zbjNTSWU5R0ZORHJjSFBmNlEvRlR0MTQrUnJYalA1bWxHZmJoWGpvYmY1UWJROElheER1NFVLaWMvdEdoL2ZOVDVmVzE2WVdWaXVIYjd0OEhvOSsxUzJqcHZ5N3RQU2lSUFM2ZDNOcGFYWUNIMUh6S2s0dktGQjhnUjQvQmJ0ZTBRM2JjMnozUnJaa0VSQytnOEk3bDM3VnZZZDdzMTg0R2ZmL25aU3YrVUQrZHpxZHliMzdadThaZ1pJMFBkUFhSZlI4cWRKTC9idFliN0ozdE1URTZQOWlaNG5hRXVvaFVKRVpBNFNnOUpBamVMY1czeVpXRy92T1hseTk1NlRKZkg5SjNidlBySHc5bnVMOTlwQzZlUjkxMTIzcDEzbkYvRGdNTmNocFhkQUZlYmEwNlROazRuK2MyVGozWk9UNzk0TU1RMmVKeCtDT3U2SkhjRG5obVp5MUk1T1VsZVdHdVVHTWJoZ2ZtaEs3MUNmRGRTL0JkM1FzbzZHbnNHb0lQZk9DdHdrSjNXU3FzVElwNEJ6TVAyT3hFM3k0alFoTTl0UGlhYmZsbmg2Nm91TFUxT0xrMCtYQk9rcVlEVnNyaXRKWGNIME9ma3FtUyt4aG1Td1Ara1VaKzZlV0p5WVdJekZSdVB4SllvRFVCSkVFTWZJK3NhTFhsSWZmK1pMN3p3enYvRDExS2xCdTd5TDBzaFlWK3pXOWlNdVlmQ0hieWplKzQ2RmhYZmNXeng2OUlsVjdVMXYwbGFmaVBSaG9WK3lIZGtsWUI1MFJ6M1pnb0VqR3d0blB0cFlyNk90Y1BtS2RyNTQvNWt6cno5emhsbC8yOE1QdjZWOXhUS2FIK3U1WXYvYmVQVDFaOGk1Um1OcjdkdWdQcUZacE5jRFRGZVFGOFRhQUV1WHVvamg0S3VHQWVjVVpwMmVpWWVudmxoS0prdkpqNVF6M3ZqY3dibHhMMU8rK3E2cnYvbnhCeFptL2VyMHJZL2RPbDMxWnhmK0xGRktKRXAyY2NFZUN4cUlFTk1JeHV5Rll1dnFxOS8vdWxPN2JzNk0rY2VtRDk1NjY4SHBvL0d4ek0yN1RtMWZtK094Y1l6aGg3NDMwTTJRV3JVbzVrdzM0TDJnRzdJQytLNDBBakNndUNBVTVqRlVjWWh4Y21aMkllRjFhcnV6elluandWVzVxM3ZuZHMvTUhBLzYzN1hTZkM0dVNhUVZaQ3Z0R3lwdHE4bnlpcEtMRzBvbUlLWDhsU2x2TnU3RjRSNy8rS0VEd1RYQnI2UVRhZG1NNXhXVlo1dDJaNzFUeVNSYVJCVGplU0Z0NHp1VENKTUtNNFBmSHZveVI2aHBZVDV3OUF5MGEvYlFmWm1QRWdxMXFIZWJMNVFGcW03clJqZ252aENXWUpMMjBQY0JYYjdhSSs3TDVEd3dyWUttR0hGUEZvZ29MMmRtOS91cW92RnkvdzhVWk9SNVdURkZWaDNQeENlblBjeTN3Z3FLSXprdlh5UlA4SUpsYUUrZkhWY0VqbDZuMjdkT3g2Vmd1c1RMaGlyOU1LNDZpaW9JOHNNTVJ0MnkvVytseURuT2NEVlIwVlRudDBEU1pXaWVTazZiNElnaEt1ak53Q0dTYW1YV1kyQmZFcms5alp5QnVOV1k1TEl3WnpBRVpCTmVqbkFhWWtlaHJkb3hKVFlKNCs4UVpscUtEWGk3VmpNY2NBaHBRaFViUThxVXAvRXhyUzVpNWZ1aFp4d2ZlcngyMFFsbkVXWlZOU2dKWmN3RmowSmtMY3d2UlM3NmxobUh6OVR1K25qbUFKUDEzQXozWDFRVE04ODZzS2NiMEZTVGg3eDBwcHBPOTg5WjhiakZzNVlxYzN5Z3Vzby9FNEd4TklYbkFrMlJsUVNjamIyUXc5TGloZkZNZHJ6aHBSUDJOV0orSWg4NEw1TElZc1pKdTE0NlhVL0o4VUljSkkxQVZSVk85TmFJd0NVMEtJWm5QVGd4R3R1Sy9wTlZ5alVKUG1wMUF6U1BDcnduenRkUS9rYmJmYVVxZHBwQnFIeWxVWjZZQVNrSzNibWxPWDJjRFdZMHJVb1dwcHRPVFZFbld1engvdjhZeis5NllsZDJVaytMVXVxTmt5Nno5SWRMeEozeTVrMXI0VXRYSDlwMzVOd0JJcFYwdlhqZ3lMNURWNmRtRktYcGtBTlh1M0t0Sm9GZ0tRangzNS9meFI4NXduYzZ5VmxWclZ3aUc4QjZRdk9YZEFrWFNnWlBEeVVEYVdTTlI0eUFKTTN3TW81SUJUdDhMT0p1VU83d1phUnVOZXFjS3JaRWFJT2cxaEtnY09qNFVVZUt0Y1N1ZDZhSmYrNXdjZGZjTlphNDkwOWc3enR3NkNMOXRkMXhZbzJzckN4KzhJMFRYZnZ4R3g1azFuSG5JeXVMSE94djg2ZTFLU3BreUVDTDdTQk1ZMDQyUDN2WHJwV1ZYWGQ5OXJkZXRuZGxaZS9MTHZhVWp4VXVYQ2g4VE9tSkg4RWQ0TUhWSVowMmFPUlBJVFlWbTQ3dGlsMFp1eUYyWit6VmlKczRNRmpRc0M0TTdxWUdLY1FJQTU0dVhxTWtmWmJNb1paRW5LTWFGdW93SDBRKzlBS1NBdGRESGRBTTExMWtFUVk4Y3VhZ2VjUXdoSmZVTUJlT3dYek5KRzdLSlNhbkdaWFRNUHQ4Z1RCenZDSDNDT3N1NnBxd2dCaUlmN3RiVUxXOUFrTW1KVW5rNXdqamxHeVcrYXVtTkpYSUNJemtnbHpQMWlkelhQSXFiMi9LTmd1YXhwZDA1UnNLUXdva2JmSUJaK20zWGc5OHBPTVlQSE5XZDh1Q0w0SDB6eTVKaGpETGRYWGlDQkxqY0x6RW1BNGppZzVoR0ltWGdCUklTNFMxU3c0cVdPWkxmTm9wKzRTenZMSVhOTWM2MlYwZjdhVWNWeEM0SUpYZkwvanlwTTFsMUlERGhHd3lycTlBSjFacC9vTWJZdWRpZDhmdWpUMFllM1BzOFRDRFFyYzYzeTBEcGZDaGFVWU0xYWpiTHJkenBCVVBXdk9VcUtKWVBKcDVKVlJ4dC96UWZsc2VnQzc3clhZVExWaHQ2TFl5OUJmd1hvaG9Vb0JQTGZJU001a1NRcDdqS3VUaklpaUNXTXZFK3JIZkxoWnZyYWE4eko5eUJQMllnS2dLRk4wWGdTMDVWcE00MW1Fd2ZKWUZhc3Z5cklCbmFlU3J4M0dDSkFxTUE2UlorbHlxZW11eCtJcE0vOVU5RXV0OWdxTXh2QklhL0lReElqRzg5SDFzamhkaWhlcXJxNm5xY3NiYnd5dFFHTU9obGh2SUJzUEoyT0lNZzZnakxNK2psWXRIQkRwQ3lxZ3VFZUFoRkVRRnp3dnNNaFR5NnFxWHNkQnJ5b2NMQkN5SWc0SW1HUzVGNEtYL0g4eGl6UTN4RmxtUXhBK2hWUnhidnhLNmZ6RWpBTi9VNTA0RTFuY0xCM2hndUtLd01lVkJHaFBxUE5DdS9kUlhZaE9UWnptaFBYWk9GTStOdFFXT1kzZlZ2MUhmeFhKbjI2NHo2ZHFHQ3NSVkZGUUVUYTE0N3J5bEJtZ0tOOVgwSndjWHFOemdncW83ZWdIbTNOaWNHdXRBb1VKbmJNcFlDdmVXREs0TzBnMm5hMzZReVNiaXFzN3h2amRCVENlbk9obmR5cEovNTN4c2gwL1ROTTFvMWd5ZEhrVS95dnk5biswZ0ZxeGdza0pwbG9MOTdHYzZyVUNNMUIyenBCM2xCODh6NU5kNXlmZ0VBMU5NWnovT01JckVNY3d6akdBSXpETzQrMmxWc0dkMENicjdFNGJFdzRoNG1pUkUvaGxkSm1jSkVmbmZOQ1RtZWtMbVdBR05jN2Vpd1dtVkYzRkFudUQ1aTVMeG03ekluQ1d5L2d3UEVzYjEyMkt3cHlLVXlMbEJad2xCRlIydHV2anFpT0k4UzVwVTBZeW84RjB5SHFUbVR1V3NRTEY0eWI2U2lhZUtJakRPOEZ4dGpvanFWZWRVbHRlWWI5UW1aOGNQaTRxWnlCUXlFeWU1ZENNenBpVVNXanFydVlmM0VsYTc4eXJIamlmVEdTbzNoSDRaRm1xQ3V0Vk9WOGl4UHJJSE0weUE3bXFodFVJZzB1cFZvbEVvSnNndEJiVTBXVHJoS2NxNHJ5ajE5ZU1mYk5jWEo4YjMxNCtmTlBJSGlWZFhsTEVwdXIzVVp6eUtlaEhRZUV0N0NJZm13QThmZmR2WWdsK0dGNjNPVjkrdHZ1K3RkOS85MXJ2SnhteFJVOWg2YXFwWVNVdmNTVHVSc0UrWGZrTlhpOWRtcTlsc2RYUzlGK0VwemRGY1p5RUxHS1dVREQzVCtQQ2JNa0JSZmh5Y0JwM0IrWkZid2hYeUtrNlFlZEVURVlyWlVLeHN5bEZJQXhxZGxYbDliNlc2VjBORnBTbGF4MlpuamhTakMvU3RlNkxGOHdZVzAwV3lzaDRFMmtGRFpLUlVMcGVVZ1prcTFXdG42VkdGWHJGTmhzakdKakRxdFl1UXZ6WHE0aEVJMERjaW5jdzBWc0tqaks2SWRvbHFOOTZLZDlFTm5uclAwSHppUUxtaExwL21tSjh2bFhJbjg2d3dMcXRLVW9SeHFRUGR1MUhPM21WejZDUTk4NFpTNmFBMUtaZ3BKSWsyTEcyNTB4c25FNHIvb2ZLTHkza21GMDl3U1VVVVVUVVBMSytrc2RvdTEzdXBJeWFGeWR1Si9HRzQ2SkN4VjdSTk1TV0lIcWVsM2NMUS93RFg4VEVZNWZNMGwzMmtsb0kvL3pKT0J6UUhhR2VudzhFd29LQVhPZ3NvTnkwVkJqNEhjU05vOUJUM3E2UHVCbUdnNUVXODVNaXJCaDRHa2F0QnppMmsyb1dOVVIrRGV3Znh5bHMrU2t3c0VjdkJlRDJFbnRVMFdXM28wQnlTRldyUzdiSm9TUElSKzUxRkJ6VDBtUFFGa1hwSlV2Y2pUTnhaSzgwamF1aDhwN3RPK05jQ1JXeUxZcXJjUGdvcy90N1g3OTBIM0N1TUkwWHN6UjhHRXNNVWdXK3dDNkxDdElwb0d6M1NKaHUvUUM3c0xuSXMwYStZdlVDQ29QOC9PWkF6aUlTYlR6QzltUUE2MHVDVkZjczZKUUgzUUFnWHpGeEJZcGR2KzVBeWJyVjZiY1RaSXhoMHdsalU5azdVNW9OdnNsNVlwNDBlYmxkWDhhdi8xWkU0bUNmRHhsOGRjMi9xdFFldDN1N2ROTnh0Tk1MRHdtamprNW13OWJmbXNCa3J4aHBiMUp4RzVWSWlIVUtobFVTZ0hTR0NYRUJsWm5TTDI4TTBFWVJ1KzJseVlxYlhtL2tyM0JRMUtYQVkyRWphQXlBMGE1THZlM2RxVWdLUEpTU05iQ3pOL3RmWkpicjVzM09TN2pFdkpwaG4vbnpXVGlidHJLUTU3eHc1U3VYUkFubUI2aVl5R012WGpmSWpWZ2VMYkR5ZzQ0VXV2WHc4UW9HandRb0NKbEVMellaaHhsczZWenVyaTRjUDdacGM2SjBWQ1dma2NJZFRDU2VwKy9lZkl0ejFrbEE5K2E2WFBDYUpsWEtWMFNweGdmQ01uZDEzeTlKaVo0enVKL2pmcU9aelZ2bjBJd0tmUzVaUDcxZnlHWUVubkpNZW0rNm03ZDdNbmFrNHordXNLNEhFWlh1VEUxbmJ4RDNiR05VSkZDSS96OWhjaExTRHhoTHM5L1ZOT05tL3VMNCtpZ09JZWNmTHNkMlJMelFPb20wVGV1Y0E0cmZPb29zd29nNGlyTTBRUzJMZ1ExUm9qZ1E3ay8xRk9KWlg5ZHJxYXErUW53NFBydU53K3RSZ1hPRk8vNWZEd1dUUXJ6OTFxbmlxNG53Z3Jtb0lZTWprTS9QL01CeG5FVzFGTE1RQ3lNZ3hGeG1pTUoxaEpVcjROVW5hTHVLK1VVemVacEZpOGlJTWtkZG9qQ1VQSE5USWZMTGMwQThzTjhySmd3ZTEvbGNPSGtpT05jakJnd2ZoY0hpczBmLzhBVGc0TndmWEg5QXV3V0RFN0R6b1NndkR1cnUxdTc2NHRMR2FLMTBNdjhqNjB1SUxNTlJLdWQ1Z1o0RFJnYkZ0SFBEd0dJdFppTlV4SzZvSWl6U01ybHEzaGVCaUxXRkhvcU9CR29wWXk3M0s0c3RPTGxaNm56L1FUcWZieSsyN2p4NjkrK2daQ3RDeDUwaXJkYVJGTmxiZk5DdDg4cFBDN0p0VzE5WTJqK0lGSVI3SGVnc3ZpRjJDQjRseHVpUDY1cDFabHFqYXlDUzFjaVVvd3h0MjNrOGZVeDU1c0Q2NTVKcWxSbU9WVEo5Y2JkU25DK1IrK3FnYlJ4N2VhWEpIN2w1KzhzbmxNN2ZwTzliOEZsTHE0WnBQZlRGQ3ZRN1ZBOEZQOU9jb2hWQkl1THBUaFVmSUU4eVFVRlUwU09VUXJ2bXY0Q1ZaRVdTQlZZeGtVK1l0VnBTK3JNdU1PYnQ3MW1Sa25lY2szbTM0SlVIZ0phNWg4WEl6WWNMeUxRdUtMUEdzSkVSci9oczFsaFY0NFB0MTJYUXlKbkNON0FsWjUwelBNem0wOUNZMVFSU3Y1Y3lNWThKaGROcGdXVTFrbWRpZ243RjlzWCtuWXQzWXFkaE5WSE50TXFIRHlqQThPYytnMThoK05oNGI5dlY4Q1dsUEYyVmZIN1BZRGFGK2EvdEpxeHVCUkNIVVRiY3o2Q055U3RpZFRoWHlybVJ6SEo5emdtSXhjRTJPNFdYTzRhdjIrVXovdCtPMkhiZmZWU2dVejJoQjVrMnN6VCtORnpsNVhuZTFSQlp0M2h6aFhSQ1RZQjB5SlhvMU9XYXVsTWNLZWs0ZlUxVXZCWk1aNnNsYllrWFpFMndtKzYralVaRnZLOGozWi9ja1A4VUZoSDhaWEpMeXhuT09EU0lBSXhPNUlsbFlucjVLTDZYajdpL0lJaDMvU1lwcmZnMjJDaU82VGRvcXVGelFpREpxZWdnNlZEbm8yeDZWbm5CWlFEdFBWMnlHVjhMYWdlYk9NTU14M29lMlF6TEQ2MEFuNXpTaXNXa3BmNWhsWDZYYXBoLy9XMTZNLzY0dkNhbHJRQlpjZEJWdU42dVJVd29qTWZKUlNlcHhJaEVFVmxwVXhBNVJTU1p4YUp3bHhvTFlzdDlTWmgvVlJXamgxNXZKWGlCTFh2K1BxL25yQ2FONkw3TmJvcWhPeWJxZ1M5eVlJMHY3Q2ZscmxjbzFZUjNqUUdQMzRVcUlEaDRVQjMycmJ1NGkweFdIOVl1cVI0TlBxdEdTaWI5SmNrN2pmSnN3dkdNTWEvSTlZdnRjQ3diK0Z3V1pPU1RKUms5alpVSWs0WVNrT0tzNlF6WVc3SmVkNEdWTjMzcnovdi9MbjNpWkxjRUlGL3JmWVpqckZGVmpwam5nV0NYZDFnWnJTSXptNCt3Z0IvN1RadVA4TjVOeGZyRnkyUVNjeGRMQzNjV0RuSFM1L0p2MzVpdVllRlBSZGlUZVZKU2ZtSGd6bWQ4OXNnNFdhTTdOWFlqVitCL0l1SG5aaEp1WVpQUG9GYnYyVEdSM0RaSnM3bjUwUjVMTlhOSlJveHlicVdRRmMyeU9KTmUwZVVQL041SnJwanZiY210dXh4WU9zOS90Z2wvMmR1T2lFTEY2WFlyNkgwNEZCTDR0eDRjUkZOMHlWb0NzWjd6K1JRUkFKd1V2OHlGcUxGeTJNSGpPTXMxNXJsQ2NuVm5pMjRwSWx2di96YzFrWEZLRWE2K2pOc1A5OUtybnJRdTZPMXNvTHMyWTlnVlIzdjUrNkNNd2puRTM2Q1ZRQXphYUJsMVRmUDBRUnpjWTRLdlNyQnFZVEVQczRPSXNZbTFvbGkvYSttc2JIL0xGVTRibGtvS2J1VTcwNGEyK0t2RlZJTkNzVUJWWWJybXdiT2hZRDhPOHRsQ2NtVjNiZ0J0U2E3NXVaTHkxbEYva2Fyd2s4VFVlUFZkK296QjczckVNdzNUUHcydkhodlM0UjNYS0FWRGtidXdOc1cvQktPLzZXK3FWb0QyaUJZdGljdEhHUUJlV1lZQmU2SEExUEk4V3pWSW9ycldvZTJnN3lzazA5RXFHdWtic1lwa1dnTmtScU52WlZvNjRXbm1XYVlmWHRJWnA0OXBsZndUYkpUdzdsMk5hZ1QrOEsrSkNFZnl2SFQ3dERXNDgwRjBWbHJnQWxqVkoxSlVuVFY0d05GZFVIRTl4YklGVFpJTU5CTW5RNWF0aFZNYlRnZXIwbUZUT2o2ZklsWVpoMk9sa1FaVjVUdFA4SUJDc1hpTGorWnBLcnVSOVUrUXN4V1V0MndJcW8wcVNBTzByMm9UemRWbHhsTGhVNVRqVmRoT1dxQmNNUXdnY1YxWllWdUlkTFFsVWg5VWtMZEJ0bWVQR09FRzM3YXlwR2dWVGRKT2VRNjVuSHhZazFVcTdtSUgyM0ZtZTRSWEo5Qlg1WmpOdHFib3FvNnZ3TzNoV0VLK1dWVGpNRS9FZTFPWUpCMjB0RjhSMWkyZVljbGtRTGF1WjgxSncvbjVCOEhURjBxdzB6SEFEN2k0V29iNW0zRXNWREltNW15RGVFYStvcW43YVRlcHhWVlprVk8wSjdGc1FFa3ZQR1pLUGlaMElrOCtqRjdPbW0xWkMxV1JOMUVCK0JnSDZQUVE0QmQwV0hGOU5xRHE2WlJkQjN1TUVUUjNxdEhDY1hSbGJSdlNpeXY4UEk2VTJNakMzajBPeTV6L2VoODlFQStSdEkwUGlIZjlmbS9SRlc5MzNnZTI5RmRMbkVFZGVwTkpIYkFESU9ZcmtOT1JucGlqS1FBT3hCemR4RTlLdDV5bTZ3RXNwVzNuMDJSQ1JrQnVXcTFKL0plQmtDWVY3UVg0QnB0aG82UVBZaUFFNzNkdEVvRFM2R1Q3Sm8wKytOblNxS0ZEZWRWY2hmT0l5ZmZ6ZThMbGIrc3NKaWh1RUVuclUwMTZPQllHazJFYmN2OEZzeFhTR2U5aTQyT0tqOU9hWXc3V01jYkxBY1d6RzQrUGxpU0FncWpPZTBWK0k2VGRLUVRCVkhJOTd6UExiQ1htQ1lhN3R2eXJWU3B1RWFUSGtIcHRwRWRaTXQ4bjF4NmVuYzBrbElTSmFwcTRXQ2pOallrSk41S1ludXFyZnk1WmYxVTdPclVqTzdOallMRzl6SzNPcG9jOEsycEFsOUtad0EyRHQvVnE3eGdkb1QyRnIzZURpeGJPUGJCUUs1SnpDVG83UHFPck0rQ1FydjVtc3YzenZxWE8vWjMzWlh6N0I1SFBBRVk3bDhzeUpNN0hJWC9keStjdGkrMG1BcVJCRWxNZlFKSVkrY3k1OGFwaWZ1OUZvUEgraGNlRkM0WW5wWU9hZnArUFRmemtUVEJ1OVorSDRlVGhPMW5zOUNZNGVnRS8vNytHUysxSGxIdVdVUkg4UUhFZGJYaklqMERJUGZQd0IrQ043VmlaV1ZpYkllZnJ6SHR4ZldRbGxuKytUajVPbjZMdGk1cEFjamROQkVhY2I0RnUyUjN5ejJ1RncvSGptdHN3ZjNacTVkZjJVOWVJOUc2OTR4Y1lySGc0ZEJ3NFVUeFFMSjRzbkgzNTVNNzN2b1ZOckgxeGIrK0JmblY3Y2QrYk1BN0ZSMzVVb0FuTW81VVN4aytHYmZnOXFITDNtRityMU15aXBSelllNnYrNE15ZGNPUmF6c1QxcFRxU1dYNHVpT2JzdEh3VmVlbHlFejNKOStVdkx5N0N0THkvZmo1dGxFQitYbjRkditBbi92aFR1d045Mis2VnJVK3RsWUcrR1prdHlULy9IOStkaDc3V0UyOUgreWtpTnV1V3dNcyt1YmtaMWVXcDFZQnRkSjZFVFFNd3VpZ1IvclY5U1RpeVNQY1dnVFRhaTIwbDhVT0lndndYYzI4TTdYYnUyRHJzdlFFRTd5dUVpQ1ZiczFraVYzdjc4NnFwRkMxUldWM2VXWXdjaWxyUCtrOThucUluUis4RHQwUXM5andWdHExZTdHNnpqdjUyMjRHN1pwbTZpdGMzSUJ1d1BqTUpSL08vZmhQbUtNQmVETU9JdEpVUWFpM2lUd2tXR2VqSVlqVjh1WEhuYndlYWhWbjRtVjlBY0hiN2dCK245emR6QmczUC9XRzQyeS84WXorZUNMMzhaL1RycExqMDRvcjhJNDRCcjdhS1BPVldCUkxHdGJ2SHBwOG42MC9lOEVMdm42T1prLy90UGYyeHk4bU1QMSt1RW5kakt4Ync1eEVtYmlEVVJrU2MyMEJUczBCYk1JZzVRdVUzaFFLaDF0K1Z6T3k0aEN4blB5N2ptc1c3MzJLNERuV3ExVXpOems3WENQbGMrREV1cld0clQvK05qdTNZZDZ5NTFhclZPbGV4ejhmcDM3OExyNzZ6aXNROU9UeGZXVnFwNlJyNVN0dllXS2lPblVMLzN3dmZJRjhsN1l5Vm8yVDFZMjJxSWtoUzZyVkpuUkZ4WFRSSmxnaERLcnQ4TjJpeHdWL2dML2lhcHFCbHZ6cmRZamxHcktidG5yVm85TzFWVkdZNXRrZGxhYldhMldtMU1ycTlQaXZFRjN4OXIxbStvTjhmOGVOdXlhbWZMajB1eXdPbTMyYWwyTzJYZnBvT2NKVDQrT1RreFFmenJ4c2V2Nno4dittTXAzMDhWTENzOThJRXFVTjBTb3FYNWRrMUVIdjlIVnVMOCtZUkYxaE5XLzZPOUhqbGpKVWJvckJYellvbFlKc29PQnIxQmhUV0tEMEtEVURERVBROVVEVjNZNHFHQ2ovcmV6ZlB3WGNRY2o5THlyb2JWcytLcG94TlA1NnE1L3I5VWM5WDF1NDcxMXJObHN0cnJiL1pJZkZkOVYxcHhycnJLVWJTcGRQMTNlcjBPWEZpRnYvaXgrU09WTysrMDk1VG44eE1URXhOYk1zRXFsU0ZuYWJhREdBemRSYWFad3pCaGtJRDlnVGE0UE55YlllTTcwSnk2OEhMcE5peTU3VFF2Nkt3bSs3TCtNUjIyR3FzTC9CSlZJWDZEYm1IeXIzNGxYY2JrRXVYMFZ3UVZ1TXdhRHZ0NEhMYzFWdUZWZVFSNjhTVjMzLzJUMXc2RWZLMkppQnNYUkd2SHJxTkhzNE8vaUp6OXdzaWhZWHc5K3JnbG95eHRNUklNYTFZYzdsSEpudHRSelZxeFZpWW5wK0Z0WmUyRkdQMmFGaExmVC9UL0h2VWs3dittMisrVGljTDN5ZEg3TnJCQ3FvcmJqZnY4aXlPVnV2NVV1TWI4QTlUcGJWQW50QllNZmRiWVZvQk9xQjVWbGlEL1NKV2sxSm1pVm81RkY3MEVuZENTeXdkZE1pL3B6RkUxK1g2ZjRmL3VIN3drbno4eVFkcm95Slk0bE1BdmNzdUVKZ25jRytNRllQYnFjVStUV3UvcC95VTlOZUtQYmw3cVFVcE9VZC9SMEFWMm16UHNDRjFpc1Q5STBTN2FsOXpkZnk1MGxJM3V3OStudHBVeXFwL2xLWkl2T3F2VWVLb0QzbkpaOTh2MlM1YWV5WDE3bFNpVGcvdS8vZTMvUVE5dGZPeGpnK0ltKzg5dDgrdTlqRStzUzRmTGFMM3Uzc3o5NHJIY0RsZmZiOFBCNDduWXRqV1RwNWh3NGZ1MWhvNkxZZ2hRMk96OFRPL1hzOC9lUkJJVE9PSlc2dFZDUEhIbHJiYytkdXYzZXArQzQ4b0tqazJySU1DUlc3ZmpFaUxHZCtXU045MURZMWFEQ1JLT1BOZW1ZUlQyNkp1ZjVzdFRaYjd0YUpxalBWeS9XS2VPdmI5SDY3RGJUdm5wdEEvcmpPNzBQMHg2aHcvM043ZlBvZFRJSE1LUlBVbENtSVlRYmpHYVNqTUl5S0RPbFRMVElwdXNWbExSZFBxVjNGU3UzQ2lucTgzS05oLzB4T1Y5ME1NbTMrbUMvdXR2eTcxOEtyZmRCZjMzNE5oMGJsdVoxY3VXR1lTdjNCNTk1MHVld0NYTDVXU3VOMVBkclJnSWE3SDlXZDhzTjh2S1RHKzZERExCME84MWZPYmxubmhKNmR0TEc4bXZHL2JuTkhxL3VWRit3VUh5Mk5EclQ5Z0JmN2VUa0c2KzZCWDdwNnE2SzhtT3NieTIxcVFVNVNUZHZtRmtuNnpmY2RYVW9xc2JrcXdaenRyRzJpWWxMQWVvdmpiOHV5dTB2YkE3Zk5lR2RHYkFMZlBBUVQvbm1hWm5IdmpNSTQ5ODVoRmluM3JtMUorWWVPUzVSL0RJMjU0NTljeW83Z2hqUDJuRUJiSTY1WDBNc3JQSXdKWjltM0syNjYwV3NvckhqNiszanJmV2ozOFh2dnQvQlBzRWpnL20vQVBrQVNoUm94eVlXRVkySGwyaGY3RDhnMlh5QUhDK2h0a3lZUDhIWkFKL0dDMXpORmN0eG1YRWNNRUpTVFdWMklCQktKQll5Z1p5UUFyOXplWDAzZW5KSC80UXBnTTVoR0JMMjN3aUVCMWxNT01tQ1FYUEtnK29Gc2IwVUovNXh5WStOdkVZblU1Mzk1OGlHekM1dm11bkdvVkNBNDZrZ0VoYy9PRVBCM09xUjMzY0xaVEovR0gyclE1d0xMVk5ZQUpvSU0zUHJhMlI4K3Mvb2pFMXk4QWdySVZ5OVRRVEl5ZGhUOGJzR2RnSXJRQ0ZHUnFnOU1oYjgyOTlmYjcvb3dkeVozOVVlQ0JQNWgvUFA1N3YvL1BQNUcvY20vK1pmRGhtWjZBL1R1RG9BM2tOYm56Z3U0WCt2enhRZU9sMzgvMS9mU0MvVFdZMDZNajJoOEVjY0FPZG0yUXpEQS93dnZJVjcrTFRUei85ajEvR09uODVxYjM0eGVyNjJxbFRvelNhWXJYdUp4RldxN3RGc25BY3dCSkFMWHF0OTNTLytyVmR1WHZ1MlJqUXFrbDBtUWZLL2FwZEUzaWNESW40cVZOazR0UXBYQWd1TTdZcVZFcHlVVkFxVjZpOHhOTEJSWEJJNFlqNmJ2amRnZzlKYlIwYmlWSHk2ZHBPa2E0WUVCSm4yQ2pCQ3R1SmRNWW1HU1laeXpOZE10Tlk4dmZNek9keTh6TjcvS1hHUXFXU3VDVlRiNVFtTW9sRVpxTFVxR2R1NFdTWnJDL05aZHNIcHhycGRHUHFZRHM3dHpRMTFYL21US2s1VVc0VXM5bGlvenpSTEozaEpHbGIvQUNzUnEydE53amh0eGp4MmExSExZUVAzeW96ZWdyRllnakgvZmJjVkRHQ29FRGxFTURNanNDQjJKK1FkWW9rNnZYNlJwMXV2b1JmOWVmcEZoM0ZKdUVmd2UwTHNjbkpsWW1KVTVPVFR3OTJvakUwaUFsS0QvMERCakZCZXdnbVVTckRYR3dWbTZQUkpvOU5icXI5eHpGTE1CbUpFMnI4OTgrcS96ZTF0VVI1V0NQYk55clJnUGNxQmpEL0xxejJueWViL2Q0eUthQjhYV2k4cnRuY0laUFhZMi9ZV3NIY1JXYWVLdWlvOFhHR29Xb2IrRFZmQzVIQk90MFFnWHVHb2ovQTh0RnBWV3QrSU02eWd1aGorRzFnRUpHR1lQaWRGa2FFWTRDdktHQkJaY1FFQ2pPOFJEcWlUcmc0ZnBZUk9kNFNHWW53TEd1SmhzMDdhRGJqV0daaWZ2THJaYzMxRWJNbVlGaWRJenhSdU1JVVo4aUtZdmdKMXVJWWczaEVKRDZSVXd4UjRwd2hNQXJQb08ra1VEREh0VEcrYU1oeFhpZVNwa3VkYU5YdC96TUhwSjR6Uk1abFpGTlRPTTNnZENIRjZGbExkQm9Iajh4UFRwWm5tWVF2VnhXNXdJc1pFWjRmQ0pLc3M0ckdzNHFJVWFFS3NWbUNNYTJzei9naXF6cWNMUEVlaDE2VVJDeW9PWFJaRlZoZjlGaGJVbHgxMk9hcjBPWUs5SDVpa0xkRWJFZXFrSmJZNm9aZmR6NTU1NHVQWG4zbkx5L20vZnlkaTNtUWFjNi8rS3FEYngyNzZ0d1RKL2J0cTlmaE04VDFEZnN3eE82dWJQWGowR2crWXN2Rzd6aUNVQXRodXovK0dISlZQMDQ1VHNyNU1OMWVjM2hCLzVZZXRkS1BrY0Y2N0FZN1l3LyszbHNyRmtmbkljaHFyWEtZMFJLK05tNWJmUGJaeGR0V01VZnllbXcweDNoQS9TeGlsVmJFQ2JSR3dzT0E2aEZnZUlmSUxKOCtla1crdjVtLzRtaTRYTUMyL3lpNSt3dVVOU3VZdG0yR3dWWmg0QlZwdytpMitwL1I4ZlJPbTFHa2ZidUVieDJkeVdlMm9rMi90SEVSL2xGSmsvNG1EU3ZSZjdiUk9FUC9vdjc3TzZBZFR3NDFyTnU5ZS9ZTUVxQUpRekV1VkZvUUd0TktseTV2ejRrOXJ5NGtFb1hFdWJINU1TTEFZK216clFSd1FIdkc2NytSd0pNZnJLZkd4bEwxYlR4OVZCZW9pb21RZGlXMG5kUFFYdlFWWU5zMW43eEdGViszL2hJV3N3ZmgzcDI4K0twMVRDLytCWWtabng0bkRGSEpFdTdXR2JiL2RIK3FQN0FYQWpVa3ZRSHRRS0d0QW5TakF2UUQ2ZG5nMDV1Y3ZHZGk0dDJUUTcrczk4TGFYd1RLT1lmNVZTcEJEZVhza2RnMkRMb0lYYzFxM1R4Yjg4UmFGS1dJV1pMYlFZM3MzYjE3ZHlseFN6RkxJOS9tOHFtQ3JtWEczNXg0K1Z0NTJTSnZHZDgxZmphZE5rK1Vib0xyaW9sYlhPN0VDZW5NUXZPQVVlVHIyZXliRXZmQ2RjY2w3aTFKREpjN1AxUE5aREovVUtUMWVTL1U1bnZSbkJqeVoyTTcrRFRhemdraTBhOVZ1djFlZUd6a0w4cjlHMXNHZWgyVjUwUXphZkE5eUttN2ZNbk41RERkNmY5bzVCSFIzT21GTVhCcHpJaGIyOWd3My9FT0U5cjQ3V2F2WjI2akU4aXpUNkgvSHFiZ2dGVzNOWXVvbWtpUGNaaWh5MTRBN0ZvM3hJTnpxVy9TSjVsRWFVcVducGZrcVpJZHo5alR3R2x2ak8rWlBwd29KY2hoWGx3WWU2V3VTSktpdjNKc1FlUVBPN3FwWGozN3lnbmZuM2psN05XcXFmYy9nUDVpMFR1OGxNcHFEbklxY1p5MkhrdEFaS05QN05hNnZGL0Q1M2JDZC9uOVV1TEVMNU9hbGhqclB6ZHU3VStReXJPQmErTUxXRW5iSnNmNmZ3S24vUEZYRlhPOXhIdHUvcHJCbWJwRG54N3hmYXNEdVRCOFVuZWtadEVUL04rR1I5d2NWbWRZOEIxYnJ4NFdON3N0ZmpFZDhqNDdKR0FYbVI5Z0VNdmsxSkIvZXZUUlQyOU0vbkh1ajA5UFB2cm9pQlJNVG0yY2hxT1JMbnBFdng5U2x6Q3Y1WjV3M2xCRXFwRk1IUldxa3k3Ni9NZ3hWRHJ1dkk1WXE4c2hyTGJUMzFoZUJZSVdxVGMyUnM2RWVTeUh1VFdXLzgyZmxBNkdQSUZNN1V3byswVmhVdDR3WU1vejZEZ3F0dWNIVG1QVldvZk1KY2ZHa2tCL1BvYzBDUFlQM1hCSC95S1phOTYwYmpqaWQwRFVHLzVOVlF1ZFRpR2R5WGM2UGl6N1cvNEhGeU05S2RxM3RqU2s5RW50clFSY0xYS1kycFUrY1A4alFGOHdHVjVoazFxYTdtcFBOaHFUaitLQjNqWWFpR1hHT2p0Sy9ONVdJYU8zaC9lRmJVQWx0Y3BJN0RXTlN5NjJpMlF6WWZlZlJIZHNjcStkNko5SEY4SHI4ZWRYY2ZQTjcwUnlUb0g2ZExxUlpuSkVLbkh0c3YxUEk5ZVRqVXZMRzRrSE50RFdGSzc2SnBuaHR0ekdiMzdrNXVWNlhmUzdFK1dmYXhTTGpTTFpPSHZGL0pPek0yTHk4TUdWNGhXdks4NFVpek9Sei8zejBCYm5hYVExTUY1K1RZUnBJcllIMHlRZzZ4dU41ZVhHeGdhSXJSdHJqVmZtODVhVno3K3lVYi9yRlRoRFhuSFhpRysyRG55SUg2MWpaWmh2Vk9UQTlkR0ZId1FUNGI0UVc2Nm1udCs4K0VJTVUrTStmdXJVNDZucUM3SDFkYklhNWtabHR2RWdsM0FmbzN6R05xNGl0b01IRFduclQvQzkrNldWZmZ0VzlqbWpaZFgzNGJGZjJsWWlvVEhjcTJTTmFyK2FuWkgwRnpUNWRLaGV1akJ4d0ppeGJ0cDc5WjEzWG4xNGZ2NTloNnFkN3ZIamUyZXF1dzREMjRVSDZzZnZQYjZ6YnVvMkc1cy9zSzA5TjdTckRlT21QempVdjZHM2V6N0NYK2hnVk1KaUNOVDA2aHVUeVo5ZktUNlZlK3FwM0g5dWFIWXFmN3loNUpPOWoxNmZ2REw1cm5qK0hia25uOHg5cUpGWVRPYlV4dEVjVU9OUlhvK24xanFxNStwZ1dvL092OGZ4ZldLcFkzN0ZKRCtCNDlzb1o3UEUvUW44WGpqZWZnRGo3VjJ4c2FHdEdvbS9NR3pZME9jNmlxZjF4SURBV2d1c0RmTmVONW1xVmxKSjl6ME1yTHBWdXNQOC9GMXdhaXdsU0dkc09HaWZWdmhVTmR4UmxETmJlYjdEV0dnYzRXSlFvd0hSZ1JqTWt2MWtsdlhKdSs0dHZpRU1qYTd2dFhpemZjaVYwbiszK2tRVUpQM09zWU91TmlNd1R1L3pPOHZMWHE0OGs4MFRFL1l1VzJ4YWNnKzFUZDdhYTEvdUFUMkhFV1kwOStDWU11Z2ZYTVBDcUd5TVo4UVJRNlU3dXBSUnl1TU1PY095SHgvWlAvdlJzNU9GOUF1eGRHRXkxTzZ2clVYNi9UVnl2dFI2TGorWnRxejBaUDY1VnY4YmREbDRjSFgxL0dBSHE2aU02S1ZDSytsbzNtVzBqSVI1RnJZYlJNTHhITmxDZUJEaWNIa1BJcnNJME5MdFJwRmpkeDJMYkNMM3dvRStuUG1EaWNnMzRETzkzdFRRS29KWFVvUElvL0F6QjM5S21LZGtsQTVtSTQxZUdFK09ydFEyNW5Pbmd5dEFsN09OcFp1VFdlT3FPYlRSaHJ2azl0VURqVm91bFc4ZTNuZmkydjR2dzJiZjZvRm1oUjdaenZ0cmtXVm9TNzRXTWNrMENsZlJKMkw4djljcm5LdStDdjZUVUxmVUkyZnFuNkt5ZkQya1QzOURQa2JlVGVtVHYwVUJocjFJN2VSdnVQQUcrSHZpaWR0dmYrTDJUNjlhYStUZDlFaS9mOGRiNzdqanJSZGV2cEE2OE5BSVR4ZEY3VzhaT1FmRG96TmkvQmtaRHh1VWNmem9DN0VYUDljcWJRMEZodktZNjlqN3pGQXVHV2kvZDBvbEdKWmYzaTZiak1na3Z3RnpzanFVUzdiSkpNZ0NqTWdsc1o4R0o2VlZFeEdmYUtlUzk2N0w0S1M4bk9La2hOZ2JCWUtabWJWWXpHNTE3VnE1Z29KeGpweTY1NTVUcEpCTkpMSWt0dGJmV090bEcrb250Ym1RMXNjMjZUM1JIZlJTZXRHMnNhRENhS09lM1JYZ2J0bzA1M0d0VS9OckxvVzhibmU2c0EvY0NQS3pLS1RrQ0ZuWk85czdsU2dZVDdXK2swalV4MmJ5L2kzM25Eb2wzNWdnUE5OS1pEZGJKNHhwODZWWGRpWUt1Vy9jMWVyL0NDNHFLdE9LYzh0NzE5YVZHeE9mTjhYV1huakZFVXdkckZkaVI4MXFPZUpSc0ZoNHJhMWF0bnVuVHZWbTkreVozVmJkRDVzdmZleWw1clJ4NHR3Sll6Q1BMRHJYY3pBcUI3YitXbWh6RnNzdWltSGR5Tzc4R2RxcmRjOWJxRFlYNnRlTzExL095YTQyZlppRUVzdjU2dUxxK3VyQkQ1T2V0YnhXSmM2VjlXaXNZcjRnSmlZZ1pmSFRwQllKekJjdmZxblJhTUN6KzZ1OVJtT1pFaDk4bjJkaC9GMmdlZkppTVJCUXk5VHkzUW9HbW5qUzIrZHV1UHR3ODJlSDdqaDA2QTZpdjYveHFsYzFjSE1VZngrS2VNY1FKN1VZbThlWWxFcVl1VzZXaUlPTTNCVDBBNnBGMDQzSFRkSWRpUGExNml4RFhTNVpleDUrWWxJT1ZLSDlKNWIxR1lrNWRndzJQc3NlT3k0SThjSHZ1Q0FjLzBVOTdmYWZjMDFkSWZmZTYxZkloTXNiL2VjOGJYVlZkOG1FOFdwV1lPTU1jL3c0dzhSaDk5Z3h2QjN2eHB1UC9hTHV2UkR6c3JLb2t5ZmZsZWwvbmNSTWEzM2RDc2N6clljRDlkaEM0aHErSStybm9UNVVZNHJlMEpqZUJWTjZObEdQalBEUTgrUWZMbm14dzVlOC9MRnRsU08zYlh1ZEgrOTQyV1BicWpLaU03UkJmbDhCYm9WR0hKakVZRUpZZ1M2bXlCYUhtQXZ4UE1KQm9zY3crdDJIbUxUZFlWWURFTklRbFNEMDhlcFNqMUYwM2x3a201SldsVDJXWjRTa1lYbVlzcUZlblhhVmswVS9YL0JTcDJ6R1Rtcyt6emsxMGVFSU1mL2FLK1Q5eERHTmd3Y1podS9HSllhNTB2UWswMkJGWXAvNEFjK0lWcWtWSnhpVUtyR3NsamNWamk4dG4xN1lkV1lwWDVCNUZyM3NNU0d5UkJSZStOaVpYUXVuOTF1OExiTWlnNmh1YkVJdU1TTExDNHJCa2Z6UzlweE8xUGFLMWxJRVFyV3BmR0szVUU3QkZCSW9uL1EyTHp4ZmFEVFdNZlFhVnNITjNrNmZyMjIrU1VqRnUxdTV3S2d0Sk9pMlJEY29kOTFXVUVaL3BRWlpMVmhXZjlXeXlQbit1cFhOWno1azkreUg4OW5DUm1GdGMvTjU2NFVZbklyQjE4V0w2OHZMWkxQUjZKOWZMcUF5aWgzU1lUWTJnVkVWR0loZWFYbUJFZXBXalRETGRqaDlRbDF0cU12dHRIakUwL0pEY01WSmhub2Z6d2NSRHFSSWthTnlUQ3ZlN0RZWENZSk5kR3BrZGIzLzl3K1pyTWxab2lGeEJpdGd3QUF2cFNTT2o2dEdSMWNERldFRE9abXc2dUZrbm9HK0VaamYvRTFabEdRbUlaYlZtbkdTWlZqMk5zRVFDTnhGNFBzMmhLeTl1TDdlUy9sRVppUk9RaFJ5VmlBODlDM0hNcG9nWmlWQkU0aklDZHdyeExuZy9VUmdKY0tJa3ZCSENrOHNQaUdtNUpzd0UraEpUa2JNVzVrN2lRbFVvRFdnUjhtRFFITm5vbWpOZUZSTDlIMXBOYk5rQ0N1R1BnR3RLTHN1QlZ5RGs3QjR3Wml1UmhTVlBNaHh2UFRKVDRrOHg5MW5tS0tzV3BZcWkwejVjQ3JwK0FZeHpKbDJuaTJpWlZqM2FjSVc2ZmVmTW94bDNvcWJmSjdoOWlocE8ra3k3UHNNNDZrck82S1MvcUEyMEZOdXhSN2xZUDR0eFpaak40ZCtzamhjTVBFdjZubmFWWXBrSjNxaDMzZ0hVNXlGbmlNbUNkTWpGS05VYUtGRFF5dEFTSlA5WkFnWGoxUUdYZmhwb0JCNXJieS8zOTh2ejgzNUZoRzBCeldlbU81K2czdHgwRXZlemdrSXlNQ3hrdkMvZUptOTlzNFRweWt5QzB0Z0JzNEpYQUF6bDRSZjg3bzdQKzhZVng4dlZNK3FlZWdXNkxXc2R0TjQ5ZzhOcVA5VGxlYmFXcVAybElRSmJDb0NJOGlJTWZENjF4OUNQQUhvTDQ3aDlySFNHRWR3TTJ5SE1FL2lCTVgzUGs3N0xBcHRIcWFPcGlHSjNUQU1zVm9Ldi9DUWVPbWg2ZzRNRVhLN0lUcEhabWFQV2FMSjhBcW43YTFXOXVwUXk1eGk4UHd3TEZwWG5GVDIyVXNQS2FNUUl4OFVqVkt0WGpKRUlpZHp1WlMwb010aFRMU2lCY0hJL29WdFlDTlJQZjhGNUpBM1FXOGp1dFhSMkxXRERJUTA5d2JtOFViNElwU3RSTXBNb1VORWdFbExnY3JHZ3k1d1U2Z0M4eXJkS2dWazVTSTd0eHVFTHZSaWFNOWI3OGdMazJOYWVmN1FvZm15TmphNUlIZThtUktmVFhiVWlZYWl5WE1UYWllWjVVc3ovWis5VVhjekZYTER6WmdrTGJoUnFHVGNjOWJhS29uTnkvUFhYREUzclV6T3pVMHEwM05MeCtGQWtDMDJpRE92NWpGYVJ1RHk2cnhER3NVc3VSNW9iVDFsZk82UnMyY2ZPVXR1djk0d1VuVkN6cHkzQnJSMVVPZUYvMWh0UmVyTlN0N1loVnBWOUgrL1ZwKzFMcTNBRmRjTUs5Qld0bGNnOTZienNGNXpJMWlQa1ljcSt1QzRkdEZHS283YWNIS2h2MG8yckg2dlR0YjZGMGlETlBvWDRiTUpYQlBOdjd3Tkw1SnFDOGpvM1p0Yk4vWkdidG9tMTd2QXZjL0dkc1h1Z0h0ekxPYndLOVZtV09vK0dPWUpxMEtydVhHNkYzbFRZNnc1UWdGUVRLc3daZmYyRC9YbHV1UlQ2NUtqK2JvRzB6RlYrK1NwNGQ1L0Z3U0dQRFF4bGx1WVBhNjVUd2hxdkRUWUlkY096dDJYMGJMQnlDZWVWUS9zUERJNFN2YmtiN3p1YUJCd3A2SnZ1OU8yeElmNC90ZG1YWlo3b3BqYlhScnN2Q0k4ODNCV3l3VGJQd2RVTFBFeVIwTTd4S0R0QXBoVFYxMm01V0FvdVdHOUw5Yyt0UjF0QTR4bFRieHM0L3dGKzRSeitOOStvVzFIL1lmWUp5NnAvenVkSjlqK0R5L1hhSmR2eXVBdER6bFBqR0tFb04zcEZwVG02ZUx0MFRXN1NVR2RReHliZ1JkeWxLd0NNYUFZbWdRQVBUMHBMbENybWVQQ05MdlZDRUlDVTFUUm14RlVxQ1FRZGFWYVhqUXN5MWdzVjdkMmY0MVN3V09CSzRpOFlMdEtodUY0NGlmc25LajZnY2NRRW1RRlhaRkZ6Rm9sU2hoRFlqZ2VZWlBGbkNVbUZNdFVDZzdEa2ZNN1NnMTNDNVJZL2llWHg2SlpwbzdvTjBtT3lUbHBoaW5BS2pSSkVYQllSbUtoYUZFdlEwSGpMRk94NHd5eHpXbVdiT2ZqSElwNEVLV1lESmNSbWhxS3g2aVJyWVFGTk10UXl4KzJVWHhuRTEyODZXR1dJYzREMTl6NE1NTW9ENUlLR1hsNXdlUTRZbm1EWmhoelZEL3BiR3NGbVd3OGZKUHJhUHlSMWZVYmVjbTU3cFUva3F6SnJacFB5allXTWF3dVB3MjF6Y01LT1JYVlZndjlxR0xvS3lCQWpaQnd6blUzSDNxb3NMR0J2dHJ3RmZsRXJJTHNSYlBURU9xeFRxYmRqUTMzYmFUZ1AvMjAvOVRBSDJ0UWp0ME41dUFxdUx2d0VPbmgxM3BzMnpWODlLenU1bE5QUVFuaytOdmU1dEpIYmI4bWRJK25qeURINlFNUnN6UTY3eUdlUUpnekw4U3pvb25ydTUwdk1NeHBBcnpqR1dEdGpsaEhoQWRoLzBXRVlaYmg5d0dTbGFUK1h4NFFoblhLMFhKb2xoYnFSdzNTU2JFSkRGSVF2L2x5OTkyMm8vQWQ1UUFEV0N6TnQ0cTFNUEVGbFN6L1FoQU85UDlTa2tqMkFOeEVTMlNrMndSNnV5YUVwVEhiNitVS3M4VDJnS1VQQWJpb0hPcDlZY2N0aExsY3diR2QvVldwaGYxRlczaVZOdmRBWjdrUWU0RmNGWHRON0gzVW0yTVFBM2M1S0tUUlFEMDhIWDJobHpNbVk2WndpSEdVUEpCckNFTTh1NTB0Tkt6eUR0eXJ3WG5FRWFNUk9pTVhlVHN2KzRITGlxWnE2NjVqQmFuQWkydUtxcmhXT3A1UHhBTkwweVFRQUF6WlNva2NJMHQ2U2xKRVFRRW1XUzM1bGltTGdsTkZid2xPMUVWTkFmNVRrUTNYU1dTOHVHa3FpcVE0dHUrbGJCMmozNndWa2ZNNWRLd2dISyt3aG1GS0lrdDRGbGhLa0RFNFJlTEVoNGlnR3hTdVh4SnRMeFdVTStuQXRUUlprZ3cxWWFjRDI5Rk1RUlpSZE9FUTVpbWhtRDdqU0daYzVsWDduQ0xCaEdORVR0YzEyL0hOdUtTTG9peWJScEFNQ25iQ3RrU1I0d1ZKc1FxU3RxQ3dQTTJNSXl1YUNnS1BZVWtTTC9ISTI3SjgxSGNrQm4xM1grd0QwSGMvVGRjaE9TcEhYYmQxV1FqajFobjBIdTJpMWsvWmZZUE9teVR0NFRVbThYeGgyMVYvbFdGVlRjV3NWNk85Qit0WFBCRllPdlNlRU5jZHpRQUpnRk5zUllYR0JFRklJREtuV2JadlcwQ3VrelVHczRoeWtpcktFaTlBRXhtMjd5WmQzekJsV1ZKTjAvTUNGY1NqeENGTzhBaUg2YnBCb29NdU1hQWtnbGpvdk1ESkVpTGZyd3VXcWlneWgvM25aSUp5TGpub1B5M2hKZ1BieWtpeVJEQzdDYzlKb2liRG1DTngzb1piV0ZHN2k1Y3c5YmZJYWFwbTJuSE5sVUdBaExGbmVuNGk3U1lOWFJKQnRERm5lYU1MTmNCVW0wU0VQZ2FabFhpV2dNRDJNR1ZaTHBUbll6M2dLWHFSZitkUW5tK2pONmJmOHFtZldLdGQ1c044S1RUR0NQM3AwT2RxdWRjanNXWFk5cDlIc1gzWjJyQzZGaHl5THNKUGtPVXZYc0RvbUFMNngxaEFVb1hoczBaam0wTGt1aEdQczhFMzZ0eVdvZERUMXZXd3hiQ2ZIaTBNaXJJMk53dGh2TlFXVDFRQ0dlTlZzVStnbnlJTXNISkptT1JLMVgzY1BFaVd3RERNUlZDK05lcjJXL2FRLzZHOFpTQnViU2pmZ0Q5YTg1MEtoaEpXMnhSaWRaQkFjTENoSVp6NHpaUXhBME4xKzluUkRlWnAydjZNa1EzNWtIVDMxWmpOQnY2a2xRZUllT2ZWa2dYZjF0cUxVRzcwZUtBQkxHL0xybUlabW1uQjBOUllUQlFubW9LbmtQN1BycjJJWStOOHdHQktBay8yRmN0V2JTMXVHQWFqc0xvaW1TSW5xK3czbDI2UmRGODJKYzgzZFNNd1hOVTFOVitPeTJLU1QzRms2U1l4THNPbGdhc2J1bTlDQ1JhTUprOFdBejdCL0FxNStrNlJQTEFpaGUvSVhIMjNCTDhNd1h2UkdsRTl3UlFOVVpJMFhiY3RVek1OMVpGdFJQaG5QZDdGUEFJdldrc1MwUklsaTVGWkhkZ2pHMThQWHNXRGkzZzJ3UWN3R245SHZHbUpjR2srS2FpQjdCdjRkclpyNkthZGtDd3BxVWkzTERGTXdNZEYyWlVkSGQvTzl1QTkzVUEwSldYRW5tckhUc2FlSEhCQmM1UUpRaUZycnVNMm9STlE1cnJzUnZDYk9iU01kYWsyaUg0UE5xRjJLT2g2WFF5L2phNkhmdDlSUXZSVkV1UGJieDl1bm9YK2xPOWJYbm5nN21za1QrVVpCdW90UXZ1Nkd2YVc2UTlxSThjSnE4b2Mxa3VIVG9aT2pHdllHUXEyRjVBT2JJWDMrVHJ4Rkd4MmljR01hWm9UdHJzcjIwQ1BPWi8zR0VhRkRranhTUkU2Mk5kTWFFN29jdDMwUGNrazV4OVlzYVJyN241Z1pmayttZlJmQVVVTit0M0RyakYxQjFwWnhBSEY4Q3IwRFl3QUZub0toNWFPNzJJN2hxNnpNbU5KMEt2a25SemhWWVp4ZVk5RkowVmJkbFFEMzhhRk5VV1NSQnlrcWtlVUpQUmpBc28yb0YvaFpReGZEbFFoeVZQZmtpMWJlT2oxM2dXWjVoclV6UTR0ei9NMW1xWUZTRHJPMVdhOEJSSnpreDdyZEt0QjlGM3IwcVVFOW1zZVZRSlJqMDJhKzZjVll2TjFhSjY2ZUdURWZ2dWluL2V5dVZwckNkb3dENlN4NkpKSGo3WnZQdXBvVjVTZDNCUTdPMTY4V2xLdXZENHJuTjN2Zm9KTTdwNFM4K1V4WjllMW1PUEtVSnk1Yit3UkRuWTlkWGRrREY4NXVkQ2N0blQ5WGZWcXVwem5abWRJWGRnemZvMW43MzJkbCtnZUZySkhscUM0MnZnc2Q4aWNoSWx4b0owcWlYbkRmT3R1VWkwbWdtcXBkWnliU21sTE8yM3cxNDYwQk0wVUVNeDNhR1F4MXNkRDVMSVEzbE1vVTR3cXJDSnExdW5BcGdnQkFsSzBEa1c2d25tQWU1RUhLam1lMzYxNjNZT2tuTXQ2ZVYvaWlGdms4a0JmR0kwUnJ0Q2NvemNUK2ZvckZjbDM5NThsNWJGeVhwemF6WWpNL0p5akdEREcyS21jMHlscVVmMi9lM2hKUzAxeGNDdk1jMnU2S1FHMW1Kbmw4dVYwbFp6ZWEzdlhqQk90aG9XWmh6Z1lXYWFSRjBzcFJtYUNhcEFvVnNuaGJzSmJQQ0tQMm8veU1CclF5ODdMQ1VGeFVhWUFWTlNhRnlmRjZqQTdKS3pYMUxtVExMS3N5anBNa3ZUWFdZdlhlZUN1R09hYzRSbm4rbjlMSnVxVnpKbE14WmJlVjg4eGR6SC9GYkVLVlpjRllVM2pkY25VL1hqV2ZwM05ZSUpWeHV6L1UvM2NsWVVneUI4NldyWnZTVHBPYkpzL0R2VTR2Y3hiTWYvZWU5ejkweno3STlIenVHMDRUYjNZYTlIbXRUMkdQWWppMjFIVjZRZHhqR05CSkYwTUZ6RVpPREZEOXBOMnR4TW1HNk9weUVBU2FIcjBqbUF1ejNoUnR1QW9ZelZsbUxJa1RNeUhtbU1nblREcFFxaTRlUm9hL3gxTXczaUhoa20rQzR5cThES3cxN3pHOEFyRCtLekxLeXBUQUxaRzBPN0E2MEFRV0pha2M2NktmR3NCV0ExR2hLdFpYbFlaVmVaWndXZUFFZ0lQVXVCRWtLZEphTmt2MFRqNzY2QzVUTDNxazQ4ck5sSGwrL09tSk4zdkVWdjVPUEdydWdsbkM1YVY4T3N1KzNFZVUwVGV6d0Z6cktyQTN2RGsvdi9EM0p1SFNYSlU5NkladVcrVmxaV1ZTKzJWdFdiMVZsMUxWMVhQMHQwMWkwYWpHVWxUa2thRDFsRkxHcUVWcVNVd0drWWdDb1FSWUFHRGpMRlkxV3orN0FjMmc0Mk43QWU0Ylh3RitCb3p6K1ppK0Q2dzIvTHlmUDFzTXl6MncxdnB4WW5NV3JwblJveXUvN2h2cGl2WHlJZ1RKeUlqVDhRNTUzZXdWTXZpZE5QUjJIaU83R1BINzhROFhHaVlBZC80Z0c5K0xLbDVaQTNaMFBLditEeUFsU2JmN09QMDZrbW8xaDBhRm92WkRJMWxMU3dBSWd0aWRuRzB5bHRJRWhRQXJjMWdGckRhSFpBV2RWZFhkVXd0SzZzVlhCbElqNStUVGlJSmkvQTVkQkxQQnlCV3ZJTEpyZURwQUU3cDl6UHFCV0s3RVlaWktXRHRkR1p3VXdwTm9WTjQ0c1NlS0JPQlRUV3p1cDVaUmJ1Zml0NzRWUFRENjV2cmdZMHllWmJNWnlIOXVwK3FUKzZQMzYwODFjQjlpbWpONllnMVEvdHVVQkJ1VjVpaFd4RWZXOVZwTTBzMENjRXJXQkVJRmQxWmdwVjFnR3lIdXlnMXU4Z3JYS3lkcWZJbVg4M3NzRGlGWDV5OTNESVNhTDVZbUtkUllrZjdXMnl2Tko5cDc0cWovbFFac1lOL2oweVhrc25TdElSRUNaV25abWNIbnh5RTZHdzJtMEdEZnl0K1YwT3RYQllOL21XbXVQV2RNK0NkaXphY3lIWWF0OUFmYVovWUZhZEhwUHoxbUQ3OE92YXpnMmZIQlkrSlFiZG54M1lVSDhObFphaFpINWRzNU4rVFR5UHdGUnNhd0VFTVB5eEtNaEVDYjRPVEFONUUxSUlBQnExb1pBR2kxMEE4Rzk2S0VPQXE5Q1l0R3RYZUhSZkYrTHZoNkgyNkxPdDVYWHEzTGdtbkkwY2NTWEs2dWx1cmhTV2ROMDdqTHRJM3RNRUxtb2svb2xGVFF4bk5VTlhCSjFGTENPdURGd1FGZFU5b1BLK2RHUHdKeXVoUHVPNFRZV0h3M3hWbHpDK29Bdy8yTHdqRTlIblV1WGcxOEEybjQ5dUhkcHdXcWpoZFIrcHRvNWJIWDNLVnQyczFsQXkvNWpWaC9yYnQxTW5jNFBNOGo2N2dwYWRkOStsaC9Kc2FudS8zS0pFeXFSVGxnaDBWN3NONVFDcGFtSVRsNkZpK0JSNEtGbzAzMElxdWQzVWR6RG03c05uUUIzZ2U0YjVJZ1gzb1dkZlZmYnZRdGQ3WnM3M0J1WTJOczBPOW9GOGVRM3gvaUI3Uzgwc3JlRG1ya0N2Z1BNNlFuR0VoR21kWjI5aFlkOTErYndKWDBDYklvVlhpRlpNakVJcE5INHNMOXpGOEpqUUo2eXlmMUVKZ1A0Um5LR3Uxd1dyTnJhWHYxSXlhdTltUDNLNGhDc3pIWFV5MTZ3N1h2ak8wYTJoMEJoOFl4dURYTnpmUDFYVDhyeGI0L2EyUDF0RHoxRFR1NmVDcmhQT0hXQloxZjhxRktSaFRZelc5QVB1cDV2YlFlcytkSkdFVktNQWxEamJPbllOOXQrdTZRZW40d0RBeVcySlVDY0F2Z2x5Tk53aW1lY1FMQzlVR1o1RTdPQWNoWUdGaWgwOTEzQVQ0bkJ6VXVsdmZUL0EvSTdsRVFZdGNnT1E5Vk91ZUk5bjBCMmZQVWVySTF4M0tCR1NybVpGVzZEcnFab2dPQWJYMkFORG9QSHZUQmY4OXc3WDN3SlM1MVV5anJYdXJFK3lkWUM5c3V6Kzg3bTZlM1NDOWF4TTI1L0FrRmY5dHVyaG5ESCs5clp2UkFYSzdYWERldzkxL0E1NUZ1SDhPMW4xRzZ4czR3VnJ3NndkUERjOWQvZlFxc1ZVTDZoL2U1b1UxRDFJTzJsWm5KN0RhRXNiV1cxdU9QYnhGMUtnaTM0WVlucjFhYldKWE8zdVdqQ1FqWXIvZFAxdGJxL1h4ZjMrN1d0dU81d1dVWlFGWE05ZnlSdTlBeTQ5U05uUVR3ejhkcmZaV0IvMVZQTlB2WVE2c3dwUy9oM3BkL0dMaE05ZDFCNmR4ejZPNllKemR2VkFaZUw1ZmorVGlhTml4TFdKeVFJN0E2d0l5eGhOOHNud0FKcmRRR2VLQnlaUDN2SS9mODJUUWM0N2d2bk8rUHhua3RZemdYUUhQc2htYXJBek9vK0dTVUlCSkJyWXk1VzFtcExDZ3dXTVJBZDBSaWtSQ21IZW1xWVh5b1lRbDNpQmFpU3UxWllGakJEN0NDRGZRbkdCSWVMTWI1QTdNM2o4OTBHd2VhTzdZT1RXMWMrcVhJdS9wSWplaW5kR2ladWhNeUNBdmZlWWJaOElNRm5Yd1ZJbmxMU3dtUy93WlFmNzl4b0ZHNDhBOVV4QVM2WGdrY2djeEd1UW02bGtJTUJWZXFwWU9QMkZWdWIxS0Y2N0trNFRjcjBUZVFBaGU5UEZaenlQNXE0UzZ1eUlSaGhDNDI0ZHlESEJCZk50MGhiUm5GY3NUMU5pQ0dhTGJqNCtqQWdmNGIxYkJqL1FReEx4MXVFN0pPV1pxV09qQkErR2ZEdzhPNm9NZmNFTDAzTG1JSWpNekRDdW1jeHFlbVZTVXdWbTNwa0VxVEZ1d1IyNi9sc25ybWhiOWU1VVZkRVhRbnI0emUyWlN6Z0hadVR5bWJMaS9DRVUrTmY5RXRqZGNrQTZmQXY4UFpiYVh2dFcrVy9MOTNhSldNL2hXQ0Rud0F2QUs4S0ZyT2kxOWRRM2hzUUc1dFZEMzQwaC9rWHAvQi9VMzlNMjExYlZOL0M1dGJIUTYyL0FEUXNNNDRFNlFFLzZvcmZXRERFNnZyVzMyTjd2ZGtiOGw0Rk9rUWNvakNDRU8yRnJoNlJKZ1V2aEdja1BndzhDZ3lTdkFtbW16a0E4ek02aE1GbHZyRHF6Skl1bnB1NU5ZYmcxNWVFNG5pcXlNYUxkOHNOVjQ4U01QUDlTYmNXbWV4VjkvaUd6Wm9CbEdvaU1NWWpPb2Q4Mk9jb0ZHdEtUd1V4RVdTL2x5eGV2c3VQMm03c29ySUo0a2JTTmEzSUVBNnJoYzdXNk5HelZFbTM4cG1oNStxYkpYTDFZS2xQRUk5UTBVSnZnOG9LWUJPSVpEck13dUd2TnZpTHlXaGYzanhrUWJpZ1NwRjNSTWZtcDZtekVzS2hwdjlSK2ZJMVBxTndFSTFCb0tHMCtTdktnWGZjL0wvNGVBUTIyWjErdVQrRWtFZ3NSdStOUHlNMjgxM2pCdkxHSSsrelByOVNlTngrSDhKWHdIakcxZ3dhY21pSGtEbURvY0gvcUErcFI4bjlnL1hNeVB3ZGppeHhCVWFjdno1L2t4WE1oT21Ld1JUK2J4dTVHSHQyWnpwUCtleVBiMWp0QldwS3loMThGZlJsYURaKzkrVHo4eTFDbFJnSDJ0Z05mOE9PRGo1OVNqUjRkL3lKMDQyVTV6RXVjUURBdkdLUExPT0I5VWhuSlAvZEtERDY0LytPQW5KalAxNlRnMWVBVHVyRCtJTXBPRmJNT1pHWllRbmNDWkNYTCtyZkZUNHp5L08zRXhzSEhlUUUvamZyZ2ZzRU5BMEFFTnBDOUJ0M3lZdXlHTVJlQ0tIcVpCNTJVUEVWOENaUml4VXJiTStrYzdla2M5Zk9nNytmbGEvcTdiMlZUWlM0WjNUYWZxSVY3RHM1STRneVFuT1pPOStlWlNLNTlrYzdhbWFqdnl0Y3YydFgvNHc3WjZ4UlYvVTl0ZjA3MTJ4WnhhekNRMFBJanFFaU1XbmN5c3ZsQkt6MGxXaHM4VTl0Vkd1dWtoN1pVZ1hoc21mUVVGdEJmd3JPMEM5SDJia0tmOE1kRDNWcjFnSGRoS1NPaisrNEVPOVR1WWtDZWYzRjdvMlBjcEFiaXBKWDhVeVoxZkRDOWNuSEhOSEhvSVNoLzh3NmpvOENJdUdxR2tWMDVkZ0ZsSS83TmFJZDlvbHpFeE5pYW1kRmtOMGM5TUxYclc5QTRYdUdSSE1KZEtzZXdjdFEyREQ5cVVRSVNCNVhJQTlSRTBhc0c3MUVaTm80OHFodzZySGYwWEw5Nm1kZ3JhdEx3d3ljb3ZLSWNQSzdoZDdVWWhYOWU5eFdsa0FyMGhudEFyVkdKWjNLcmx6RHlwVTNGL2paNmtuWUUyQlhsdGlGRFNjb2hkeVFVYU5ZMityVDlKbXBPMGJLZVEzYjJWa05WVkpBSU5UN2NKUlU5dkxSUk50T2xMdGVoRkd1MENUVE9jTDRKOGxhYnExUFc0RlVBZ2hDaHB2cm80YUFKODdpK3VZZ21yT1p5MEJzNlpYS05EZlBrQlhqalFjTUthSzRrM0htZ21tMjlJbEJBakl5MHFLK0VQbStrMHJPRnJER3RFN05RMEx5Ykw1ZVNIcld3cVdrV3FvUE5pdnNHeUtUc2V6OXUyVUE1TGtqeWIwa1dCVXd2RnhtWXBydUt2cnFYcHNwS3VaQkN0V1pxbUZ4TGx0cGUxVFJlSmJ2VU9WcFk5WGxENUtGTDFRbTQ2WmtZckRKMmNrbGdrcXJGVXN4REVkS0htU2IyelpHWFZyME5oSENTcXRZWCtDOVViM1N2b0lwOXJNa0xNY2tVTHovN0haUDd0MW1xOWl3MkpaZDdROGpHYmRpSUt2NFdhMjhmVUMrNThRTnNxd2pJb2FSUEEyWCtaTFhMSjNOWi9PamRITmd0QWorOEJlWDU1MjdKMXQrWXdscEZYcUQ3MU51bzkxUHVwajJLZWg4RmVSUWgrWVZTWVJ4T21XZk9vdFFMb0xaM2d0NEthV1RSaHJBVmVUQ3VvTlk4bWpMbnd2QVlQRWdMNE1mblpocEVGRG5nVDlsM05GVFRLY3JSNGJPTGMvUUNSSFdKVEY2alhCZFRQTVVrMUwwYWN0TXlsTFUxMHBaQ1ZacFdNWXdnRk5VVVhDblJhTFFwUjIxWFl0SzFLcnFUYWFVN0oyQkc0emVSU0NkNTErUVRqUmlOY0tzWHhwaXNLa21zS1hFcXlPTVBBbWZPNUhKOWtja2FFUzZld2lKMFRSU0dIN3lkU25CNTF2MFhnVm5YNm5wUW1WdmV1VGJtSDc1R00zSnRUT2ROT2ZVYlV6QXlucEoySWtGZHhEamttaFFtTk9sbUZHMUtTNFdUWGpvcUZVQm9JVGFrRjBYQXlNcGV4UWxMUHpJbUNtTU95ZnpMRlI0dzhuZkFKeVJ1OHltV1NuQkJReXJQSk5FOElGYkpaQVZmRTBQRVQ3RmNJRUd4TDFGTDMwSHMva2p5Y2NveGNPVHRUeGFUZk80cjU3TTg1UUdhOEFVc25WTlMzZFFDQVVkL21XaUFCL0x6eWY3VWJEQ2Q4ZjJPYnVkVGhFSkJVRlIrNTU3QTdWYzBaS1BkZmE4Ri9KazJBcGdVelY1M0pIbjZWM3hUdlN4MU81b3paLzFJVHZKdndFS1J2U3NlOEFwL1ZLV3FCV3FJTzRKbjhMZFM5STk4cWdzNUkzclJocUJ2UGRBTGNHOGRIWm5VV0NGNGo2UHJLUk1tSFArcWdGSU5Cd2dZbFZ3ZVEzUGtHTWJnRkpUeUIxQVN6WVo2WTVLSnFzYnEzQ2lzNmVGZWs5OTZ5OXl6aVpEaVhPYlRZVzF4RG5Na2hYVGRZbm9iUVo3VEJ5NWtLemRQNlVabXY2Zmlnc3Q3TDJQU09hS2J5N2Q1aUpSUGRRZHYvSU84dVYvZm04M3VyNWQyeXhsZjM3cTN5dUhlaGZCNXhhbVZ4OFpmeE1UNUt4MkpMQ0ZaeEdVUE5vR3BFTlVKVnRKSEpGSGxOWHhTYk9VQWx6alhGUlYzamkzN3NrQkcvOW1OTzNVRGRUdDMzRXJ3Q28ySjRtK0hyNU9VTHJYS2UyTU1RbTVpOFlPWHJ4T3JCTjU4aGdPYkFJcnRCdm1Dd3BpN2s4UWhSZ0hDS0RhSlRiTFRQWjlZYVluaW9QTEdGQWMrSWdIWDRFT0daRnpDRFp5RDZPMlpqVDYvNXZMc2FKbXpBemFPVmpNL0VDekhzdjlHTTZMT0NreUVvTjNBUC9zbWN6eENST1U1WW1NYk1QRklOQVF1WEViQ3puaUdNSlBpNTRtaDljeHQrYmhRSkNMOU44eWl3WStrRU5pMGdoeEVCRmIrQWZVVGxYNlE2WDFPK1Z0RjF2VmQ1a2FvSWFUVlZTU3VwRDZYVU5KcCtrY29qeXYyYThvY25LcFUvcWxSZUEydTVkK0M3cDFOSzZtZFRZS2NMOFQ0SDZDbjA1dk5vSUJSMEprb25nVFk3UGxveWVNZzhSVW9IN0lQZDNmeWNNL2RGQjIvdzM0NHV5ZzFleEx6WTErMytVYmQ3MG5Ydm1MT3JqbE8xVCtIOUxRU2l6UGNuQzJMYUc4VDd0OVVCWkMyaEVBRUg0QUtBcFpGWVkvUGdUK2FnbWo3WUFHT2RqM3hLK1p6N09lVlQzMlpaMVZKVVh1VGRzL281dUgzdUxjR3QzOGNYNFI3TGJpbEhJTWo2MUFvaXhRQWZjU0hqRWpiNlVFRC9EOXpQdWY4d3lydmZ4MW4zdTMrTkwyNk1jNTJjT3kyTzU0SEZ2Sy9SSDhrcG5WYWJ4QVJ1QXBnK2o0ZFlXOWlDa3g2b3Q3TWZXWnVyTkJpV1l5VU9vdnh5WnRRenZLako4UXhpR0R4dDUzaTZNVE1YekwzdVhUdHlXY3ZRYUZFWEZWTzFkSldXVTRsRW5LRVRpVVFLOTBQWk1GVmIxaVFaaFNPdHk0NXNuN2MySjlDa1FNOCtzbm56SU1BYjBTS1NtRFlRMTJWc3ZoaVlJNXk5WWVkTWd4RTRUQk9EYVp1a2xHVTRDZGVBYVZSMmpDYlBsMFhDdENUb3NxMmFCbENHNlV6UVRCem9wRlhkVWswRlY0TFdqTXRHYTY4dTBRbHFsQW4rcS82S1ZNZUpFTlN2VnJSVmlCUWlwWlpYaUd4MGU2WER0WE1Bekkyb1BlOUdxN0QyZlhqdzd6WFVxdzFPdTBnZm5LMzkwOTdCMlMweE53U1NMMFZXNENQTlNOU0p6S0JJeXlHZzNLNitjYzc5emNPMWpiTmQzWFZSYjdDSmVqZy81TmJXOUc1dis5cXdST0s4Z3g0Z2pZaUJtVU13dlRCMXVhNTc1cXg3cmpib282NExtZFJxNTl5elozR1cxQURXQUM2V1R3QW55STN6MGMrQ1hSckpDTmNHTWdJYnRVMXdPY001MVNZd0FoVmkrVXJXd1hIRjhOUENjUDROWGJxL2h0eTEyL0JzV2psMGlHZzU0RTFCK2kyZEgvMm9veDQ2TkpHUFNuRDkvSHc4M3lZZlFwUS9NOWg0Qmg1V09ycnVaL0J4ZUZEdGZKeUFUREFFWTNvVlVlZGhGTUZxL0Nxc3RNT3ZyK3VMNUc4N3JoRVBIQUNOekFyS0NibVd2NjRCOGdVSjdQbnh3ZStFME9xcjk5TkhhclVqOVA1WGcySGRhMTYvK2EwYnJxSVBsRW9INkt0R3VBUitmaXFzRDVWeUxTSi9FS0VFNXdVNVBUSE00Z254dWVlNlB6d3hmUDZFOXRSVFJDYnE0ZWRyVklSRVE2ckJhbVRKOFMxRHEyUjhJTzVNZVdMZzAyd1FNN3J5Y0tGMkNHa3BETUZTTGY4Q2VpTVdmMUx0dG5kNXVZUUhVcTlXUDM1ODl1cGEyNTVlS0Z6dUpVcWwrUWhCOE1jU0VzUWwwOEdpd0ZUTmFDSzZnUitNRnZONS9OaGlQS1BQMTl0YXFwQlBUTVd6Wndpdy8rMkEyYkNRTU1IVVFUY1NaalRnNmJBT2NlSlJmUjc5bzlWM0FnQVZFTXRmZ013M0Vyb09XWm9pRXFMNHJRUnRFQ0tXTllzbkZJZ1RjUk5vOHBaUm9HUk8weDM4bldvSkVVZC9ybkptZzhCM2xmN3dyaE5YSjI4NzBlLzNIM3NNVVk4TnNjN0pzenhaSDRNSE5rbmk3aWdSUjlLc2tqU0FtR05UT1lKa2pLZnpIYzREWFJ3Um1acXRNTUt2RUo2SzVmRW9aaldSMnoxenBvdENjMmRyRUtqaDdOd2MwdThnV0xKM3JLUHU2dnI2NnVyKy9iMGV4SjNwcWZ0UDl3Rkp0ai91VDFDZURLdThiVUFySWNEMXRqZURPb0VteUpsaENkN0dEUG9BenZHUk0yY2U0VHJDamk2bzJCYnhzRmJCUlhyU2V0STZmZG9xclFKUXdpb1VCT3VHVkF5ZFJ2ZGM0SnMvMHJJTnJVeTMvMUN3NXk1MDcvUmc3ZURpOEIrcUFBc3I0L043Qm1mMFdxMDc4ZmNpZGZyME92N2JlaFhxci81VUdpOUtJWGVwMUwwMGJXdTZmdnA4dW54OUFjU1V6cEM1TjI2WE5JUXBJMU1WTERRQ1FxdHZsTjFzdEoxV2ZuUTl1SGFPa1JuOGwrUFRsUjFDMXRJWmV5WloyU2xJR1lReWtsbXJ4TEtXNmNvNzVxTTg2aUdrZnhnaFJnb0o3MzdYeDJoR2tSVDJ3KzlrRlVsNE94K1NSbm9BbjVhZlFzbkZpNzFRS1VQTVpPckZJR2J1YnB4L0Jna2FBOTR5Qzh0TU5BaVlpK2NKRHZsZ200SkdCeWJteERROWlPU0wvNjlldmlweStabTg0dDZHWWpsWGkxZjhvTHF2RTJyNWVqMENwckNPcEJsVlJabUxLcEtwaGRGNjZ5Tlh6ZS9QYXRkZFZWbVptbDRlckFXUmRtRjcrc0ExaXpPN1Y1eDRNMVBPeEUxUmRPUFZxaVROeldjeXZCaEpwbjBicGhIZEY2ZjZZbVM5Wk9sYnNLUjNVSmZCZWxqSmhrRENPU2hoQmI4YnJWMklmSkN0NFM4TVp5UW1YNDdva09icEphSm90NFJPRTJKRHpxQTh4S0FTNmp4WnRHeUFxMVlkL1l5Q0NnRHZVVUlxQ015ZzFLM1Y2SEI5NXkyR0hrNGdLaFhpcGRjdytNNDNENzcvb0V6UHZsRDlxeWYzU2FyeGdpWUo0dFYyTEZrcXB1ellsOStvRTA5Q1YyZll1UDZCWXRLeFpkMktmSmw5UXRmZitOVkhIOVVqbFlwKzhpRk5VVlZCc0VOamYzVS9MbjJlS2xQVFJGKzVUTEFXaEdCTnAxTW5wRytwTmxRVkRCS0U0SWVyM1hJVzVsSEJoMVJ2b010RlFkSmVNRlJwMzVNUFQxWnVYVjhqdGRzajdmeU1mUEFEbHl2VkYyYjNoR3hCVUZWRmUraU95YXE4OFNIZGo4Z0ZmMStONkk4K0d0RUJBekV4OHUyNmpscWw3cWRlU3oxQnZaUDZSZW9UMUdlcDM2YitHL1YxNmp2VVgxTC9TUDBFc1NpTW02ZU1GdEFTT294ZWdlNUNEd1B1bVc4MU8zS3l3SDAzVHliQy9OQnBHSTRMK1FXWVVIZUdYc2ZFbHJhMTBDQWhmUU5IRElHWTFUWWJwbWY1UGhURXV3TG40L2hPR1htQlhDRXZpZ0JoYjRpZW5ZVE82bmpFNjZ6UklkOTM4RVJqUUVoditwSThEMzBYaThXKzJGNE92cUlCelczY3FjR2FGMTVERzA4MUNkQUNJWWhVQXFleTJ5c29xQXhNOWpGQm9OSXMyVUtaRC9zdWJRS1ovZ0kxRFdFWnJTQ05kb1oxWHloRGFLV29UZUFDbG1tUHBNWlptTGJWRnNCTHJrb0xnYSsxNDVzUUYvS0ZVVVRZZVpTaG5VYXpFOWpkMnVqKzBpSk5OeEs3bzZ6b3pDVXl0QmhlREl0MEpqSG5pR3gwZDZKQjA0dWw2Ni9QN1diUVFnd1N4V1luRXMzR0lGRnNBVEc3Yzlldno3Z1ptMU1VenM2a0xEdEdlN1lqQzhabjZKanRHWUxzMkcxM1pqNEZLVUswM1lQN3M0b1FPWU52VnlLQ01uc0xwOUFLUjNOOGlCd2dIb3NTb05wL1hkaWtHU01LVGlBeERjOHZaQlI2aEVFMFNscHdJMElqRmJ5RVhtWGtWVFVmTVNKUlR0Z2hjaEVSMzJQb0VIcE1uSVk3T1VPUG1ubi9Xb2lWcFA5WFN3ZzhUUFlkbmFVak1WbEZnc3A5T3FLR0VvS0FjQ296eWdvY0E1ZS9LNllrbWRXbWxDck8xWWh6RmhOaVZVNkgrRjRucWlLTFgzOHBLY2xjZUNvT0RrVndWNURWVDJnOGswa3NSZG01UklPd2h2Q3ZrWmhqbzB1SkRNTnJ3RDNYMlcyeXMxc1R6TExtYnNjRjlxWVpHWmlCdU50c0Q3UElpWVNZVjJLT2Vrd280dGc5bVNFY0N1N09Sa1BNM2ZobWhRbEZaeEdEMlQvdk0xb1p2TjdPd2tuV3h2WCtHREZBZTF0RFJBWENyU1hGWWVXSWFLRUhqTHlpRnZTbWlMckFPTVVSZjQvR0hJN0ZlRVVYWkE1ekdIMDhFb2NXaU1lNElqNWpPZWwvS0VsSnhIeFJQU1NLUWIwdDlMTmlWVXBKRXFmUENGN1ZsUEYxalJWMktnbFJCR2JIbzBvRTgxVGwyVGNrb2pLbkVtYlRSVVRZejB6Z05WNkJSL0xicVZkUnI2T2VwSDZCK2pnZU42aFN3eXdFQXdOLzNxaHdvU0hodkFGaE9CeU14cGEyYjBCQjNremVkb1plWHgxNE80Y0RDTHlRays5ZmRQelNPVFkzeER1QWQyN0xHNGJ1di83NjRMMHFMMDI4TDB2bDg5NG9jN2ZmSTBpWDJXMEdiOVBlV0h6VTc2OEx1cnFKdS8xaTBNZW5jQXVlSmIyYUpUMzh2Mi9wME05UDlHTTZNdmcrNmJ1aG9DZWp5N2IwMisvNkpSUEtKcnNpSVh5aXE1b2p5b09LbVVGWGZUeHZCRjNxTE9sRFJkeWJmcEgwSGR4bDZHdHhsNUZKNS9ueVJJOUJ0NDI2Q1JJL2lQc0ZGL1NSR3lZNnhtU2NhTUFROXdnNnovWllFZURRMmZUeUFCU1NhempFdGhCUU5BZ3VkejZ3bFVLL0lvZEM4bUJORG12S21pdzROUHNSaWVIUWFZNFJma2hPa1NjTzFrU2VRYWNGdElwVG5sVzBzSXg2Y2dqZjFJVkRDRTBMK0dqd0s5OFh4ZTh6L0JaZGFJak1QQm9UQms1TmdzNVp4bWRDYTBRaGVrNzBLUkRSUitVUXd3MTZIRE1rQnVuaTk2SEE3NHU5a0R5TjBDRlNMc2pjb3pVYUg1RVp2djR0YW9uYWo5K1FxOEYrYkx4dTAyNTJ2QmFlNXpkcytKUXd2QUJmbUN6ZGFUbWVZRG5OamxQMjRHTUhZZGM1R3hZUmFRZVdXQ0Y4V0Rrdk1IaXM5aHdBRWZKWGRmNlZadW1ZZVo4WkIvOFp3L3B0bTU2NWRrZk81dXFYWDMzZ011TWU0M1UwTEpOM2RsN2VIbnlSVFIrd1RGVC9pd05wdHQwdzk4M2JOV2NHRC9YbVIyYmNSWHE0OEhPTzduckkyME56S0ZtcGwzN09udS9TenU2ZGI5NjVFeDA4eURVcXJRTjFzN0p6ZDJ5NU9ZVzhxNUQ5YzJpcVdYV3UyblI1ZnZBMVZOSWJEYjJFbUNBbTVwZ25XU3dSQVVkZWlnK0VCeGVxK0FWcmV0U3Y1U2N2V0xmeksvTklVSkgwQmNrUC9CT3Z4ZjJrU3RvUDdFWjNVMWRTTndEZUplNHhNOGdDbjRZbFZNZ1RDOWtXV01tbVVSQTllY0dETVkvQU52cDdiNFRuR09EMkUvbTB0VFZjNE1jNURzc2xYQUh2T0p2N1E0Z2VIM1dpVWJ5L2xXd0wrS2NyaVJlOHhWUzYvRUk1blZyMHFudjJWRitBelZuOFJHSDh2S2ZvU25tNkRGdjhtMWJBUlRpYVc1aWFUaVNUaWVtcEJYMzVlTGQ3ZkhrWWI4dXZweEpZL1hVaG1pMmFJSXk4bTRIdGI4R1AvVXBFMFNYUWhUY1dDTmluNCt0Sy9mZ2doVHl1WTNBRFhUTWljZ2VwR0ttZnhSZTRrNlJXRFZKUG44SmxjZ1ZWZmVwZU41R1dLekJCVFpUeWRaZ0xVYkVGNXhSWjh3NXcvbjM3SkwrMWpnRFNmbkZrRDdnVmtYcXJyV0NnbXJUNTRDc0FscHJCSVFGOGFEYnNodit4Y0phUkQrQkFkQm9CcWdQK20zRG1CalA5d1BFWHFiaE91cnBJdHYvRGRSelhNY3ZsdjU2NGVKUE9SbmtoUGhOMWQ4VjJ1ZEdaT0JZT1dUM2l1YUdRc3JPOVV3bUZYSS9oUlZiUml3a1Z6MGtxQ3hVczlxdUpvcTZ3SWsremNralhiVHV5SEZ1TzJMYXVoMlQyeDZSTWwyeXZkUEtPa3krVzV5YXU1ZmJlS0RFTE1VbUtMVERTalhzUEhKRFljSmlWRG55WFNWODJ0MjlGWkRoWjVoaHhaZC9jWldrR3FacVo0am1PVDVtYVN0NEhuODlNMEU5V3FNc3hueW44ZXVXNVMrQWVlNUhJTWRzanlod3RsOUh4UytETTRMY0lULzlvZ3FHVEhQOVJtYjlJWmE4bmpHRkk0a1dmVlJQSFc5ZUhvVS9kUnYzOCtYaTdIVjZ3QTdtRGlEYit5cm9UZUp1UEp6SWd5Z1RlNWUzUkNqMlJlSWhTWVR3MXNoMC8zRHplbTZBQUk2R2g4UjZDczdkOVZaclhCdldhSDRrZTd4dnZKOUNoSzJTQkx4NE9ZekUySEUxS1dQNFZJWGFYeUFtc2xJeUdHWm9PaHprMVlscTZ5djIwVkxwbFJ0VGIzTGdXMHl4VjFFWFh4UnZWd3FkeFY5MnZYdXhHQUU1Nmtpd20vakVuaUxvWmpxSlJocmhZRkEyYllMTXhMSFNjWWtqWWxoUkpVYy9HTkRZb2xOVmlXYi9JOHk5dTlRa0E2MzZxZUtrTW5HVDYwTGh5OWRKcVBIRmprelRBQ3orTjBOSEZ4LzJBcm9HTWRBSy9VNm5BTDRFcTRkay83Mk1CMWdtV2FOMzBlMHFoMVNTZENQY24zL3dJajFjQnhTUEtQeHNPTTRsa29keldUYjFkTGlRVERGeElGTjI2cU9aVnNlN2lTeWU3YzNQZHVkOGwyNjhaK1ZpOFhSWTFUU3kzNDdHOGtVdkVTaGxWelpUaXNaTnpKQW41ODlmSGhuUytMQm92aWFhWG9tT3liWWtlRS9tTFFZRmJRS3ZwNDV2N3k3aUFZWVg2YTJ0cmVsOWZDM1o5Q09rME9zUC9UdmY3MjN4UkNzTTRMcEVjYW8xQzB3VHJUa0htK0hxLy95SkZZalNzOW5CV3NBaE1kbjBvQVYrbHhwZGdGMkN0QW01cW5FVHJIZUhraEZGZ3ZFVll0WXpHU3NaaFpKK1JXcEg0Z29QTkdicTh0WCtxc2pzMkxZbXB6dTdLMVA1V2RrYzR2T1BPcUNTbHc0WVJYMDVxV25JNWJoamh0Q1JGbldKNTJuV255MFcwdHR6dU5PcWViakdNVVBUcXVOOHZwK0x4MUovYXlaZzluOVE0WWM1eDVnUk9TODdic2FTZGN1TXBSVW5GM2FGdDlKRCtsNkQrSXBSZHJHUy9QYStsK2xqZUVFQlRQTVRRN2dCMHdqREFFZThVRm9pRjNXRk5salU1b3ZNb2l0TFJtQkdMbytqK1JQNWFHYTdmRzlidGNpSmlHMWJNWGs3SGs1T1lEREJ1ZzJmMytSYkNqUUFJWkV0aDlnVnNtTDhjTHlTMkZMeEVpTmxxVGZ6RlREd1IwM1VMMDJFWk5xYmpkd2hwNTlrcWV4ZjRndmpGVzgxeWdCREJDODMyd25JZzNYNmRGTlpNNUJQN295aU9DWWltTVNtc0ZCVC9CejRIWXNsNGV0bU80YUlqaVhKSUNNdVQzeTZSUkQ3S2t2aGVmcmZtV3A1QWVqVGpXeHdUZTRDQ3RiRyt0cnFHYXFkUDkvcmREZlZ6bjFQZHJ1NmlYdjlzdjM5MjQ3blh2T1k1M01YWDNxKys1ejFxZkhVdU5MMXZTMnd0WXlML3ppaGJrdVY2a0ZtUTFabGhGb0dkRytoUXdRc0oxa01MK1FCQWtRRG5nTkVBR1ZNV2ZHeGRNbUl2QkM4SVhFSWZUNmN6RlMvenVKM1AyWTVqNS9MMlRHZ2FydURyWGdWZngxZndkWHpYdjQ3WTlOWHBWT294MjNhNmptMVBhMU9wMUhsWENGMDNvTE9vQWhxSlM2T3J2VEJCMVdlejJVeDFMdk1HTTVzeExjdk1aRTB2N3NFVmZIMnVpcTluc3BVS3Z1ZGZSWEwyV0RhVGVjdzByVVhMTk12eGNpWVRYS25zckpEem9ZMGkxVVdBRmh6eWZZbUpLcDJNZkdJRjNBdHJpS3BVbmhIRmsrSVdYQkltd0svZjlreDUyeHZ4bkovSEt5Y043NGY1L2ZKV0EveXRmVG8rRVVjZ2tOOThCWHh6WkVIL1RTS0trV1htb09NYVJNajZndGdIYXNlWWZHQzlGbUJTZ3NmSU1GQWxnUkFkQ29mTWNLRDBUWTlBbXRxR3lZTjdDYjNkRStsVStYV2ZmdXl4WTN2YnNxSlpDWUlnbW9ycjRiQVFFa1ROWWcwamYyMCtuMHlFdzJFOW5pZ1VyeTRXM2pjV3E2cG9SM3NmaVlKWkZxMVVNVVJDVTI3R1M4V3lWelFNeHRJQTNFYlR3a244cEZjdWx1S1FUeGpSRTlJUXZDckc2SDJSaUVZM2Q1NGY0cXVvbjhFemxwK2wzazM5SXJFNDltZUw3V0V0dHZ0WGVZMGhrNFpYaXR0U2xIL0tlU2svRENkUTN1YmhQL0ZFRVB4eHhNdkROdTdmMmF6Z1dwWnJQemFiemM1bVMzQnN2ZExKWnF1WkxPL2F0bXVoWWpXRGs1WFBTL1dHS3FRcStZbDJUVDd5L0xaVWpwMzFrOTBQYVd3bmU3TUZwd2V5a1BQdTROZ2gxUGgzem1ZaGgxMFc1SERaUlk3djJ2SkVDV3BTWGJMOVZMWXpPZ2xpb1kvYmF6ai9oLzU1WkxKMThnSEh4cTJ4UGZiUmNEL0I3ZkdkZ0x0RHJyNkQ4T0NZenhaa0VSN2VUNjY5aXZBTkhmWnZmWDUwRFZkbnlCL0NtR3hRd1hlUVNrLytyUVIzN2llVkRwNFlZc0pDekpVb3RRUFhidyt1SVlWTUg1T2g0QXNsaEc3QmYvTUkrRVVXNXJ2NEsrSTFIZkNiYmVJdkNyRTZxaThJUVhSNCtDRTNrMktOZmxSME10ZS85dm82bjZ3VTd5bFdrbmhXWitsdUpPdG1JNjV1aVRwNnZOdGJYVjFGMGFucHNwQnRJbFRQYWRucHFaM1hYZmR6WXFsWXJ4U0xsWHF4bEJDMG9yZlc3YTdCcjF6U2JFUy9RSUE5QTJ4UGRsU1BjWlRCVVMwNkJRQnA5d3J3a1JyWGlEbVBWdGZWWFNETERXZytzNVd5ZnJmYmg5K1l3c0hQVDlJZ2JwRXB0OWplRFRGT25jRCtEbjZBSXMwSFA3UUdWalg2b044SHdLb044T0RHLzhqVk5YRHF2a2ZYVjhuZmM2NjdTdjZDOWFrTGxVZTArZTNHUW40aCtFMXE4RWw4TVQrK0VhSklZWENsNTNieC8yOFBTNW5rcHhwRW13WWNFRjlsTm5iZkM2TXEzVG92aE16ekR4dzZrSXZIY3dlK2NQTG93V0pSci9WZVMyeGlaaXZKWkNXSlRoOXE3ejI1STUvZmNYSnYrNmFqdXh2UE5KdjJaUjl2N0dhSkdjd1ZTVWcxRVF0SUJYc29ZNks0MFNyQk1QZlgrL211VCtSMXY1L0xFUE1WNHB6NkhxTUZZa3REVEM5OXExVndiSWJzd051NFBReGJYbTZSRlNJa0xnNDJGcGVPTFcyY2FSNXEvdDFnODgwcEk2YkhjQ2ZaUEhmdTRNelMwc3pCZzZWbWMvQWJaOCt1RzFwTXlPV0VtSlp4eDloZ2ZybU9id0U2V2FyZ0d4TmpmbHJOWWVRNnUyR09TMXlOR1ZCV0Q1ZDdjRnpjVjNEK0JpbHBIUW91SGV5NXc3Sm9DcGRsNFg1ZkpaS0xINGJiR3dxNGNMaU1vbGc2Q3dDcWlCd0Ria2VOdHRjVVNoMEhVY2RPc1NpRzJBZXVyQitMMHhhZHV2M2JaTHM0Y1Yzb2R3ZmRiaGZnbkp3b3k3R3gwSlVQTkdZWmhhM3ZHSHlMN0NadnZCVW43UWIwL1JqOVQvUVVpVG5tbytzUTlNeE9uY1FrOGJFK1BEOUNzdUQ0T0tKTEtBaE9naWtzRWFFUy9ibXkwSkpuVktRajlPQlZ6UnZpV25LMWMvUlJWSUg5ZFkvUytQcEQrUExnTnhlVXFXbGxRMm0xbEtrcFRVQ0NkdFdEQzdOaWJmSFI2NDdqN2M5Y3g2RGgxYTlDa2drTWl3Znd1eFNCdGlJK0RYN2NNaS93ZndQYk0veisrTTUwWURDRUhuanRhOTNYZHZHUDdPUitYKys3ZmQzZklYYi8vc1hMM3Y3Mnl4YUQvZk9IRHFVT3ZmZTllT1B2UnpGVy9USXZVT0syL00vTGNRTERBZnpuWjZrRnNGN3RGQUJ1d3lLbUUyQWQwUUtyS21zY0NLemplOWdUU0FjTHBnS3dxQXNBeXB1dVhxdnBaS05EdzNYWCtvUFZQbUE3bkI2Q1M1d0w3cnQrQXNEcTMwQjRNQUdNaHd5Z0VrQUVMbW9DMnlKSzdPOFdmQ3ZOR1V4U1lRa1JYek9JdTN0QlNuengwWjkyYjQ0SWNydGJhRmtuWlo4WkVkeWZKT09jVDlrSTd6eEdNSGhrRXFXbmhpK2lEdkpBMWVQd0hlaDl6V0djUkV5U0VJaklWVUlmTWF0emVDUVBCaHFpbjhsVkg5YVh1TGZabFZ5MUhwTWprWis1N0tOWE5BNUU5OHdsYk1seDBYUGk0T0NqdGNKcmYwKzhMaFQrZTdkZStOQlVQcEp3ZTk5WU1Zd1Y5b3BHcnpmWFZYUjFIRU1kYzRpTURmT2oyRVZFQWVVRW93RUlaQjBJcHJlZHFFYTdkZHZlYW5WdjlWMmxoUkwrcTBYMk5RSlNidHFEMXV1RkR4VHFzUG5pQjFLVlNnbzI5L1VhVjdBVFpIVG5odmhFUGcwRk1nY2ZCY201V0trZkphVzZrOFVkSDVYMjhBWEtnUDc5ZWJ6NUt0UzRCQkhnQUZtQituemt2TGx4OUVKK3ZEbHJjaTYrZ29uZE11OCtFSW04Vk55dzRkT285K0x3d2R2d0UrT1lPZ1I3dkFROURVYmxRaVRIQVJMSjVwbnU0TVh1WjlEbW9JWTJBRHRjUjY3K0lqV0t0emQrTm5yKzAxRHExaHdHUGJRK21jdTV6VTEvckxtSytqWnE0dkU2RDlxa0RqOE0vakYwZzdPYlFxTkRZR1dKQThtWEZWbmc4dTNhL3JtaXFJbU0wcDA3VkU3VzkvSHh6SzZmWlJSaGFsL05XMUpvV3VYdCtGeTNFbU1QMW0xRHJhZW5kaExDaDJWZHBLVHpNejgvVDZJakF2VE16Vkg4VzlBQVVPMXRNNGZ0TTRuaXR2TmZCaEFpMlNYR0lUZE1IS1BLeE1tZnlIQVNJeFlQN0VXT2grMHhTZE41OGVHSHN2alRKTnNIL1pKOEpKOGc2T1BFbjk5Zk5Xb0RQUUtSQTZQNFRaaEhKTlkxRHl2MnpVZ1dOWndOL2dwYWRJemxwdTNjUk5NMHVnbnRFZWpRaGhITmFJaVo5V2lFSWxHaTZ5UjU0ZS8vSTJCUFdDS1NLTTZsZ2I5eExjRXlKN0p0ZFZCWFZwUExDMUpVWVgrWEZtMWpaY0d4TnZ2MWNDVEljZDM5S00xRW9xa1FZdWJ3K1Q4V3FBdTlQOE9vWThNNmwvREhDbVUrOU1nakgzcGs4UGYrbTFCYnhiTGlJM0RwemVSOWtEZjdGM3Qvbkk3UURId0VWamY3d2Z2enJjM1ZvRnlJaVZqSDg5VytIMGREQURSQVAvWkYwTDF3Ny9JMVl2TUFnRG84OUpkTUJCSmJvMFZXVlNBR2pnRFJoV2hZVkdrVnZEQnk2cjR4UnQzakJZMGhTTHlORmVRVnlwMTZ1K0Uwc2ZqcFlHa0d5eTloUEpLWDVWQ3pVMllZR3JGYyt0V3FwQmtzbTdOb2xrRU1GNVdXdENMREFOaHNMaXBITlBscWxlZTR5emhPRURrTzRSdHhGQW9oVExFa0lDczJxMm9hTDRtaUlDQldZR2xFNjR4NGw0SHdSVU5BcVJ0ZUtYSjNSeTZuTldibDVtL0pJVjB1VmJJTVl2bkNVZEhRRklGdFJXakVZTkhsRGp2RDBBeGZTZXZ5a1NJckFmSXVMbEFVTVhsMEJrVndjUnlQRE8rQUZ0RjRubE1Sci9LQXphdHpoMnk0RXR1enJqRzdJNCt4SXZ0UUsyZ2I0UFUweUhRalRrK3dlWUZ3ZDhqbEVZczdKQjRCL3RCSndCNWU1TktQQUc4NEtTcWErTXdFenVCOXpwQU56SmFiN2s0ZFNEWDJmVXZDOVNwWFhFNzBxeVdMU0V1SEl2aVUxQXZ2U2JXTzcwcS9Ucisrdk1YM01FRXdyTW9FUXlvM3N2QUEvd1Zpd3RGdWdSL0Rsc21QUUVMeTlJelE0RXNodzlVbEh1M2xwY0ZadmRidm56dTNzWUdyUFhnV1FtaWl1ajc0QzE3Qzk2K0JqenlXVFhyRHY0bnlKNzJjSnNySC8xdE9ZRVE1UlBhZEtCU1h0VkU3ZDI2aXJBR2VjdUJKb0w1T1prSHJRYXdKRjcvSHE4UzNRYUtvVm9raDdwR0NnN3BQN3doUHZacit5WFhQZjJDdzhXcnV1bitsWDFjYzJ6WERNelRRMkNvSkhjWkQzVzk5NittRjV6L3cxYThPTnU0WjZxejdKTi9oM0sxRTdhTmU0ZnVQa0hrME5DSHgwOGZsOFVJUVBZZW90ZkJMOGZKOXgwL3I2eDFGZHBYM0txN3lGVG1yVFBHOE41M08yZ29UampudU95L1ZqM202M2I1UDErL0htU0Q4K3lNbHF5UTR3WnhKVDhjNUpwS3pTMU9YNU9jc1hLRCtIdWkvTGxqN0M5VEdjOGlYMFJJS3ZOQ3lmT1pzcitIUGJ5V2RSbzZIRU5KSnRTOVFqOXUzRUptaTJma1k0aENTSWdoQi9ZaGM2OXVJajJLWFJBc1JFcGZXQ2ZZcjgvUDZrWE93SVU1SGZ0U1M0Y0ZXbTNmSWcvSTdhVE55NUk0akFXVGJZQVBMcXJnazlIcmNyM1hjbzJ2VUNuVU5kVHYxR1BWQjZsUFUvem1LMk9PcjE0bWhXM3VJVGs2c0RrcStKcDVZeHhGbG5MQTgwaW1Sa1Jqc0Y4Q05EWFJMQXNTaDhIalFNNEhxRG13YkNyenRLeU1LZVFoamxTZEczN0JtNGdSS3FwRjJxZ254TUpwNFZHNlFnb2s2R3c5RXhEOU9neERsRG00M01BRUExYUNHME92bGtKZ0tpMEpFbG9WMFdPVERxZ3pLWjhiV0JFNm0rZGpnUDJVNUlvamhsQmlTK1RBdmh2RjR3d21hellDcVdnN0YrTXNzbDJHaUlZTTNrd3huaE1LSVRZVVpNQzJWaFJCRG15RkdTYTMyN0VoY0RQRjRtb2lsTHBVUGlmR0kvWUpXTkF4akZ2K0ttbTdnVVo4Rk1RQnZReUVqRXc0WkhKTTBoVWdveWpDdWxXVkNnc3hvY1pyUkpaa05tZitSekVSampEaVhzT0lNZjFuTVZCbTZHTTJ4cUp1WUU1bFlOSk9NOGt6OEtQN0VGR2xHTldQdVBsUkpGV080ejVUU0ZmeU5RbzhhR1R1TGFGRXYyQm1FbmozZXlXa3F3NGhJbGtsWU5TM1hlWVhrek05YXNxTEkxdXk4SThrU1lsU1ZRZEwzVU5pcHBFdFlwb2dWVXg2NnFxQ0xOTXJhNmFpQ1VJYU12K04ra3NPejZxc2dOdGw1dllQYjNoMmM4OXIvSXUzZDJkYWU1N2ZmNEsrM04xanp2QmFTTHRnaW45dkc5UzFjTGsyeTF0akd6L1FGT1BqNnJad0t4aGNmdjRPaWRsT3ZwejVOL1NIMXJ3aThFSEZYeDFQUmhTM1EvandXdGN1T1gxMG5ZRXZiQmxXbmhzQTZtOHpIOEExOGVaZHZBQVNjd21OT3F6MzB0aVR2RG43QnpBd0Vndk9qd0ZqNEdUcU5oakhpd05CamhpWlNZS2ZGWXhHbVRTUkEzRVltdkUwa0pnd1dEdkV6amwwQWtJOXlCeWJIblhJN2VMc2g5SkNGODZJRkRxaWVScVJKT3kzZmtHU1pCaHNVTU1UQzVFT293NEtmbGVYWnUyZ1NrRzZodVMwek1GUFp2TldLcC80dEtYc3hMUFN3TE9ESzR2Y05wQmloYUprNW5zT1hHQWdtUUNOOGlGOVhWVWgrV1dMWWYrSmpRZ3BMVEhpc0YzRnFDRTdHSXBwaitHVWpETUVIYUFiTHgvZ2NQOHN5TkM4WnJNTXJJVjNpNkhnbmkzUVZtU29XMDBRbE9jWFRFS0NBVTBYRTBZcElNMXlrS2hxWUFwRlRjWTVzTXM1aG9nd1JJWU14OEh0eEU2MUZGQ1J5aUZiQ0lFQnhMTXV3RFFkL3NNQ0xsVVVxeE1hVFEwejJHb1hWVTB6SVlNTTBNa1JjRFM2ZXhKSWR5K09TR0VGQ3ZiOFFDM1l4S2tpTXpFWVptcFZGSFlraFpDTTJiRWVpSmtKMlZJdmpBckdBU0FzQ2oyd0ppVWlSWlZ4UlYxTHdkNVBGZ3FZaUtEWitOVGhWUTV5b0NyUmlHRW5WMUxNMENaWEhxcGdEdEdCd21EamFNbmlSUmZnaFY1S1ZqSXpKMVdtd2RJa1dWYU1rRlZnbGhPbkNURk40d2oyT2pvUVVJY1BSYWxWMTRsSkRvdE02RDE2NnVxQ0dvRTBZbHRFQWJrd1NiakJEcXN2YXFzSGo3eFZpa0k0d2JVak9KQldPeDd3M2ttaVVCNWNSK0JIVzMvRDlXS0ZlUzMwU2p4MzEvOEs3NFRVSnRySGZ3V25jdjNINjFrdjM4SUxRYkdPcHRuREpuUmt0dmZ5KytoVThoZEprNkhVWjNPdG9FL3JVaGJ1ZGhwc1IzMnRtZTVmV3d4NytYKzQrc3FpUURzQ0hjQWVnQlZxS2xpN1NCZkRNUnBFemw5Ymc0elVLa0QwcFBHZDRHNkIzMmFSSjRUTzhBcEZDOHlSY0RSNytJVUJsQTdmSjBCcUN4M1VsZzF6VFIrWEpWeEcwVEt2VFdrSCswOHNBVE4xcHc2VmxwclhnRHlTV2lWdlRncmJGbnpuVEpycWhMTEpHY1hMSS8vcysybHBmYjRrdUU0R0JRaEJ3KytCYXNnaFZEbFFRaCtkRTBKYU1SUE1SeHIzejdTd3JHYXJHY0J6dDhNUXdIak1kdDZJSW9BODh3V1RROUZSYUQ1RkRNdERRSWtTa1pEZ2E4YndqODJySXdLL2Z2M3pNZEYwVDRnaXdVN0xvcXJ6T3NSd0twWk5UVThscEpORUpYSzRqR2lYYzBKekgwN3dBa1VsRVFZeVowTTQ4SXh0NFIzT1lmaG5JNVNWVndGS3RIcklGVmVLaFBUaFc0M0VUWVNsWlZ2QzdMc3N4L0RTbWtSVndia09mUW1pTEdwbTl2YnhtUU1xbHMrem9wVmMwV0ovMTZWSW9sVnFpM2p2RWQvUU5xWVQvWC9RWTFJMXI4YmoyeGY4ZEhRZDVVSFE4WHYvZjI0SG9pWGJhdmEyTlhuWnY4dG1adW5SdURwbndweStyYjIyTnpSZ2g4M0dDOGN3QUZDbkJOT2dTRTdxMXdYb1A5ZlhCdWt2aU5PcWdPMEJyTmJ6VnQrTFZFZDhpeUFXQVBnb1IvK251NEl3ZjNyRmZHNXlEbVJVNzhqOHlxUXcxQlg0RktJMi9VY01RVE1BcDhrSHp6Zk1oY0lkdk4xSUhRQ3BMd0NKZGEyR1piaUpLL1p5a1J1M21pbGNzTElURGkvVlhIRHQxNnRqK0I4M24zVnFwR0srcW45Ty9qbVdlV1AyR0hlaWhiNmpzWERTUzBFdmg4RUtoNlBVVzY4NnBUNS9xcmRUUDBicWVhVjlSZHF2Lzk0OFh0TGx3dUhoZ3BidzFkcDRFSzdMUkVUbk1tSVp6d3hMSEpmWDliQkUxbVp2dlY3eUo4MHJpdWZNaG5CdkVJQmtIcVFYZEgzeC9pVVU2K0NrR1lScUVLTDYzQU55QXU1Q29RSUtYa0Jjd1dFellkUFZRdEI4TjZXNlVUNXhLOE5FdnFkeVhPSlZtbFZNSyswRWtTRmlVL3hJVzZDVUIwYUUrL3VvMWJ5bGJlMEpSUlk2cSs2enlMYzFYbEVPaGNqYmViTWJ4U3phNEUzK2s4S2M2VjdHblo2dDFMc0t5RWE1ZW5aMjJwbklzSTZPQUw2TzZYSEpOWHBMTW4wTFV4Rnljck5ORUl4MHZoUFEvZVlHb0tmWU4vdTJKOVlsWWZFRTZDdGJ3Q0VEMCtGNFgzK3ZDNm1scC9JTGlqblF5OHVpamtaT2ZoODNKOHpGQXo5TjNUT2pvSnZVZVh6a0orV3hWZlh6RHozbzdGa3gwVXY4eFZxTU45U0Rrb1pFcWhHUTdmRy9XTWQ5Wll1bGl3VGlEUE9TMENveGpqQ0F4ekFaYWY1RmFSOVRwdDUxNzI2K1JGWE1BVmxsZkgyeXVJL2VadHczT3ZRMVZ5REo2eGczMFcrdEU3d1pJdGhTMTBEQzlKczYyT0RRanFyazlrdDlDekRSamNPcXVRVmJySnB4VFcySVZndzFqb0VGSFRZc0JSWEFUcmRCTGRJRUJQSHhoRzVYdXViaUQ2Y1M1cThwMzN2NEQ5QUg5ZTZISFJ3VDNUdy9PeFdLZ3FIeUZxdjdrWGwwZm5IdjBkV3YvcWFLcElmSFU1RmdDMkRVMitFU1RrcU5lTTAySDZWRXRiRERjT0tPZkMvM2ptZlh2cWJqVVJsQU9LU2FFNUY5eDliWC9WR0xyNnlSekdvdzJ4cnBSZjcxeWZvU3dQUU80NUlVUnluYk9LdUZ6QnRld05QU0dJMWViRGRRSEc0RGFpMVFOOWk2Qnk2ZjBUVUNDV1NlV2dEVWQxamlmMVl4SEhqRzBaME1HZ1RFZnJHOXN2UG5aY1BoWi9manhMVHBhZnkwckM3aWFPVnhpamtRYWNJWTBBWUswVDFPejU2dnZjR2x1RHBaTGM0UE5iTWlNYWdUZFl4VmlKSVErRXJJZWY5ekNPeU40TjNEZjNNUjlzeHpZVEFHMGNuNCtpUFhDd0s3VkpQT0RLQW51MkZ4RzZBekFhdVRVcHNyb0RVWkZJYm81eDRUVzdseGlWWTFlbUdOaVRMck14VCtUcktTenl2eXZLaXBhK0MzVi9lZVFObmorZzRweXZSWWRsdnNUM0g1dkkxWVhXOHFkS0hXeTBIWGZxbUlQVHpzN2FKWGUyYWI1MVp1Vy9TT1Z6dXlpRFdoQ2h6djRQQlpNYnZvdXIvODdMd3crL2lXT3UxblJodml2THA1TExVSUVxV2hncTRKTEJUdUxnckRsWU9KQ0ZYTVZQTUo5UStwRzIvSFJZUVYvTlk5UDA2QWVDVlozNjk5TlZlSm1oMlZGdWxySXdqYzZYbXJoSFZNdHVpd2owbkU3a3pIUlhNbWQ0V2s4MDh4bUxUN004SkZJTE9teEhCYzJGVlY3UFFwTnArMmkyTU41c0h0bldSR3hoU3Raa1lkRG1zMmozR3dKaTBKMHNlYWwwV1BaNlJ3ZFRvYTBTbEtWc1lTVUNPdUtPaHp2aG5YOVg2L3B5Nm5NeTZBNldQZnA0VDVYSS9yK2NiUUhpaUw5SU9lUEZmaERCOUhvaHg1SFE3K2tuNmJOUlB0djZYYXJnLytvZHJ1M2RGdFB0MzdjdWJyZHZocXhWM2Z3d1VNa1ZORWhZdW4wNllsalZOdHpmQS84elMvbmNzdnpRcS9UNlhXKzFJSGREU1RxMEN5eGU3SW5qb1A1K2ZaNlhMZ09BZTNzTml6dWk5SDhhejVSNWNBaUMrajhhN0lkMDluTlpydnpEL2tweU44aFFwdi9OOEk3aHJWN0RXeUxsOGlDUWNzUldpVE1RU2V2c1drcytEZXRqbGR2M0xxeFVaM3lpdWJ6VTN1OWxNb1hYbkhndmUrdHVjY2FDMnl2MysraHFMRXJlemFhTHBiU3NyU3J1dWYyMjhkOXpNOS9lKzdqSExmbE12RXRmZ0NzYllsWFFST2U4eHV4MVRSLzg3N0RoMXVycTNNckt6ZXRtTjNEOXgyZTdTNHU0dU9WdWRiRTk5bkE0MzBlckxVQ0UrUnhGdHZOcHRGdTgvQkVscjgvOGRYZWFCMmV5UDgvdDlwUVQzNnpFMXU4QWtBUTh6R25PcDQxZ2tMLzRIMkhUVUxtNm1ycjhGQVhlN2hGQ2wxYzdNNGV2bTlvUzdSQmRISEVXczdYblBoZHVObG9kM3l6cW9XMTliV09kR0NmMUx6M3ZmZmVlMmpYcllacTNyblNXMFA5dFY1TDJyOWZXamgwRDc2enI4M3N2R0p0UGZoTytKakZHdVhpV2NodGdMZ0hzUFJscjlCeENoa0VubE5Od1d1Q0VWZGdCTi81YVlFeDhtUUZkUlFhQXhhTlJxRXgvb2xXNk5qZUJwc3BlMWwyYWlIditFZVZaTUtFTzduQ0cvMjRFaUZyVzRnTW5zRnpHcG8zR09FR3hDbGhDVStyK0dHVWpEZmhVZHlxdW8xR3ZQUjJzOVJzSmtzUnVJSy9XR2RDNXJaWUdYaTJ5RnNNbVVrR3dUS0c2eXJEMkJqVFpEYjJFbkV4aEk1SE9OVDBoQ2JtMEFxWkZRTjdISDhCdmpBTWpyRzFFak80Z3ViQ0ZKdjF5aG0yc2JlS3QwNjhrSXZCNVVTeXdtYVJ1NTNnVCtGcVJFcnhSc090empWTHBtT1I4eVIxUG9ZWEVoeFBjSlpReCtwRVBNdERaNTU3YnZQTUdaM0FlTjExMTlkT25MZ3RlZDlqajcxSVBmWlluem9QeDh0L3hvZnhHaWNTaVp6VUpUTDdIT2JKUWVwYTZsYnFCUFVBZmh6V3UrRjlIWm5tRSs5WWdHSnBkN1RBdnQrM1FzSC9TK0JHUktab2ZuaFRBaE1xK0VEWHZEQU10UWpYUElKMTdVMWNLWHR0bEtJbHVsMlB4b1U1dzVZVXJmRGFncVpJaXNEempieVlPUExtSTlWNUw5UnNad2YvR2FFaHJxbkd5anlqMHNuZTNub3NGRk0xUHBOVXZtS0h2TGdxN1NweVhJSmYyY2xvY1dldjlUNThpeGUxWkNFZE51WjBHWXZGTk5JZEtjd200dG1xWXpraDF3MDVWcldVekhhYU00ZXV0eGNQSGx4Y1dFbmFmRXlYNUh5ZERUR1lNQWltanZTcGNDcWtxNExJUnAwYkRqS3NDajZwc3BKem5YQ1NpWVNUV1ZwTjBXR1JqeFQxaW1MYVhIWXNod0ovSTNpY0JSdzc0T3Y1dkJzemE0SkZROTUwdDdMZ3p5YnEvTWZqbW41d1dNWHU5bnFVSmdpL2NVeHVmb0pPZWtJUEg4Y2pKd0g5STRidFBvU3UveG5Gclk5aTdBUDVCNFRLek1xTk56NSs0NzdDaVFNSFRoU0s3eE5lbFg4VkY3L3A4UnR2WEpsOVUrSEFpUU9GNGgxYjh3MUJOSXlTNEkwekRRZWVONkFLUjMzbjRha095VFAzWjk2T3hWNXZyZWM0RCtkdWhCemJVN1NIejN1TE93THNVUEJuVTRnbE1OWEtnVVdKVmNCaVlhNEZla3dzQU9Qand1UjFsSlRiOHMwMzQ4M2diMkNMa29PL2dTdVQxdy9HWW00czlzc1Qyd0J6YllOZ3Jpa1RYdWxqbncrS3d2T1YwU2RsNHJnOGNRd1U0Ymw2R1RNUXpQRk1EbE0xUE1leXVoa056ajNUdjRKNnJwc2hzNURhOE9EMDhPQUlpZ3krajlCdDZKcHJVQWIvOEJFK2p4eUh3K01Jam05d2EyU21NdmhoY1BDT1lNL3JOTkZtc0xST3YzWGlHQms2NHNnNlBNdWhJUmJraXovR2JmWVVuc1czU0RTN3ZFWUx2cmFBT0V1M0dtMmlVd1FnZldZWDhqWDgwR002V0VqdlpQQUFPby9GUlQ4d0RpL2dtaFdxQ00xbGFpVXpnZ2ptTHlya010T0ZaZ0xPR0dUWWN6dEw0UVhyemp1dFpnWnZGc0xIZHhtSnBacldmQ2JSTEV4bjhqbEI5UityUkdmZExGa0Y1T2dWMDNDTE5ScGluTk81WWpNMkV6OTZiV3o2WGRjZWpjL2NscXMycG8vVmlxNWg3VlpzMFAvell5d1Q2SXM1WEsrREVFOGVFNnd4d3RacUxiTitsUndUQWtFdjVGdmtRMGRxQXlEcVVNZGxCSEQzVUZFUFRjdkwxZVI4b2lRWnVDcnBZcWJpZFpMNEtLS1dzczFNZFZrKzlxOElpTVNYa2gydmtpbHVIRHVHbjdocEY0SkZ1K1JLbzdyOEE3VnBHZ3NSRjMvNjJsWkVMOVJ4K3F5MVlGc0w2c0dqOEtRQ3RlZnBla0dQV0Q5MytVRjE0VGFvazRqbW1zMnQrZ0xBMHdYc3ppWVo3QXVkTElvSVhxUzV4Qno1d1ErTzlJVHZmT2Z5ZWJUNnJuY05OdDcxcm5XMmo4VCtVNFBOeDhYVTQ1UHIzTUw0ZVhocW1QNUM1VVFodHJjUXdkL0tlUlRoSW9VMDg0TWorQmxSRUw2RFhGd1NQSWU2NzdKWnRqLzRpWXJjeDFQaTQ5UzJzb1o1a0NkSGorQTBlQTVNdllpLzFlK2dxSTR0OFBNSWdMdDRyNHlsS3RzLzhpd3p2NFFDK0tHVzROOXRlN0JiUVVNTUlySkdTSFRsc01taXRuOWRjQ0FTTGlSb0xUVFNhQWhQWklHYlB3QUR3emxaZVNRRkNTUDhvditBd09ocEJuOFVCSnJsdWxFSWFNcXBraTZwbk1xSG9udEFVd2hpUzFwa1dDRXRoZ1NhRVNLaFBYdVVxRWpqZDBoSVR6elBjSHVpSVY0TkhvZmdwOUV1Zmw2bjZZbkhhZEZVdXQyUUFZK0h4Q2NZVVdBanFvclBSRnNyWHNFcFVMNU01MFF4Ujh1Y3lpbmNGVVU5S3VIYnFocGhCWkhSUlk0V0JaclRpcVVRRnEwZzdwZ09tZUM1SUdSaUdKQUpmbkNVQjg0UU1qRU1rUlhsa0Q2Umg2QVdpemdQUWFRNWNZeXZBUEpxbkxyY2o4Tm5EUDF5Q2JJVGxnekRORWdEclFXdTNRR25SZUFsRmhsSjRBczhHTUlYejZtSEVWbkh4Y01nUVg1ck9HM1BFWUlvVGhBRlBUQ2FDaVQySjM3bmlVVmFvR1dVS1pTUGxiSDBLdU96UlR6OXAxMlgxdFJra3VkUU1wM05UZWxlcmhqSFo4bWs2dDhMbTkzZjZacDc2TU5TQ3FLQUt5cmVhNkVwMzZTMC84U3RSN3UwU010MEtxenI0UlErRU9udTBWdC9MVmZSSzdsTWhtUVUwdWh5bWRiMEdKeGxNcVNNbk5QdE9uK0ZqcXE2bVpKVVJZVzllSEJvNE1xTmVGU2w5bExIcURYcU5SQmh2Z2tWSnBnR1pRK0xuZURGREZqOWRZSzdidUVydGhPRUFNZVNwckJBb29UN21ETndzVW5tTVlGMkFPZFNHUEo0N04xRkUvVU5GdFpwM0tWaGpldE5HVHFrbWt1L3RHU3FJVHFGMGtqVHJMaU00bWJSeld1b21NM1pNU1Z1aGpXVWVWaGFvYThJYWFRMkVOdzc5VTZmNDA3cll5Mkg4UHF4aGFYZG45Njl0Q0FqQ2NVT1hua3dodmVmN2Y1S09KOU5PanQzT3Nsc1hzKzdyaDNEMlVmMUVKM1AweUZjbUJLMzhtNWUxdFVyMFI0eFplcXFDaTN3NDREdjNhN1A3eGQySERtNnRIdjMwdEVqTzJRRStXY3lrRDE2cU5zZHI1VnVrQmhwWVlpQjAremdxUXNXaTZPV2c0Zm1wNTc2Vkt2MXFhZmE3M2pITys2ZmVlQ0pkOS94N0xOM1BIdm5uZWorSDE5NTZ2RDI1Nk5FenZFRXlDU0xoL3lDSnhUQTRuSURubTlEVG0yY3g5VFVFdy9NM1A4RHlBYm45ZXkzVGgxKzdMSERwNjRjclkzNWVZMXpjaWFlSHowMVlYTUxYcU03UnY2eC9sSUxmRzZzZGdjV25XRjZSVDZvQlRxd0JyVE1qdThJNUp2Tk5kSFZqWWMvOG5BVEdhSXo1VWlOdmJTN3A4Wkp6cFF0R2Q4OGZkZGRCeTkvNVcvR1lxSVlDMHM2bXV0Y2NmVkREMTE5dUkxRXA0SVQxTmx5bVovaG9wSmRjY1RCbjU1NDE0bTdEbHgrb3hCekJNTVFITmxnM2pUaWtVL3IvS1ZRQ3RiQVhxdGd3VUpYRnIwRWZXK0pZV2swSEJOZm1xNWZGWnlZOEtZM01ZYU15YUw4K0pkRCs4MnRQbm5FZnQyUGVEcEc0OC9DNkFPSS9BRXVmbnNiS1BRdkdvWngyK0pnWS9mbjhtcnVrM2sxLzltY212OUNYc24xdTdPejNkbUZXcUZRS3dBVzd1QW51M2REWXFPRkUzMEJKM0tDQjl4WlNIbHpBVklHZnFZWG8rK1NxZnNwVkYwQ1BiamRXQ3diOTdCc1hLTnU4YTNJYUIrZ0JyNTVLMzdzUHZKSjg5MC9ZU3B2QjI3NUJPOERyS0o4VUtTQ0Q4M25rWTlrWU9WTlRBOTlWVndiOVRJWjFRbHJYbnVtTUpmUHFMeU5EQzJLSjhkU1dGZERDRXc3RUcxS1NHSzRtQ0FiVFRwRXkwbzF6TEpwUFl6d3BCd3hESmlENVd0SVZzVXdyWE55MHAzTnpyV3locm1XS1dvYVhja1c1M2N2RnFNYVVnMlVpV1J0WFdEQ0tBbm1TS2FJeERDWHVjd0l5MnFTTmtKaERWOWtraWdxcWJNN2tDb2hXY3ZVZDgyNWJsbUVkM1RNazVmTmtaZGJ5MHNsZll0L2Z4VFBLZVpnUkNqNUEvb00vbVA4VGlINDFzQUJnc2hDdXdTSXVGWEdnNWsySHZKeDRnekNlWWozWGNFU1FWb2tQdTZSdFNNMFB0ZTBiaWxYUUlNM3J4MWhVYXA3TVBPbmUyL0RDYmk5dHdyWG45d1E4VGYrYm9HZ1ZCdzdzb2JsOFZKWDAyQVI5c2hhNW1BM2hYNWZ1SFV2ZCtxWWVOdGU3aVExOHNFRWVtRjh5RkRUc0hiY2Nwb00rUTdWTVNsMW5pZ1o2Z3VkT2lhdjNtN1dlVUE2QlVKNXF3M0JGWHpVTFM4dmZCTnh4MDRCMmJ5Rzk4TGRWL0R5KzZGUWhlTk9YbzgrZmVyWWtCNkYrNE52b3ZWVHgzU1JFSHVNeFZUZko2S3ZRM1hROVNjNVRybnpGTjRNNnpwYTF6U3czTWhEelBhTzBDbDBtc0l3NmwxejIrcjhGdVByWVh5MFlJWDc5MjVJTDRRUDZvdGdleXlLWUUzTmd5MjE3a3dZV1NzS01VcDJVOVA4bWY1cXIzWm51ZTFGMHBVTTJFdUhBTzJMOW0yb0kwT0Q1RUppQzQwQzhSMXE0b0VBVStrMWhWMUlDRWdrL3BScEZJUnVlMy9GM2d2VVhIKy9ibVJ5VVVJU1A1MXlxOUZVMXRMT3VLdXJQYjFXODlybFJLSHFpc2cxYlpqVWgwYzZNR0VMbG5rSHoxOVg4QXoyY2hJRmQzVzhla2tGeXp2RWdCUUJXZ1owdkVhSHhnSUUvTnI0NXdaN0k5aXorRmVlMkVNNkxLOFQwUnlFOVRLV3VSdFlac04vNk9peXB1dmFNcEhieG9jMzZtQ21Qeml0SDhRN2lDbml1MXIxOUEzOXVLanBQTWVWV0kwcFMyaWRaRFA0d2ZZTXlDRzZSeWU2c3pQZ3FmVU1QajZyNitmSXFmOTN6ci8weTJIaGxDaWU0a1Z4UmVUNUZWaFZHL0VJUm02YlNsTkZ3cWY5bUR2WFVqZGkvcHlZUk1nd0czeGpJUS9vd2p3RXZ2TEtBbTkzeUdGWkoyY09lQjNEalFLYzRkbXFrNkdibHRsb09YN2lxUDhvSG0waGJYbjhqTStrdjlOeHZmVWlEMHRjak16eWVDS2c3WUJKQTQvL3dhemdLSzZmSm5KU0dWOWlTeHlIOE1DaUgvVlRLRmhheDZuMllYN2hKd1VOTHJJMlpvN1B1cHN4SSs2R2RLTHdlY2hLNUsrQkJJdzIrQjN5QUJQWFB5Q0V4UzYraE5rRFZteVlWNDZmQkhXQUVvYjllNUdROFZtY0IwNTFpNzVGZjIyQWozbkhxekp0R0VYclpwUG83VG9CODN4ZllEK1FFaGIrdjRoNG94eW5sekpwUEpmRlk3bEtScThsZGZHaDlZZnVPcVNmb1lYNFFvR2VzUzJFNTBEaC8wbVd6UEhkSTcySEh1b2RmcEMvYlcyN0Q1VUppQUhEbHVyd1dQWWw2MHZ6RVBJS1hLaXRab3VFUFNKZU45NXdaZjZWYU1hMmthaklZWkU1dnI2MjF0UDMzdkxLMDNjM2xjVmdtZDVFdTlONGxoRTJSZWFiYTBkNmE2dFhDeWYySFh6bEt3OWUwVlFYMTRNMVZGOE85TzBDZkZ5OWZRUlZiNXYycVVUQUZNR2RKZ0NOOURWQnplMCtkdDQ0V2FHVUd5ZDh6YVJTYXVYRjNQeDhEbEc1K1pvTFlaOWVwR0NMeklrMHY1dXIrU25tYzZEM0hhWHFUMmlxMmdUZ1pGNG5hQ2VMWnk1Nko4RCszQWpzRkdBdGpFU1hIbXFyU2hQMUdVN1dpb0YwdzVHcmZrV0dQTGt5VUZtTlNVLzQ5VHBLYmd6T2t0cE0zUENKdnRLblpwMVErSWZuWHhyR21IYUpmajZMZStRY1ZTZTJSRmFCQ1l4Um1BSng0dDlGRkFCZTRMYWNSSVVvQWNSc0FacEVSeWgwQ2s3Qnc0TnBMS0srVTQzRXJGNUVQYUJHSHI1RE82QTk2WHpIQ2I4emZLdTJROUhrT3hWTlFVZkNnKytwa1lpS0NtRVQ5aWIrcHcxK0ZlVUhmNDQvVDhZUC9IL0JmSEJJVzRCeUFTdUFGeUROeHpYQVY1bW1Wd0RmcDJhbklKenRYWWdlVmxPMHk3WGRGeVpFRzN3cEtIMnIzaThKTWtlQlNFT1cxeUdyS2d0VlhMN2d0TERzMDVmTm9qZFYzZGk0ZWFHdUk2TjR6ZUo3MzN2Z0ZUMDN1OHVJSWxEWjRSSC9pT0RzbkMzdHVmMzJQZFh0T3I5dE9XL0pibXNtVzNBV3dqNjZ3M1lVQjIrTXUwQWdUV0ROR05BZW5oNkNPUno4aVkrNW9Qc2dENU5RRHIwQWVFRVVBVzVoOE8yelowZmpScGZnSzVGMVpNQy92RkFwemdUS3crbXQ1UVQ0RHFmZHRTMGxqQUVlUnV2ZlhlS2p2UzBtMER3SzRyZU9Zd0w1TVgwbVlnSk5rN0ErUC9yUlJEN0NSRXlnWnN0SEczQUVFaE5JSnlHRkZQLzVqLzNvbW10SVZDQ3lUdE5GSDBOZHpGMi96NDN0VlFLN0VQQllIOGEyQnplMEZZVGJUYkFjaE9XY3FQWTl6YmJDL3lnTDN4TVVGVytrK1R2dXVLYmJSZDJvOWdYTnN2QW0rcjB2Q0pJa2ZFRlFsSGUzTmxxdnl1M05qV0syK09WR3p5K1Q2MWplUlA0b2RjY2RrMWxlanpPaUF0cngvOEEvT08wamVnRUVKTmwwZ2hPOHh4M05LN1NRUFQydGVWNUZTNmMxOXdqWXVOanZQSEJnSitydWZHcW4zTzYzdnlWN3h6MTU1ajVGdHJ1Mm5EcDQ1ZUxHWW04WUU3cVBYSGhEb2ZhRjFrNzgyTi81ZDRkMmVodEVUNVluYUFpV0gzL0d0N0FIRGZjdUJQV0RsV1JpM2VZVitBQk5kZ2tWQW1pcmV3NzJlZ2NycXB4d3UxMDNJYXVWSlpQN0VHZTJPSm1XN0pCZ3I5dEN5SlorN29PNi9rSEhsZVRrTEl0Rk81ZWRUY3FTKzA5N3N0azlmMGtyaGl3NkpaWXRPYUpzS0lITjNaQ3VTNkhxWWpTOFJLbTQvcEhSZDFZaHRsd3BYTm9VbmxPMXNTeTVCMHVTVjFQWFV6ZFR0MU4zVTY4YVdrVFdmZFJoQytJcmVrUXJXQUExb0FWZ3FjMENnVThWbklJUHJRcmJsZ1czbXlTU1V3c3VGSnErMnRBakVScHRvaXhzRTV6V05tTTdFTW1CWkhJV1RDM2hKeDVHY3FKY2N1UmNSQy9HWWtVdklhTXJiNkdsZEtiQzNId3pVOG5ISlEzSjJUemMweU01MlNtNXJvd08zMExMeWR3b1JiblNkUFRVaDF0bHZSamVWMm5Hdytsbm01VllhZ2g4ZHVyMVYxYkx2RWJ6K1JsT3VvS25kWm92VjFzRk1WTGJvKytwR1VLaFZTMExOTTZUdjBMaVp2SThIVUZpdVZyM3hnbXVxS2l4aHJSSHJVaHFiZkNkaXBxb3lWMjFFcElhWVBFdzRuRU16N0VLVklXZ2Evc2N2aEpMb3pkUXQyRnA5SDdxRWVya1ZpNUhpS1JRenhNd2dLanRGRnB0WDlmYTdsaGxFcHdSR0FiS1JZak42RmhFc2RqQ3Y2YkZreHNPVVR3eVJOK0lqNXYrSTd6QThCWjV3bGRGa2xUbEVjTkJFdXM5dEhaa3IwanZUeVJ5bHUxZWJoYXluNGc3bWwzSFFsc2lWV0wrblJaaWhhTzBHTXNmRnVqOWhVTEJqR1hydHBZeWkyKzJ3aGtqLzJtUlBzcVVVbmU2dHBtL1Via09INFp4NG5TSmFSaVpzTlVZQlRkL0dBdUZEL1h3VERXYW5kdVBicGYzY0xUUVZhNmwweUZoemxiZlY4Mkw0Ym1kOVNSUDc5Zm5zbmg3WmJLK24xNVZ1aHg5dFQwbktrVjAwS3BLY3VHZjg5V2RjMkdXNXZiSWlKOHQ0dU43cW5sQm45djVpQ3hWclpDUGI3NkJ2MkViUkE4S21FbnZvWDVoWWcyc00wUWNhamQ4bEE5am04ME8xd2J6endXeWNMMXRVeURZS1R3b3lyWnZ3SERVaFBpczl2Yk5FbXFDZXNLREZwcmNFTVNwYm5kdGZRMnNZRGFySjZwWUFzcTg1Zmp4dHh3L2NmTG8wWk5IRVV3R3VEZ2I1MFdGVmJCNHE0UkRHc3R6WVUwM0ZKWm50VkJZRG9ja2haVUZJY2JGR1o1alkyeE1FQ1JXd29ubHNDRXhBcXNZdWlseEpMRVNsaFdjV09MajdHOThESVYzSE90aFdmbllqbnJyOE9GV0F2K0RCYXFUeDRHQVB6a0tCTnhxS0VJb0lxaWlMb3U4cUltV2FNcHNpQTV4SVo0UDBZeEtxNnhzaXBZVUVqbFJNa1JWa0UxQk1YQjZReEk0Z2FSWEdJVldHSHJyQTZJbThLSWFGdFhPeHo3bWo4cy9STCtOM2s2cFZBbHNGUEZrQXdZNzNJMXhTeFZCaHhOR2RSN0d3alllL1BLdDhncHFPeDN1dFZNN0plM0s5RlZxdm9xdXFob2ZZUGdHT0IwdGxNR2tmNWNZL3N6Z3hVL3VuTzJHdUlnVEtucUwvMUsxUDZOSk93R0pBSlVic0h4VjU1Z1BmSDJJQXdNMnorQlpEbC80RGdJVEdzY1R1TEdXZjgxRjBaMGZmLzZaRHovNElEcTBWR3dVTW1IVWR3Zi9vSzV2UFBQTWd3K2FlM1B4UWlFZXJrY21iR1lOZ256YXdpTXJyRnZ4L3FLVnYrKzBiWS9VRWk3NCs4NHlLbzltOGI3RlVDZUk0RU9nbzN4MDZtVzZrVUhvSVU2SHlSNW11OHhMUENPSFk0M2YwMlFHSDh1U3lER2l3T2ljMUpEOE9YdHREWGV4dFYrVlFod3JjdEdhbGVkNVRtUzVrRVNINTNmT2h6OFJaaEhOQ0NvRC9ZZG1RMUxZWUtRUVB1SjRobEhCbVlJTnA0dy85bWZ1ZndWWnJhL2RHTUpkSzY3eWdnQkp3NllaM21xdnErQzZnMTI5a0VVcnlITVl3V000cnlBVWtzaHJlcHRmOEg3aEY3d3ZiRlovL2RlcmFERjVLbG5wOS8rUG85T29mOW5mOW5wL2UxZHZjRzUxRmVubkZoZFJiUEIzcXplT3NYb2dieHJQMWNMRStpbkl0cW1nWnFmNVc5UFQwMEdHT0xkSzh0VEdqVGR1RG5PQ2ZCWW4ya1VnMkkvRkFQUEhuMnZtQlFmTWhxcklEdXdOUFFnRVJtQkhlYWRCUWhXQlBQdVc1OTZDL3padmFMWDV1dnRCNXpyRFcvUzh4Vy9jc0xkdEtJM2sxYkhmT0hSdjZBRTNoTlpKd2xmc3Z6VTdOVlg3QnFUeDl1Mi9TN3lWbjN1eThqZjNIaXBsMHVXWU5ja3pnWEx4bDJJZmxtSURJRGZRR1BBQnNIbTlSZHdtbXZBRmdDaEx3aEMvM0xHOVZ1Qk9URzdpYnpHQWVIMllVUFd2ekIxWG1qSitnOFZYaHR3UE1lQU04eDB0ZlBWeWRaOGg2M2NuSHNIenZYTDdWaGVGVkRXRWRQbnJicDMvQktIMFhzTThjaXJDZ25QT1o2MVlPUzJacGlUOVBQZGtxTHJudGxyRmRuNTk5aHlhTWtLMWFTT1JNR3g3S2d2ciswRTk0bVJPMlFqc2tLNm5icVh1Z3Q0UEFneHh2b1dscWFYQVp3YmNGUzEvaFdvRitlanR2b2NJeEpGdCtjdFlZVVFVd2NSMmdlaUN5eVFmcTRNL2ZkdXdWdEFKUVRTdnRVVEp1c1lVUmZNYVN4S3Q2MDdRWWxhazZjclBMR2Z4cDV3V1hJRzVPM01GSTJSRmh2WWV3Sk4wUEZpSVROeGoxRnZMREN0a1JPYVZHWmIwOGNGZmtkZm54Nng0amNpRkZ2RVFwclUxVHV4Sm5OYUc4V3pSYXlPYXN6bWFUaXhQV1RZNHRsb2N3K1FxNWowdHhPQmpoQko2d21IQktaZU9KTkJWeXdtR0dTYjVQZkllblNZdmxhOS9DUGduNC9jbVMvRGoybFNQdWdsOHlUc1FDc1h6MlFXRFI0ZXNNbmNBUElzd0ZIOSsrSGxFREIvYStIajBHUXM0U1BpRitVLzRUQko1N1N3U1dxUU52TTcveFN4blBab1I4UWFMUkxjeWdydWZ2clZDWTdhWkZZOWh2SWlJK2NPOE9wT3gvZEhrZnNHOERqZzc1dkcxcG5pRVpjcTNNbUptS1pNNXphRFdsSlZBaUxOMjBqUnJMemVoMWtrYXRWY1NtRVcybnNUM0VncFA4NGpCSGV1ZkNRdmVlbzNJRWhhSE1JdWxub2hackFHTFE1ekxNQWsvQzJTYUU3SHFkTXluQk9qczVpRThlbjBGRlR3OHQvYWFwUndlRlVyUlhOUkJoVHZ2RUdwc3E4MnRzYTlqbjJOL01QZ0s2aGMrL0dHVXlneWV6N3p4bXYrdnRhdUprZU80emwzVmY5WC8vOTB6MC9PMzg5ZjdPNXlkM3BtbXhCK05sVFZGV3FKRVE0NjBBV1ZtSWNVMndjUUdBWWUycFFRUktRa0JJdWVnK0dBSmlCRXdnWU1jRWdTRUQ1WU5HellQQm9MY2VMQ0RJTEVSSWdnUTMwd0RPZVFRTFBOZWRjL3VVZ0Y5aVJ2VE16MDExVy9xNTNYVmUxWHZmYS9aZkg3VmNSYlRmUHZGZzg5dmJkWEk1WU8vSGp3U0R3L1h6R05vZjVIVExQcEpyc0lKazlFSjB1OFFoR3hFY2tMOFM2RCt1blFkNUFacG9yNzZlWklqdmQzLzJjNm5DOGRaZmI2NVhGOURYZlVVU05oQzBJTWVvU1UrWFBWQlNpQ0hNaDdCR1hxS0ZCdGsrVUZLNzEyUVFhYUpXcTU2UTBraVBDdDBOQXgrc3NSZzMvbW5Gd1lyYnEvbjRya3llR0U3azJmcFRoeTVueE92dWU2WDZGZmNLTWxidVp4dEY3bFdaRnU5cjdLMy8xQzlzVExPQ2kwdnZqbUZnOXhNYTFQRGM1MEpuT20wbHJLK0d2anJsdU42RXpqcDBBL1VQblBOajJtdGxqaVpUTXhlQzhUaEd3Mjh2SEhrYzREMUhlTHErR01LbWgrdnpydThETU9UZWxXR2J4YTVmbks0MVh0WGZmdk94Q3IvSUlVL01HN3d2NlVUNFpHK1FyK1pPbUp1THJ2L0JLbDZpelBJVStSNDMvK2VoVjEyeDM3MU5XVWl6bWNLdVgzRUFSOStmWnEvMzJ4ZXpJQTNLait4a241WVVTZEZSYmFQWlB0WlNkaVRmbW45alRLYml4UGx0VmZ0TzFKSmtqalRyd01QWk0rbnpmZnp5dDZpdEgxelFQOTZSdmdzWXBlVW9BK1p5dmVzWnZCMG93a1dybnZDQTk0N3dsUitOQnRxaDl1SXcva1Ixc0JJa0pYaEJkTEFoVnFVWDI1UFBLOWoyRkxzNVBXVyszcW54cHhhdlhhUWQ1cFJ0TnEzL0RCb2RUSzFzM2E2blhwQlZxOGxnZHZxTlBSdWIzc1FkUHRKdlRINHpkMlBGUU5udExGVGIzLzY0MlR2Uit0eFNOdFNQWDNxSno5NW01MVYycU1mczBZOGFpYVJZNXBlMUxCdHAydW50YXdkSnJadU5Oell0b3l1N3JvTEw3Q2R3TzZlRzUrT25vcEdibWowZGplZlhOb1psbTFqOGhXMTQrMVEvT3JhM1RtczBHT0tlL1d3akk4dmdIZ1lWOFVwTmZHUHhNbktnMWxmeFFpNE13U2VMTGhuVitteWNzQmRnWDU2Y24zOUpKeC9lbTc5NURyWjkrMkhBaVlUZUg4bzNOM2R2YnMvbisvRGNlUi9lSk44QStiSnp3bENqT0RtdU03UUlmRVVwRnQ0NGlFQlJENFlGaUJwemlNYmxmR3hNQ2Q4aFV3ZHZpeUFsdjRqanQ0WXRVblpJdWptQVR6QjEybG1QQVFRYmo5aXEvMmp6MlpNdFExS015S1NiMUFLcno4WDZhb2Z3anpXU0p4NHpmUCtvbngxdHpJcGttbXRlU0lZOUFkWjcxbEpJcUVzYjY0Ri9kWHUrckFyZDJVcXE1UW1oTHhDNmZja2NvWFNLMFQ2bmtocXpEQS9sT1VQNjZsUjA4TWZoUHB2Ni9EQ2l5dC8wS3ZMa21lMzBQcyttYVk1a2FRazFrQTdDZXRwOTFGN0pCdWVqNHZDTmRRR2xxdy9Pa1F4VUNwa2xIbnhpTGR5WCtsbjFkWndDUy9NSTc2VXNXRG11RmtjSjJLRnA4RHA4ZGNTUlFkYThHdVdwdXVhWmZ1YTlyZVdwdm1XbzhIeFJ6MUZNeDJ2cmdWZVEyNE9GbkxEQzZ6SWMweE42WUdxWVczdXhxdHJVYTNYdEN4TGZIcTlZWWIyK3BTcUxZVTE1Sm9hYVBXMTRVdjBVMzlwT1RDV1dnMC9OQzNMSGpRczI0T3JMNDZlWEU5YWtPYUxqRXBvQjhsazF3ejlWckorYW1qWHM3WjBRbEU4RjJUemRuYndpL0RNSURGRktuSjNaaTBlbmczOHFzMVViaE01QXNucmt5QXpDSVVOOHdvSG02bU00dnZjVUpsSC8ybFJIdlUwN3hYQUxQeVJrc3M0cUtEQWhxaUhuS0dsaStjOFB3c3pFQUlYOWZqb1BkdTVGVFdkdUtlSW8vVE5mYi9aQ0hwUmtLNHcrU3JvRzU2SENDU1NHbVJ2N28vejhUWW13d3dQTjBRcnQzeWRlZjhnZGFNTk1XdGJObGt0M0ZZVUlacER3MytpMDlQbzZ4N20yTGRXazVuYldMSGhXSm12ZERYUTBYcjFrZGovUHREMlBZNno0MUdCZkVGNFgvZ3I0ZStFYnduZnhUWHF5amFRZDJxbFVWVWhRcmxPUmZsUGlHQ1g0U3FLZ3JvWHoyZVg5b1VGUXJKd25JdGwyanhQMm1JZWwzZ3lKWlJNZ21RS2p2R1V4QXEza3FlbE5XRVpCYlc4U3JaamVaN1pLR1h4VkpTODhEcUpNUldvUWFIbVZLQ1dMb0p3WkNoaGI2UnFUZzBVNHhWTjdpcHlFTmRVU3N5UWlwUXB4TmNEelFidHkxYmtVSTdjbHE2dzFHaDFGTjIxVDZzN2JkVTczYjEwWlRSVTVNUzc4S3lCTnFhaXF0dEszTjQxMWJpNCtpbWFUaFF4OWFVb3NVUktOVVdKRlJZUm9odVN4eVNxV3kwWjlEb29pZTZlSHZvSHYwK2tlSU1RMTNEanE4Q0ZVUWpzR0gxU2lZamtYd3hVdUUvK01yTXh1cDlraFpacUdMSHB5WklWTkszYW9KNVlqa1FWQlFNc1NrNGtyZ2ROUlhlMHNLTXFSRW5IVHRKb2VTcFRyRGdPMjNJbjlWYTNHMFBiOS9xZHhHdUxMY1Raa0dCczBaTE5tcDdPTmphOVpsY21oaTdYaVM3YktsTnp4cWFFTm1NaXkxUk02MnNOekUra1RobzF6QzNGVm9lK0RZM203YU9ZZlRLUXBiQkdJeWI1bGg2NkRpR0hQcXlvMzM5RytMRndYL2dQNGVjd3UyejNjQWUzQ2g2R29DWmNxSFpJV0dJR0paT29OSlBKK1ZNalRzK1drYWVuT1B2dXpJcWQrYzVacVRoYktpZXpIYTYxOE1Ha2ovWi9ZMUpHenExVXM3Z3lUOFpocGtQNGlOWGpZYTJqVXIyRFlhZ2FpSHJMcUdZOXBZeDZuYzE2U3p5SE0rUVFEb1pEUjVXNFVod1NKdTV4UTlncEdyN2lEdjRVemdmRk9SVWFOL1NwWkZKRzI4NGE2NW9tZFczTk1Ja29FVVJRcWJIUWxtcG1yUWFuWkVkcURkSVErRUNraW16SXRrdkkyRjl6MmxTanBreGR3eEtKZXU3MWQ3SWg1TEVsSnBrZW9TSFZxY0hrZ1R0eUZDTVZaUVYwSWhEelBXQVZrZGlhWXhqaWNIZUltV3pkaGlSUjhSQkhDSUVleE5SUW5Nd1pTS29GdndlVWVDYVRGSU5RTm56MzZVUXhsV0Fhd1B0WHVvc3VvcFhyZlZrbHBnYXNZdW4xak9rSThnQ01Kd0t4RU5sZm83N0NtT0pUVFNSUVE0VnlRM1dzSnp4Q2twZlZkVXREY0NDaVNIMTkvZ2wzYStQSldBUHVjNDFRdzRMSkV2RjdOaFRhMEgyTVRVc2MwU1NFS295bUtXR2d3eEZpaXNCU29DYjV1dTRRNnZSODRIaHNTUllaYVBKcmVhYzJQdUFGeDNLM1FWaWRIUHFQSVA5OVFmaVM4QlphUXc5Ly9Td3cveFVjdDl5YTVnWUxQVzY3TUYwR2V5UDNmNDNkbGoyV053NyswOVkwVzlzNzdOWGthVmFtL0w5YWUrdHhuZmd2ZG1qYjRXTFpGOG1NZnovbVoxOTYyZGM1cG9YYVYwR2FROXhnTkp2UGNlOFl3MzkzMFIxdnNkZ24xdy91WFZyc2R5ZTNKeURWUDdpK1dKREpuWHNIRHhhTFM3ZmdPTkpEU3JwV2hiZFJVZVc3dm5BdXFkMDdUdVoyUmVCb2ZTc1h6bU1NOWdBR3BKaDdicFhDLzNLOUpGbjJMWENBWEFtTk9GZFhBU0Z3dFNRNVZCQXFuMnNWN2ErL1JWVVZGMFp4dFREMEd6QUZPRlJtWXBmcUJQVDdoa2JhQXlNQlNRTjAvWmlRU0dXNjl0WUhUeFFwazRNemxya3h1WGl5S081Lys5YXR5MFgreG1xWGpPVFFoUWRKQVhwS0dIaVdKRk9QQXZQNFJLWktxRGt3d2pnd2dMaXVLVXV0VmoxU1h5aUs1M1kyTGZ1SlFNSko4K0p6eGN0dmZ2dk5OTHN4TzMzNU9CNkhLU3lxVmJsbHllVjV4ZTdsQWhJWDdYaDA0V3dIVXhGL1FrRXJuYllNN1FQdDlDZEhwYnpBWUg2alhaSEpVRnVKZ2ZDRmE2UWdQV0ZqU0pyT2NHYUxSWkdacnBjWWd6YlJHdVQyWWJIK1BsU29ERFdDb2NTak1OdDVRYWpBM1ZCcjRvYXlvVWIxVmt1U1RUVG1rUjFKSkk1d1RGK3M4WWhLYUJHdkhvT1V3TkJzV1E3NlE1OWI0b0lHQ2N5UkxPT2JRWllpQnphWlhIRDI5aTd0N2RtZm1GeS9kUDM2S2V1MWpUZmUySGpOT3JVYjd1MU45dmFpM3lDMzcwMDYzbVIvZitKMUp2ZCs5clA3dGU4OGVQQ2RtcnM1Y1BmMzNlSEdVZ2RmbHVYeEpmbS9mL2RSMmxWTWpZZjNRSisvdy9kd1Y0UzVzQ3Q4SFBUWDM4SjRGSS9hNWlyVGVSR3FVWW1qanJqbG9UeFQxTDVOMEZkMWxFVlZqTTR6QkVZaStJTCtYdmxjN2VkRmdoTndyd1F1NGpaRy84NjNRbjczMm9VTDF5Nzg4SjFYQ0h2NXJaZGhBS2lsVzFTdWQrc3kzVXFseG5BMkg3WjIvbmllamtWellZcmpaMzN5UG1QdWk5ZGVkQmw3NloyWHlLU01aMUVmMU91RHo0NGFLK3FEZERoTUg0aWh4aG9IbHh3RkY2OFY1eExUYmR2NDh1VWd1T3dvclpieTNZbXI2Mkd0RnVxZ3MrSU41VGhldG9Fb05JUkNlQmJVMVoxdVNMR2VZZlZvVnR2RnN5ak1wdmlPL2lqNE5zWmduSHdBSDgxUW5VZXNlejdXSDFXWExLNjg4NUpsanp2VXR0RUdkYXZkK3VEcEs1VElyZlpZYkhhYjRyamRZaWZHLzhxWXQ3WitkWDNOcTZwMzgrYkJQdythTjBIcjlrSHFNVTNMVnp3dnV0bjhyMEdUU2JZbTcwZWVwemh4N0dEeVBrTnM3NS9Yc0hJbUhGaTlXbk93eE10OWVCZms2N3ZDRk8wdUNRNkMzSWZqT050d01IVGNDc3Y0RU5uSEhhNHExbVpSbXJ2am5ITDl2ZFhQV0tjM3o1K2ZuRCsvZGNxS0J5dUQ4ZXA3NXpiZzB4dmw2MTFGKy9TNVArT0dTZVR1ZTgvOVRyTjU0aG0yTTE0c3hqdnNtUlBOSnViZmV1NjkxWFhNUDBoazlzckJmNWNobkxDTXYrRDJTeGpUUUFqVTVDa1k4M0l4NnhEdUpkVGZIcUZGUnJBU1FCSGpaUHExcTBZMm92WlBiVHJLakt2TVNucjVGMjkzRVF2V1hYUnZoNXNiNUZxbks4bWpoOExEa1N4MU93Wno2TG5KSGp2NE43TEM5aVljdy9MSVI4REU1K2lJZUVIdUhpY1ZrWDI0OFQ3cDhodFgveGNwWitmaEFBQUFlTnA5anoxT3cwQVFoWi96cHlBaGxDTnNRUkVLYjlhV0szZEpVRVNLdE9rZHZFNHNKWFprYnhTbG93U3Vnc1FKT0FPY2daWVQwTUd6c3lCQkVhOTI1NXMzNHplN0FDN3dEQWZIN3hxUGxoMTA4VzY1Z1E0K0xUZHg2VXd0dDlCMTdpeTMwWE9lTEhlb3Y3TFRhWjB4dTYvL3F0aEJEMitXR3pqSGgrVW1idkJsdVVXZnpISWJ3bm13M0tIK2dqRUthRVF3UEdNSUxIRGdPU1JIMkpCR3JFZk0xcXhYbFQxUzlxNUlFK1RJeUZVc3NHUmR3SWVFWXV5enczQnRFV0xBbGRqZTVMZFhvbVFtcVdycVY4QzQwSkhSc1ZnY3hEQ09ObUpVUlBGYUg4UStOU3N4eVRNenlZdWxGcjVVb3I4eVpoc09CZ25WcEZKbG1jaE1HN3BNNjBFcGJ1dFlVc2l6OURiUFNMUDZoU2wyZkJkbU9rNTNqS2NlRVhMLzl6dXFBVng0N0hPNUZTbWcwWjhiaHVKbkxqRndQZC8xbFJlY3ZONmNzd3RLYVYwUzlLMmNaUjJyMjJDdWl6TE5NNkdVSjVWUzRwVGJOeEQ0Y0tJQWVOcHRsMk8wbmVjV1JyUFdhcHZhU3QzVXpuN1hzMVZ2MXJhTkZDbFQyMGhTMjdidDFMWnQyOGE5dHpQL2JuNzBHK09NN0crZW5UNWp6ckVHK0lELy9mbDc5SUJCQS83UEgzL25QLyt4QVc1dVlXUFoyRGFPRGJSeGJUd2IzeWF3Q1cwaW05Z21zVWx0TXB2Y3ByQXBiU3FiMnFheGFXMlFUV2ZUMnd3Mm84MWtNOXNzTnFzTnR0bHNkcHZENXJTNWJHNmJ4K2ExK1d4K1c4QVd0SVZzaUZXc1dKcXNhaldyVzhPYXRyQXRZb3ZhWXJhNExXRkxXc3ZhMXJHdTlheHZTOW5TdG93dGE4dlo4cmFDcldncjJjcTJpcTFxcTlucXRvYXRhV3ZaMnJhT3JXdnIyZnEyZ1cxb0c5bkd0b2x0YXB2WjVyYUZiV2xiMmRZMjFMYXhiVzA3Mjk2RzJRNjJvKzFrTzlzdXRxc050OTFzZDl2RDlyUzliRy9ieC9hMS9XeC9POEFPdElQc1lEdkVEclhEN0hBN3dvNjBvK3hvRzJFamJaUWRZOGZhY1hhOG5XQW4ya2wyc3AxaXA5cHBkcnFkWVdmYVdYYTJuV1BuMm5sMnZsMWdGOXBGZHJGZFlwZmFaWGE1WFdGWDJsVjJ0VjFqMTlwMWRyM2RZRGZhVFhhejNXSzMybTEydTkxaGQ5cGRkcmZkWTZQdFhydlA3cmNIN0VGN3lCNjJSK3hSZTh3ZXR5ZnNTWHZLbnJabjdGbDd6cDYzRit4RmU4bGV0bGZzVlh2TlhyYzM3RTE3eTk2MmQreGRlOC9ldHcvc1EvdklQclpQN0ZQN3pENjNMK3hMKzhxK3RtL3NXL3ZPdnJjZjdFZjd5WDYyWCt4WCs4MSt0ei9zVC92TC92Yi8vdTkzRHgvTHgvWnhmS0NQNitQNStENkJUK2dUK2NRK2lVL3FrL25rUG9WUDZWUDUxRDZOVCt1RGZEcWYzbWZ3R1gwbW45bG44Vmw5c00vbXMvc2NQcWZQNVhQN1BENnZ6K2Z6K3dLK29DL2tRN3ppeGRQbFZhOTUzUnZlOUlWOUVWL1VGL1BGZlFsZjBsdmU5bzUzdmVkOVg4cVg5bVY4V1YvT2wvY1ZmRVZmeVZmMlZYeFZYODFYOXpWOFRWL0wxL1oxZkYxZno5ZjNEWHhEMzhnMzlrMThVOS9NTi9jdGZFdmZ5cmYyb2I2TmIrdmIrZlkrekhmd0hYMG4zOWwzOFYxOXVPL211L3NldnFmdjVYdjdQcjZ2NytmNyt3RitvQi9rQi9zaGZxZ2Y1b2Y3RVg2a0grVkgrd2dmNmFQOEdEL1dqL1BqL1FRLzBVL3lrLzBVUDlWUDg5UDlERC9Uei9Lei9Sdy8xOC96OC8wQ3Y5QXY4b3Y5RXIvVUwvUEwvUXEvMHEveXEvMGF2OWF2OCt2OUJyL1JiL0tiL1JhLzFXL3oyLzBPdjlQdjhydjlIaC90OS9wOWZyOC80QS82US82d1ArS1ArbVArdUQvaFQvcFQvclEvNDgvNmMvNjh2K0F2K2t2K3NyL2lyL3ByL3JxLzRXLzZXLzYyditQditudit2bi9nSC9wSC9yRi80cC82Wi82NWYrRmYrbGYrdFgvajMvcDMvcjMvNEQvNlQvNnovK0svK20vK3UvL2hmL3BmL25jTUNBdVBpTEZpN0JnbkJzYTRNVjZNSHhQRWhERlJUQnlUeEtReFdVd2VVOFNVTVZWTUhkUEV0REVvcG92cFk0YVlNV2FLbVdPV21EVUd4Mnd4ZTh3UmM4WmNNWGZNRS9QR2ZERi9MQkFMeGtJeEpDcFJJa05SalZyVW94SE5XRGdXaVVWanNWZzhsb2dsb3hYdDZFUTNldEdQcFdMcFdDYVdqZVZpK1ZnaFZveVZZdVZZSlZhTjFXTDFXQ1BXakxWaTdWZ24xbzMxWXYzWUlEYU1qV0xqMkNRMmpjMWk4OWdpdG95dFl1c1lHdHZFdHJGZGJCL0RZb2ZZTVhhS25XT1gyRFdHeDI2eGUrd1JlOFplc1hmc0UvdkdmckYvSEJBSHhrRnhjQndTaDhaaGNYZ2NFVWZHVVhGMGpJaVJNU3FPaVdQanVEZytUb2dUNDZRNE9VNkpVK08wT0QzT2lEUGpyRGc3em9sejQ3dzRQeTZJQytPaXVEZ3VpVXZqc3JnOHJvZ3I0NnE0T3E2SmErTzZ1RDV1aUJ2anByZzVib2xiNDdhNFBlNklPK091dUR2dWlkRnhiOXdYOThjRDhXQThGQS9ISS9Gb1BCYVB4eFB4WkR3VlQ4Y3o4V3c4RjgvSEMvRml2QlF2eHl2eGFyd1dyOGNiOFdhOE5YRDRzS0g5eXBBaFBDczhDOC9rS1o1Vm5qV2VkWjRObmsyZUxaNXRuaDJlWFo0OW52MS9ueFg0RmZnVitCWDRGZmdWK0JYNEZmZ1YrQlg0RmZnVitCWDRGZmdWK0JYNEJYNkJYK0FYK0FWK2dWL2dGL2dGZm9GZjRCZjRCWDZCWCtBWCtBay80U2Y4aEovd0UzN0NUL2dKTitFbW5JU1RjQVJIY0FSSGNBUkh2RmQ4TC9GKzhYN3h2ZnI4dk0vUCsyTit6dmZ0ODN2MCtUMzYvLzRlaGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2SmVHenU4THVTc0pQK095d3NNUENEZ3M3TE95d3NNUENEZ3M3TElJditPeXlzTXZDTGd1N0xPeXlDTDdnQzc3Z1YrRlg0VmZoVitGWDRWZmhWK0ZYNFZmaFYrRlg0VmZoVitGWDRWZmhWK0hYNE5mZzErRFg0TmZnMStEWDROZmcxK0RYNE5mZzErRFg0TmZnMStEWDROZmgxK0hYNGRmaDErSFg0ZGZoMStIWDRkZmgxK0hYNGRmaDErRTNlVStUOXpSNVQ1UDNOSGxQay9jMGVVK1Q5elRIdklmdjBlUjd0UGdlTGI1SGkrL1I0bnUwK0I0dCtDMzRMZmd0K0MzNExmZ3QrQzM0TGZndCtDMzRiZmh0K0czNGJmaHQrRzM0YmZodCtHMzRiZmh0K0cwNGJUZ2RPQjA0SFRnZE9CMDRIVGdkM3QvaHZSM2UyK1h6WFQ3ZjVmTmRQdC9sYzExK3J5NmY3L0w5ZS93ZVBUN1g0M005L2w2UGY3Y2UvMjU5L242ZnY5Zm45K3Z6NzlDSDE0ZlhIL081ZjNtSi94UC9KNTVQUEo5NFB2RjY0dS9FMzRtL0UzOG4vazc4bmZnNzhYZmk3OFRmaWI4VGJ5WGVTcnlWZUN2eFZ1S3R4RnVKdHhKdkpkNUt2SlY0Sy9GVzRxM0VXNG0zRW04bDNrcThsWGdyOFZiaXJjUmJpYmNTYnlYZVNyeVZlQ3Z4VnVLdHhGdUp0eEp2SmQ1S3ZKVjRLL0ZXNHEzRVc0bTNFbThsM2txOGxYZ3I4VmJpcmNSYmliY1NieVhlU3J5VmVDdnhWdUt0eEZ1SnR4SnZKZDVLdkpWNEsvRlc0cTNFVzFtSFg0ZmZnTitBMzREZmdOK0EzNERmZ04rQTM0RGZnTitBMzREZmdOK0EzNERmZ04rRTM0VGZoTitFMzRTUGJ4UGZKcjVOZkp2NE52RnQ0dHZFdDRsdkU5OG12azE4bS9nMjhXM2kyOFMzaVc4VDN5YStUWHliK0RieGJlTGJ4TGVKYnhQZkpyNU5mSnY0TnZGdDR0dkV0NGx2RTk4bXZrMThtL2cyOFcyMjRiZmh0K0hqNGNURGlZY1REeWNlVGp5Y2VEanhjSGJnNCtQc3dNZkxpWmV6QTc4RHZ3Ty9BNzhEdndzZmp5Y2VUenllZUR5NzhMdnc4WHJpOWNUcjJZWGZoZCtGaisrekM3OExILzluRDM0UFBqMUllcEE5K0QzNFBmZzkrUFFpZS9EcFJ0S043TUh2d2UvQnB5ZlpoOStIMzRkUFo1TE9KSjFKT3BOMEpybGJrcnNsdVZ1Uy91U1kvbkMzSkhlTHVGdkUzU0x1Rm5HM2lMdEZkRXQwUzl3dDRtNFJkNHZvbWVpWjZKbTRXOFRkSXZvbTdoWnh0NGk3UlhSUGRFOTBUM1JQZEU5MFQzUlBkRTkwVDNSUGRFL2NMZUp1RVhlTHVGdkUzU0x1Rm5HM2lMdEYzQzNpYmhGM2k3aGJ4TjBpN2haeHQ0aTdSZHd0NG00UmQ0dTRXOFRkSXU0V2NiZUl1MFhjTGVKdUVYZUx1RnZFM1NMdUZuRzNpTHRGM0MyaS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLytyWC93SHVmOWQvQUFBQUFBQUIvLzhBQW5qYVkyQmdZR1FBZ2pPMmk4NkQ2QXZMakNkQjZTa0FTLzBHOUFBPVwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBUlRBQUJJQUFBQUNGc1FBQVljdEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQmxBQUFBQndBQUFBY1pRWUVNa2RFUlVZQUFBR3dBQUFBS2dBQUFDb0hCQXJvUjFCUFV3QUFBZHdBQUNjMkFBQk50dTBZRlRwSFUxVkNBQUFwRkFBQUFySUFBQVpNYkt0Q0pVOVRMeklBQUN2SUFBQUFWZ0FBQUdDNWN3RVdZMjFoY0FBQUxDQUFBQU1oQUFBRWRrRXFUamxqZG5RZ0FBQXZSQUFBQURBQUFBQXdHQjRDdm1ad1oyMEFBQzkwQUFBQlBBQUFBYnd2NWs2cloyRnpjQUFBTUxBQUFBQU1BQUFBREFBSUFCTm5iSGxtQUFBd3ZBQUF2clFBQVhlSWVWR1I1MmhsWVdRQUFPOXdBQUFBTVFBQUFEWUpadlNPYUdobFlRQUE3NlFBQUFBaEFBQUFKQXVkQ1pSb2JYUjRBQUR2eUFBQUNLb0FBQkJFRVdwOFFXeHZZMkVBQVBoMEFBQUgrUUFBQ0NRRGFtTVViV0Y0Y0FBQkFIQUFBQUFnQUFBQUlBWStBaE51WVcxbEFBRUFrQUFBQW9RQUFBVTA4YWIzSlhCdmMzUUFBUU1VQUFBUTB3QUFJNlpmZU9IZ2NISmxjQUFCRStnQUFBRFdBQUFCTTdWVVF6TUFBQUFCQUFBQUFOSUJKdG9BQUFBQXhQQVJMZ0FBQUFET0ZNd3BBQUVBQUFBTUFBQUFJZ0FBQUFJQUF3QUNBMllBQVFObkEyY0FBZ05vQkJBQUFRQUVBQUFBQWdBQUFBQjRuTTJjZTN4VnhibjNaMllsNUo2ZGhJdDRLU0EzTFdvRmFzdEZ2TFFIUGRMNktyVzBDZ2Q1cVorSzU2Zzk5RkNQUjYwM0ZNU3E5WTVTcTRBaXRtQlZWRlM4RUJDTVFuQkR3aVhjZG9Ba08ydnZuYXpzYTJKdHJabjNPMnRmc2hNaVlqL25qM2V0ejQ5WmE5WmFNL004ejIrZTU1blpVU0dGRUlWaXREaGZxTWtYWHpwTmxONzRpNXYrVTV3a2NxZ1hXZ3Z6UFB0YTNuRHR2UDhVK2ViS1JZNVFsRW9VZnUrSWtHUHZOdS9LVmRaTXptdXNkVlpsenVpY2lUbVg1c3pMdVQ5dkU2Yy9yeVYvdkxuS3VUUi9UdjVEQmFVRnQrVDVDMmNWTGloY1hWUmN0TFJvWTdFcUhsSThzZmpDa3V0TFp4Y1BLYjJ2OU1uU3VLZk1NNHAvUjF1VlhTZXR6a3VlYnJ0dWl3YnBrNTdjczZpWUZydk9pY216ZEhibWpOTkwzS29zVm1uUWN2STA3Y3dybnRnVDZmNjY1RW1lNlZHVXprNkQwWE1XM0dMTzlIak1XYmlncUxnMDdzckxhZm9zdU1VekQ0MVZKcVhKdWJTbzJHak80NWlhb3FWSjJmSmFyRXJ6dE94Vm83dnlKUVczRkJWWDNGZTR1dTh2OHpZVkZmZFRwZkYrK2YwcUJ1d2UrR3BwL01RbFJuc25QWDdTa2xNZVAyWExvQm1ESG1KRTZHcHdvY2RKanZ2VVV6aC9tTmR5NnI2OFRWYmwwS0dtdDJIOWN1WVZyaDV4aGVrckxVMytuSnlKQmJlY3VxOXd0YmtmYWI0NjViUTNUci9wMjJqejI3TkhUUnkxY1ZSMThVVFBxRkh0Wnd3eWZaNjV3R2pVTStwc2RmYWswWE5HenlrZU12cCtvL0ZSRzhjVW12dlMrS21uako1alZaYk9McHhWR2pjWTFjNzd6cWlOSHFkd3RXY1VQU2ZQVGFiZnBKN2MrazNKZjgyWnNkUzhwRFhORTFmZjlIL3FQbnBJd2JRNmFxTjVhdDZtaFFYbXpMYjE4YUEzRHZUa1E3YlZlNkowZHBLSFJwSXU1RnpxenBITU9lYWNNUmVQdVhITXpXTnVIL1B3bUhWanRvODVNaVkrZHVEWVFXUFBHWHYrMkYrT3ZZMlpOa01VaWY1aWd1Z25Kb29LTVVrTUVNdkVBUGw5VVNISFUwNEVONEo3d1AxaWdCb20rcWtSWUNiWHM4REhva0p0QWRXaXdob2tCbGhEd0ZBd25IYWtxTkJEeENsaXFONHNydFFSTVVNZmxoZnBzTHhYTjh1RnVsWXVFZVh5ZWIxRmJoWjk1VUZkSldPNldsMnVsNms1K2lmcU92MWJkVDMzTitoNmRaK09xemYwZjZ1MTNIK2dMMWZyOVVQV1hGMXZMZElkMWlQZ0NmMko5YVNPV1l1MTExcWlQeEpLblNpS2VOUEdheFR6NzRXNlhjeldFZHBxRXdYaWZrWnh1MDdJdTNWVUx0RXRjalAzQi9VUjNqOWl6ZGR0MXRPNlErU0tLVHJNZUZ2b3A0MTJvN1FiRmR1RlJ3OFE1V0M0cmhKbmRYNHV4cUcxeWZxUXVGaTNpbjhGbDRBZmdTdkFOUEF6ZXI5S3Q0anBPaWhtZ252NDdsNndBQ3dFOTRGRjRBWGFXQUZlQkN2QlMrQlBZQlZ0ckFZdmc3K0FWOEJhOEJaNEc3d0Qxb0gzNmVNRHNCNVVnZzMwOVNIWVJOdWJhZWNqeWlyS2p5ay9vZHpLTjl1QUYrd0F0V0FQMkF2Mmc0T2dIaHdHRGFBSk5JUFBPaitYSHQwcXkwRmYwQjhNRi8za1NIQUd1andMbkEzR2dPK0M3NEVKT2lnbjg5N0ZYRitDbGFmb1EzSXE3OC9oZWk2WUIyNEZ2K09kMy9QT3c1U1A4czB6NEZtdWw0SGw0QVdlL1JtZ0U3bWE4blhhZUlmeHZFZTVnZTlyS1EvVHRwL25iU0FLNHJTUm9OUzZWUWxnZ1JJZFZQMTFsUnJLOVhDdVI0TFR1VDRUakFhWHdlNHJLYWVER1Z4ZnpmTnJLTy9rbTd2MElYVTM1WHpLaFR4ZkJCaTNXZ3llQm44QXovSCtNdkE4ZUkzN05lQjE4RDdBSGdwN3FFOHB2WlRiS1hkUTFsRFdVdTZrM0VXNW0zSVBaUjNsWHNwOWxQc3BEMUFlcFBSUjFsTWVva1JtZFlTeWdiS1Jzb2tTVzZrQUNJRldnRDVVQk1RQStsQi9BMStBTHdHNnNTUkFOMVl1eUFNRm9BaVVBT3h0bFRNVCtvTCs0QVJ3SWpnWmZBc00xa0hyVkRBTWpBQVQ5QURyUFBBRDhFTXdYMjhVK2N6eC9ySko5R2R1KzVuYnpjeHRQM082aVRuZHlNenpDOGw3cmFJdmMrNUQvRU1WZm1HdFBLTDM0aFBlVldYNkRUVks3MVRmMFZ2d0Q4djV2Z3FmNEZkdjZrL1ZXMkM5M3FZcWRjUzZsOTRYYVJ1ZkVMQWUxUUg4Mmd6OUlqUDRNV3UrNk12VEJFOWpQSTN6TkliWE9CZXZjWURaUFkzWmZRR2U0VXBSaW5kWUpoL1RIWGlHUTNJcGZtcXovck5zd3UrOHFwc1k0Y2RpaUJpbjk0Z0pqSGlpZHNRa1hTK1c2WG81WE8rUkk4SDN0U1BIY3o4UlRPWCtSc3A3d1AzZ2RlN2ZBN1Y2anhyRzZFZUF5N2llQVdiaTVXYUJhN2orV0R0cUM2aldqalVJTHpjRURBWER3WHhHZUJJaldNTUkydWk5aHQ1cjZIME52YStoNXhwNnJxSG5OZlJjUTg4MTlGeER6MnZvZVEwOXI2SG5ObnB1bytjMTlMeUdubXZvdVlhZTE5QmJEYjNWMEZzTnZkVVFFMzZtMzBLSG40aGZkYTRUZCtqVDBjNy9FWC9XRDR2MzlQTlk2VlUwdFZVK3J1K1VUK25yNUhONkVScTdGc3N0bFN2MDlmSkZ2VXF1MUwrUkwrbFphSEdsUENnOFdOUXZHL1J5TkhxVHRQWGRXUGNOK1hkOWgvd0gxNTM2VmxXcTc4RGFkMkh0SlZqN2dEcFB6MWNYY1AxajZpL1hiNnFmdWRhL0hmWThnemUvRVJiWVdPWUdtUEE0VEhoRnZVdlUrRUI0WU1Sak1DS083V05ZN1RWcy95NjJmeGZidjR2dDM3VWUxeDlnL3hpKzNrU0VZcno0aGFJY2FSdkZiSmd5WDYvbGkvMThzWjh2OXZQRmZ2Y3REMjhWODFZcmI1WHkxamJlQ3ZGV0lNTzRnV2hsTjFxSnlzVzZMUlhmanFDTkFKcG9SaE5oNWtFRldnZ2grVjRrMm9zMHU1Q21EbWtNcHdQcURWR2kxb3BpSktoekplamVRMGdNRndXTTBveTRSTzlnUEJWRXFoYkd0SThJMjJKR0wzNmxYOFZXWG15MUhGdDlpSzAyTXFvYStRZys4ekZHOExqK1dENGhTaGhoQ0x2VlliY2dkbnVQa1lZWTZUYnNGbVMwQnhqdEo5YUZlaGM2VENEcnk0ekV5MGkyTVpKdGpHUWIra3VndndnNSt3eGt1NWN2VjJvL0RDM2h6VGJlYk9WTmh6Y2RVU2JPSXBxT0IzOEV6NExud0ZMd0dlTVpCYzRFM3dHandWaHdEbmhIaDYweVVNRjdlZWdyQ2pOaXNDS0IzbUpZUElIRlEraHBsK2pEMkZ2Y2NUZnhuZkZ4bHpOLzF0T3o1SzVEL0loNFhzWnFwQ3hsNlFyaWRaQjRIU1JlQjRuWFFXSjEwTlhkS3NyVjRHWHdGL0FLMkFxMkFTL1lBV3JCSHJBWDdBY0hRVDA0REJwQUUyaG1MUDNkdUJlVTAwUVpzUzFJWEFzU3k0TEVzaUF4S2toOE1yRXBTR3dLRXB1Q3hDWVRoNExFb1NCeEtFZ01DaEtEZ3NTWklIRW1TSndKRW1OTVRBa1NVNExFbENBeEpZaXZEK0xyZy9qNklMNCtpSzhQNHV1RCtQb2d2ajZJUHcvaXo0UDQ4eUMrUEdpTkUyWFdlREFSbkFzbWdjbmdJdlJ6SHBweDBJeURaaHcwNDZBWkI2MDRhTVZCS3c1YWNkQ0tnMVljdE9LZ0ZRZXRPR2pGUVNzT1duSFFpb05XSExUaW9CVUhyVGhveFVFckRscHgwSXFEUmh3MDRxQVJCNDA0YU1SQkl3NGFjZENJZzBZY05PS2dFUWVOT0dqRVFTTU9HbkhRaUlOR0hEVGlvQkVIalRob3hFRWpEaHB4MElpRFJodzA0cUFSQjQwNGFNUkJJdzRhY2RDSWcwWWNOT0tnRVVjVXBQalRBbi9Xd1pnV21CYUZhVEY0MUFyVE9sd3VXV0lLSHVCS0lzQU1mTVVKNUhnT3VaaERMdWFRaXpua1lnNjVtRU4rNUpBZk9lUkhEdm1MUTc3aVNET0NvV0F4K0FQNEcvZ0NmQW1RbHZqckVIOGQ0cTlEekhWRUhuMlZ1SEhvT1ZIRTdHeVJ6NHRpUnJjRnp4Z1RmY2hERjVDSExpRFdMaURXTGlEV0xpRFdMaERTZlc3bW04TjhjNWh2RHZQTlliNDV6RGVIK2VZdzN4em1tOE44YzVodkR2UE5ZYjQ1ekRlSCtlWXczeHd4U09UcXVDZ0UwM1dDekRWQlJwa2dvMHlRelNYa05CMG5RMHVRb1NYTS9DTExTcEJWSmNpbUVtUlRDVEttQkZsUWdpd29RUmFVSUVOSWtDRWt5QkFTWkFnSmF4eCtiVHlZQ000Rms4QmtjQkg5amNhWC9RcVA4cEQ0MVpjYnhCMmRkNGo3T3ovQWo1MkJIL3N4WHVZWGFPVVJmSmhIUHRVWnhIY05sa3M3bTdIZnhYSkZaeHMybkM1WGRuNHBYK3JjVDh5NWdwaVRpN2RkVDh5WklwczZPNGs1ZlJueHZ4TnpTb2s1ZllrNWVjU2NVdXhkanVZbVlmTy9FSFA2RTNNbUVYTktzZi8xeEp3cGVPbGl2UFFGNm9iT0dGNTZvM3ExTXdJdnh1Q0IvaTh4cDVDWWt3dEhSdU94OTdDS1FnZGlGQmdMemdHL0EwK0N4ZUFwOERSWUF0Q2YyQUtxd2FkZ096Z0Vqb0JHNEVlL3BhQU1WSUIrNEYvQXBlQUdjRE80QXl5QksvaEQ2UVUxNk53RDBMYzZEWHdibkFIT0FtZURuNE9yQU9OUmpFVXhEdlVlK0J6OEhmd0RkR0lqQVJUSUFYMUFQaWdFeFlBeFdVYkdjNUhVUmxJYlNXMGt0WkhVUmxJYlNXMGt0WkhVUmxJYlNXMGt0WkhVUmxJYlNXMGt0WkhVUmxJYlNXMGt0WkhVUmxJYlNXMGt0WkhVUmxJYlNXMGt0YkgvSnFRdFExb2JhVzJrdFpIV1Jsb2JhVzJrdFpIV1Jsb2JhVzJrdFpIV1Jsb2JhVzJrdFpIV1Jsb2JhVzJrdFpIV1Jsb2JhVzJrdFpIV1Jsb2JhVzJrdFpIV3RveWM0MWoxK2NXNWVpZDUxeTVXY241V2NuNVdjbjVXY241V2NuNVdjbjd5c1Yyc3V2eXN1UHlzdHZ6a1pMdkl5WGF4OHZHejR2R1RsKzFpMWVObjFlTm4xZU1uUjlzbEYraWQ1R203eURrYldjbjRaUlgzdThsMys1TWhUcWFjU1k0d0M4em1laTY0ay9xN3dRTmNyd2IweDRyQ3oyckN6MHJDenlyQ3p3ckN6K3JCejhyQno2ckJ6NHJCejJyQnowckJ6eXJCVDY2M2kxeHZGN25lTG5LOVhlSTBmTW9nZk1vZ3BQUWluUmZwdkVqblJUb3Ywbm1Sem90a1hpVHpJcGtYaWJ4STVFVWFMOUo0a2NhTHA0b2pnWmVSZXhtbGwxRjZHWjJYMFhrWm5aZlJlUm1kbDlGNUdaMlgwWGtablpmUmVSbWRsOUY1R1owWHZ6WUl2ellJdnpZSXZ6YUlPTDZFekZjeHo4MGNkOFFhNHBTUE9PVWpUdm1JVXo0eEZUNytCRnloNjhSUEthZFJkeFhaK1hUZGdQOXFJSWI1aUdFK1lwaVBHT1lqaHZrRWN3WVBYb2NIcjhPRDErSEI2L0RnZGF5bTYxbE4xN09hcm1jMVhZL3ZhOEQzTlJEemZNUThIekhQUjh6ekVmTjh4RHdmTWM5SHpQTVI4M3pFUEI4eHowZk04eEh6Zk1ROG4yVCtTT2FQWlA3SUl1QWg2eW9IZlVGL25wL0I2dUFzY0RZWUE3NEx2Z2NtNkFaaXBZK1ZjejN4MGljZjVOdmZjLzB3MTQveUxKbk4yWks1VERiWFNqWVh3aWMzeUQrU2Z6N3JabllCNHF1UCtPcERjMDJzb092SjhMYVRwKzBtdXp2SWFycWU2RlRIYXJwZTRtK0l3VDRab0F5Q0VHZ0ZEbWpqblRCbEJFUjVKMDRmQ2NvTzd2OEs4QjN5Qy9BbDBOcEg3UFlwZkFmeDI2Y0tLSkZaRmJzeG9vRW9XRWVjYUNCT05CRGJmY1IySDdIZHA0Z3JhZ3JBaGdyN0VldDl4SG9mc2FSQjRlZlVMZUIyc0pDNlJRQjlxTWU0SndzbHF0YVJCL2lJckhYRW5RYmlUZ054cDBHdDVObWZ3Q3J3R3MvWGdOZkIrNkNLT214RG51QWpUL0NSSi9qSUUzemtDVDd5QkI5NWdvOG9YVWVVcmlOSzF4R2w2NGpTZFVUcE9xSjBIVG1Fanh6Q1J3N2hJMkxYa1VmNFdDWFhzMHF1WjVWY3p5cTVubFZ5UGF2a2VsYko5Y1RBQm1KZ0F6R3dnUmpZSUc0bXdoNGd3aDZBeVZHWUhJWEpVWmdjaGJsUm1CdUJ1VDZZNjRPNVVaZ2JoYmxSbUJ1RnVWRVlHb0doRVJnYWdhRVJHT3FEb1Q0WUdvV2hVUmdhaGFGUkdCcUZvVkVZR29XaFVSZ2FoYUZSR0JxRm9WRVlHb1doVVZnWWhZVVJXQmlCaFJGWUdJR0ZFVmdZZ1lVK1dCaUZoUkVpL3dHWUdJV0ZFVmdZaFlVK21PY3dPejB3endmaldtQmNGTVpGWVp3UHhrWGMxYytmS1ZjRFAvVlJFT2RaZ2xLVFp3bGdnUkkwUGh5TUJLZHpmeVlZRGE0RTA4SFYxQytrWEFRWUF4YVBZbTBmMXZaaGJSOFdqbUxoS0JhT1l1RW8xbzFpM1NqV2pXTGRLTmFOWXQyb01pc0orc2FDVVN3WXhZSlJyQmZGZWhHc0Y4RjZFYXdYd1hvUnJCZkJlaEdzNThONlBxem53M28rTXBnRFpEQUh5R0FPa01FY0lJTTVRQVp6Z0F6bUFQRS9sNVZYSVpqQ2V1MHE4ckhwdWdwTFZtRzFHRmFMWWJVWVZvdGh0U3FzVm9YbVkyZytodVpqYUQ2RzVtTm9Qb2JtcTlCNkRLMHZSK014dEYyRnRzTnVCSHlHYTdJNnRGeUpsbU40eFFOb09ZYVdZMmkzQ20xV29jMHF0Rm1GNXFyUVZCV2Fxa0pUVlVnYVE5SVlrc2FRTklha01TU05JV2tNU2F1UXRBcEpxNUMwQ2ttWEkrbHlKRjJPcE11UmREbVNMa2ZTNWVKOHVCdUF1d0c0RzRDN0FiZ2JnSzhCK0JxQXJ3SDRHb0N2QVhnWmdKY0JlQm1BbHdGNEdZQ1hBWGdaZ0pjQmVCbUFsd0Y0R1lDWEFYZ1pnSmNCZUJtQWV3RTRGNEJ2QVpkbnl5aVhBeitJZ2dUUXJKd0ZzTURwNEV3d0dsd0pwb09GZ0ZVMHZBbkFtd0JjQ2NDVkFGd0p3SlVBWEFuQWxRQmNDY0NWQUZ3SndKVUFYQW5BbFFCY0NjQ1ZBRndKd0pVQThlaDVVU1R1WkYxWnpMcXl1TnQ2Y2dyM1prMTVCZXR4czY2Y3pwc3pRVzlyeTdXODh4WjRHN3dEMXBtOVc5NzlFUHl6NjA0UGM3QWM5QVZtRFRxQkZVUnlIVnFjV1ljK1N0MWp4TkpuS0ovbFBiUEtTSzlOelVwakZYVm1qZHBHYWRhcGNaNzNYS3VXaUNLOGVZc2FUamtTOUxaMnZacjY3UFhyWXQ0M2E5Zy9VTktuV2diUTVEZGQwK0taVy9ETUxYam1Ganh6QzU2NUJjL2NnbWR1NmJiZUxlSGVySGtIaXlMclZEQU1qQURqUkRGcjRHTFd3TVdzZ1l0WkF4ZXpCaTVtRFZ4c3pkY2JySHQxMkdLRmFUMmkyOHdPaHZXNCtaVkJsRnFMUllsRnRzMzViN3BOWEkwR0o0SHp3WVZ1WnRJZ215bmJkWnU2Q1B3Qy9CbzhDRjdtL1YvQ2x5TDRVdFR0OTRJcDNDZC9Nd2k1dnhuMHZ1Y2ZnaWNoZUJLQ0p5RjRFdnBuOS9EaFJ3aCtoT0JIeU4yL04zdnowN0N2Mlg4M2UrL0pyQ0lPTDBLWnZmY1Z4c013OTE3Q2g2K2lQcm5ISG5MMzJIdnVydy9Wb1c3NzZlbTk5Tzc3NWFIVWZubm9xRDN5cjkrN0RtSDdFTFlQWWZzUXRnOWgreEMyRC9YWXV3NjVlOWZqc1BkNE1CR2NDeWFCeWVBaTlGNk1IZVBZTVk0ZDQ5Z3hqaDNqMkRDT0RlUFlNSTRONDlnd2pnM2oyREF1QnVQTjI5MnZabEplN2E2TTIvSGk3WGpyZGxwSjBFcUNWaEo0NjNhOGRMdmJXcHpTdEZpaTIvSEs3WGpsZHJmMXF5bXplM2lPKzJYZ2VVQnZlT04ydkhFNzNyZ2RiOXd1RmhCYnFva3QxV0ljNjVBSmVqZnJrWFozUFRKVjE1TC8xcEw3MWpKQ214RkdHS0h0cmtmZXBHNEQxeCtTSy9iUnRlU2l0ZVNpdGVTaXRYSTRhNDJSd0t4VEp2RGNyRldtY2o5TlY3dHJsZVQ2cE4xZG56ekkrNCs2K1dZdGt0bnlkZDU3RDZ5SDgxVzhVOHYxVHE1M2MxM0hYRGhJbnRuSXU4MndKa0FaQkNIUUNod1FCaEVRMDF2UmtJMkdJdVNVdGVTVXRlU1V0ZVNVdGVTVXRlU1N0ZVNSdGVTUnRlU1J0V2pSWnNYZXJJYnAzV2pUVmlNb1dhR3hlbThpajZ4bHpXUzBHeUdmckZXWHNUNjZYSDlFWGxsTFhsbXJacVRXVTFmemZuSk5aU3dRVWRkUS8wdHl4amxnTG5XL3B1NW0zcjhGM0VyZDdaUVBVUDhnOVk5eC9RUjRsbm45SE8wc3BWeEd1Wnp5ZWNvWDNOeXpsdHl6bHR5emxqV2FzV1pFdmNFNHpXN1NXcUxLQi9TM1htOGxENjExMTJLRFdXV2E5UmdyV1hkTk5veVNkUmxXdDRuQjFjVGdhbUp3TlRHNG1oaGNUUXl1SmdaWGl3SzB2QmtON2tESzdZdytvSzdYaCttcGxsNGNlbGxPTDdWaUJIeXBoQmVHRXlaYmpNQ0ZDTGF2eFBhVjJEMkN6U3V4YlFTN1JyQnJKWGF0eEo2VnRMNlYxZzlqbndoNmo2RDNOblFlUWQ4UjlOMktmaXZwK1RCNnJVU25SbytWakNDRVhpTG9KSUkrSXFrZHRDUElHRUcrQ0xKRmtDc2lLdVJtL2FvOFNObWdqOGdtL1lxMFdXbjhuZDQ2MFU2cFBxSkdJZE41dWw1ZG9CdlZqN24vR2JpTzFtL1FCOVNyZXIxNmw1NC9FT1ZpRXZMWnpJY0E4eUhPZkFqQS81Z3dtUUw4UUVZYmZnZmdkZ0E1YlhnZGdOY0JlQjJIMXdIa3RaSFhoc2RoZUJ4SGJoc2VoK0Z4SEI0SDBZRU5oMlBvb1FhT3h1QmRBTTRGNEpueEVURjBZTHZhbjBFNWsvcFpZTGJyTzJMb3c0WlhRU3dUaEZkbXBzZmdVeEF1bVJrZmcwTmgrQk9HTzJGNEU0UXJ4cy9Fc0dBQUM3YVpYN0hSWFEwY0NjQ1BBTndJd0l1QWVFUU1GMlZpSkRGL0ZCZ0x6Z0hqOUJHMGNBUU5IQmIzOFB4ZXNBQXNCUGVCUllBNExKNEVpOEZUZ0hnc2xvQm53REsrMjhRN0g0R1B3UmJxcXNHbllEczRCSTZBUm1EeWcxSlFCaXBBUHpBY080NEU0N0hoUlBBdjFGMUN0bm9wNVZUcTUzQjlBOWMzOG13dTEvUEF6ZHpmU25rSDVUM1VtOS9uWCtmZE43bGZSLzE3WEcrZzNDejZ5V3BLOGlGWkEycXBUM29adUNQNnloYWVmUVkvOGtXWjhwamZlQ2xQcFJ4RzNRaHdHdGZmQm1lQXM4RFo0RExxZjA1NUZaakI5VXo0TkF0Y3c3WHhCdGRTR285d0hlVU5sTCtoelp1QThRaTNVWGNuMTNlRCsrQWtPbFhvVTZGTDF3T3M0UGtidExWV0gxSnY4ODU3MUgvQWZTVVczc2o5aHdCZHEwL0JkbEFEZG9MZG9BN3NBd2VBRHh3Q1IwQWorSngyL2c3K0FUckpiY2pITEFWeVFCK1FEd3BCTWNBK01PY3d6RGtNY3c3RG5NT1c0Y3hZY1JMelpCeHpoS2lWaWlGUllWWnV3K0g1U0RDZTY0bGdLdGMzVXQ0RGtuRWdpblZpY3AzdXdESXg1a3pDOWYzVjNOZHl2NU43NC84UHV2T2tIYzIzdS83NE11NW5nSm1zdm1ZQjQzZXY0ZDc0MnQvZ0g0eHZmWlkxK1ZLd0hCaWYrUWFhV2d2ZTV2a0hSbXRrWVlOWXFRMEJROEZ3eG53dDg4Q1RtdjIyT0ZlVUlva045ejF3M3dQM1BYRGZBL2M5Y04rRGhEYjg5c0J2RC96MlpIa0hFL2xzdU9weFBjUWN5aHNwNTFMT0E3ZUNlN2hmSUVyUmdPMTZqSFZjdTE2RDNHa0R6ODFmc1ZSUlZ3MWNEMEw5YnE3cmRMUHJRWHhvcFFsZjE4SzdyQ3ZnYWhDdWV1Q3BCMDJaS0dhcnlhSTA1VTBDS1c5aW9wU3RabE9mOUNUTmNOSjRrMlk0aVVlaC9qZmdKdHE0bGJyYnFMdVQ2N3ZCQTlRL1MyNjlGQ3dITC9COGhmRXcxTDlCVzJ2QjIxd25QVXdBVHBiQ1NRK2M5TUJKRDV6MHdFa1BuUFRBU1ErYzlNQkpENXowd0VrUG5QVEFTUStjOUdBVkU3MU01REpSeXhhanNVZ1R2R3JHR21aUDFJK21tOUIwRTVyMm8yay9XbTVDdzJiLzB3K3ZtdEdxSDYwMndhdG10Tm9FcjBKRWgwYTQxUXkzbXRGb0U5d0t3YTFtMlVMV253OG1JOUZseFB3WllLYjJveWsvdkdwR1UwM3dxaGxlTmF1YmVPOEJTckpadUJXQ1d5RzQxUXlubXMzZkhjQ3BadlVocTRSQjJvOEVmaVR3VzJhZmR4Z1NOQ0tCR1hrakkyOWt4STJNMUl5eWtWSDZHV1ZqYXBRTmpOTFBLUDJNc2pFMVNqL3h6TTlJV3hscEt5TTF2L1UzTXRKR1J1aG5oSTJNME04SS9ZeXdsUkg2ZTR6UXp3ak42UHlNcmxXY3dHaGEwV1VDWFNZWVVTc2pha1dYQ1hTWllHU3Q2REtCTGhQb01jRUlXeGxkSzZNeDhibVZYbHZSVHdMOUpPaTVGVmtUeUpwQTFnU3lKc1QzeVI0alpJOFJzc2NJa1ROS3hoZ2hVNHlRS1ViSUZDTmtpaEd5dndpWlg0U01MdUwrem1yMmpRSmNCMEVJdEFJSGhFRUV4SGlublhjNnVQNHIrQng4QWI0a0kxQ2dBTkF1R1ozSkt0cmQzOXZJUklpb1VUSzNDSE1nUXRZV0lXdUxFRW1qUk00b0dWbUVqQ3hDTmhZaGVrYkp4Q0prWWhHeXJRalpWb1JzSzBMMGpNTG5DSmxWUkp5YTlUdFdCN2xQQjdsUEI3bFBCemxQUitwM3JBNXluZzVHMjA2TzAwR08wOEZvT3NoeE9zaHhPaGhGQjNsTkIvbE1CL2xNQi9tTXlXVTZ5R1U2eUdVNnlHVTZ5R1U2anZtYmxrSmZXOGxsd3FJUUQ5Q1B2dHFZL1czeWI3RGdjbUw4dGVBNmNCdFlBY2luV1NYbU10SkNkNVNtOVE1YTc2RDFEbHJ2b1BVT1d1K2c5UTR4L2FnZHhPUmZuMFY3M1RuczdhL0gvdGxkdys1L0NSWjFkd25ON3VERDd2NXphMlluMFB6Rmx0bjVTLzVWVnZTb25UL3psMWhteDIrVXUycnN2dXVYdmVPWC9DdXJxUHRYVnQ5d3QrOXIvdUtwYXljdytSZFBVZXRleWtXc0lCK2hmQlFkTFdQdFhvSlZTZ1JTb3ZFd0dnK2o4YkQ1cFJhdGg5MWZIcVpScHZkN1h1QzlGZUJGc0JLOEJQN2tXaVdNVmNKWUpZeFZ3bGdsM091dkVPbDlvTTE4VXdVK0FWdDVkeHZ3Z2gyZ0Z1d0JlOEYrY0JEVWc4T2dBVEJQc1ZTNHh5OE80ZFNlVUZoT3dSTFRSQWxXQzJPMXNMc3ZsTndUcXNONllhd1hkbjhod1BKd2VEVldET1BUWG5OL0VZaHluZHdYQ21QTk1OWU1ZODB3L3U2MTFONVFYZGJlVUJqck5tTGRzUHFPS01iQ1lTd2N4c0poZDQvb0pyNjVDeXZOZHkwZXh1SmhMQjVPN2V5SGt6djczZmFMd2xnL2pQWEQ2azN1M3dMdmMvMGg3YUF2QlpNVlRGWXdXZTBDc0ZuQlpnV2JGV3hXc0ZraGs0TE5xc2xsVHhqMmhHRlBHUGFFWVU4WTlvUmhUeGoyaEwvbWw0QXc3QW5Ebm5EcWw0QndML3ROSmRaNE1CR2NDeWFCeWVBaWNEejdUYVd1M3pBWkxuekdkMFJsSjFvMG1lN2xqUDVhY0IxUjNHU210M0c5d3ZXQVVaTmhpaCtKaTBXeCtGZHdpZG1YQk5QQUtyQWF2QXorQWw0Qlc4RTI0QVU3UUMzWUEvYUMvZUFncUFlSFFRTm9BczJpV1BZSGs4M2VJbmdZTEFQTHpWOHJpSW5TVDlraUJzb29aWXdJbnFEOFRQOVZha1l2Z09WS01WQ2RUbm1tNFFXNEhKNWNTVGtkWEt2L2ltUk5TRFlReWY2cUZsSzNDTkNYZWhxc29PNDF5alhnZGZDKys1ZFRUVWcrVURFMkZRQWgwQXJhUUFURUFPT3c4a0FCS0FJZVpNbG5oTy9oKzNjUWlRNHlpcW4wL0J4cjE2aDZpOXh6dmI1VURFbnQvVVRkdlovc2ZaLzBYazhUOGMxNHhoYWljSExQSjhwOFNQVFk5NG1tOW4yU01lMG1uai9vL3BhUnZmZUQ5ZHkvbk9pKy8yT2lRaDFSb1k2b1VFZFVxQ01xMUJFVjZvZ0tkVVNGT3FKQ0hWR2hUdVJrL1JWVzBvTVZXSFAxUG1yajFNWlRmd1VadDU3UUc2MG5ZZHhpL1ltMVJHOFFpcmM2dUF1N2Y1RzUwMjJudXljczVJMDkxbnhSenBNb1Q4SThpZkFrU2x2dnA5cDZoN2JXaWx4YVNGQWJwc2I4cloxRGJRc3R6blgvK2pKRWJTczF6VzZOK1N2dXVQdmVFdm91T0s1WllVWVljWHY1SkNWWGxIZWpaaXpJTVYvN3pOdEdibmVXYmV5cEVaNTZhS3VNdHNwTUsvQWdLVkZYSzZhSFBVTEtWWGgvczI5YndXcGpoQmdwVGhPbmkyK0xNOFNaNGl6eEhYRTIrZTRZMWxUZkZlZUk3NGx4WXJ5WUlDYXlGcGtremhQbmk4bmlJdWJlRkhHWnVFTDhWUHhNWEVtRW1DSCtqUmd4aTNYS3ZheFJGckkrV1NSK0p4NFFENHFIeE8vRnc2enVIeFdQaWNmRkUrSkpzVmc4Slo0V1M4UWZ4YlBpT2JHVVNQU0NXQ0ZlRkN2RlMrSlB6T0tYbWNHdmlMWGlMZkcyZUVlc0kyNXNKRzVzRXB0WjVWU3h5dmxFYkJIVjRsT3hYZFNJbldJM2M3cU9PYjJQT1gyQU9lMWpUdHVpUlRnaUxLSWlMajRUbjRzdnhKZENTeWx6Wlo0c2tLWFNJOHRrdWF5UWZlVUo4a1I1c2h3dVI4clQ1U2g1cHZ5T0hDM0h5blBrOStWNE9VRk9sT2ZLOCtRRjhoSTVSVTZWUDVYVDVCejU3L0kvNVBYeUJubWpuQ3QvTGY5THpwTy9rVGZKLzVZM3kvK1J0OGhiNVczeXQvSjJlWWU4Uzk0dDU4dDc1TDF5Z1Z3b0Y4bjc1Y1B5VWZtWWZFSStKWmZJWitRZjViTnlxVnd1bjVjcjVJdHlwWHhKcnBLdnlUWHlkZm1HZkV1K0xkK1I2K1M3OGozNXZsd3ZLK1VHdVZGK0tEZkp6ZklqV1NVL2xwL0lyYkphYnBPZlNxL2NJV3RrcmR3cGQ4czljcS9jSi9mTGc5SW42K1VoZVZnZWtRMnlVVFpKdjJ5V3RnekpOa2tlSytNeUlkdGxoL3hjL2sxK0lmOGh2NVJhQ2FXVXBmSlZnU3BSNWFwQzlWZEQxVEExWEkxUUk5Vm9kWjQ2WDEyZ0xsU1QxVVhxRXZVamRhbTZURTFWVjZrWmFxYTZXczFTczlVdjFIK3F1ZXJYNm4vVWI5VWQ2azUxbDdwYnpWY0wxRUsxU1AxT1BhQWVWRStxeGVvUDZvL3FXZldjV3FxV3FlWHFlZldpV3FsV3FkWHFaYlZKYlZZZnFZL1ZGbFd0UGxWZXRWM3RVRFdxVnUxVXU5UnV0VWZWcWIxcW45cXZEcWlEeXFmcTFTRjFXQjFSRGFwUk5TbS9hbGEyQ3FpZ0Nxa1cxYW9jMWFhSWQ0cHNTY1ZWUXJXcno5VG42bS9xNytvTDlRLzFwZXBVMmhLV3RKUmxXVGxXcmxWaWxWa1YxaUJyc0RYRU90VWFhZzJ6aGxzanJKSFdPR3U4TmRFNjE1cGtUYll1c3VaYWQxdjNXZ3V0QjZ3SHJZZXRSNnhIcmNldEo2d25yY1hXMDlZUzZ4Mmgrcm4vVlZmZUF5V2ZrNmQvU3dpOVdOK3Z0K3NxN2VqTmVvMzRCb2YrK1RkNXU5dVg5MmV1MmtHSHZrdEg5Q3I5dm42QjYrMUVoWEs5VlZUb1I0NmpwV1lRQkZ0NzFDZSs5c3VtYnpEZTFxUDZiQUY3VXZjTm1TZlA2QllkT3VycnRpUTQrbVhxSXF6WGozMVU5RFphMXNqSm81eXJjak1TYzkyanY1YXZhZm1ZaDdaMXlKV3dJYXN1cFBkbHJsZGtyalptcm00V2ZiUGUzdERacHF2MVQvUi82WEs5Vy8vMmEvcTdHWnNuZXJXWUoybFh2ZC9jZEg2Z0c0ek85UGpNbDYvclIvUnorZ253RU5vb282cU1iOHIwODNxZC9raHY0NDA3OWUzOE85SjllNkF1MDFIOXBudjlsdDZwZDFQdTdONnY5ck95eXg3YllQZmZnMWsxZS9SaG81bVVka296OVcwOXBGcm8vdnRSajFvN3lTVWQ2UHBhdDdwdEdSdVc2OXJNbXp1enZucEJ2Nk0zNkgzZ1kzaFFycGZEalhMbXgzN21iR1BXZTJjUm5ZWCtWTFA2UzdHd0pOVmZhN0x2cnRHbW1QTVZoMTUvakdleFkzNTVqRm1GbmQxdldadjMwbVozelgrVDQrajJzcDRkMHcrUWEveXpmVHJIZUJaTHRudDA2NjRmS1hPdjJucHRvL3VjWDlqanFjZHRPM0VzRytpOTdyK0x2MnJNeHhyM1Z4OUdrbSt1SzMyK1BsTlAxdDhGcDhHb1BLcnl5T2p5OUkvMVBIMmZmcHczUExxWW1YMmJlYnZ6R3U1cjlmWFpmaVY1ZE1JTXZRVzhrbXEzSXpsL1hGWm5ScFdNQUhxbGZreXZ4dyt2WjRhSE12cE1sYm9hdkcvbVJ1ZXYzUHZmOVJqeE1UWFU1UU83MWQ1NkRBM1VaNjcyOTNqU0lTUjU4RG1wLys3NmVBNGxMQ0ozcnVqajN1Vng1b3NDOHVNOFY2dEZxYmRZVVptVnEvR0RQZUpDQlQ3YXhKLys3dDJBVFAwQXpoTmMvejB3VlhNaU9JbC9UejZ1Y1IzZjJMdE84MStnOTBtZGVha3oxMFg2TkVkKzZpeExqYjNyTkZHMGYrcnNPb3dNNlRQN09CSEpUcVRYaWd4eStENGJwaitEUHJUWEV6MlB2SlRlOG5wQmN0UUNtNWlqc0FmU1g2ZVJiQ2VYMGFhUlBBWm1vZnRSbklYOHI0Q0pLR1hJYTJ4L2NnWTliZEhOeTdqdEhlOWhyTmNuWmJHeVZJMGxUdUhmUHZTVXRHTUJkM211Um94V2k5d2V6THVlbEE2UzMzWHg3OFJVMlZXVHJETWF5Y29xc281c0MvZHg1OE1wcWJiTm5QaVd5V3BkS3d6aTNvelljcC8zY1VlUTV6NUxzODZNTDRmeERYTEhsN2JrdDFJd1IxSlhKZy9vejV3NGVoekpPV1ZZMXZWMGlJdmsySk1zSFp6MTFSRDNlYmJrMzByVnFGNmxUZlpVd3RzbG1TK083K2lMM0lOVHVqSHlKVWRZMEFONVBiNHljOEp3SXNtanJ1KzZqaTVMNVIzMU5DK3J6TXZNT1hNazUxTVNSN2Nwc3VaQVVxK0Q2RDhOYzV5UzBlTGdYcjgvMW1IR1lHYWRtUjlwWlB1RTQwRnYvaUViYWZaa3orbWU2SDRrNzlOenQ3Y2phWU11NUI2WHRQS28wcHk1MWcreUlrM1gxUURhelo1N1gzMm9ySkVteXk0cnBLVTQyWTFKNW0rOERHZTdlekZMR0hibHVQOEhrcHlzK2x3M3F1VzZkVWFEcGU1TVBjV05ZVjkvSE4rYzZCNkJldGQzZnVZMDE0V3BzeVExOXE0ekxVVk9EeW42WkU3aFNwRThqU3dlMTArbWtjOTMyZWpTUnM1Uk9QcmRZeDlmTnk5eU0wakgyVDVaNk43K3lWZ2pHMm1QWVk1Q0pPc054bk9VSUsreGZWa0d5WjV5UkhybVdha2FrV25YSE1lVEIzWDV5UHlVWlZUbTM0RWliVm1WZVNkOW1IZFB5RnpucExSUTZsNTVzblNUUGt4ZDBvNDVtWEduajFLZVpOOG50Wkx1NnlRMzcwcksxRjkwOStwZEhxQThhM3dtait1ZmV0bzlOcHZEeW93dHgvWGx5UnlwYjJiVzVLWmtNRTl6M1h3bU4vTkZibWI4NXEyMGIrNmJZWUJIZEo4TFh4V0JERHVLZU5zZ3lVVFJyZXg1OU82blRzakVvcTduQmQzR0tqSThOL1ZKSGlXL0szQjEwMDhjZmFSYkxYY2picktsNUp1NVFtVG1YUExvbWxkZFkrbnFQejBIOGxPV04zRXFqYTRXaytqNnZyc2ZTT2ZjK2QzcStxYkdrTnN0aTh2MkNjZUQzdnhEZDZUNzduTU1aUHVUNUgxNjdvcGVrTFJCRjc0cVVoay9mS0xyaTAyc0daQ0tPZW00a3N4MzNUcDV2N3VyNzBFclhidjZSKy9wZDkvUE43djVGNHRMeEkvRlZQR1QxSTcrZEhjMy8rci9oZDM4VlpuOS9EZS9aa2QvcTZnVzI4U253aXUyaXgzSDJOa1BmT1hlZmgrWkovTmxnU3lVUmQ5d2ozK1NQRStlTHkrUUY2WjIrbzkzbjkvczhwczkvZ1h1L3Y2RDhsSDVwSHpHM2RkUDd1Vm43K1NuOS9ITkxyN1p3Ly9xSFh5emYzOVlOcnA3OW1hL1BwcmFyMC91MVNkMzZudmZwLytxWGZycDNmYnAvK04vWmFlKzZ2L0R2Zm9KcWQzNjg2d2ZXRDgwZS9iL0Q1Z3lhY0FBQUhpYzdkUkpiSXhoSE1meDMvUCszdWxVTVpYV3prbkVvWEdnY1dwQ0dwcEc2UWtSRHNMRVFVaVhvWFZXdFcrMWE2MVZJU0lob2JhaVN1MlVvdllscUM3MnJkYmE2dmMrTXhjU2lZaWpmdExuZmVhWitjOU1NdDhaR0FBeEdJeU5jRkpTMDBjZ2tCSE16VUl2dURwSFN3djh1aGc0b0U1OGlQcnR1VDhZek1oRjc0eUpFNExvbDVFMU5STkpJVzlOenNrY0gwSnFUazZmdmtqWG1vaGhtblRzdFBkUHUvcnM2a2FlMDF1ajdPcEhOT0xRRlQyUWdFUWtZU0NHUk9hU3c1Tk9hZmkyVXhHZWRyK0hiL3NDa1d0QzVEb3NjaDBKeHpUaU5WZHpEZGR5SGRkekE0c1pZZ2szTVkvVG1jOFpuTWxabk0wNW5NdDVuTThGWE1oRkxPQitMdVlTTHVVeUx1Y0tybVEyQzFuMDA4eWZUUnhtQlkvd0tDdDVqQ2Q0a3FkNG1tZDRsdWRZeGZNOHhBdXM1a1ZlNG1YVzhBcXY4aHF2ODRiYjdpL24ydkNtM0pMYmNrZnV5ajI1THdmbGdkVEtRNm1UZW1tUVJua3NUK1NwUEpQbjhrSmU4cFc4bGpmU0pHL2xuYnlYRC9KUlBrbXpmSll2OGxXK3lYZHBZWXVyajh3MTRnaGRzcHpscnZmbmt5anhTN1Mwa2hocExXM2N0aEtRV0RlV3g2Vk1mY1NqUFRxZ0l6cWhNN3FnRzdxcm9zNDY3YTdQdkNmNnEvQVVwR2szRkdOVVVqN202R3dlaWpBSWExR000U2pCVm96Q05wUmhMQTdoQ0xKUmlTcmtvaHExbUlaNlBNSnlQRVVUQ3ZFQnpmcXVmREVPTmh1ZmljRjJFekR4S0RVZFRUTEt6R0NUaGpwVFlBclFvS1pDYUZSbnhYamsxWVdYS3RDck1ocU82dHFqblZITmpxbXhqL3IzTmY3cHpQOGUvMm1QS2kvK2wvTEdhT2MxTjhBMmwyS2JHMkdiRzIyYkcyZWJDOW5tcHRybThteHpLMnh6UmJhNUV0dmNGdHZjRHR2Y2J0dmNBZHRjdlZxS3MyM3BWNVFUOUI3U2JWOXAyblZGRENkekNqZHlGWGR5RjB1NW0zdTVUL2VZeVB1MGovbk50NGkyWTlpT2plM1llNDBvVG9yMHE3M2ovY1lhVS9BREI3V2s4QUFBZUp4allHYVp6cWpEd01yQXdEcUwxWmlCZ1ZFZVFqTmZaRWhqWW1CZ0FHRUllTURBOUQrQVFTRWF5RlFBOGQzejg5T0JGTy8vdnh4SmY2OHlNSEFrTVdrck1ERE85MmRrWUdDeFl0MEFWc2NFQUpRRkR6WUFBSGljemRUcGIxVkZHTWZ4NzV6bnRySzBWbm9wVy9GMDdzRzJLb2pZQXFXbEc2VVdrSUpWbHE2VUFxMG9WZ05vM0tJV0ZTb2lnaXNTRWRONnF3VkJXcU9DQzVxSWlVWmpUUFFGd1poSzd6bjlBMHlJSm9MbkhFZmFFQTJKcjUxazVwbm54U1NmeWZ3eWdEQThwNkxNaXRWdU9uV3hqMWcxcGo3UE5wSzVpbFFlVngzcVJkV3QrdFd2S3JReXJRS3IzanBwZlcxOVl3MVk1MFNKeUdoSmsybXlTM1pMdDN3dlA4cnBTR2RTMUZaMm1iM0QvaU5ybVI2ck03U3RIWjJqWitsOFhhU0xkYVcrWDNmb0h0MnJqOGFTWXRIWWhKZ1R5NG5OakRVN2xwUHNwRG5wemhUSGRxWTdpNTBXcHkzNzI5Ky92QkFKd3RBUFF5TkxSZE5sUkYycXo0ak9XNU5HUkY4WjBSa2o0cEpvdXhIdGtiajhZRVJFZHRyWXBmWTJ1OHVJMEZFOVVXdWRiVVI1dXZDU0tHNUVSLzRsYWh3UmpmdUhxUFdpU0JuUm4yRVkvaFo2NGFtd1A0eUgrOExhY0hrNE44d016Z2Y3ZzczK29hQWoyQlEwQjJ1Q3VtQkZVTzRQK21mOVgvd0IvMmYvak4vbkh4czZOZFE1VkRVMHcvdkp5L1cwbCtYWjNsUXY2cVY3cVY2S2wrU2Vkcjl6RDd1OWJvOWI3WmE1Slc3ZVlJdWJtN2lRcUR2Ym5xaE9MRTFVSmhZazVpUW1KNnpCY09CQVNuelVIWkYyMlR6OG12K3JrV3lOK2Jzb0xyTXBySkdkeFgrUDRaTkNoQ1NUeWlzWXhXakdNSllVazRZclNUTTVIVWM2VWNhVHdRUW1Nb25KVENIVHBQbHFiTEpNWW1JNFRPTWFzc2tobDJ1NWp1dVp6Z3h1WUNZM01vdWJ5Q09mMmN4aExnWE1vNUFpNWxOTUNhV1VVYzRDS2xoSUpUZFR4U0lXczRSYldFbzF5MWpPcmRSd0c3ZXpncFdzWWpXMTFGRlBBNDAwc1labTF0TENPdVB2NUdtZTRWbGVZajl2RU9kTmVuaWJ0K2psTUVkNGg2TzhTeC9INk9jOTN1ZERQdUE0SDNHQ2szektaM3d1cFd5bGxUYnVrbkllb3B2TjNDMHJlWUJOc3A2ZHZDWnJ1VTgyU0NzYmVWQWFwRWthMVVGcG9aMUhWU2VIK0lRbjJNQzkwcXdxWkozYXlqMDhKaFdzNTBsMjhLb2FyeklrWDJiTGZDbVdBcG5IeDlMR0Y2cElsa2lOVk1raTJTaDNTaGtQUzZHVXlFSzJzNXVuZUk1ZDdEVS94UXZzNFJYMm1SdSt6T3NjNUFEbjFDclZ5QlpWcStwVVBZK29KdFdnVnY4RnRMZjlJQUFBQUFBcUFHWUFWd0JvQUl3QXFnRUJBTllBQUFBVi9tQUFGUVE2QUJRRnNBQVZCSTBBRUFNaEFBc0dHQUFDQUFBQUFIaWNYWkROU2dNeEZJVVRaOVRXSDNEVkNrRklHS3BRRXR5N21zVk1RYm9ablM1eVhmaURMZGl1ZkFGaEZncERGajdMbWQxMDE4ZnBTNGltVXkzcUppZm5YUEp4YnNEMEVPM01WcHkvVTgwLzMvQjZVcldEdTFzRHJxVk1wd240dmNHV0J1OHJnMERMQVlMZTROcEdKSjEwbDJNbkIvTHBZWXl3MTZnZlRCeWRTN0RjVHYwNXNnb3hpYzExUW5SaEVLNHdZWU54NUFHemI4Q3NBZmozSHdiYmVpZ1JuR2IyeXFKSUJPS0VoRkl5eFNLeldDUkNFUm5zYkRwNmZaa2VyOXZ1YXV6MERWcHJRbTRSQ3pCeWJ1MGloY0k1NGZ3R1AzN3gxOWVjL1EvaTM0SC9nYlRtUmRaTWlraUpWUkNwU1BtR2xCaTA5VEMzcWErb2ZNVTlqVTVxc0svUjlYS2dxek5lU3BmYmVjeEM5bGkzV0RteWM5WUpsczhrRUhtNExPc2p0c2xXV3g1cXhHVXQyWTJ0dWl3UmM5WU5sZ21aTDdFUWlLMEFBUUFDQUFnQUF2Ly9BQTk0bk55OWQzd1UxUlk0UHZkTzJmVHNKdGxzQ3Vra2dRVFloQ1dFRGlKTldrQjZDVDBCcVFrQ1dXcm9SWHFSVHVoRkFka3NBVUVRUkFFRkZDSVdRQVFVVVVSQVZGQ1U3TjU4YjVtWnpDekI5OTczOC8zOTgvTTlabmNtWisvY2N1N3A1MXdPY2tVY0IycUlEbzduREZ3ZHpzRzE3T21BMXNoaUdOQ2tGNzBSOEkzZzFhU1hreE9nS2FpK2c3TTZCS05EY3Zpazlyd2ErVzJ2dEhTUVlMSUZKMlRZUUd4QmdkK1NKZUFtZi9sWnA5MGN4MEd1VUdnSXJraGhuTWo1Y2dtc2JSRTNKNGJndG9IU2dzT3IxQ0VhSFQ2bGFlbkJmRUp3aHMxQ3J6L0h0ZUZ6SDhXMUVYTEVacWlNSzc5NUZaVUJlSjIyK3pMSENadHhueU81R0M2UHRldVAyL1ZYK2t3SFFQcnNMZkdwRHNsWUxOSzN4VjJOZklKZlhPcndOaGI3YUo0RWxEcjhqUTVqcVNQQTZBZ2lmM1hFbERyTXBmaUhqaXFsanRCU0J6QTZ3a3NkME9pSXhKMEVjYmgvQ1JseHdYSDRuNDBuLzJ6bUJEN09qSi9qdXpoNEMzM2NZVWlIY21Ec2d1NkI2bGxEc2tBRGZQbnhhUmV1SEQzcU1PUTZhTkFGblFYclVTNVludzJPRGdCYkVQMDNBTFhPeHMrZWdxTjRqSUFiVjU3R3U2WEZYRTF1SlJ1aE54NlV0ekpDUDN6anA5ekU0cHRZTC9rbUFkOGtrTEh6Q2Q1a3ZmQm9mSlNwZHBxOEU5aXo0aEROK0hsamNZVG1Oc0hvaUZkL1VZMjFrbUFzVHEwQXdaTlFKeW01RnNpb1V6Y3p3MmFPQm9FZ29VNVNRcnhrRGdtMVJBTnppR1F3SjJUVUFrMkJMU1RVVnJzdVAyZlo0ZEpQUHRtWGUrQUR5T2R0V2JacTNmeFRsejR1ZGVRY2VpVHdlZWVYcnRvUGhvNWU5Rkx6OTk3YTltbkErZlBHbjA2TGEwOXNtREIyWWJPVzcrN2U5WEhBaWZkOVAvOUNLdDY0QVdQUzZQTDc0bXp4RE9lUFY3ODZsOGsxSkJoUXorcG9ZS1hENS9Id2VXVmlrdkJORXBrTG55U2VqTUxIV215Q3VuR0hWZHc2WXhoUWpOV1JaQ3l1cVlHTE1SYlhnWnJCQjllcGE2c2RHZ1ZDcElUNHBBdzJ4TWFBVFFENGw3K0p5Y0F5ZXRQMHdrMGJwODBvR2pDNGI2K0JnM3IzSGd5bjRFZEZtL0NqZ1lQWW8wRW9yaTM4dUsyd3R2Q2Rkd283VE51L2YxclBLVk42ZHVnNWJWcFAxNmZUM25sbldrZmxXY2Mra3liM3ZwOG1qRTNET01OemZjcnZDMGZ4M01SemFWeGpiamJER3dsUGdxVE1pQVhmV0JSVXFZSnZxcERwU1pHcTRKRTc2MVNSeUFlWFVvZDgrTmRKSVI4QjdHOG05cmR3OW1FT0Q4QWZ4UWtWS09GTUNnZ25zNGMzVzBNZG9sQXN3Vk9Da1NJUWdDWUF6NGxrc0JnU2tnTUFtU0dNUWNHMTYyWmlzR1JEQU1hY1VCNmpVQ1lHbzFNR1puZnU2Tnl3N0szZTNUYURqZWwxUjcvUzhpaGNNS25iK2ZHZlAxbStZRy9mQTYzUUlORUFyZU95OXNZMWZhbTRRZnByL1hMSDhKRkRkdllvMnJkdGN1K1pMMDFDTWEwZFE2WmY2WEZWWE55eDY5ZE8rNmtoN21adFhnYTNSWU5RdGQvYVpsTjJDeldiTCtrMHUrYWdlbG5EWnJKOUp6VG5ibE9hRmNGVkVFQkNzV0FGeldPRTZuWlNHNjljc1J0NkNIdytwYjlkaE5MaEtLa1haK0s4T1l5Sm1DaGhVQ09YR1FNa2FESWJnL0N3a3pqVEloQzZWNHBZZnZYcThnaHBQM29BMjRNUnNOa2c4TXBROXgvb1VBZzY1UDVqUktzaHNBNFlSOXNNUXVuZ0Q0ODJnWkhERTFnM3lKUmhoTW1adGxET0JQNUFEL1pKRWN1dTNWZ1VJYjBOUW1GanRNajk2WkJXdVRBSXRBOEJyMEJ6YnF0QjdnL1FtN1ROS0RpVmI0dnBad0RYWEROR2pDTk8vMENCcktLLzFRa0ZmL0lOV3AxKy9wQ2lCZlFqRHd5bFRtOC95Z2t3emZRbDlEQXhVK1J0ZktKRkREYjRnbVR3R2lxSkJlMkZZVjZnUlJ3NmVLdmIxNTkyNDM4ZW1UTVpqRVVMQzNOZVI5ODBCZW5vODhha0grMjRGVUs2Y0JoemgwZ08wemNIUjBtenBDVk5sT0NhNDB3SkpreHVUVFk0QVJ4RExTZWlqc0E1RWQ3SlE5SGdkaDY0VE5ycWdoQUk1STdqZFROeWVEd1YvQ1V0UFpHdUZnZ2MvbXJMZ2lEMEFGaDJZL2gwMkFBYTRXYThhNEk0UE1waW9NTmEvREpvUkhIZ0ZteVF3OUU1d3h3TnBIRTdNTHlNRnh5ZU04NUxqeGR4aEErbUxWaXdnLzBtdW53Vy9JWHkxbUNPTUU0dGMwMUx0eVFBMjhKUmNNRElxVkpOanZLMWVYai9Kc2kwclNGN2l3OEc5MUYyTHlWdTVKVSt4bUtUbm9DSDZicHZoQW54TUJ3WWcyeTFnMHpKalBxWUtDM0tFQktlWEx2NjlNbTFhMy9aSGJ0M3YxTzhhOWNCbUlGK1FxVWdIWVNEbHZoZmJYUVIzUTM1N3ZmZnYwTnYzdnp6eVMwMmx1UGwvOEJkWWdtZTM4WWFUcTcwVEowTXpNa0ZaVDZLZVExMWhieUlrU1l0WFV3d2lSbUpjSmNkTFFHL0dNUUdxVjE3MHZhSFk1NXV3bU9QNExKWSt5YmNwTW16ZlIyamdxVk8zc1FSVkRRWmk3MDFmekFaSFg2bFRndG5vbStzRGpLQVFsRE1DY2xKTWpVeUFFdWNZSExad1kzWm85WXQyclZ2REJUL3Vuejg5cHA1YUF5RXYvYUZVVytlNnp0L3g1SDEwbUhYMWNQMnAydFJBNUgwYzNENWZmNEo3bWNLbDgvNkdZaTdGcWowTXhMZlJGSnBLVEtRU1V2Ty9oeklkbHJ4eFJGb0xEWm9laGxJaEI0SFp5eE8wWkJSY3dvZFVLVFJFVnVLcjFvU2k5ZVZMT0J6NDZBTU55Rytxc0p0TVVRcUFDc1hidDZ4ZnUyaWczbFEvUHZFUjNlbmo1cy9yK3pNU2ZTckNQTk9yZHZ3enVHM0Z2TGhtNmZPMzdaem52VDI3YTlQREQxVUkvbm90QTl2WGpzbExYUnNYYjF1SmNISGxuaE4ybUg4OWVFQ3VWY3FrVUpVMlJBSVZFb0ExbUtvR2FCRUpTZmZVcWNYOUpWRkVYK3luN0c0UlBjenNJRTRVN0tCSDNyblRvRzdHOXc4eXowU1JrazI4RlVPV2dieVd2QXVWeUxmQkk1aStQY1czaHRldUM4eDNCRFdFNEJmRHBTZUJPQ2JBSUovd0ZqTWE2YlRLd0NRTjN0WnNVam5GR084eUEyVzhvS0pyRmNjcXVtcmw3RzRpbmFxSXduVjRadUF6THBCNWhDOG01STBzNHZuMy9CK1ovaVJlM3Zkek5uNTc5MjVjYlBrTnhHTzJMMXcyOWF0eXhldGpJTXIrYWd4N24rdzNNT1hjMWR2b0wvUG5aRldiano5M3ZZenZYclRmYjRXanlXRzRub3kxMWxEVFpUUmhPQ2JFTXFsZFJqakRBaWh5QkZnTFk3VWREM0VXQnl2dzVMYW9SWkRMY3hkcFNpTTk1Z0MwQUZ3NGFBT0Y0eDdibGFHQWVlMVcxRS9wbjVleDIxZk5Yb3YvL1NkUDArZnd5SjI5RnNURDhWOXNIckZnYmZGTS9HeGcyS2pYWi9ONk5nUC9YSHRDdm9aMUFBaUdPTUNUZHpycHcwZThma2ZQKzQ4OERWWm13NFlUOGphK0hGV05ocGZQQUJmVHl4eCtPcDNLVWR3d1Fmd2hvVE1JSTVJMDRMWGcyY3B2bmJmRk9EMWplc1VmMHhzaTM1Mm4wUUxKazBDWTJFUFlNZ2xNczRRUEhmK2VPNHNXS093Y3EreDk1bnhLOHpLK3lpS0VxeXM2VzBtMDFVVDc4R2FaQS9paTNiaW5IeGtUY0xZQW10R3lrSnhuS1ozWm1OeHNtNVc1WjBtNEoxR3BCWkZydUVWd1pmSXVkcnZkOTU0ZmM1VzlPemlaZVF1bXZQNnZJZnZILzg5NjVQVmEwOS91SEh0NmVyRnMrZnQyejkvemp0Qy9RbkYxYXFmbkg3Nmk4dG5acHlzWHMweDRYanA1NjdGYit6Zi84YlNiZHY1MXROMmI1a3pZOE1HakRPOU1OMzVVY2FaanBYb1BBck9GSE9hRVJwQ0tCTTM2QkhHM3dOaEVvbUlTc1F4bUZHSHcvZ1NEa0k0alBISm1kR0F5R1laeXFoQSthN1RHUWRIZi95WUt6LytCVUpQdnVtNHFYVm9pemxEWng1SVBMUmg4YnY3T3QyOHRLTHZFQkJ5L1FaSVFRL1JNOVRGamU1Rnh3eUpyUUx1ekJtMC90TDFKL3YzM09iS3k3bjFHR2tTaEhwR0xBdzk1a3dHemxUK21GOUYrTFlxci9vUkJza1IyT0dZcnljTERZekpHT29wdjlva2NZRVdUb0dsekZTR3BYZzRpWi9QbDJKSktaczdhQUNTa09vY0k0RjhwMVhDeTMrTFhQclRpd0ZmeGhqd0gyNlJiMVp5OFNZWElCbVlET3NRU3gxQ2FVbUNZQk5ndnNOZ0pEcXFkMmxKRGU5RzNqQWY0NExCYkFGbXpGYk1JSDdrU0pqck9zTTNoTTJyU0ZYUWsybGc4a0F3YVJyajUyK0NYZndWZmkvVnJSdHh1SGsrdGNRSVlnSE1kaG9CeUNmRVNrTXZuVWJTVjN6SjlsQlptVHhDQkNEK2l1c0UzNXo4NDE4YTdpNGJqc2M4QlkvNW5ESm1DSGd5Wm9qYjZRL0owTWpsRnJsNDR3dlJZTEgyeStHQjRPNUFETU9UaWVESkRKRnZ0L0FGeXhKNDVIajhKUW1pVGNRd0JoNVNMaHFjUVVlY21aRThoZS9nT2dqdEkwZnkzU2FqdVFQUm5Da2dLRktLd3VQdGlEZG9HNHFqMFZ5UFNyaTR5aDBqSWdscmRrUllNUU9QZURFRGp6REp2REJLWTI3QU5Gbmg1Z1lORjhUS0E3VkNUQVFwMlNNSHo1ODJBYk1ReUgrOTYrQ0ZPWk9hUkJvWExnU3JaZzN0bHJkbTNQUkZDOFpMTzArYzN6ZnY4N0VaZlFlZ2tldnBXZzFGRGFXZnhVV2NqWHVaRzg5aHJ1NUl0enBTclRxS29oUENuSkkzWWZGYUZkS1JiaXlPMXR5bUdvdXJhbTR4aGNuVThmL2lsN1JxSlZZU3lLNmplaEZtT3paQ3htMjhSSWdKSnBCeHNSd1B1VGo4M1lJaFlybGcrZ2l3UHpjQ21jR1U0a3RYZkw2KzJQRTFVOGJHM0Zuemd5MFA5dlFiMnhMeXRYMDZaUzdaNlJ1RUhHZzFlaC8xTlFXRFVhQnp6NUltTWMwdTlrZXowWURnSVBBVktBRHp3SUt5SThhdUE3b3ZyZ09zc1IzVDVqb2d1SW8rek8wellPQnZaeEN3WldSQzk0ZXpCL3p6TVpnRERxRHFhRHFhZzJyV1NHaFhQUTA4Qmc2d0Iwb295djEwdzVIdVk3RitCV010RWIreWZSQ0wrY010ekI4TVdOSnZwZGM0ZFBhYWl2MVBoUW9veUVLRmwyYldCR1lxSWxZWUxEOGtnRGlRd0gvbXpsazlCVmJQaDRsVFhFOWhlM1JUQXF2UmNOSHhyQlBlRUNFYzFZMVA0ajdNb3pxUEJmY251eElaUXBFeG5XRWNGUnJDckU1ckdHWVpnVnA1SWpDTWluWEdZcVBXcEdRc2p0RnVWNXNwVGl1YUFYeEw1WVpFK1RQdUpIanJCM2ZocURtNzNGK2k2V0Q2MWlPN042TlJJS3RvL3hFSHVpZzZUbjZRdHlzMjdQenNqeTdERSs3ZG01Zk8ycE96Y040YkN5bU5tNDM1M3o2OHg2SzQxdi9PYTRsQkMzUGNZTjNjNmVSblBKVlJaQ290RW1acUhGWW1NZkVYc0k1S01BbEdnWkFnZ2xyQzJ6QVkvZnJUWS9RMVNIbjhNekFHdzd5d2MwZE8zcjE3OHNoNUMvaFl1bDRHK2dQTFF4QUtCdjUxU3pyMEFicDY5OUV2Nk5yeFkzamR5WngvaHVmY0crcy9EZjlseHNrRWFnMXllSHA5UGVZemxzTUtOQmRIcHBKcmpDV1poSk5nTi9BRmZkRU85Q2ZXWGRLdUFndjYrWXJvUUJ2UnZXUG9aMVFrdGkyTEJMWHVucmdEYXRGNUkzM3BoZnZpeTNXdnhDNmlTckkrZ3NRc1JVNnJEMTU3b0o4OW5YUnIxT0lsd1VnVFVWVHBQLzZ4KzJVK3daWEx2K202RGQrSHA5dzdja1JIcnZ1RzNJOEJkRTZHL010T3dDS3p3QVJYWjM4dmtGMFM0Mlgxd3NRNHl3dmtseFI2TGZYQ0hNU0tuenNMOFFQUFRrb2V2VXFRKy9UTTNhaUEzK3I2R3A2R2I3dTdrLzU4alB1ekF1UFRSWXhQc1Z5L2Y5YzRIWUdsUk84TTB1dWQ0WnJORWNQN01BTmFTV0JNVEF6TUxvN1dTUmtVeTdCU3FzVXlySlZTTENQTVRiaVlqdHhuRURvR012NjZEN3pOY0V6RWg4ZFBQMEtmTGIrUWlLYUNzdjJ0SjRQZUlCaXZlZ0RvZXYrNHRPSVF1bk1UUGI2RHZ1MmNCcWJreW5ON2o2N3htRXJXV0Rjd0ZmVjBxKy9GVmwrWjlRTmVKOGxNM3lMZnRiTk9sa0dyWmhERjMwUW1HaU9xeVNiY0szQ2RMaWpnR3hYQUl2Y2cwZUh1Q3ZjeEhlWWF2blNtOW9Db1NpenRTcGRvYXpiUTJXN0hvRXl1d2JKZk1iNHhLdksxVGx1Z2lqaGRJMkpJTC9iWGE0d21hb2xVdFJlK3Z2M2g4YytJRnJobjQ1eDlvcVBzNGNmM3YveFVLdHArYUMybjdwTmZLWjNNcVFRL3ZmQ05WNlZrVzlIQW5CTERYTW5LaEMwaWU1VVVTa3NscU50TlRsOGdVYmtDSk5CNXN3R2J4UnNZRWdENnBLRGdZOWg0SG5UdmduUGdFcmpmM1FWUDRTQllKTHJydStORXRZOEczRWVScS80dmUwZ3JDV1AwSTV2QUJqSmhxZXVJUFFkdlI5YU9sSWEvbWJndWxjeXJ6cFNzVHJLS1Njb04xZi9sTFVLa0t5SzZZR0V4TGQwYjh5Y2JIbHh3TW1aVGhtRDhEZlNGRmdtR0Z4WDRTTzRmdXJqdlNMNEZtRWtoRVdKR05RdE9oYytRNEFMdStlNnBkT0haT0I5UmZINzUvd3FmaVNRTGFaZThTZ2xXQVFPWmE1Q0pjZlJSZ2V1TVpMZnpEYVVDNFE0b2k4S1lFQTJFN3htL25vSnB3ay8vVCt4UVJFWWhqSVY4Sk5lQktsOEp5aEIrUWhlUXE1eERsMEFhNElBQTZoWTgrckwwNTN1bFh6MkVBOUZQYUFmb0N5SWVnbkRRRDIxRGQrRURFSXUrZS9Eb1YvUWRpSG5FeWJ4bEZiVk5CQ3RXVE4yQ1VVWkRMVEdBWjVZWUxVOGhYUTNTZFpXUVNjcTBLN2cwN2hMNDg4ZXlzaC9SVERDdDVGREpJVFFUWnJ1M2k0NTdIM3o0Yys2N0N4Y2RwWE5WUXd6QWN4WE14U245TU9KWEc1L1RSbmx2SSttSDBWaHNBVHFaVUVjbFFRZzBXQXlKVk1SNzBjU055bm5XQmYzZGNGYWJGOHplRHZSUGx3ZnQvb21LK3RjcHhIMC9qdWV3VkR5QTVmVUVoU3RXT29mMEpnamZCT2tuVkt0TSszQlVpK1k5alJIcXZHSmhDQThoMUdMR2xKOTZSQ3JtMlZZQUh2N3liTzZrZVFXeGlaTVNvL2R2UU1QQTBET0hENzJMM29BcjNLUEZBNStkR2ZkdVN2eUIyUXRhakl3UHF6cXoxWnk1RzNJM3oxdTJBZStSL2hoWDdYaitreFdaVG1laGlzSTNVWFQyb3hSdldBQTFNbnVnclhaSm9veU8rRko4TFU2c3pPTlZGWE12VDNlWG9MRytDWnp6eHFPL1FQRFY3MEdJd0krK1ZIemd6T0ZiOS85RVA5ejRCaDBUNFdpMGIvOVhJS2RnVFlOR0gyemZmZmxaaWJUaStNWnhvMWZXYS9UcDduY3VYcjhzdmIxakxkMzdOZkhhTEtVeXM3V1N2YS91d09lY213ckx4L3gwS2ZLMUkxOWhrTmoyMldHeGJhNXN4NlkrSWtMejZsWkM4M1QwWFNFakhpekZ4R3dnbUdnemxtSVNqcUlidjl4RnQrM2ZGcGZjRmgydXhGOWQ3b2Y4ZFZmaWV4Zk9IK092cy9jU0hlQVNsWHRxL2llK29tZ0FkRFNKRmxzbUZmUnRzR2VVRkFVT3pYUi9uKy8rZnVaZkF3Y0s3ejNyUk9sNGZVekhpWjNkck5CeFhkczYwa1hOSkRvdnFpZCtPL3lNRGtNcEllVUNrWG53Z0dNQTZZR2xLYUQ5U0U0d2tONkE5MnRJbWFCT1BxaVRJVm1CWVJKNkl4OGRUWklTMGVHeDZJM0pZT010OEowUVV2YmdlL0x4ckpPUXZXNWQyWGFGbnpmRWMrR2dkTDFUSlZLeHJyOHFLU2MzQm54am9INXRnNCtNemRSbDR1RHBWV0pNeHhzazBQL2I0RGl3WVRtcUFwNHNSZDFROStYZ0NZcGN6amVIbzkyMTNkRndwbnNhdkEwdjB2N0U0ZjY4aC92anhhVlgwaC82MWtyQ0FReVVmeE11UjFpYkRZNEVIeTEwUHl4dy83NFF6dU9ydTRhNEg4QkkvazNTZm4vYy9naTY5ckwycDJ1eU1uN3RGQ0ExZFJwMDZPMzBGdGxMTXpFenp5QkdFZk92L05TeUozeHYxeW4rODV5Y3ZzS3Z1VDN3KzdhalQ4QkRhVHJlTzhrY2ZoZHhCK0dHT0wyWXJKUGZTQkFERVpMQnc4dVgwV0hRVm9yNEp5VFhjQVMzbFZZK2l4Y1ZIdzYwNnJaTVdub3d4b2kwOFhEQWVOSHh6eGQwTGpuODduYjAzVldwejRlM0ZndDYxY2FnZmJHSjJIV3dsQURhb1VOZmZDRk4vN3ROcnZTQXluendHblRST1V2d2xCWFZ5QW1SQmlVWVNPUUVWWVo1akp1bnhvSFUzaUJsM09sb0tSbzNjY1ZkSGR3WlBwemhIU2pmd0krbDJuQVZUa2RHOUtLU1NDeE5ZMTFMK2Z5Y0hQcTdiT0U5OEpGNG1oTzRhZzVLanF6T1F1TFFVRDA5Slp1RkF3TE1QaHdveEFoV2djOG1FOHBuMnNCSDQzK0g2L0dQUlpIWldMQWMrNG5RRWRPQ1ZHNEc2MEU0N2tHNFgyVkNqR29INEtWdzZvOE9sMlRYcE5VZmk1U3gvbW4rTU44UnJpUGx6aEIveFFzZHB5UHdqcW9reGtOUDBlTXdPWmVkMEZVYkt2NGhLMkFXSlV6YkxJbkUrTW5JUE4vT3o2ZlJKMU9MRGdEKzIwZHZ6cDI2Y3pTVTdwVWMvTVkvMFAxc3h0a2F2Mi8vYUdKbXArcmQ4dllzWGwweWQ5enNhWDJBTlBIazRiZmREK3FQek9nMnNkL3RoVU43am1HeTFTWk1meVVwRE5QZkdHNndobU9GYU9Wb1A0OE43MkY0NG9uMzNla2J3RE4zUnJGWno4eXFlQWdVeEtwa0lFSTI5UWFZRW9nNElSbE0wZFNkSkVqZm5pcllsK0UvMUY1M3o3aVB2cDI0WmRQVWRZblZOay9ZVkFUS0g2TmIvWHR0bDhMYzlqNkQwVG5rdmdUNEtRT1JwZCtZbjA5VHZCaUkxL016dko1UlhBdU5MOHhQUzlNOWtNdmhSWWxWb05FUlFxNWF2a3Z0MEJrMlN5aldWeUFXRUlnQlRHRzBSSENBMW9MRHc2SDRiTWVOMy8rNDdud293QkVIQ3QvWnZhdlQvSW5TNnZQQSttdktBNUIyZWE4MGM4TS83NmQ4OERlZDZ6RzRmMS9JY3oxQVEzbEN0RFBxNXlHb2VXZ3oycm4rMTRrT05sS1RIWjVtRnRzQTVlaVBUQlBUZE1kY1A1Mi9LN05ndUUvZHQxLy84THA5VTlHNERhblZWMDhzMmd4REFBOHlCL1NFTS8vNWVWUDN2aUR1OGVtZmgvVUZybjdqOFl6VGNmVEY0eWpGOHh5S3g5RlZNdzdQZmVQMDVhZ0IyOWZxYWFFeTZFVWNYNCsraS9IVXFFSWpWK0tZLzRLWUdYbU1KcFk0NGlxcWN3RTlCcjRuUHI3akZqNHN5aXVxWjJ0OGJObWNra0FJSisweWd4by9aZjRNYXJzdTUwYTkrMWVUQnE4MmE4ZTdMNndUb3hlZklEalNIQS9nb0ZTVHMzRHpPZUtIZTI3ZWcvRk44SE1VSU5pb00ydkFVdWNBb25uL1JpNTVXUDBtbG8vc0VxdFhVNktVcDVFSFc4Z0RoOWNIeEU3Q2VZR3h4S1VYcUczQ1NHSzZRa3VKT1NraHc4YThONnFqakdpSGZ4NDh1SDFsWEl1RXdEQmIvS0JoQUNMRVh4MVV0TjNwNHoxWU1rekpLeHJrcXNiMjhCalVqdithNG4wcU42MlM5ZENOandvWlB2Sk5CTDZKWUhoRjdkNStPZ09kMHhKQnQzU0VubnhaS1BuQ3VseGlLY0c2YXBWZ1hhYXM1eE9mamEzQ25lT0JnVGZPdkw0bk15RG43c1dPanVZeHpaWjBMdHFhdVNmdm94djJMUmdYVTVMWFRDemF4bkF4cCsvK3NpOC8veU1wTGljMjd2QzIrYS8yQXZGL2ZIUnZlRGI0cTU4ZHVaak1VSVRaeURkNGJ3VnpIYmdLK2FuU25hV2pZbFE1b2dJRWI1UVZCajhkdlNKRUN0UGZCQk16OFZPTk5iUnVpWDN2dS9hRmt5YnZUTVpLNjR5Qkk3Kzg1YzZCbXh6clpveHdFMm9LdWYyNFUxWHhOK1pycWVBZ0lWb3A0emswSTY0ZU5kWnRtUWl5bWZHRklBaW9Xb0QvRXhxQXVudndtcGN2UnUxQUttNC9FSSs0VFNVanBrMzZhYVVrdk9ZNmxUUEk2REJWdk10RTNnVjBxNVpob2g2TTFDMUxvak9pL0kzMXpMMkc1Sk1lbEkzYWZjakhPMGYwbVd3WFZvSUdPK2o4YjhielQrS1VBaFNLb01ZcHFiVFh6MFBBOHJUVGVERTd6WDlsbHRuNmh0MCtEYXhZQkZFV3VNa3ZnSUh1MzZVd1Z6OXdXa1JoN2lNaWt5OHExa0JyM3dyeG1IVFp2b1duRjRQUzMyR05SeXJFK3lsUmlhbDRmaktWR3lvYyszbU1SYmUxNkkwYUJRa2lpRFhLYVJEb2R2UFIyOE5qcVBXYklwekZBKzFDOUNnSWVOODYrKzFUZGxkTlB6UnovM0g3NG1rTDF3YUJpVXVuRnI0WlBWRm9jTEQvTVB2a3NUTisrdDI5QUU3OFpPYzc4dzBSa3JzQVRqejkxb3hSYmkraGdiSmZydUV4cXZ2bHhXTlVHR2VGQTQzRldGQnZtT0JwNGZQc09lbXRsMitkNG9tT0kvYUYwNmR0VHJBTERkNGZNdXJLSGZjb3VPSzk5WE5HdS8xSmp3Z2RJL0dDWWJoUHhNNVRqM3QrNHlwMnJuODE4Z1FUdnNGRlVaOHhoeWtPTVZKZ1prSk1GbVlzQmwyOUJpUlVkdlViOU14KzR1M2RKei9ZcytjRXJQbUlCQms5aXZzTlhRTHB2eDB2SitGRmNVY0p3VDNLWkNRMFFCQnh2enhsSk4yNjY2aUxqNWJ1L04vS1NBVGpMWlhLU09LM3A4YnVyV3ZQQ2F5N0Y4dEk5aDFGRTlja1ZkOHdidE4yS2lOMTcrUytKSDZ6cC9jZ0lpTmRCTUxyZmQxLzk4cDk4SkhNS3did0YrV3hEUGhQdklLTzB1ZTVuZnEveWlDWnhPejRBaGxrek82NmZzTUtNbmVOcGpKSTNyb2ExZGU4cnNnZzJkMDNQMHVDdGJLNkVobmtmazRQR05Rckg1VmRVdWc5M0lMSFllU2FWVElLR29xZzNLaTJVbjhkRTNmNitMTVFNSkFzMDNXTG1lMDl1S3hYL3ZJWSsydUIxcUpSbHRRQUxMTVZqbkdiaFFZbGZrUHlEQUtqRWNPd0RMUUp2eitaRzFrSlJsUnE1M0ZHQldCcHdROWYvaHVManpNNEhnTyt5T3hUVnlPTnFsSE96TEJPY1lSUG1ycjl3Nk9mNzN2M2F4R09XVE45MXF6OHQwNTljTDNrelBjU0hHMG90czljRFlMYmo2MmE4c2EwS1hzUHpaZDZ6YzV2MzI1UVl1cWIwK2Z0UGo1VEdqOThMQjFqVXZsOW1DOW1ZVm1wbjBZUFY4WklnMXlVRzlYcURJd2FoVkFmL1VRRWJDKzlHaFJjaWdWdnduZElESllxNXhFZGlMQThFK2o5NjY4ZG1rVmxWZzJLN3A0NnR2RFlNVEVMM1Iva2JqcThseWoxOGc5WXRoR2VHZ1RNdEsvcjhYcGN3WVFrbUd0YkNUNVFMcS9jcUpZVjNRNWwvRi9QL0JQbHZzaW1wVXpDaWZuQmRSejJ2Ui9hNTAyWnZ5M1dQcnk0LzlDZm44RFgzUXZQN3BzMGdvZGxaM0ZmYW1EYStoSHVpOTYyNUZjWkw5VFpsb0JxV3dLWEU2UWtrRFFGNVF4QVE2YUF3TUpDUHJYc0xLT1RnSHVKNDhUVCtFWnZYNnFVSlZIN2trNzArOC8ySmR5TFlGc3d2VElkbnJxMjUxV1hiRDhOL2FtT1ZQUE1GSFFtOXplcmxQWmdLRG83QmZRL2RRcGVkeWVlUFF1dmw1MkZkNDRkYzFlaEhRVmNiVHdQSmZpN3I5SlBIZjdvK2xtNVhZbnpJZnFEVTZMbUpheDRFeHVNMDV1VEZFdVBhbG9DZjRERUpXZzVtTFlJZllvK1hRSUswZkxGY0RwNHovM1FmUTE4aG13d0dRYXp1VXZBc3ZKNU9uZU5LK0V3dXVtaUMrVkRXSjFYQ0VHTlFEMmZ3N0lJRldzVmNZbmE0ejVQa2tEcnVTZ2xaZTRNYzZPQUFMOE12NDc5NHVxamZuTkE0Z3grZFZuNDZQWGU0aEFvanVteFFxaEIrOU1iejlGK2lpdXRLc0hieW0xUkhQenZiRkh3cEdzL1hPU2V6d2ZtNVBUa0p3L3RoZC9YQW8yRTY2WEdYRFNYUktOS09LdlRpd3RrWGtaZGNKL0Y0TVdvbzJ3ZXo2Q0pBM1IvUm9FSzh6bWMrdTZHL0FrVDhqZThHMUU0dms5MmRwK0M2V2hrNXNPM2IwOWFNR3p1NUR0N0gyVm1WVCsvOU03b2JZbkoyMGZkWG5vbUJmZkJpZjRBbGhmR0lSUGJGN0RrNUtBL3BCTnN6Ynh4bi90citoeHRkWVpHMHo2SFdyV0UwMm13aExMZ29DYUE5cFYxbmF3UDZhdk5URFYzeWVCZGFPODNlSEMvOFlVUmh6Zm1GUlRrYlhnWEhVODVzL1IyM3JhcUNkdnk3eXc3Vnowcjg5SGVPNVBtRFZzdzZmYmJEek5KSDVhQzNjSTlQcGdMeDFqdDlBN2xVeDJoZXVMbVY0cjNGeUhzV2owM3ZOUVJicVhCZWdSUHFHNW5UbWFhbnN6SzcyMmIySE41ejJhajZtVzlOckJvY28rVnZacU9xTjloSkx3ejQzanJyTG9aRTRjRXpqcmN0bjE5Mi9SQm1IY3ZSMitBR0l3clJLZElVV2RPQ1ZCejhuUmprS0I4U1JQMXJNbUlDckhiZlpjc1FXL3dsMEVTc1NWT0t2ZmxmeEtUdUFSdU9QYzhTYWVCSEo3MkVsOXFML0dsRVdpK21sUWVoNW5tS3VGcmlQWlJCSGxVSEZXWlZZV2s1Q1JSdzRvK1o0ZmFWdG9VSEI0QmhTL2Z0Si80N09MNzlxSUxQRjloWFZud1lkQVBkeXdnK1hyS05aQWM5dTExMDZlYlZDc0xvTGxZYVRUblJKYmRkUloyaGR6cWJLQmVwYzQ0aWV4d1I1elZhWTBqRVhseHhFa2N0elFPWm12ZFJ3Ny9Va2NjRFdRSm9SbFlJWjV5bXdVakY5bCt0aVlnSXhuUE9LL24wOEZ4WnJEQVlLdkZBMWNYbjFhdERKY3UrSDdwUEhhYzUvTVcyS2N1OXdVZndwbU9FUjgyeThrSi9NbnV5QVhWUHIxMzZSMXAxUUxIWm5RMWw4aHVvOHAvRlBzTHY5TkkweVRPeVpzeEZ2SzZ1RkF5MnpXZjUyREpobVFXSUpxWm5DbnJGNWtXRmcxa3NCaXdxSXdsNW93NlJHQVdSblE2TjNyTXVhd04zVFkzYXRheTJaNXV1enQrT0dMNGgxbHZkOS9icEVXekJ0dTdsLzBOSWo4NUN5TFJqMmMvUVQvT2FadVY5VXBSOTYyZFQ0L08rL1RWdlQzZWZ2bVZkaS92NzNuZzFYTmpScDd1dEtNSG5Id0ZYUWExcm53RmFxSXZWRC9TQ3J6M1E3bXhiSDFDOFpLRTZqeDhudTRRWjJBd24rcmsvTWplTGdrTWpnbUcyWTVnaW9mQit2Z1BxZFFaRzBnRDJ3bEh3OUpHZ09hUFBySUxISytQV2MzZ0lQOEROdGdmN0ZtSTZvUFhVUit3RS9VcFlBbHdZQ3lxdnhEZWdGKzRUYmtIY3RGN29CWCtnSS93T214VzZaZUJDOVB2UTVLMEFrUStGZE1na3kyYzdMek5kcnNkL2NIekxqZi9DZnhManUwekNmMHhqdHE0bHR3Q2xtbWk2SWprOXhhYUZYYzR5VkxYMHNyQ1p6c3N4dUxHMmpCaFMrTVh1UTZkNlRROTduRDE5UHJwcjZUam42WWJpK3RvL2h4Vko1MWx6em1xbFQ2ZlE2ZU4zWWRLVkxhY1ZpZTdHajFrenNSYUlKbG1TZUh2RmhvRktmU2ZOTHBmdi9LdnYwSTNSWmgzdTJqNzBmVlhIdjh5Zm5qdm5vQzdjdk1mQWVZZDM3bmZ1ZXI3cDdmZGYxWnJIWk0zdHVoSmZKT28xMmU4RFE0TVdoeFhlL0dJWFNjKysxYUMrNHNXanhsdWI5eTRlUGVnSmZIcGkxL2JldnJXZVdueDhTV2p4MDVvK3RMdU9kNW12NEFKM2NkTmFPRVQ1TzAvdnV2SXFVeC8zQ1lHODRueXVtVFNwQnNyaDZWL0l0dUltaHpSWnQ0ay9tT3pkRUFTc3B0NVowbjlwVEZTb1NUa095Q1JmdkMyRmNuV1RkeS9INlcrODQ0WXZHblRKdHppaVBMNzRsL2lhUzZLcTg1bGtJaE1zbVExOFpMVlZORFZobTlzaExiRWFXSXNhK0x0cWNrNkVlS1NxZEpzZGZvbXh6SFRxTlBvUzB3Q3hjR2FYNUhBT00ydm9nUmZ4b3FwTVRxcE1kQ1JGY3JhOEZvbE11ODh2ZkthNzBJdktPeGN1ZWJ3NFRVcmR3bXd6K2pobzZkTUhqTmlwT3RETUFvSUFJQXhhQVZDeUlWV2RnTkZvQnBJQmtWb0lQb0dYVVdEWUZkcGRkRlg3eFRzdTFMMHBwUS9ldmNNKyt5ZEk4Zk5RZmRRSVpnQlNNaHhJWnFCN29PR3dJRTZvVFBvTk1tRElubERzQVQrVFdPNFVqbTd4cTlDa0Z1cUVTNkg0OFNTeUdLdWxFZ2dza3ZGajM3Z2ZYOTRwTjhVdjBWK2ZMYXp2Ujk0M3FuaVY1bFR4YzlZbk9TUjZhZm05UDBuZHdwYzRPMExFeWQzS1poWnRQcndxMWw5Y3daRGNjZTh5U3Y5QXRER1ZyTkNEZzE0TFF0K0dKNVpKYVBscE9HdmpXdmNMYnRkYTI5cDBNeWxjOURadEY0MU9yZTNydXhRcjNsckdoOCttZHZHTitQM0dwUDRWb0djMGNDM0FpMG8zWnNDWnZKN2VDOU9KTDR1VVorWUFuUzhtbmk3OXRqZDdma2FZQ2FvTWh5M0tlZUdCVWxZMjhYa2s4dkZ1UGdIeGtWZnJKblY1aHB5YjFRU0s2RzRENG9EOVJtbVpnMWVoWHRUYTBTNDFSbkpVelUxMGxyQ1JSb2pZYll6TER4U2pqbU5KVEduTnMydjRtMDA1alRjNkVpbEtVRU5kYm1vR3NUVGZ2K1h1SXRrSlVjb1Y4YS96UmovcmhIODZ3WkdBeDVBTUpwaXFCdXRBSmNHQWJpeTZKVVdMUnA1ZWVmNkNPMTdIVCtVTmFMdjYxdmdOVDBTZ2tZZVNPcEVHL2xYcDAxcU1UZzZmSGk3ZXRXYW00M216aWwxdTdidDA3bE50N1kwMzB2TTRyMG83VEJ5bUc1b3MraUlNTTE3MFppdnJJR0V6aXpsdjRRVE1INlQrYy93bVB0QTVYZkYzaStjZUNWbGw2bnNtWm84bnFYTGNnWXZYVElrWjFudlhzMWY2dEhqcGVhOWhBdTVxMWJsRGx1NmJHaUxuajFidE9qVEY3Ky9HNWNtQ01Kai9QNUFyZ0h0TFpZODljSDdaRHRvQTRXRlFCcERESTF5RnBTM1J5SWp6VEFjQ09ZaisyZzBDQlNOQnR0ZDcvTXY4NDF6MEN2ZzNSeHd1S3d4aWRmQXVEZ0Jib0FIeEk5TlBMOERUOFVHSmZOQmlhdFBTOGN3cjhPbDhJeDRGc1BzeEREckZaaHFHS1lhaGFGNXJjZkJOZkVzOWVFS1ZwSWk2U3dVQ0VHbzhPRnlCemppdytWaXNMaERmYmdrRlIrOHZKTC9aNlI0VmtJdXVxKzJvUUg4RjFTZjYxZUpIVk9uYTFQUGpvOVcrL1NNbWRPS2hVNi9RS0lBT1lPOEFobngxZGdBR0dFaEJqb1F2bVRpZ3RWVjdFTjkwemFPNnZsR3pRS2hnWHZlcFcwRlkzaWg3T3lHYm4wYU5YYy9GYi9CL1h3VjYzbXhORDZzS2xmUnRlZGl2UUhIdEM2OE1QRkVKR3NJVEhEUDhIdklEZmg3dDZFWDREKy9CTVJublpoZXRBdm1nWmY0cWd4bm9WVlBSN0M4LzlLR0RUQ3ZoTUVPUWgwQXlTd0k1SnA2NUl1cXYzSjRxYmhyME9BdVJxd0FMZTdhWkNraG1ja0htWC81WlEwc1dtbm9QYm5Mc0NqTVRydjBHZFd4Y2NQNk5iMEtLYjcwZ090QVQvRU14b1h0NWVWd25ZSUxTcllteGdYS0wvZ0FPYjZ2Z1g0L09YMnF5S255emxnU0FQM3ZsdDhYNTdyUE83QnFsZVBBeWpjZEkwZU5IRG9tYjlpd01jS0VWY2VPclJyMzV0R2piNDZZUFdmNHVHRno1dzdEL1oySjZYY0hTcjliUnhINjNScjBwT1BZd25IaWUrSnBZeksvbldzRDErTFBWNEFYWGl3RHZ3c2U0TGpueHlYLzVoejl6U3RZeHZaU2ZvdC9zNE9QcVBpTkVpRkdmN09JNDZTRjRzZjBOMWZvYjNieDB6a08vMlluRjE2eDN4cmgzelJTNW04a21zRG5DQTFwbmtzSER1OUZDa0t6VzRoZXlKa2k1ZHpQLzV5ZTZwbmRFZ0JZR2p6QmZPWUxwem55V05ZalZTWmdJNWphZDlTZ2VZWGpsOEU4Q0wvZVdYSis5dVRHVll3TEY4SmRzNFoxelY4elZzMXVtZlA1NjNXeUI0QTNOK0F4MHZ3TFEwSlFFdDRMSk4vcVpVeWsrM1BlM0VFL1hoU3c2TXlwTURFcXpBVHdCZWhGWUl5OG9JZXhLVENnRzNjVFpCT1lBTUdqbmRvcVRCL3VDd3lIWVFJOVlTVDFYY081ZzZBNzNpa0gvVVVNdzRweDBKUXVGWGFZMmw0djBBaXNKckJtMGkraTgwWXlXTHd1Sm80enhPQTlIOGlGY0xzcWlacXJQT2liRjJRMTN2bUlCL21IWTNncjM1VG44ejBDL0owK25DNHpRR08zSk03MkFQMCswZG9rdklpbTdvd0tBdm5PeHZoU2NpSG9laERtK0tuNE8wbE81a2ttQytZTXdmUWZpT09URFlZWTF5V1RlKytQSy9oOGZvQzdyUVYyY0w4YkFVODgyd2NERXFSQU1BZE5KdEg3dDNMZDI4Qnl2R0Zxa0htYWpWcVN2QkE4VDBrWTBRM2NKSEM3L0cvOG5PWTkwTFd2eHRhZSswTlplMGxaRHdZVG84Sk1BQTVsN1QxZ2JBb01YdE5qYk8yTmdnZU1wTFl6bkZ2RzF0VW9ZaGlIa2VYLzBuVXRmNHFKWkRidFZ3M1dyL0wxckY4Q0Q1WDJ6dU5GdGRKK01aZ0pYSGZXTDY4S0dCN0QxS0w5cXNINlZUNlk5VXNTZUJtbS9Cc01rMDM3eGRvWlhsNlA5Y3RMeE8yUUJSSlZITUxTbzNBZjR4Q2hqYS85UzZhN1UrQkVXYlhvTDVBNGQzTEpFanpTTVFKS1BTTXhSQjBSSlRiZ0NDVWtRYzF5Q1k1VDAxend0eHZyMWxYa3VsUkYrNVJrRjFRS3VzTGlYTGhPelhtQnhlNFNPZWZGL1ptOEhvL29Ya3huZXhHRUtYdFJYVE1hNjIyb2gyRnF5N1FoSFl3ak1GVjRIejFNSFJWbUFuZ0VSaE9ZV0UrWU5nb01mczh6TUpiQVJBc2VNSzFWbUQ3Y0l6Q2N3TVI0d2tTcTd4ck9YUUlqeUZyRmloakdFY3R5bGhpUHplWWU4V2VGWGxndUMrV2NnZytmNmdRK3NydlhoOWtsdlVHbU55QWViRytRRFhMUlcxbWdPK2lSaGQ0Q3VWbG9QZG9BbW1DZHJGOG50STFlME1vc01CS3RZdmxpVThyM0NUK0ozM1BoWENLZXZhNlZSSGFyd1hPMU5PdHAxTVUvTzZOcnhaUCt4TVRYSWg4cDdDT1ZQbVRoOFRRMGk5cE44UTExM1JGdUw0YUV4Z0RBZkhaeG1PY25BR0s5VklMbSsyNSthY0N3V2QxN2s5RHZVVWRmR1RCcy9zdHRYQUVONjBudzlRWWIrcGYrekU5T1RaYmNLMjJ6T2lpeDlOYWFHNzdzK25RMWpRVnYzbVRqemE2M1pqNmNjS29aNE4zMUc2UHZIZ3pjM2RnVldLMDZDd3ZIYTBCamhPbmVyQ2ZqUkNPMk40TjRMMldkR0V5TUNqTUJQR043TTlRVHhxYkFnRzVBWkhzelZQQ0FrZFIyaG5QZnNMMFpLbUlZUnlqeFdTbThnTWFwR3NJd2JDUDVuZnZCcTZROWY5NUEyOFA3OTEwTTA0Ym1vcHVWU2hLNkNHZEZEc1dTbnc5TEwzUjYrMUF1N1UxbGVvMXpuUmg3QW5RcXJwSWlRTVQ0WUNXckQxaEJpeHQvLzMwREhiZmJRWXY5RHNkKzBZRks3NzU3OUVkMEhIOGI0VjV5cEhEbVVZS3ZhL0JZMjRnL2M4bWttb0pvZlo0bnFjNStiNU5JYzB1MXRpU1J5Z3VZZmxUMXlEeFNkQnR6Q0dmV3haUFV3Ukt0VWpBQ0JOby8yN3ZveUdTUTkrM0c3b2VTNDZ1dmJEVjFPVm8yemQ1aDRuS2h3YWUzTnk4ZDlWWEg3dWpPOG5YYnJYRTVNZW4yL29OQjVMenNhNi8yZlgxdkVaNTdHcnNwM3NaejMwTG1JOXV3OUlQbnZvWVFycXdsZzdtcHdrd0FBN2d3QXBQbUNmT0hEQ09CYmlPcUVJaGFJb1BnS21CK1YySDZEQWdoTU5iblljNG9NTnp3Wm1hQ05Xa0dET05JTXpwcWxtcmVKeVVyZmNJNGVnN3JjeGd5Zy9USmtXRjBOSlRwQ1UveXJLUkpRa2V1RmxlZmE4NGRyaVJDTlFiZnhQeDM0YXJNdHFJUFYzWCtocjlYSHJQcXJFTGpXNTBKWEF3MUdkSVFQazJvbDhOS0kxaHRlam15QVRVck50WEg4aVdwZGhoYm5ONE93MnpSdWhpL1JKcDl4L0w3bFhBLzRmYzNMalpLdjdINTdhTzN2d0xTdENuek5vMkc0cTMzcGhSWGEzeHk3Q2UzM0FFSER3L2QxTXphcU5qVk52ZGtWZVRhc0dzbXYraU5mZjRRNW04d2o4bnRNZTJ0NVVXSGVzNWRNVGZIVDNyajBNaWhnL1ArdmpvazZ1U3ZMOVh0a2RseHlJZ21JSGJKYXdQeitYVVhOb294SzQ2eDlSeUlXcEpZVXJ4T3JXVDVwVGVWWDJqc0k4VzdOakxlSFdKNEZ5c1lGSnhpTURkVm1BbmdkWVozVlQxaC9wQmhNTjVObzNnWEx4b3FjSXJCbkZGZ3VPRmRLRTVWTldBWVIxV2pJNDdoVlBsWldqUHZVd3ozV0paZFh1TzhxT3lpeWh6Y09neUR4RTlrR0ltYmtBaXA1Q0pBOVgzbHBIQ1JXL3hXYVFmTExyVTVpY291b2lxN3ZJV0pXZzNSb2I1cmVMbUJhcFVIdlF6UHlTNkRNWDJwS1Q3RU1uTWFONUhEQ29uZXUrdHZpSlJSMHV4UHZwWFVNRGN5WTBrMEpwTFV5WENHbUFubU9hTmo2QjBYRWswK2pQN1VJMnlKRHBHVmxRaUtobG9YaU1IREJRSkNnNVJvSUJwU2FzSHNMVmxNSnJaclRKY3NpUmErVGxJR2M4MFJMQXpLNEJ1TkdZZCt2VlNLL2dUQ044T2NkWVdnSWUzUnA3VkJUTTNCZFpNN3pLMFBnRzB1U0NwWnVQL29oenVMUGhhRDdlakE5WjUvb25NZzZQeDlFTnpwWlhIV3hTeEgyeDF4OVN6RG90dGJWN1oxZmVtZDZOTisyRStPTjcvanlzL2l0YUN4VitKdmVBNDd5M0xITEM2WXpMTkZWSFViR2dzbGZvOWhYcFh4N0J3WFJlV2dpalZsTURkVW1BbGdIbWRodU9nQjg3c0NnK1dnRlZpU0pIS1E2QUh6bXdyVGg1dkgraFBqQ1hOYWhzRzRPRFNFU2tFR1hpc0Y4UmhUdnhScUNTdW9EZDZYeStRTzhvQVRVbWtaQjlYT1lGQy9jVWFINy9QbUIyWnlTeVFpS1A0bjFISkY4RCtoM2t2d2YzRDJ1R2RiWE0yM01QcllwM3ljRUNhYzBNdEVPbisrRXQycGs0bjBPV0hPS0oxTVZGMHZFd1hMS0dOalprc3VRUkdRaUgzQllxdEVKaUl4Wm8xR3BtVmw1L1RKUVdWWE13Zlg3Smc5ZU1nb2U2dVhKRENqYWpmcm5oUHdZclA2RXBvZTF5RjE5MGthZXhZZXR2VlNtMStXa2ZnemM4aVc4NjErWDVOM1BKTVBObHNRT3BwYlV0LzFoOGtFU0hJY3JWVkM0bHpvWHU4cDQ4WEhiSytIVk5BV0J2T0pDak1Cek9Ib2JnL3poUGxXZ2NGNHNZenQ5VERSQThZaHcrQTF6NkU3UFl6U256QVN2OHpnYUV3RmZWOWYrWDB2cy9kRkNDR0tITFFWRFJDODlYa0dWUFI1Y1o3Qi83TVl1c3J6REx4WkRKMjk3bHRqS3craE14eHhUKy9SLzdrWU9uVzhEbm04ZUY0UzZMeEVHUEJvSFJGR2g2VlVZMWVRbnFsMmhYenVDbWhMZFYxUjFNc2ZSMVc1SVgrSU41VmlKSTFzd1d3T1RWU2JRdy91TGxqQ2RGMlBkdHlxak5KalhBY3E2V2hsbEZoa0Y4MjAzMVVKVHdPOStYRk1ka0YySGxGZTE0STloOW4wT2EzdFFQV3NKSGxkN3pJOUs0NzNWZDVMY3k0b0RXb2x3L1JuTkNoZUNGUmdXRHR0bEhZd3J2M0JkTEZZd2FPZDMrVjJNRDhjVHFsVXJCaFkwWC9XVHJ6YVRrOXdYTmJwUkk5Mkxpajl3VEIxRkhybjBaKzJhanZkZ2NCMHpIalAvanhXKzlOOVNoVGp6NXIrMEhvU2hnd01rOHphNFk0eXZTUmNBRW83WS9DN0hraGh4aVN1TmJYaTVmSm54S0dLRmE4cVJ1MnFJWEs5b1A5QjErZVpyczliV2NrY1dpMG5pOGU2dnRZREVGaVpyaCt1MnpML1grbjZMTmRGbUkzM2V6aWVtM2thVDMrbCsxMFhFYTdLQnlHaFpMODdRcXpPd0JDUXJZdVVCcVZPd1VDcGdTbUFwcGlFR0IxaHBZVDFSMm10SFI2NkNRa2laN2t3allHY0hVTWlBR3htRzlDRnBRcXppK1cwR0pvamcwNkRSZ1hGcnNFVktUTEN2VElMUzQweHMxd1owQ1gzM0RtWFE1c29vOWlmNlA2dkp1Ly9FcmIvL1VWSkx3Y2VWV1c4L0FLNi8rTWtneDdQZXRIOVgwM2UvNmVWL2UvUmpsdVJPVEhNUEk1U2dLb1Y5SnkxNDYrMjB4UE1ZZnJ2Yy8zNVZHMm5KMmpEVldFN3NhSWRaQ2UxUzFnN2hGNkFUa3hlUlNVa0w0ajlsajcvaTJ1a3ZqZERmVzkzN2pPMlQweWUvWCtpdnJjNzVrZlJIdjJudFVFb0hVbVI2VWdaMi84SkZmWWFtZ3RENlVoYkdXWUcyLysxS21RWjFrNFh0WjBlZVA5dkp6Q0pudTI0MUhaNmNHOXc3UmxGOVdnblhtMm5KempEK2hNbmVyUnpRVzJuSjJqSCtsTkQwdzZxU1dxZXNIYU1tRWFBcytnVDViZFNaK1czZkNHZXRRWWVmYUExUnFoTkkxVzJhVVFvZGxCMTNtaHVETFc3dFpQbkpBUDB4VlRHR1VZQ2E1cUdrZFFQUW4vQ09VNGNodWxQTUtiZ2xWV1RWQklCbkVicUdzUFNWVW1nTWNZSXFSdmZvNUFBWDhwMEFXY0k5Wi9oWGF3ck5tbWh4U2FwQlphRTZ3UnA2akRpZjRRZzBkb2xSQTRVTHE5ZVRTcVlMRjFLYXBpNE92Q05YS2VGd1FQTEVDbG5Jc0NCb0FNNkNEcTR1eUlsZDVqL0c5T2RTS0p4a0U2SDRVNkhLVlNIa3ROS00relVjZ0tSWVNKemhUc0RJd2xaamNSa1ZSdDlDY1VnMmU0Um9ETzVrd3hDckkrRXNvejM1NU1nU0k2WHpSd0g1NkFEMnV5aERSdnNvTE53RDYzVjV4QUo5ekJCSWZyV0Nid3dQZWphTVh0eW4vS2V6R1pxRUJXYmMvbGlESk5FZWZCakdRYnpJdzhZckNQQ0laUVdNWnR6Zm5sZlJvdUVDcGczTVl4TjNLbnFkdm5scWVWL0VoaFJVbUdlWXBpNmxCYXgvdlFvSDhsb2thSkp5dThTeGJ0cWYzcVVOOFNhZ0xkczMyWTQrVEt5Z3dXVWh1QjJqQkxvL1RPamRhSDRlVitKMk5UYXMrZXlQdjRKWHR6K2xIYXg5L2JrVWhtZWkzS2JlTzMzNEVzc2pZL1U1dnQ0bWtma2ZKOVl1NTJHS2VPMnI1WGZGNitMRGlQcmk0R3JDVlBvOC8yb0hYUlIzdDJlUHU4QVBxZlBPK0I5UDk4UWhmdFNVOTV6NzRQV3BDL0JLdDh2WDRSL0s0bm5nNUtBckhlVk55eC9RbTJXSWxkQlIrdVQyamE0blZyeXZwK0t2c1RQTjZPR0pKY0tQKzhvUDQ5RFh4TmZOOTdya2JqVEFVcm1oczY5cmNQdEYrUllpWkFGMzVTUW1DZklxdUg4Vi9sV094Wk1uRGdYSEZzSVVWVVl3QzhEdnlHajBBREZndTlFOTkvdWF4S2J4MkpTQjBmNkR2ZmJLdnRIR29NSU1tYWZDcC9kWm93YmdxRXZoc21TWVZMQmFnOGZ5a25Va05UVFllM1E4VTlHWHhQZkxHcEk4cm5ZYjhuejhqL3BjN24ranZKZURIOUFWTDJyU3ZrQ3VYN2pmdnorVitpYVpzbXc4Ulh5R0ozUEVCWFdvMTFNdXo5eTc4RmFFb2FqdmxyU1ZvZUt0dkRmdzkySHlOOGxLNDF4c0dCYVZFYmxPYmtXaUs1TWZrVmhPY21QV1g0SkdmVUk0K0JKb3FVdVdwV1hxejlTM2JtVUZaOUxOSXUwcUpZaEl4TXZXU3Fvano0bWRZVTJiclR6MWlHamhyaTM1OENONmFQUzRXN21wNGpBbDM4d2pmVEYvT0I1VFV4VFJkZm5YL3RWU3FJc09SSkxRdXY1Z0V3em9YT3NENjJkem9MRGh3djR2cTFHdFhLYjRLbldvMXJEWDVRNWZVVHQ5T2xzL1dIWWM3NDlaaCs1b2RoSHNFNHhpK2tVWVlLZ3haRkhkRzNTWlJ6NWp1SkNFZDQ3MTZnTTBsbCszazdGa1VkVUJrbVhaZjZNNTJRUTl0N0hxbDJtTzdlRjJWekNWTHRNK1c4RVJqSXJNQmdIQjRzNUN2NG92RWF1LzNrWXRSUHU0dlVQdzNyaTg1Wi9YV0N5bWovelhJSktwYm1iSVRRS09WQm1OeDY1dG1wWkplSHUxcVV4ZGFJQ0FwdVlld3h5blNiMWxScEpvdU9mcHlSL2M3RGtNM05jTCtFR0tLc3FPc3JpZ1hDRDlua1Rsam0rRWpwaUxiM1hmOG9MVkpLY0txTEZhYktFRUVWY0JVRTZwNkpXNzlEa0NPcXpUVFg1Z2o0WkJ3b2NSN1l1alc4UUcyQnNHZDV6d01McFV6ZFd4UVQ3eU1BUlYrNjRROGdBaG9vK1U4ZkIrKyt0bnpqVTlVeG9vUHJxQWxWZlhUNzNtSzF4bFFwNWpObXhqcWcyczN4dUliT2ZSRW1xVE1YYTZhTDZCWHRnSVg4NzAxYzkybkdwTnJNZTNBWW1IOGFLSHUwTVVOdnBDL3BoK1RDUU94aEQvSlNPR0pKQnJjajR0RDNKVzIydkwvY1hsbUVJTExIbGFXQkp2RWY1ZlVNc3JUbWN5QzJwcE9xaVRtalRaZGFvTG9KQW5XYm9ER1lwSU1GV3B6VVljNFFRbldTamsrc0V2Yi9ZMTZQVVpIV2FFaU9YMVF1MXFCVUl4UXJ0eWhRU1pJaDFiUnE0K0pWSDZDdFEvVkc3OVYzNWZxUXVJYWxSV0piYmZGYkRSak5iZlBEZER6NitvRDN3Qm1uQUMzVHc4ODUxMzhoMTd3Z3hlQW0vR2J6UTN6K2lpM2ZRbjVqVDk4TnpFWVB4bFp3eFVaK2JXWWtOVUplWVI3MG55bXhRN3dtekxNV3draDdlekNCTlhDSWFCSFpXaWFFbXB5U2E3NjR4TGp2U3FmVzU3blA1cDVWNU5wUmlxcDVKcWFxYm94K1FycTY0M3JEaDE0VnlYWU5OOWVvMFBqWmo0ZldHRGI1WkppZXNuamk1Wjg4Sm9ZaldPcGk0azFvUGx4ZE9YYWtwZHJCMDJyU2xubG1zNEJncmdJRHhqTmJZb3ZRM1E2YXRPeG45cmNiekdqb0kzNlgwdDV2TW8yOHkrbXNXL0JXWTQ1aitsb29IV0R1VXpvNmlkSFlpYWtyeU10bHZLWTkrZ0w1UjM1dWh2QmZUMWcvWjNxeGVZYXVlUTkvN1dINnZCTHE3S2ZVTkZmMHJkR0ZhWDR2YXBPcksvWCtIMmFScThONUtPelEzay9hL3V3enpDdXQvRFVHRlllMjBVZHJCTXZWUnBydWxDQjd0L0M2M0k0RnVYYW5tbGlKNmEvcURXcEo2WDZ3ZDZpZDZpL3FKaHFFMkpEK1UvWlkrYjFGZXByNjNyZnJlN3R3RlpudXE0Zm5leCtwN3UrZEdNWTFSODk2YUtJUFU0OEl3bWZMOEQwT2wrSGtTU2ljNW0vaDVEL2FjK3hKOVN1QkovUzVER29Pbjd6ME9lbFBkdjRML2tYelBlVktFa2Y2V3lrWUR4T0VLYjZPbnMxVHdOcVVlV0tCUy9idlNpbng0Wi9uSVdmMGVaeDc1NkdQUS9HbEJpWUJTV2ZLVTYwdVRFb244blB0MlZBNEFxUnlHZk8remN0TzVZRnR1THVxSCt4R0MrMndYc3pDL21sNUpqaUZsVWJyNHovK1FvK3FVZ29IY1lhMjZHcXlyQ2tFcWNGdG9oOE1KUlhCRWxqcXFxRm1zcE5QUFo3SXEyYXdnR3QzV1pMUis5cG1jMDRxZTVxSjMxTFJXOEdvdThCNEV6R284UW0wMVpxRVA5NHpwZjJaUnhSZG1wNytoMnZMN2tKM0UvRW42dUFhcS85V1QrUjVpK2wrd1p6czdWYjlCUHJlQTZYOW15YUJyaCtwLzlXVGVHTUQwUDAwTUJXdm5ydHFmSHR3NnB2OXBmQXVzbldGcU83M0FZQlpIRjBuaU5ZZ21IYWZ5UnRvZTFrdVU5bnB4djNKTkNXd1VzWEdRZE9rRUZaYTEyMDV0dHk5NERldUoybmJOMm5ZRkgycHo2aW56M0NkWWV0ZTJhNmxvRjlsSm5UcldMclZ0RmJNMjhITS9vUUZyZzlyT1I5RG50QVljdGNzMGtIWEVHMHhmalJETXloelFQRjdxZytrdHczUm1QcGdJVVlWaE1TWTFsQmdUdlBaSDhONmwrMWFkYithUCtGYnhSNEJ1SFhXdFZNU3FTT1Zxck1wd2JqSElZakdPWGl6RzBVY2RLNjJQUm5sRVk1bCtibU04SW9CWDE0L21yVktmVDdZTTA0SDVmQUlxN0U2c0hYK2xIYXdmRmJBNThCVTkyam1zdElOaDR0a2NhR0JZT3hscU85MjVrNHgzQkFvZTdkeVUyOEUwY3ppVjZnSlZmem83TXdmbVNEWHhxTHZRTTNsME52WGZTTUJjbmdEeW5ad0F4cFpZaGFZQ1ZwQkpUSHFKUS9oQWdQbk9OUExITFFSc0FJbFVGNTZyQ3EwdDRXTTI3YWJGZTR6aGFiR0RSZ3BYU2RtZUFaS2hNSytNRk8wQjVXZFFPL2cyN2tzQ3Q0cHpXS3dWY3I5Q3JlTHhUYnhPdHljT3NYaDkzVGpSNkJINFNkUUNVNmt6ejRLN09zQkNLaFNSUzZHRkZDZXlOTFhnRVcwaEQ5THczMHNjbGc4c3BEaVJCWXdsT1diUkhxWnl2WEQrZklraUcrejVaT3ZTNk5veEFZR05RbnNNTENsaHhZckNhOGNQR3ZhRXYxcDJhZmNoYjUvQm91K004VUs2dG13UmsyRVhsdDhYWFZKdktzTjI1UnhHNjc4d0VYL0dSUHl0T3NFVWM1QkluVjdzVWVtem90Z3JGY2ZvUVYvUndPeFJ2ZlJQYmRuWEJUZmFMMWhpZDJ5dG12U2k0cS9EK25rZjNIemlUbmlidmYyZXJ3RkxaUGhyd2xWbFRONlZWSmRTanNWd1NpRzh6R2Y4ZFhyZHY0NUpsUzNsd2J5NHlzblEvVTFINWVVdG1WTXRwYkppSisxYStDNmZ1dnBvV0lzZGZTc3Zla0xyY2tvMnFTN1dRVjdWeDRZRmFKVlV6L051bkNDQVl6WUQvWW1HSHBYVmdKbU9nV1FCVjFLOVU1bzhLeC95cHcvcnFuaGVoQUhGYThRUDdwamQyUjdsUEdudEI4RWxITU82ZXE2YWphbnpMOUZqNXA0ckI2SUx2NHV3VUJ5TDBKVkhkQnA4QXA2djA4TVM4UXhLR29pMlBBUWRsL0FVOHF1V0QvZlIxb21RK3ZVVmpvbHI5d1c0Tm5wVWpKZ0N2V2FPWi9FM3hHWm9JTDRYMldiWXZieEQrVi9VdDEvaHU2UytZQzgxZHA1L0I3UUI4emt6cHZZMC9qeUMxa1dQSU1jMWFlUE4xRGc1L2gzdUs2NDFnVy9BazNpekJrWVN5SVd2eldSNEdyTk9hZjk4MlQ1VHhtaC9lSVY5aHNhbFVWcTdSNGJaeU9LYldsZkUxZEY0VlVNMmhsa3Z3L0JnRFlHcHl4c3JkT2h4V0ljbWZPczltWWUwNTBJcFRJVk8wQjhsYStWckxKTk9RQjlTK1RwRksxL2o1eVowaHNyRm5iVnlNWmE3TjNBQ2xZczd3SzBWY2pGK2JxQjBHTTg1U0JFYVlKNVEvVVgyRGcvankvTmxza0RLbGlYUmRhTDlqVTNNUFFZbzliRXc1WnM1VGxqSjZ1VTlVT3ZsOWFua0xhckgwOC9Bc1FSSUQ4OHQxczhOY3NrSHJTN3U1eG56b05ROVNtb001RWc3UTNJVGVtaE9NbEZFd2Q4WGdEOTZjdnlUTzlCOWVsUCtwa3hiby9kV3pDb3hRdmU4blVKSDlPVlBtZmRRNmJNdmNxTU8vZDIwUVplbTdWMzh1ZlZpMUpMMzZWb0p0WUZKQ2d1VytIb1ZtU3RLalM5Wko5Z2kzSUVYeEs4NUw2NGhwbnFVeFVKYVZrUU4rQ2s1YWJoa2dObk52QU14a2xrTlRRMUN0alBMQVBJZGZHbEpLNzQ3VDArek1TY2tHeEl5TW0zd1F0N3VYYU4vR0NUOEZiUm5qL2tHNCtIejhUdmVrOS9Cc1hkd3BTV3ZjTDA0bUU5ZUJTcGVCUzRCK2lvUUE2eWdLU0N2SXFmY01GdWx6V3hJU002d2dhMjdYcjgzOE9leFlzMjNUTjkvYjJMdldDaThBODlUM1NhSXZLRFlEM3JzZlcwRmUzZ2FDdXZuek5rZ3duNjlCL2JMRmgxUzNxTEZZNlFPL1FhMG8vWTAwUXZVb1htRjRmcTh3c09GY0NuY0RGbHhVdHlST212V2lGNTdLRy9jS3l3QXo4VExOTDh3bWZJUnM2cXU4T28zYjJORnN1R0xNd3IzRG03Vll0REFscTBIZGN4SVNyVFpFcE15eEJvdEIrSUhmZnUyVHE1anExWXRveTRkY3g5a0Ixc3gzd29tK2FuQjFvcHNhWDE1cnpnMUc4aWlIcGdKK3JScG4yU0xUUThMaTM0bHZmMmczT3hHQStyRjFBMEs2QkljM3F0VDYva1p0UDFjNFJFc0YyL2c5aE13MGVXd1lraUxGeERqc1VTOWdEeVZYZnhaZkRYTDRhcW9sa0VudW56MHEyM1gxN1UyNnpTeXkwczdNbW8xRjgvMUhEZTZWZDJnN3VOSHQ4a2s4elpYdU1PSGlyL1M4MzJUbmJ3M24wcVBxRlIxUFRXWGtOaXVlVGtKMG1ZQkNjazhTUzFNaHJPV1EzUTFIOGJNNGYvTTVjVmZKZVNTZ0lDdklwTlpqcUNONEdyNURyb3VqVGxIbUZXN0dtcDJ1WVh6Tm5ySGVxZDVOL1B1NUQzQU84OTd1dmN5N3kzZXZ0bUVNdk5NLzdDOFlMV09kRy9Vb0d1WGhvMjd0VW1OaWE1ZVBUb205WGI5RGgzcVo3WnJseG1lV0RVaXFtcFZFcUlaSUp4QW9hSUw0NVNaMWZSVjN1ME01QUVyZG10RG9mM2ZtaWFjQUUwdy9CYmhKTm9odWhtOGRrS2NnUnlGdC9FSnFJWjlYMC9SVFdpcjY0RHdxTHlOZUFOck0zMWNyM0IwVDdoSENaZlJlcWtYM2hPczhvaTZwWXU5TkxuQkxIM1JHU0JuTVlJTWRqUlNwbnplcW50cDd3N2p1aG5tRnczcUNJVExVNldVV3VtMU92VExhdHZPMEFUUHJ5dER1SVBPcU92bnhaSDE4NkkweEVzVEozZzQwRGZHMStxTFY1RkVtaExuVktZTlgvbE1tN3NVNXFPcmNEbHc4N2wvOG5PRVgranFsWW40U3Nmd0dqcUR1UEpSZUI0U0tPR29XTDBLRk1uanBuUExPR1ZYSW03TkduUm1EOGJmRC9BKzNpMTEvdGM1QkFIcnRyU1dPcU4zTWRSMk1ZeTNTaHZrT01pNjdBeFFQVEZzNWx0b1dHclliRGhnT0drUXM4a3dEZFNsNDJzbEhoN2lZMUtLRVdUYThQaXNtemVqa0MxYk5yMHpxYWNZdG5idDJ2dlhLMkxNT3NzeFhSSVlJaklkVHM0TkRaYTRpZmlCUlBKRGljK3EvQW1HZjEvcVlremlxZzBoK3VxUThqb2NaSHhmN0VDZnA4clBPOVBuV0c4RWg2VE94RGNxUHg5STIyK0laYTVuOUhudEVQWjhNaWY3a01Wbytyd1JnMGRmVWZpZXhQNUhub081SWJTZmE1bk00eWkvRHh0SlhiRE1zNXJLUERubC91VkhpSHdTUXVMSGlLUERSTXV0UkdwajZqQi9sOGg0WmIvT1BIcWZTT25NTVh5ZlRNL2lxUEZ2SnpzSlJuMk5hVmFrWGtoMit4YndJMm1CZWdmYjh6WHhlUHJLTlNVcU8rMUVPWlBBbzZxMlhQdzh6cHNlQ0NYQjdzOCtoOE5RRS80SEZDR1JnNkR3djBQQ3UwcHNETzEvdFFyZG05NDNWc2Qzajk2bnlubEE3Q3dNbmtaU0ZuSVZ3bTZBcHpRQmFZUVVPVEtYSEw1V2NnQ2VoRVNqSmFleEhTQ1hMRWhPNzhGY0NMS1QyVW91d1ZzUWVpU002YU1zRFo0U1IxeEduUGd2cDJyd1o5MWZ3eFNzSjczd2JJMGRPWHYrNCtrYTFFZlB6cXJCODFCRG5aZGY2VDA3VDRtY0Rmb0RQWjhnN2I4OTBZdHNSbnJvWXdJdHVaWUFWMHVvOWxRWU9oYUdUaEg1WjI2eVRzcTd5TGtzK0YxcDZyc2YwZnQwdWlaWWZCZjhaQnp4eFN2NGZINTNwWFc4UkZieFZMUTZyU0lwT2lTU29rUGlVaEZtNjg0Yzl0SWRSc1VLZkpIa1RITEUrM2gramV1MUFmQ2l1M1kzZnF4clNVNE9iOHpscFZ6Rjk0VGxab240bnVTelczNmg4MVAvdjgxRUpaNW5xR1ArTERvblR2aWx3UFZSZ1pDcTdoTjVUbGJST2JIUjl6WEY5N1dvNzd0SkpmT2g1cXBwY1UwczlSZ3JMU1h2VFpKUk03d0JzUVliQUR5SlF2bGVMaE1VM0M3K2lPc0JCRGZoWFhkaGJqWmNEL3RtNTRydXM0cXRtL1lsczhMMlJlOGIwZlhxaGZkMGYzbytRelNXci9wVVVpZEtWUXVEUXFoYUdFU2tUS2V2VDRoY3p0cFE2Z2pTZWI0Y29mUjBNMDJ0Um1vN0JMWll6aHpDeFNXWUV6SVNZa2tDUXB3dHd4WU9sSklYTk9lZ0lURHhGZ2dBYUltT29YSm9Cd2loOThITEFBSzc4TlhUdjcrY2V1WHBYMWVCOEFSZHV2c0x1blRxRkxEKzhqT29mUnpkZEsxOS9ORUhmencrZGZvM2ZoaWx5ZXdjQnp6T2hxem1DQjZuTng1bnVIS2FpazVucDg1cTNYbEN6eFZlQ3ZVTFlsWFdTQVJBcUQ0WnpVY3VWa3ZWWDQ2NGJaTTRwZ3Bic0NJTW4wa0hiOXJSalFjVDc2RTc5cXNIcEluZ0F2Uis4Q0ZNYzVmK2hiNEx3RHMrT3hERVBpSDNwKzc3UXY1SDNGODc3djl4VE5zU2xCcU9TdFVZZlN5L3RnWUFTV2d0SmU0NnJiWGVSSXpISkxpTW1JVVR5Ym5rTWxFeUJsa3dMc1dSc21QRVA4bVp6Q0dRRk95Q0Q1Y2QrK0hrQjkrZlhJblNRZXJzcmFEYWI0OUE2dGFad0lyU3g1RktNa0xCSXhDUGJqNHFRR1hvY3RxNG5ONmcxZVh4SUJLVHE2M29wL0dmbzZPOWMvNlh2TjcvMFI1TFlta25TYW1ZUnk2aFBISUlHSWZmUldJYWhUQkZUeDVSL2l2L281U0NZVmJJTUNubDF4aU1hdDh2UWdQNXIyZzdxMlNZbHF5ZDBJcTRpc09VSDRmSy9Cano2V2RuV0dTVEp1NTVRL2w5L2pIbDJkc29URTRueXJFakJFNkpmeWZYT05WZlRmdVA5ZDhxV0hiTXJVVC9wWmpvV1haT2w0Qkk5cGJXTGhOZ0lqVm9uSkgwZ3h4TkhlWjVQSzdwT2Irckd2U2JxWS8yNVM5bnBQbFpBazJXdE1oT2ZmMHozaDVId243SDdza0ljRS9aVkRSK2JXcksybkZGbTRVR3JxdkR1Z2hDdHI5UDlyRCt1VXJrNzRoQlI5MW5UdCtmbmcrMmpGdkpTdFBpOFJhamZLRTV4dU1RUE41QnFtMVRKemFvV3l6Rmo2cjhLZGJpNmxvdlZQVVVNcjVBamtZR2NYcXJvTi96Qnl4cnp0Mm1PUTkxNmdhclIzUExDUStFM0dUQVY0OTgvMXEvTjFiOWZYN0EwU2IyUC9lc1dicG00YlM5TlErTzN1bzhzSEdwZU9iS1d6azdheWFmZStPVDcxOXFoa1R4OER1L3VjY3VtNVczMHpuWDlmRXIzZmF0V25TSW5HdFhBK1BSUjdTdVozb2xxNm5VSTZ3ZzlDUXN4SnVYQTh2azQxbElsVkcrOVJTVWIwZDVVMEJLZ3BRa05DajdFVFVISjRSSTExZUZoV285YUVxL1VyaGhsY2hlRkRzOGkwT1QyZEpHdEFrMHI5WVp5cEpxdzZqbk1VcEhMRHd3QjdNWlFha2ZUY3NUeWlsakdieGlaV1dWSERIbWxMaC81VEYxYU1kc3JQOWM4cXRwaEMwdWpRc2h4dFlGWGFJN1IrMDVJVHFHaVB2UXFPdXluVFh1VzVEc0w0aFNzeFd0czExOVphdnJzcHNOREg2eTNaWHVZNkVkSG5GQkpYV0ZhUWtkZ2paaDFieFpmYWFTTVdHRllUQy9wSC9ZbURBaXg1RnFUZHBERVBtdzhCZFZpM05VTXhiSDZtNHB3UXpXbkNhdEtmZldFSmpWdzZTSjZWYkFxRFppN0poQkkzODRjK2h2RVk0Nk5Idk4ydVhyang3ZHZQbnR0U3VPaklZaWVucjR6RitnK3NCWjBmR0ZIVmRzZm11dTFHZjgySjU5YzRma0RCOHdmdFpBYWVNdW9sZTlndkw0VFhpTjZXbGxnWlhzRkpvMVFFM0wwV1FGZFJXRU9ZL29FMkFHMUQ3UmtHeUpBRUNNWDR6TkptWGdkUVRKY1JuOEpqUnU2bXZMRnJlYXVRQ3M2bE96eWNqMlhUdTlmNmJnRGRDRmQ3Y1FIYThnZnNNdms4WXZIejEwMElhRUh1SERXdFJyZEduZE9CRHpGdGdxNWxLZVNtbm8vMUEzM2NlRGt2MnZkZE1QRkJTL2ExODRmY3FHUkx2UTROMEJJeTdmSzdzb3BMKzNjV0t1NnltckI4eHpjL0UrTWRMNk9jVENPTy9mL1BFQnpKVVNnSFdDQUtJVEJKd01JRHBCQU5ZRUxnWGNDb0JZTlFnZ3FnRjVVQml3bFB6UlNxcFdCd2FBc1o3bDZnUDBvVURQWldBWkNkTU5wMFEzeUNRcXFiK2lIQktUSVJnZmZmWGxINzk5K2RYdnJsL2grcjNidDcwTjE3dHo5MjNEbnhsWUpTZ0Y2VmdmYUluLzFVWVgwZDNYNTMzMysrL2ZQWngyODg4bnQyaHNIZUZUUXYwWDJHM1YycVhDaTVsQ2hnblVhdDh5b2xhVjhQaldLWlB0UW4zWHRlSGR2THg3QlFVczNzekhFejRueDl0aWVlb1pYZnU2NVg4SzdjVmZNYTVpR2QvZnF0UC82STE2b0RRRTlLQnpmOTNwcDZSWW1zYUI1WXhoV2E4UFlsd3h4RTdwRjFNbHBrWk1veGdoUHkzZGxnQll0VmlDd29SbjBlUkNsWjN4Q1laamM4Q214ckhkV3Zxa0dNV0FlaUVGVTVQQWE5RWRiUDR4QVlKdmpZRGNncHEvUy9GQzFOYitJd1RZWC9CZVA5clZzTmRyUEo4akdCWlBndk5lWjN4Y3JwMkZ4MWRBNytXNjFmaStGeDN2WURTVXY0MzNaaTF1UkNYVWwzSnRCYjFqOFUxc0pkVFhPMWF1WmFDVDYyUDFHZWRKUHBTWUFaWWxyOUNaaGhWZlBIWnp4WUgzbVFrWi9PTDdEc2ZlSTdObW5YdjQvUW5ia3BWMFc0OTZ0VmZtUFhSNTM4YnhNenEyUmFJamQwbithUHZRWXNlS0ErTkc5bjh6cnFkbDRFdE5tdjl3ZHQzRmxNU1YyVDFuVnMrdGlNRVRPdUx4djBySDN4bmZYOENiektMRXVGQmE5Rnc0aVphZkV5bFpxekNiYUdWdFA4L3owejJMbmJPa2h6aWg5eVlOUmlLTGZhWGd6WC9oYnFyaUpUenVxc2wvTVJUenhpSTBRT0RsT3Y1WkdpdkFmNU5DK1Qva1RpYlhDYXJJblZSRUNZSC81bFRlMi9Yc0FQejUvcVU3OXFKTlJSdFQxcisrYVN0Tm5lelV6djBOLzlUN0Z5QmdwYi9zRWhDZmJFRkhlK2JjUDgxczYyTlFEdjg1amRmcldNbStwUVdJbFY3VGlDT0dVMFEzNVBUVjQ2c1lQUXB5Nnl0aWtvcjRLczRrczBMRHNMSGpqZ0JIYkp1eHkzSDYvVFdMd1p0OWFqWWQyU3ZuWWZrL1FzY0xUbW4yT25Ra3hmbExzQ2wzV1A5VjhUM0NCalpyMk5BbkRJVDlrSElQMkJSNVpBVEdCeU9lODdiL2NzSVVpYTdVSHpLbGMxd0g2c1E1WWtSUlBia2s3eTR6RHFpQ1JpcmhaOElJOVBHb2llaWZyN0dNQWNTcjBPWWF4cnk1WU0vNy9CY3RmMWdXZHh0OVFXU0xIMEV5Y0YrV2hRckhYK0N2QTJ6T08rQjlmUTczVzM5Mm81OEhjdnpiMlkzOE9WUmdSM1A0S2Z5WHJocjhsL0xaalZRUG9MWDM2bGF5bHJyNjdncjdxNHdnQjJVa3dXUWJFVjhKMm9VREVMeHQ0YTdWc0VuR3pQVDZuOTg0LzUzUXdMM2pzMU5ZOVY4R1RQT25sdS85RzVYK0NUalltOHJhK1NoZURNQjlDTU5VdVNjOVhlKzVqdWpXU0RYK3FMSVY2VldvWnR6aEZOVmk5YmhGdEhnUnowVlZTS2lPVFlMbWtDQ3M1d1lUQlRnSkJnTDQ1Q2RRQnoxQ1QrM29TWG03bDJhMjZuVDhjOGt1bmY4Qy9uaFlFaHFnMDcvZlFCZE5LQU5jQ0FLWlQ3WS9tVGdUL1RQL0dQckhIL0kzWGJIUUYrMDlDdndFeU9hMUdlb20xQkZhdnVEOEdWMkJlRjFOUTZvdUUyRTdMSnhXU1JBTVZFdnlFcWlXcEk5aGMwYUdDYkp1b1JPaGdqR3pDU2FsN1lNOU9BNUlBTHpLa3RhUG5weStYQUkxcDZKRlYyd04wL3hqQW5uZjFNQytvNXU4TGFHU1F2RG1DV3VibC8xcStvb0JtVUxMWmFOUk1XenV6a0JCcjNVWDRGRFJNSEVwbU8yZXdYdUJnem05QlRoWThDSmpub2hhaWo1NEhhT1V1SE9kejE0WHg2ZkxlcUdJcFV5QUVqaXZVNWNnc2RXd2t3MU1scnBCR1ZpVUo4aG1wT3VaeElVRDJXWUJIMG5YenNDMnpXWTFiSW1lb2ZzRmo5RVQreVduaE9XQ2VPZ0hRaitlVVRibDlYc2JrQnNkRDBROXdWdEJvQVpJQlBlUStmRlRYOGpmSUdPWVhYNWY2b1hIVUkzci9TTGE1dmNjYlZOQ2ZVaTNOY0tDMDRlTFovWGRpSDhzc05RWkU4OHhCVXFDQm5wSXVSSjNvTjgrOGxsdlJOeGQyNllMWExKOCt0cUphMllzV3dxN3RKbjVjdGFGTXpPYzFhb1hUejk3dm1NTG9jRjg5R2pacVhMdTFHZWdLdm9XN3pEdTFGSmdXb0IzMkJQMDZZeVpNMmVBT2svMkFzRHMrdTloZWFzeDhhc3pPejAzdkR5TTFmMElNYWgyZXAxOWdNSnVZL254ZlNoa3BNSE1JdkNVL0hnVzg1NnF4cndQQWE4d2UwUk1oZitmMlJwQzViWUlUT1B5TXl6SFdvMlJvL05PWVhZeEdQZ2FnNmtoVkZQcUQ4ekI3NXFCWmVRSWptUnVLQkZYdXJCNUZYczRYcU0rQnZteXNtcmErQ2hpamtqUTdwcEVrbmVSVkZXdXpHdzJHV2xZamlrVEwxQXdSUzRtKzhLSko3NjRpWDdmTzIvSkRuVG53ZmZvb2YzVFQwL3ZFL3YzN1Q2a3l4L2ZWZlVxKzZESnZrdm5pOTNYMFY5WS9tMkU0RW5vYnZvbDR0OWRka0tFWVBtOGhXL01KekVMVjdCY09sRTh4aVVvNTNEckt2OVMxSG91cjRUWFcxYk5wYzY0d0NvTW9aaUV5Y0s2REZRNzE0bWU1Q1FRM3M4MnFYdDAzVkNMVDN4SVdsWWl1bXRIZDVJN1dzMnhQcGJRak9odWsrcWNxQ3BWRmE1TUdSYmcxMC8wYWRETnZjcjlGdXdGaDNkcjRDUDI4d3NZTmdWMXo4dWo5TG9lWHF0RXZFZENzYlE1cUpKVEIzU0hzOUZqZk1pTldjOUJJNGxVNWZUeE44dEJFU21hdjhXVk9oUE5WUHBPcEI0MHo0MUJaTVk0VE1tU3FTdGJ0NUdreEYzVnJVZWNFM2NuVjl0cFAvaHVyWlExNHNNek1LT1dxNGMxWThyVWdrVVRGMDJjUEpYL1l1QzF1WS9SaFdtRmhkTkF4dU01MXdZTmRWOFpkMnZNbU85ZVozdkpIejBtZTZuOGY2bDFXRW1OUWhPdFVXaFNheFJTL2VPcFdJVGw4U3JjRUs1QzMxQ1dtaEpNWFRvT3VjRTZSNFErY1Y2MFJESzNBOEZpclVWWDlJeHlZbW1zZ2psRXNrSThUUXdyNU1PYzE3clA5WDduNVorQnorTTdJaWcrQk00VnQ5L2IxWTQ2a09PZDNYZGlxdDI5ZS9RcEQzdWZXSG13T0RuRzNaQ2Q5NHpIUy8xekpMNEk1TXN4UDIreitDSWxSeENQYzFINUE2RkVQSXM1K3RSS3NsdFU5NFF2alJqdzFSOVpHRVpycFpQQzFWbGhXSkh0SDBhY0ttRkxGZHVJczVBOFBZQXZ1bElJZ2k3OGtUaUc0cWg1V3hMd1BpYXVMVHdORmtNQ05mdlF3eGtaNW1RS1RoaU1mdjNwTWZvYXBEeitHUmlEWVY3WXVTTW43OEwrN3ExM1R4NDVid0dmU05mTFFIOWdlUWhDd2NDL2JrbUhQa0JYN3piTzZmQUx1bmI4MlA5Znp3dC8zbC8zUDluR08yQ2FYMHgvVzVQU2pEb2M1MldsWjBiRWNIbVZuQnFoZUFaME1wMFRlSWZLNll1aHVraGRrcW11blQ2Z256NXZqNnJDbWlKN2Nid1BTQVVabUZKRUFxQ1UyeE51ZzFFL2xybnVvRWozeFdEVEIwK3JKeDVZWmJMdzBXQlV5YUhEQjBXSHUraVg5OS8vQlcrS0wxQTd0RFlIVkFQTDRFcDNmZmVVOTk2WWM0elppNC9qOFpFWW9TQXVVc2xpMEhscUZDTHU1QUtENUVxKy9UbUMxOXhTanVBMVIvTFVPWkJQNUJ4STB3TDlTcDJDSDJTTXk3TWNyS0MzNHZqcFNDdmQ5VGJOa0drcW9WcGEwTVkzTGdDamZucFc5aU9xNHZxb29JQXZJY004Vk1LYjRHYjMvTnRIanY0STk3bTc0a0hIdTljNjVzNG9ablFyazhhNU83QWUvV29scTZmTGRsU3R1QjU2TktGYm9TengzdXBSQkxHeVpIdENvZGE1TC9VOU5QVFJuL2FEUndjZTdXZEhyU2xwdWhrZStjVUROQmhzT3JvbE10emQ1UDhROXlid01WM3YvL2c5NXk2VFJKYVpUQlpCWkJsSkVFMUlKQ2xxWDJwcEJHMXRFWWtsc1l2WU1naEJMYVgycGFnU2JWRkxNUm5FV3RUV0Z0VW9TcFZTV2t0cGFZc1dtWlAvV2U2OWMrOWthRCtmei9mMyt2Znp5VFZ6NTl4em43TTk1M25POHp6dlIrVkwxSjVNL1I3alpMNjBodkVsc3pOMm1jV1FZbjRPUG1mOEhQUlIrTG5xaTkrQW5CbVErQWp3alJ6NzhEMkxqMUN4a0xCeWhvcG9YS2lhRjB0M3JxSXpYT3ZVRlRYL29Vc2tycGZSNlg1RWNvQ2I2QkNTYnRpZmp3Y00xYkdpQ09Kd0lIWjQyZ2tWZ1Q0Vi9DandITnlPdjF0bG5Nck9icml1Q3BaUXlhaUhRL0NzeEp3TVhveFVHYUdaVXM2bEUrYndCa052UFgxMkUxWGpoNUxQTzdkdjM0a0g2ZDRQKy9iL2lHZFJ1R05wOGF5M3RsYnc4MUQyRWZLZDdDT1kvcmFvU0h3YjArLzdIUHBWTGRjSlF3Wm9PSjgyVUpXYWRZa3pXaVhkN0dOcEdVd1dQakVacjN3Q1MrRUZEQ1Nvc1REMzJiYkJQbjFmLzlCWWhiZThYMWJrTnpPRGIrYjRndlF4L2p2ZUZjd0JHZEQ3NlU2K0ticUJYaDhqL0t6QmMxRjhQbGljdVBRYnRVZlBkTE1IVUNGSVovSjRzVmVEYXN5bVNCM1FoeUYxMk9PTnhNY0FYL1NKNTB2dFpzN0kxRVBpZFdRa0hraHlFSmFGcFZaTFpEZ0Fuc0FpOUYrYnZ4SDVMWWVoeUhNQk9GbWN2d1djWElBOFlQWGxjSmVqSGYxN0FBODVobUgrUnY2YU9ZeHMvZmZDYTZJZjN1TlVtNGFTQ1VEUHNFTThhN0owRkNWcElaa2h1U0U4M3I1RENMd1J2dWlnUi85em00YVMyMGE3MHpHTG1PcDZGMmlKaVNhYm8vRGE3QWx6RnFETGQ3NUNaMFdZKzkzbWc5K2UrSHpidHNON1BqdXc4bHd1bEVDVlUzZUFqMUJ2MkxiWUdQdU1JMWN1bnBUbTdONHdmK1hDQVV0bXpsaTdZWnBrdS95TjdHOXhuNjd4bG03V3VGdm5FSmRocElkZWtqd2VKSU5tREVrblpBb1dyUG41VXRsUmZDRU9LaVNBTzFLMFBhc0JuSFByUHVVL244dnhXWWtLVnBDSGxvOXBmV2RxNGUvWHFiOXIyeGQ0T09tUHVEaDk5ak5YSnhXYTcwT3pYUXJYclk1NVp0L05sMnBGTFozb0UweGRvTWlXK0JwYUptK0p6L0d6VVgyZlhIMWE1Tjkvb1R4Z1VrVWZsSElaNTR1V2oyWXhrMXEvRU54dXlxdnB1bXZzUm8vU09ZU28wRGYvUGhjZzdObFVBbXZtT002K3NtaFI4Q3RlWHQ1SkFWMXo0cE1jMzgyQ1N4YnoyNTYxTFZob0VQcndRbmJ2SVVJQ3gvQmVqNHFieEh1eVgwb3FSNVQvZ0hpTkR3cm1XQ0RlN3MzY1VMeXBHNG9obnV6Z1dyK1R5aFY4VTZxLzBCT0ZmSTRGa2VSWDRvbVNVaFY0Z0U3SWh2NnVPcTRLMWtPM2c0N0FzOHE0MENzQW9QSXJ0cXVvSEhEWHFvalYwSjRuVDlHdTgrZkJxMCtmZ0hhbDZHUlpXK0J4L2l6d1FJL1Bua2RQK2Qxc1BycjZwSlNnRDhUaDFDK29oU1plVThmclhIYzRRSk9XUU1xZmZEU09vR3lybzFCQmlUeWViaVg1ZkNPWVA5ZHoyTE1EWkxlRFlydW51MUJEdkVQTHVhQ0ZaUlRicUptYjNZRWVvN211UjdzZnBIdWJYN3oyWUliTmJkZklEMkdaTmZ2QTBBZC9XdTE3Y283MUo5TWJMZzhOL2VaWHNCZ04yMXNVR2dydG1BYmNKWktOOG9RMmJ0YVpidkpSTmRqVkc4bkZXNHJLcGlabHR3ZDFZVHNyZk5YNjFFUGU2dWwyajkrRzM0cytNRFNtNjd2cmYvUmVKYXJIMVV2THM5VG1pMlZNNXpnNDZhQURvZEl5MTNQNGt6ODA1SlNnUm9BNFhuR3cvREdXQ2RmSzhzWWJicWhTZHdYb3lURUJnN0FjclJnUFh3eU96YnNWT2J4Z0gwWGlRTUhrTTVVNGJJNFpWT0pvNzVnaFN4eDBQV0laUS95TjVtd2hpRmk5M096Tk9rRldkM1NoN3NDY3daUEo3RHJpRGE1cDVsVmE4WnBVcEcwaWVpY3E1Rm9aclh5YTFjb242K1VqUjEzYXA2b01SK2h0NFlaYVoxN1YvNTZtV0ZkNlhHZ2hhKzBEckw5L1NmWDNURGUrbU9yUlJFWGxQWVNtUWlNSnFWejMvT2RvNk9hWWFPYkhSUTdjbEozZG4wUy9SQ1F4azlVR0tJTHd1MytBV0hUK2o5L1FEUkdPK1BiQWdkdU85MkgvMndjT2ZNdmZrYzREaUlyUUw3K2lPK2lEdnk5THhVZEI5SjArT1RYdmdKcWZsZUErdlZCK1Yvb0N5eTZCbklWNzN3M24wQ2xxT2tReFovZ2lFNUY5c05aR29MZTMrUnowd1ZxYm53L0lzeGVTU3hxNVhDVS9GZnJNSno4UmhHNzdObnhYWi9EeWQwVnZkTEZSeUc2NFZHUERiTkdkTzY3MGhlS0lpMzYzV29GZlJYZGNOZG94eFRFUUQycHE1K2Y2NU9LKzZZUG5XMVBLeTRNVXp1STJxNUdPaWVIdHk0TnRYMXFyaXgzUzlJNUVqdEN0NGtRTFlLY1dWSjBCREJnOE1lTDZGTkJ6L3J0QXVnWDJXMUZQc0I3dDMzVnd4eHFRQS9Qamo4OHJ2WW01Nyt2d3IrSlZDK3hPYkhacTEyM0Y2TWI3Zm5YSlJQM1JPbXJ5VndWVVhDY21XZDhtMlVIc1ZXZ1VsczU3eU9BS01abmdyNXJ5akZ5S0V1WG9Dd3pCVFVDd21xeVAyUFpncHpNTzlQVGlkOFNvOStPeWliMmhzSzE0NWZsQW9lR1JmaHMrUGJCeHc0R0QvQi9vd2JtSUcraEhFSDU5RldnQUp0VUlmcTJkOUhaZXNQbmFJVEV0Sy90YVVjUzIzMzdiRnZIQkQ0eGZiY1RqVVluaWd3VmovZTVOTjNnSXlvam9nc3NxR3dFN010TmxEUFB3cTh5TThucjdVS0l6alJ2aERTcGpqWXBnb1I0Ukc4SGNFOWV5MHdkUHViQUhyUVBwTXhZdm5ZYi9qWis5WU9WeTlJdlFjT0dDMXlkVkM1aWZzWGdGK0FPTkhOaTM1K0Qrc0U5R253ekNOejdDaldpQzZkZjc3bGVBTkhQdnU4ODNjVnl4d3BYODJiS1htRjhNNUpMUVlhRUQ3UTlWSjlUVnFIcUphSFZBanVxQUVrMXZxMjV4Wk1zVFhIUkNQTGdwNWdoNXg3UHd4QzZEZDVxM3V1WlU4b2VGSXp5SGw1MGQ1QW5tZUdaMWdGM1JrT3lodno0Q004dGlVUVpvZ2c2RGoyREhjK2g2THo3YmlmTk81MmRiS3F0VXcvdE9HZlU3bUtYeDVmSFc3c3E2WE9adVFkOTArcUJ5Tm13M1Flb0FZTUljMW9RWlRxWXAxd1FyYUlRQkxCVlVBSTNPb3RtaG5CcGhqRTRsTkZqNEN3dXM4OUdJaFR3NGhJWXZCUDBXV2hlQmZvdlJVUEFadndnOFJON2tUNFIxb0NlS0F0K1RQOGRqeDNtUjZZWDl5My9qUDZTK2JuMDBlcUVyUEtQT1ZTVEVKT3VJejFjSVg2d0I2bUwzS21xQXhIekR6K3ZiYzhDZ0czczNQTUg2MzZZcGM1YlBYYnh1M2J6Q0dlK01XVGNjU3IrczMxUEtWMG1iRkZsOWF0OGxIMys4VXNxYU5yclBrTDREKzJYMEhERzJwelI5MDJyYXRyVjRMbjlQZlNTMStwOWJFK1kvNkg5ZUx2b2YzODlxbFJ3SHNQNG5OSHgybkI4Rnk5NFJHcGJOaFV6ZXB1OGwyQnZnbG56K3RKQmhieGhsTEJDMnpnUWpYUmZELzBzY1FTanFjQVIza0FTcU1JL0NDZTRncVZYaHlIK0ZLbmg0L2JoeGE4SGNCUkMxQTdmaE1qMnE0RVdSMEZvYnQrY3lqYzl0NjZZZi8zdmQxR1NFc2FBcFNFZ09BZnhsSzBwZWFvdUZVY1A3MFM0OWkyYWh3K2o2RUhBRm1NRVBiSzVpM2lvbVVUcGVkNE10cVZ1VE9zUXRKMUd0TlY1Q0hpVHloS2cwQm9iZ0Y1V29qREFEYjRNUEpMQjVpVlZDT1craTNsTCtxZzM4SWt6WFlGQzJsQzhFWlZNcGc5UE9zZUZ1L0RwMFRNTjlxakVQbG1yTUE0K2pSNjRISHNkdEhnYzlZTjZPWEk5Q0R6S2NIbVE0UFlvODhIRHkyaDZVQTBHb3lNOS9iM1hzc1JKcFh4NitxdUJuTjc1VUNxMzYrSk1Ya3ZmYytCUDJTajVGNWZYNGZhdFFsaURTOTcxTzMwZnh1NFdPWENqZTg1Mkg2SzZlT2k1dU91UXcxWThpdWZxNUlCWW9XY3VwR3pueGlkSTVHOEg0L0pMQlVIeTY5c3J2ZjN4di8xV0F6bXpsNzU0QThiL1Z2Z2ZxZnJOWnpWSk82S3RMOEVxZTY1T2pManZKNk1LY05UNDVXOURZZkRTTm4rajB5Vkd3WUtnUFh5OHFFK1NpTERGRHFzeUZjUzloRFZ6T3hrc0ZIRVhhMGVGVDBCbXFnMDFRZkN0MDdtNnErNEszemhCT2ZFeTB0dGg2SkIyTTdXVWlxTXQ0MndvWWY2RHFZc2JNc2xFNmNQNEluWU4rN3FtOVNUMHQrWlplRGZhYy9tcDNnNHdhK1ZFOWtuZWZFdktYTFU3cEdGSXRMV254MGpLd1lIRkN4OUNxcjlWZnNoQUdFSkUySkFnOFFYemxxdWdFS2d2OEUxMnRISXphZ0QxQmxZbm4vdGRBckJ4UXRzOC84TzdSWTc4RW1mazIvc0dvckpUMVh3THV0QjIwLzlMWnZFVUhoWFowamJWeHczOTA0b1RiNDNucE9jZnpWR3hZUzViTmNDd3FmSU01ZUN4L0hzc0hQVUZ6K3Q3aG1JN1YrTDNxZVlWdXA5YzVoU3RNMEM0Q1QzY1drZ2o5Y1FVV1cvRGJWMXRiTDJwMTVsVCtPeXZiTG1scUJaK0hoTzY3RFB6UmI1dG1nR3JCMEZkWnMrSUoydlpHei9QdmNqMGQ0T2dhQW5UdjRvMDBnRXQzU0ZFTi9HZ0ZWNnhQTHlrTjVzOC9PODdrTmNBVm9ZUFNxNVRIZG5YelB0MDgxVGxCL2ZmbkZNR01uS21ldzU5KzdhU29yQTdxQVpvVHFpRFcramhoSi83b2VrN2hLcVg4MStjVVpyZm5GQlpRQ3BMM25UbXpENzJPUGlhZjM1azFlelptcnZrSGw2LzRqRCtIOGxHVmR3YjJuNi9LL1dKblRHUEZjd3FGU3AzajZ2K1RjNHB3aGR4OFJpdDhodmVFWWtJdHB0ckVxSFhzWkgySzZlV3Z5L1MyY0VQdC84VTVSUVY2WEdnaDgyMEUzaVBPNGowaVFyRzk2K1FnMVhYR3c5V2I4M25iaEQwMG1LcTJvZkV1L3JTcWJFbVVRNmlSUUZOaU1DTlBpUU5RSEwxMUtCVC8vUERjMHlmbnR0NFc0ZENQQzlaczRYbFVIVnlINGhiKzl0dFdhZWxKZFBxWDJuZlI2VE9mU05QZXU3ZE56QlkzL1VUMW5JM2xkeVV6alVtSVVPSmtkTnhDeDZWMHhuSlZBOUsyQWdUN3l4ZytMbVpqUFVKVVJESTVlcEcxM1JobUtOWURXMGFBWkU4Z2xINEhKUFRzNGhsVTVvVk9XSzFnaXdwRmxIb2RoS0hUOTJsb1RKVWJxTExRVVBWZWxZR0lJRUh6NG92eFhOR2NNVHhmQWxTZ2Zldzg0RmlDREIyTXA0SDNsMTBlelJYa1FjQU9HcEpwS29nSWtvR01MN2FTVS9CcHdEaGkvRmU3ME1PeFkwRVhkSHJHRENJaWdoM29OWEFrZE8yb2VUdlJ2bDZGWU84VVZZLzdWN25CL2lHbkZ3ZktmOGI3K0NXOGI4ZHdiK3R6aFZTVTBhdmpMOVYxSWlieEFZMnBRV1gwbUhpN1h3enhENGlwZ0dOZm5SN0Q2TDBCUkwyN0VFZUFoR3d4eEtORWEybC9EbTZ2QW5IZkRuMUZJZTdYTElob0ZPYnIxenFrV3g4R2RyOW5qeFVrQ21mUlZncDI3MDFnY3ZxS1hsUEd3TWN5NnYzWm5LdFgyVDVNendJSXZoeTRMbU9RM21YNGNsNkM2aWMwSFBmbEpicCtlLzd2TXA2OUdzUEFyUmF2UGVCNWtlUm5JUEMyV0ttRXIxU1UvajcrR0VMd0U2b0dvUnNwOE9ZV3ZIYUxmK1pVckU4cXQzWlY4TWtweHJsRU1PZi9rM3hySkE4QTZnQmk2Yk9wbEMvVTREaHBEdlcxQytNR1BFOEw5WEJoZDNiZ3dTbXczM3FmUWI4WCtzMllTQVlXdmJzTTFiRlNFb21PcFc1cy9BbkNtTC9aaTdxZ1Y1ZmJZMkgwOEFGd0kwaWVQWnR1YjJrNzVpOG9vZnJYRWZUamdCdkFIL3pnK0FVMW01YlZhekp1RDVaSHBQZHhlNGlmVExZYlBxZFR5WFNJMm1xNHBkTXJob0p4Nk9hK1QrbC81Z3hUamVnOHlYdlBuTUdOb1NyUVFkeU9XYk5td3psZ0syc0pqSEY4aDVtYTBnS3lyZ2wrK0tYL0tUK0ZmK1gvcC9rcDNrQ0h0ZmtwdG02MWdpYkNWZlNoUzM2S3F6bG56OHJyVkRDS24rTjFla2YybSttRlZ5YU5HRmI5WnRpWnhDbmxUQUx6eFlNTWM5dmJGY1B5bG9waDJhMWJDc093REhEaU42NUZSYksrKy9vL3lZYzZrRGYxSkVrckgwTGlPcURMT2VkMG16SFJzVVZycldnVmt3cWZIU2MrSFlxYytnbmVid2VKTmk1YzUrZXRzNXJwbkRMZFFuR3I1K0VHcjJCeXFxeWRpZFUwcU81NlM2UG1nelRvKytLeHhYWGlkdVp2TzI5ZFlpMWNQV0g1eEFrclJOdXp1MmV2REJrMGFNaVZzMExnczd0Rm4zeFM1UHlYMGIrcS9LNTRBemNtM0syZit2T1I4LzV2NlJkdm5GdzcrTU5hZGRZTytmQlkvclNoSStkWlorVU9uNFdYUzZ0anB6Tjc5ODQ4ZlF6dWQ3UmF1R3JWUXVlLzlGeTMzQ0hidVFnZkdPQW1UNDBxay90NytqSEx1WXZMa3A4cXFSTzhIZWJ5QS9YTXdMTWlKM0FtMjJWTFJlVUVzQTg2b1pqRlNrb3dUeUJmaVhGTUdJQytKdVl4WVVET2pSdUlkOW9XWWZrTnZDWitsRUpvRzBacjJxQndBbW9KTjJxOWZveXViTUhrNm9ubG8ydldmOVlnTXZXZERjcEcrMEFTazUrUEhiTVNZQXFRSkdzZ3M0Nit2d3ByYk5sZ1BKcmhPSUE4Rmd3ZHVBVFBxWXZsOTZSQzhUaFhTL0ZncklYSnJPVVdYaUlhZjRsV3BwRVNPS2c3ei9Wbk9YaVl4NE5JVXdXSmVpM0tYOSs0Y0FyQ2JEYmFhbEQyOW55SDNVVEZwWmZ4OGs3QTRPSzQ2Ky80alRydWpsQWNlOUVUcTVWL0tWTHJ2bHNqSjV1Njc4cXV2ZG1PQnNUK0NyajFlRjFOdy9KSWpOSUh0S1Z1cFhBcXpTbDlvT0RRNjhRUlU3REFUdXJKU2FGZ2xDMFEzcm9kVjJlNENLUEpVUDFsV1MweHVhS29vc1p1RTJFbWhwN0ZndXJQdkI1OEl3c3Q2OVlMRUh5TjZ2SWZiNVlsbW91L2kwL3h4dGJqQ3FoTUpaZHJtN0Rrc3VNdWsyZ2lieUZ2ekVVZzhhNFJQcU4rRFg1SzlNNi9jWERTTWhGTzhtQ2FuazJnNFZjK2VwbE5CUWEzOEJTcUIwVHdGbjdsSC9rL2ZWSUFnL09ndWNBUkQwR1p4Q3dNS0lyNlg3U0doMWhPSzJvVHE4U1pkRFpLdC9GZ3FwT2dWamV5Qzd5SEtqTzRFbWFzU0ZpTXhRRExObHZ0aXdyQTBVSGdXSUhqQ0ppMHZJWVVCZEtKUFF5dG8vckRaMkNnMVVwa3RGK3dUUE9ObkhPclFIT3k3TmErL0M5T2xyVXFubDN5a1BQOUZBZnlHbGxBTmlzd3hIVnlDczJFQWtJL0w3ZkZ6TllIN21iUUYyd0NMVWdmYjZMOXZSVk54RFBDUXJvYnR1YUhQTzJrZERycitMS2x1TnR4dTc2VXo0N01lQVRrZHRFVFJMZXltbHNIN29ydFV0VzdTa3lLcTZRSEJBYlVabWVnVjlhdTRPZTNDNDhTYUE2NkFFOHlSSXZwY0MxRUY3RjZXaXFQMW1kd0hCNG5lY3pZdURsbXNsRWo3VnVOMjNjVGoxc28xajZHL0JPaWtockhRcjdRY0JmU0NrOGZpY1ZHa3pudnFWL01sYWwwVXAxbS85R1orUW5LZENOQUdxWEliN0hVWkJCRDQzTnhVeU5XMy9ndUczVVNocUswck85dVdOL2I5SUdYMWJCKzB3cFl3d3o2T1dxQ2dtOE93TFdPWHArZVJkTkF3YnJwUnNkZ3VMTFNqTFZvR3U4Tm16amI1b0hIcmhxV0VJYjgwMm05Ym9UVTB5U1BBTm15UU5ybW9WY2NnaW1lWHlodG05NjJuQ1MzamNURFdwSzBUUXNGSU5FY3NmclNHUW50NWQ5SGU3KytaRjIwcHFWWHZxSDlod3RBU2NBVHg5TWozM3dLYnFQSzROTXpSNDZzblc1RU5jQjFyK2xyajhBdVlBcHAwd1dPODVEd2VFWGhIV3FoRzY4VXlwQXJ1S2hVT1BoV0l2enBGeVZ1ejI0d1UxNXRvTHphWUdSUWZyclVtMEhVdFRhYy9ocE5PWGxOL1dic2ZreDlBZjJlbk1LbUxSNWRrTVlIQlZZWTM1SVBGbzFMcW85cVdxMkNOeDFtUEpnVkJsbVlzWVo4elY1U3o5RlR0RGw2NGVHR0JNRlhJakh1TmJpYVNyL29naTB0K0l2RnJRRG9kdUIxbldUbnZDM3krWjAyMTRNZm5kczB6TllXUnE4UjlCcEZrOGZyd1ZoY1o0SXYreTUzaUVudU5uT0VHS25PaUo0clpvMUxTRVE5TVplNkdNQ21TMDB5UWZCTTBNNE5ZZnFhSTBleUY5ZERBVmlvcVV5bnpoVGNIMlBRQVA2MElZT3J3eVZ4ZTFsLzFNSE5xYVB6Q3ZWeVdkZmFNeE83cFVvZDBtaEx2QzdMdEJSSnU2S09zVGhXMHhWMWpMYUVVbHRDZkRPZnlRa0xFdFlrMkJJT0paUW1TQm5OVEhVVG1pVjBTc2hLR0pIQWZ2SElzejlJQUhtMmwzQnhveTFPVVZ0MkhJejdPbzZpM01hRnhjWEhOWTBUTW14SmhPdlJzQzNtOHl6RGpKRUlQN3JBWEF6ZkVVbE9OTnpMRndFL1orSzhSZWo2cFpicG5ZYzJmYW5Ya2tYem0yMDdjL0xZdEdtZjdkNXVRd2ZCYWhrdzEzWmk1L0F0dGFPM3ovejBZdk9temZzRWQ0dFkybnZvbUk5bXZiZGt3S0laQlN0eWdDQWo2a0t1Tis3VG9WSUE3ZFBiYnZaZ091R1VQbFh3WGdqWDBJSjZCZWtzVGZZNkZyb3AxNG5YOXFmZEw3WU84eUtTdXpWWTI0V3NjNjhsUEVpb2xORXNna3N3Sm9RbnVIYXpzNHd4cjVtNVloblBrYTRqb08xNmVUVGtFWkI3VitNdjg5eWhNS3Nqc1B6am9oWHZvc3VneHNIYnVmMUdqa1hsaDE5Szd6UzBhVno2MHNYemF5M2JzVzNMVzV2WkFNQWVBM3AzeWg2d1ltYmFaRXYxU2IwV2JOU01RbDVtVHRZQTNwOE9BUEdiWmpody9oS1lUcytZNUZoci9IMmREbE9TNGNjTWZ3RitqUFpjMis1YlRjR1NJUkF4Q2x5TUZsZUd3TWk4R0RWR2g5T1AveEdaM3g2a01ERU1vZittSzNoa21TOC9nVGlzOFJQS3BydUI2Q2ZlYW0zYk0zZTFiYzJjL21xOFlwT1cyOW5SVGE0bzFhYWxPVHV4VjJVSng2dkc2OXJCdTFpSUtUYS9jaHllQk9qWlBoNTBNeFcrVStJQVFlVm5KK0VFeHVGYTBYNFJPbHBBZnY4SGEvYUpFQjZBaHYwVW1sODVENi8zQUxYNlpZc29icjNETDcrelFSUTMzR0c2ZXlpV1o3OFdqMkpwOWhXTkxWY1hDZWZxdmtzRUk0TXUzUTUxV1U4aGdiOVlSeUpCdjFoMmhXR2hlSmROcURON2FEVlFxWGxtRFdUTlE4RlR1ZkxzYkg3UHdnbGdVUHNSejdJbzJDTWdFWHhDcEpES0JTbzBVS2JvMWpTbkJuY3hHbnhkYVREcmc0K0pERzIzU05GN2F4ZDBDMHNPRFBhS0NLalhPUlI5bjRXbUZRQy93a0xZZVZLdXIwK0c2TldzZTlrT212T045b2Voc1g4MHRGQi9sNzVDSXNQUkN5QTQ4OFNIcVlvYVZ5Z1N1a251UHNqeXFQZmxTN0d1UmpMYWswd3BKS045ZGJWc0FlcmdXVWM4WnFTNTI0d0dycGZZbDJIRW9BNGVUWVNPUmhxelR1NExvNm5NVkZDZUo5eVVpTTlXdklJTm9oc00xZWdtVUVuQVRCUG1hcDMwcTlFTzBrZ0Z0bGpDUll3R3lSQm9TWXFPaWNaTEpDVTVKU2t4TUNnNHlCUlRQeVk2QnQrWERNUUJJVGdvR045UFRrbkdxMlhsekF2NWw5NWV2bnptOS9rWFpxN010L1pmbjcrcC8ralIyUnZ6UCs2ZlQ1YksxdVhtaVFXbWxWdnBjdG4ydmluZkdyQjhHM0h3WERET2JCMW5LbGh3Ny81dkN5YWFKb3czajF0d24yTzRKeFB3dXRsUDI1YXE4WUd0NEsyZ0Vieko4VU0xclhaS25YMjFlMTlOM0R5UnRxd3hxSysyRExjR3QxalRKUHlqMnRSQW1HOHRIdkhXVzNrMjYxYjh6NGl0cUZkbTZtVHJ4TlNzckk0RjFzS09tZE5IK2IrMTRrSEUvUlhUL1BOR21xZXV3R3RweFZRenJMNS84aUN6MVJvd2NQTCtpRDFUQmdaWXg1a0hUOWxEZVFJNXk4c3gxT2ZpdUdaY0crNWJUVVI2aGR3VzlldnhzYlpBSTVuS3ZpUVl3UjdwU3dQUUkrUHRsWHdwV0VPZy9ramNWKyt6SEZOSzBoN0hsZHFiMWlPSVd2aFNNcjllVWIxdDlmaU1IWDcxd3VyQlBMdGZmZnhMMC9ya2wvcEY5YmZWSjcvVUQ2c1A4MnoxaUIrRnJiNnh1TEVUYmh2ZkxHNm0rWXByYjE1cWF4NXZhNlZzVG5hL1ZoU2NPaVZadGRySTUzSDFrOE5BSUZFWlhJL2w4SjVsRHJSRTFxQkN0NFhDd09FbEZVT0dSN2d1YlR6LzdWYnJqcGZpZDR6ZGR2N2NKc202aEJ3OFdsZE56bi8zM2Z5OHNNbm96NFp0TzZaUHl1MEVqTU5SNU11Tlo0dnJvSGp6a3VPejcyOE5Iamh3OEszdllkTkxOMFhZYTlkNngyY2ZsM3hTQkw1RE1VV2ZsSHdNbTY3ZkJkcS91YXBMYy8rd25IRWZvS0s0Y1hPbTAvR1pXMzVYUEN2K0tvL1BjVGVJQWY5cWZDSjkvNXZ4c1JlUlMyNDlrRWNIaFExUEVibmsxZ2YvYWt6c3pRUEo2YWh1VVA3RmVEUUdpWUgvWWp5R1N1OGZPLzdCc0hXeHNXdUhmbmpzNkNwcDZEUnlrSm8vYjlTUWFkT0d2RnQ5Q25yWXNGMHFIbzgwWU14RkVTODNma2RvRE1VTHA5RDkweGN5OFg4WFRnUFRxUXQ0UEQ1ZWdlNi90MzdWd29jUEY2NWEveDR3cmZnWURINXpWZWZtL3RWenhuK0kxdERSZ096Y1cvcURNMkJkNFNNMzV6eTZhQWg2cU9VS2Q2azNaUmdrUHRZKzM0QjcxODlBUXZNTkpFdVJvYWtCUzFDWUZRSk5wMkt0U1NpMUYwcTQxSHdKNU8ySWw1cVM5TVYrNUlaZkdEVjQrT3RCTXVsQllGSkVjQVRtSE9JL0hVVkRUL2duUkR0eStXaDNSK3JTQjUwN2p4ejUreitkcTBOMnJrNHhsbXR5Slc0UXcyaVg2S0FjWGJkSjFpVUhTVzgwSlpkNHRYTXl5YVdjWExhUmZCbHUreWVUZGdlNWJNT2RSTHd4OGJ3bFh3K1NTem0ra09OQjcxSzduMy9ZODdvc2hYWFpQNTdlZ3k4QmZBalI5bHg0MWQweHZwalp1ZlBVcWVqN2Z6ak1COXcwdEVqWWpHWFBFQ1VYc1M1aVJkMVpnTk1UMjEzVUozUVZLZ215ajR6YklKK0IwaUNJUmdEZXQxNUg5MEh0UDM4Rm9RSWNjZUhUZzdkdUhleUlGb0YwSStnSnZDaE13OVB2SmRzeGRQSFcvVi9RZHd5emJCSEZMTlBUV0dIMyt5OW9kT2RNaUdtY21YLzQ2cFB6VzI0SmNNaUdDZXR0MnphMHd3VDJNb0hZSHdnVUdUMkpSYnRyN3k4aitWQW9Ga3dUem96L2gxbWhUazNIN3hBTlViekZISlVpMHI5RUhuK0h6VUZFTXJxeWQrYVA2R29TaUxxTWZrZ0JscFBUZmdkUkRiR3NiUHNrY3hNcUJ2TTI5OTRNWm0vTzJnd0dvcDZiZTI4aVkxWDJrWENvM0U5OGpPZTNQOGtCVWN6cjhxTGdXUk9CbVpMRFBBS2c0V0tqQ1NlRzdzUFBGSXJCNVYybFFDeXYxdUhzM2tiTW9iMk4yZ2VKTUVUampvdE51dG9TYXREOHFSYnFtbzMxcHFTeWxjT0JzVlB1cEY2cGJSdWlQeWVIaWFNK0hKOVQzYjk1NTFWdmt0d09vOFU0OUlyVUI4dDRIcHdkaUh3c1dmNkpnY0VHeCtqWlRScUlsNmZQR1JkSHluMk15K1VxNVhpT2xvdEppY0YwWDJ2UUJMd2p4bEZlNS9IVUd4MEZING5iT0pZeXBDbVh4bVZ5dVZ3aFFkeC9JOTdXUDk0MkduTjBUWGZqR2F2TkUyTjdneHBjM3pBVzk0STZHYTgvc1ZIZ2EvRlF6ZjA2cGJiUlJsdDljaTB1ME54L3BkVFd5bGo4bXE1am1JKzZDdUhoK3QzOEQ3Ly9wOTlkNnlzcmg4S0l6S3c4QVE2c2w1QVFCMzZHWWw1VzFrZ0JEcXFibUJEWG1YNGpQK0p2OGVnYjNWZEhkOTJqamplaGtKZlZKMDhrdjlhcmkyN2lyNW4wYTN6OWVuVWIwMjhqUlRnSWY0c1gvcFRTQmd4SWsySWJOcWlEN2tvZEIrTFBkUm8wakVXZXpzK09KNXI3UDBtZGNuSTY0YzhONm9oVmxHZWZYNTd3YjQrbnRWQS9NRkE4emdtY0orZExUNjZyY3hiTXkrTko5Z3dzUnRpcXhkdGk0b2xacWxKOFJkMkxzbm9qV1hWaU1GNXpmQXhlYmlCRkRJekNheTVKQkNsUndaSUlER0pNRkIvRHA1aEJzTm5BbzloSzR6TmJOL0FlbDlVR1Z2Y0JxV2o5c3pFK2FEdm95YStFb0htcktGUmVobm5zb2RZZ090YTBwUGx4UHRPMHRNV3hWM3pSRnRCSCtOQVhkRUZya01tN29PK3JqY2dGYkRXdWFCVmNYRGJQdEtMMUYvQW5DTnEwUnVmTGJrQzA3MVhBNHFjUG9tdGlWeVUyM0JqRFlzTk5CczVQZUxYOHVrdU0rRnAwVFdpaHhCR1FzaVNPZ0pUbEUrV3lTanlCM2g3Yi8wWDJXTlh5YXZlSGJpeXovLzhZWXhWYmJEOUsvMkRPZWJMbkZuVGgrZVpYazg3ODZ2Mi90ZUo1RmxpeHZXTWNzY0NLN1hPMmJ5L2JJdHRmSWNYRFdJREh3SWpuYkFzMzBleHFVRE1IZWZsTTFnVkRTTy9kUjl3Z0NIRllHUXMyeEVpV3FJaUVsSmlVNEJSMnFBVVM4c0dqbjU5Tk1oaG1kRmc0YUNtYUNpWU5hait5dzBReGZjZE9OQlZtT0Q0U2JYY09IUjV0a041dHRiWmVUdGpVVnZQRlh1L00yU1BMU2N4WEgrdVR0YmgrYmp5M2RNY0pkQ1M4WEdlU3R5ZUpnYmViQWp4WnBKSk9rUEYwQlVoWFd5R2ptZ1l6SjNTTHh1bWNOQTZyeitKd2cyRnc2cUFlQlNNM0oxdXovWkkzano1eTJicDI5YmhsMGJWV2p1N1hPaTkxYUNkUS91ZENUNCszV2s1dDFMV1Q0MnZ4MG9hZWZkR1h5SEVhQ0tONk9mN3VrUk0vdDhXTXNaOFJ1WUhFNDBZWS9KMHhELzhtRncyeDlVb2FWU0dLT3FRa0NoRU96M3o0Vjc3WURwQ2tHNkF2OFpmRzg3YXh1TmlsL24rSWwzT3Ruem04SlBLTkhaZXNNQ2FmeFZTQUhvVCtXRG1Yam84aTk3aTE2dHE5b1JMUXFmV3ZFWWczRmJIR2ViamtTUVVNN0RhUkpZYUg4OUZIK1FzVzhFTWRsVUFHUE9Kb0RJL2t3Sms1anFzY29JZDJUYWp2WndjM3A4YnErMzNZKzMzaVhVSWxDRmlBNUpwVHBNTDcrNk5kMW84K2dpc2RWMEE3OEJoNWdjYzU0SWNCYUJiSkpZUnVDZTBvN2xRM05adW43bWhBTlEwRnV2QUNjNkRNQ3p3citJTDd1OUNTR002WkFxQU1zQllMbERSRTU0QVBTUDdsT3dtcy93VDhlZUVjelVyaytCMzlpSDY2Z1U0SXNNZXpnN2Z2T09LWjMwRVIrcFBmVEhGWW5YVHExcEI2Q2hmZ1FxZC9nSk5PTHoyZEpsYzZFNFRBSUVoQUFWT1NveG1kZkVQSGxmbTNRVFZROGxuNDh1a1FYdDQrbjBaZ290VjNia3hEZjBWbFJPNnpidHZ1ZUtMRTZBU2pWWVpBaWd0NWpPWnNIQ3Y1MGZ2VjBDckpqK1JRQmoreis2SW5pNHRFcnhQY0dIei9PTHNQaXNwTDhQMys2QTBTTjRqdjM1VHZKNVhUWEVwb2xWaVYra3JHc2Z0RU1TTSthbWlWVUl2V2Y0ZmQ1eTFVOTloSmNsTGhMZ3pRZVVmcWRGYTNMZ3lxMTRMWmkrWm5NTWZiNDgxRVI4TVhYWm9LSUppcE9ZSzZwaEFmQms5b1lkNENMQTZPeHNJSlMxQXF1TDhNdGVtVnN6QS9mMkZPUHpCSnRCSHdITGdkWFFmVkhhbjQyMEJRQmN0SHl6SE5CSk84S2U3UUFBVkxSK2U3cFF2ZitRZWFkMlNhYzgwa2RzOWNhQ2JCWG1ZUzdHVXVNc09SLzZJTkJFV0V0UUZ2VzdnTlBtZzltTE1hYmUrUTgvYTRjVy9udkFZaWhJYU94NDVTOE9DMzMxaFEzKysvZzJzY0tQK0w0MFJJMTlRME4vcWU3c2hVNTQyaHBnSHc1VDAxQ1BaYTA0TXU1TkRMazJmd3FUcVBEWUZHNHhoSzdXYmc2NHhJbERkZmttMWVqa3lFL2wva1g3NmNEMHpvL3VldzhVem9XQStudzNsd2krTjE0ZjJjclZ0ejBGaTRXblEwY0VUUUdNVkttRTg5bGlyak5vM1NuUHpxM0RnRDNJMkpzMDNReU5yazBnVDRQelFCN0p4dDNiREJDbHFoL1pQQW9qa1FwWUVmK0ZuUXovRzdjREhuMHFVY3gycHdWRVNWSGJ0RmhuWE9jZEpnS2orTWR1UE5vRE1HNmRxZytwcDRRTm5pYjgvMElPTkNZZ2NMUGVaNzZNZUYyUHkxczhzSGVEZ2JFWkhrSko4Zi8wVStDb0o5WExvZml6Mk92dHErVDhUenFTN0Y1TTc5cHhqSWY2S2Jrc3dDSWY4cmt1SDE5ZVBRQ09qcEV0SEtuOHZSaHJUS2ZLb2Q1Vk94TXA5cXlXSjNpYnNwNVZQM1pENVZuNDdOZm80ekhLTDc4QlEzSGtJNlB2VWM3eXB2THkxdTREYnVJTUVOdk9vV1F4QWFYVkxadVJpT0l1aStLUWVBZ2tUK0ZiNnpJenFmNEZIeEF2d2s1MmtKWE8zb0srOUxlR3ltMHYxN3NwdVlXUjJ2ZWc3ZGpGZHhtRmZoNFlVeTVYazdpQ0pPV0JacHdIejhHamp5UHlRN0dMNEthNkEzV09UcW0rRG5BV1V2c2VoVjJ0L2IwWDBEeWY5YW1XZ3pNcUs0enBGWFRVdWs4K2ZoVE1HeUQ1dmUydWFTekpma1d0ZkhuN2dSQWFnWThNTkduUkN3a1dWZDQxdTZTQUV4em55RlZCYVFabEhzZ0hTVmR0MGhwTTdYeWhuOVpReFNhU2U4bnRPaDZ4UGp1MTV1b2JDd2VtbUFTZ1RmcnI4SEltUng0TnF1OVN4T0YrYnA1UUV0UmtOQitVMXhxWGlFcTgyOVROSE80L0ZVcUtpQlVTOVI4Z1d2UlMxcUNDOVJzc09OeFVsNkJ4T3N6OFJweW9Yd2NVUmRpSW1qbTBLUTBWYTcxRlk3SG12cTdJaVQySi9yKzRkQm1pT01JMzZpMFRESlJGTWZCT0tSTVdBRkFRVDRFL0J3R2NoWlhEcm9RSmMycTd1aVcyajdzMk1TWEw0YitGNUx6SXhkV0hUUmJyL3lsclhodFBhT0xpc1dqNSsyYkVyaDRpb1dTM2dFZUFmRW4wYWdpd2l6ME0rblNoRkNOaC9mM2lCcU8rQitBWEhvM0QzMHlJWnVwUHViNEJ1YjBLTU83WUhIT3VEejZlK1BTQXpVMlBLN3dtU3NMOVhHY3I0Y05VQTdSS2NpdVYxSnFxZldjL3N0M3JYZmJNbWw5cEJrbm5ZWG42eDJsOXBYTENrU05WWXdXQm1TaW9NQlg1UG9OdUxva01nbk9mTXdKRFlCd3VUWGw3VkltZHo2Vy9Sdy94S3A5K1FqSDlkb0hUWThmOTJzbVJ2ZlRIMHBPNlVvcDB1M3JOeHNxVTJhZDdXcTRlR2c5ZVBVcjBBbEVXYWVYWlYyRXYxZHlUdjF6dnpCbnoxRXo0NE5MUHp1TlY5ZmNHaklraE83RncyZitubEtnODhJemh1V0V6K2hNVlhSc2p4NGhjcUpmZERySkFZYzMyOGozMytUM244SjgxbE5qbkI4L3lIbHYzWFJLaEtUamZudjcvTDlTUlh6QjVJOEtTei9sYjhFRnRBMUovK085NkNPYmpETmRFY2hLbzVjSzh4cjdZSUhrTUhGdFlrWEtsRi9YeCthK3hCejJFQUxjMzFLd3AvaFVIRGtIZlRTMXR0U1BuUWNSbkh2d0psOHJiTHpPWlVjOTJCVklZZVBaZlo1T1QrWFNjbHRxTk9iZFA3OWxDTjd1YzRXN1NHeURwUytWU1c4UXhoTEtkYTdLTXNkTEpjWG9aU3YvZGo2K0RLYXpmSjVnZWdDTlB1S2dMTEJ5aHorSXNucHhjZVcxYVNZY0xqL0Q5TCtieVR2YzN0WTdEWHUvMHVrLzBuc05ia1B6OUgyV05BSDBsRGN2eVlsQWxlMy8rbGtFNVV6UTZOck5MQkpuNHpIbTBLYitERi9jYW9LT3BIa3dBNlV5Ky9FczBmRmsydWZuZjJzcWhOUkRuQ2g2S0R3RzQxVlRuZXp0MVhzY0prbVRrK1RyNTRtTDJxNTlORnE1NHcwbGJCMjZCdzhpcTRwWWVQOCtlenNzZ1ZxNERpSkg4TjkrNWpxV04vS2ZmdUE5dTF3M0xjT09yY2Z5MzM3bHc0WEw1UnJwL0grY3l1UHF3cDNJQk5YQStOZGtuVVM0eXVMQWJPWUpOVnZnUnFOZ21uc2YzS0tESldYbWZSeXppL1djZFllM2JibkpOZnZwd0RtK1hrSWZ6MENBd2N4Mkx4T0hRSG9qamJ6SG40RVBnL1R1aHpMMlYvUUhCSHQzSndhVVV5Q0NqSHhuc0JQZHJLVlNsMU80S2g3Y01TTFNFM2t2N0MyYmhkZWZjREJySno4MXMxbURZaUliRStENWYwa1llTTZzWHR2RmpMZnNva0lvdEExM3VCTEl1Y0I4YWtVRm1teEJuWDh3RDBxbHNRQjJWVmJCeTJaS0NNbWFHTzFObGo3SHhoMi82RjErMjRLTmVnWVdLMzYyWHRvR0ZpOFowMzFhbzZPVE5kZXplTE1NTS9xUVBmWld1VjN4SVY0bnczbmFpbFJQN3BqVFlVcWV5QUQvd21rbnJ1QnVwTTBzbVk0ZllBb1hsVFJXbnBGc3BYR0FScmZISnlTSkdmWlZLSXZnbjBCVUJ5OCtHSjBFeDEvZDdVQU0zUDZTU0R4cGdOVUwydjE2LzBKaHpyRXREcmxtTW0zL3ZiMG9SK0RRUWRnWE9sWHZGQWNOTWtUQm9GS0lCMXRRcGNHcjdpSzdyUkk2ZEhnTmI1ejdSK3djdno5SlE2Vy80MzN5WTRVOHlOYWFhT08yYWx0OU9kODVmZ1NnWUpsV3ZUY2wzdVJtd0RaQ1BFV0dBZVNTQk9UbVpsS3ptbEdHc2hUaHkrOEFVTDdTZlJuN3FpYzVzMnJjT1diUHYvSklSeGVQV0wxeTRtTjl5Mll2c01Qd3ZIckEwR2Rtd2xCN3hWMEdtUSsvcVRzbTV6UVhZK2JOT3pTckFQdk9MbENyRDczQUJuSFdxZ1ZHVGYvYURoWVhyZmZsbjljWGw3K04rcEYyb3J2RDVIM3FqL0tEN3JKazB5eGhlbVovekVaRC9haWdrZnRvNXoxVTd3cGV0Yi9zMXhtRE1NTXFpYjZLckcyTzlFcFlRT1ZpUWU1UVNqWFdmNTFpV1Zwbi90cnhVMS9GMEYwTzliQWhGaUtVczVyWlJITVJ3U05YR3lKVUxHRDhDNklkOFk3aWx5TWp1Zm5GOE9ZV1pBUGgxZzB2cWtSamR2ajVURUNMcER4cGo1RWYvSTNxV3lNK1ljc1p1cHlTT3I4U25TaGIwbzA2ZllBM29lNWxYRjRuc1JURDJVWFFWaW1zZTZYdjVZY2lsZytBOElmOWg0WU4yNEcyTHdBd3E3bUt5ZW5JbFFqSTNMbjZDMGJWTFFqT3M3WG1FNElUbEMvTWoraFlmbDFmTDgydWlhMHBIejdGM2FmcjE5K25XS0lkNkFZNHNIY2EvK0U2YWtvS002ZENXLzQyeUV3MC9oaEZ5aGJ1dGZvNDdzamFNSk8vaFhyQi9Pcko0WDYrallON05ZSDYzdTRhOStBbnp6NWkwUng5eE1yVFJrRC82S0tIOG1SMklFL1QvdDU4ai9GYWJxbHpRNEM1UkRrSFprZ0Z4QzlEeHdFUk84RGhZRG9mWURvZmFBSVlMMVAzd0FTbEJ6d3I5b1RoTGZRRCthSDFjZnRhUkxVclEvV1V4aDAwYk5oenZhMEl3TWsyODA2T2ZWMVBEYk42ZGdRRzFsenA3Nk94eWFCM2lkNzhETGRIbHhYM1lOWDYvYmdGTVV1SjlIeUJCV0kxQ08rVGV2WmlOLzdQaTEvVjM3dlhIcmZkWTFUTEhleXhya2FNdWJYTFFYeldZM0JwUmlJb2dPWGFjWGlhMGVua2hKMXhSQm5YbDlXajZUVXd3M210ck1jRFVZUjEwTXM5VDZxZnlTcjc1aFNIemU0R2NVeHFHdkE5ZG5xc2t4K3BKeUo0d3hobE5hM2xkd08wbmdhNzc3QmlZVk9hYThwMDM1VW9WM1NZeVk0RkZ3RlhHWW1SNm12SVJxVS9ENFR5KytLWWVJeDZ0bmIzTTJLVVB3dnQzdGpRVG5XVlNVM3VEanpnbkNHS1VvQk5SbVNLRm5pNWdUL2xCaXltY0V0b0Nab2owcit3dnptZ0JEclFGTk9kSXg1OWZ6NTA0OEJYL2JtMytJeHRBeGQyb0F1b3VuZ0RSQXpKdjBScU44eXVjZkxIWisrQTE3NVZVeTZobTRSbXQ4dXY4ZVhDV21VNXZUblpmcWlGaFlESnlNKzYrbTJtMW4yWUQzNXhNTkNqeitpK0NWSEUyUlVKa1hRMWlUVDFnVEJHaWVCRDNwMDRQT2ZZSmx1ajNMTVdDK2tvWE0zVTI2ajA1cjlxWXgzN2srMDM2V0xlQithSWMrWjNhQW1SYlFRT1MyaUJTbEwyeXNleFdWbnNqblRJNENVakRDUWtoRXNlTk81WjBuS25zVU5CbXZaUEt3aStpZ1pwcFU2MmQ1bFUvWXVYTFk1dzBlb1pzQjdsNjBhQ1RSUnlsSWNla05WWmsrZ3RNNENRMGpaZUxFbUxodHZ0TlZSeTFKc1FyTHZFaHNEb1RYTVRFc2FkQ1VCTnhMWFdZbm01R251eHVxcStMMXRsMEFWL0J5dlYwb3FvQTBRTkpoZzRCNm9uaDhJSGJGOE5rUXRidnlHeXIvYWh4NklNRy8vc2c5S3RoZVBFMXVMT1JtTzMrR05jNGQva1BIb2QyNWcrV3BIb2pFMC9yRWE1bDA2OXJzOUFIZ0xzVzRKK3lkS2VrTkhFcUdrM2FVSENKM2FpKzdMbEh5MmZUQi9XaHlRNGJqdjhkT3BRMWUvKzFLYXZYdkQzQjBiQnlpNDlOSlROWGRHSHJDQTltUU4rMGdlZXB5QUloVW5JSStiVW43ZnBRekR0NWZVZWdaejVVcStKQTlkdmlTMVBwdGNIeDdERERvelRBWnRTUVZYbnN3TDR1dE42L3lhell0dzBRdVhEQ2ZCYWtxZExDZjFVVGxuR2E1ekFKM0Q0UVplVTFLTFZROGo5TGxGWWFRVHk5NEE4RnFJa045NUYzUm02OGJMZGQyd2QxN0RaU1BaT3p2VlpaZ3h2S1lrTGtkeGx3M1ZjSHN2eTNXZUIwTkp5V2pLdjZNWkVpYXJrMklma1hhQU1sWm5LOXFPYU5vM1Nra2xud2tkdDIva01Ubkp4aTFZQ3RCak42eFRzQnU0dkZjZmFVdHd6cndva2xyUFlPNWpaVTBIdUs1cFZwOU5yVyt3aFk1YkZZTzJwRnBuQnpYWFNpK1FEREpJeVRDZWxBelRybjFXNTBPNVRseVdzM01TTFV2eXlPbkxVcDJZMHZxdFRPc1pSbXRsc1JLTEV3aFV5MUtjTmpySEhzdDhndEphMmVDbEtVbnlsV0NaSUlhV3kyTjdQemRYc1UwU0d6ZkR1VEZLL05oc1RzbHZJbUllYUl3RzMzdHd4aGl1anJCSzVtOUxHQzJoZEo2RWF1bW1PR0NpRFQvempQanNjSDhLOWVSbkdqT2VHR3FvOEV3VkxFZTJvOC9rUlhMR2FIN0xxbGFZdXRFY09kbWkremZ1dHh5aElmNzllazM2KzRjejZPL1Q1TjhiNGVlLzFaemxqT1kzeTJjNUhmamZOV2M1bytGeHlvL2tmQUJZTHNoeWc2YXR3ODdRMld2VTJGK1RLQ1BZNml6WjdRWGlGRXVQZER4TDdjMTlRQjR4MEpBRUp2aVNSTEZxeVFIVmhsSndjVDU2RTNWZENDNmNQb3hhTFFRcndNcUZxTlZSdU52UkZrNTFUSUs3YytBaXh5STQzREdjNlF3eUhxQUx2YzgvUzZ0SUwzUkhiK3EvbzdmR2FkQjdEanFGVHMwRHZVdFBvbDF6OGM5Ujg5Q3VMOERmeUFOOGhSTEIzem5nTW1vRDlxSWE3RHo5TllySHdqRGdXN3M1ZlZCUnlUa2V5Q2Yrdk41SGdYT0ZWeU54bGlTRGVqTEJ2bUVBM1B5S2ZGVHQ1dE9uTjhFd3RIakhqdTA3K2ZZdzUybW5YejdkZjh0UkZSYnVtalo3TDU0RHVZVEgwRE9JVnhYYUpBK3FRMFlvT1l2ZDRvWGJEWnlIRWs5ckxJN1FIWkRaVGZKdnVuT0l1dlZrQ29tMG4wSjFNWklTMCtBTExERUt6YkFPSXppL1lQeDBBWVJYSHhWdWdjSjNxLzVrRFNDazR5WnNCNkJvYm1mN213UFdwaDcrT3B1MWhOS2VXMzVIU3BVcWM1RmNvcEtEN1Brb21qUVJxeXU2ZzEzaXFkZDFpRDRQcTM4WXpkVmFMWXlhSm5qZGVRcnhvSGxKaDU0cFVmekdaS3JNR0x5QVJWTHlHZ0laNm9LZFE4U0JwTnp2anc3N0tOa0tCdmRldGs0QWtXRmpJbkZ6SHgwY3NUUWlxWGpDNGUvaHo3VVdqMTVkdEdyMXFQZHFReDRHQUI2azlIZ2RqbjNXZlBJcytOdVozbDhNQllWNzB0RkRkQlAySGR4bkVJajRFMWk2RDBXT3J3T1AzaDdZMHovQ1JHeXY1YmZGNDNnODZ5aVlnN3JsU3dGQVhHTUd4V3ErTWtTbG9EOWgwWFpKb0VEZ1AreVJ0V1FEdHo1YVZZMm5EQVc0TjVMOWxiR1dJT2tOZUhueDdJTWJkdHBMRHFJVllNQjl4K3pDVWYzQndHNEwxZ3ZBRWo0MnNnWVVIdTVkVUdRQUUyZXV5Vm42N2x1TGNvN3NMZHhUcThiV0tXbjlDeURnRHZiK2N1alVrdlJuNkR5L2FqTlovM0hsTndXQ09hUzJrUVo5dXhyVHRQQzRkazhqQ1FheWg3d1VXUkdxMmhhcGkrZTMxNkxJMVhYclJha0RLMDliM0JRcWJjVW83WTV4eHBIQ0wwQ1R0TW16QlZpanhvVElTQ0Q4c0haeW9UalplaGFlbmp4citkdm9xUVM4UDd2WXQxZm1HK2RidFlMYlAwaGQyM0hRL0ZjdjNPQnpwM1R1bHRsL2NOZU1jZjNXTCtoU0VGbk4ycDN5dUw3b2UvNjR1STJMNG5aekZZMmRLcFFTVktPS2ZNVmdONUdmVjhubnByNXB2bGhGMytZTDh1emw1T0xuQzBiYTU1UExRWExCRDR6YzhiWHZWVktvVVA0OVQ0a1hwUjRkOTNFSm5jZERzTjUyVmQySFRTR3NMemdQeWtYZVlrNnlVRVBVOHlaTFFIQWlmM3h3bDlaUlVXR2ZyUHgyM2ZHZE8zZWhuMEhWTzA5bmpKK1pML1Uxb1hzZzJDZnFyZGJUWjd5ZlhmVDJncFhaWHgwZHZhdDJwRzNhckRwUmJDL0lROWY1K1RSV2ZwU21uOXdHeHp0OVY2aE5EVGk3TGtydU90Y21CbFpzSW43UThyd21xdk1peGRsRW1NalB4dzJzSCt6OWxyVWNYSDEzNXR0TDBTa0lFbzU4azVXVjNiT3JGMm1ob1hMZnhLeU13ZGs1L2JPSFphOVoybU55Uk5XcFdYMjlhZnRhbE44MnBPSDFIS0hUUnBWNVVBVi9xYUswejEwK2I3dVhpWlB4RmJXcCs2cTRhcU15RTZ1dlpXSXlXQnhKRmhVQ2hOT01hMFdHalNWTTYvR0JwUjhaSEo4ZnZaNVVhLzBTMGZac295dUg0b3NQOGI4N1N0QW9ORGNidkF6NlFka1dqdm1UUkd6NkVWeHZycUxMZ1E0aVRNVlE5SGF4MGVpRDBLdnIvT0xzd2RXOUdZZlN3b2xINkprMFc4dDhPNVM5ZkZNRFVDY3ZCODRDMmQybkw4UThPWHdNNFVmWHRzNWZMZkZuMFVwMERIMDFCRHdDUHVDVUl3eTM4YVM5eDhGc1VQQkoxM3QvNHhhU25HSjRmS0twcldhcW0vR2htNDdiWkxBdkdDeDcxZUFRRnR5OFkxdlZnMVhKR3F4S1ZuVFYrZVJ6UEVHWXU2ckN6QVg5bTJGa3NPRENXakNFRFNGcG8vam93Tksxa3NQTGFvV1BkUU5Zc0srWFBJQ2dsYU9mYUhPOERyZXdzWHNYajEwSXRmWE1jdVBiK256OGZHV1cyaVVvdU1PbzM3Rk5Pa2orS1pLMmtRZ3lnbGh2dnkvaHhnSDlsTldzVHJ1NWlvY3l6RExvdWRzaDd1TFlqeHZZS2w4ZVhrdVljM2pCWFJRb05FU0I0SzR5c3A4T2NJNHNhZThzck1zc0ZJL2h1ZHJDVFZ5M2FqTXl1TUw2NmZoR1ZacWdoRm9vUXFnamd4eFpEUU5OQWY2YS9VVVNZTWxmNkFSSS9tdncrbVkxV3k1NDg4dDc5NzdjVUNLQXFwWHpxK0wxaDM0UEJCbDRIdUtOQlBTT2llb2RZVUhmZlkvKy9nRjlCM2QrMkdWNy84a3JPbDI4eWNacERKYnhqbEFNenFadVlzRlZnQXl0N0N2NUJGUjAyc1piSUp0TUpKTTVGV25rMENpNUJjVFhBSGFjTVliM3FUVGF4MWM0dGU2eTQ4OHp2ZDZPall3YjMzcnRocEpPY1BTQUJoTmVialVxYWZWYTBQQkc3ZXVnWVhoWVp0VlE5TlJXdXhnOVliUkdZSGtsRksrZkVFVXkxdG1SVmVDSmltYmFJSjAvajkwdkNNcnpnVnBuM2F3RFdNUGhFQ1k3eWlCYkJPR1VqNUZGWUJEYjUrU1UrYkVGOE9VUURRZkQ5TFVzdnkyc3dITmVUNS8zL3lsOWJLNkM0MmdpL3c3S3czd1dUMVc4U0MxWWpQaHh5NUsxSHNTaTdKaUc2ZnQwZlpmdEdXQk1VZHJWdThvY1hZVG42SFdheDdHUEc5OU5HdEJJeGxvcjMxUU85NVJ6eTJoeUY5bjVrTXJPZkIwVkVqalNzd2R6ZlNyRnV1WXJiZ1FDMlFjWnlZeWNUaTE2YjluTUpjQlM5ajE0U1lTNXR6YWZPM3Zxd3E1ZGw2LzhjbmJmM1Z3b29NOHVPOUFYNEowWjlwalliY01PZjNQWkprM2JzSGJHaktVREZxNmN2MkgzSE9ua3hTdE1seDFTL2h2L3M5REJYd0tMT0daNzZ5RDJjTnBrK05GQ0hMMWZHK3U4cnp0dE1sam5yY25PejFFUnphbEt6OCtOQnJ5RU9uQThPU3RIUlRUL0VEMHJKL2U1emZRK3pYZEljODdXWmRpWjhDRExPUnZFYzhyWnluSmNwbEM4Z3N0MGtzdWM1NEpKbWRyT3MvMEd1TXd2Tk05NFE0YXZpY1g1VEZhUGVrYlRuT2JnUGVWUExLTXNkKzNiRElNelNBalExeE9tMWpNV2ZzUG9xZUphenhkcVBXTmhHNGJMVzhXMUhrbXRaekN3UC9lc2g5Vm5VK3NiREtJNU42YzljdjhlMC9WdlArRUdzMFdnWTdyKzdTZjdVeko3eGk3Vkx0Skh1QWg2czN5OWVydUlORmEyWTVBeTJYalB3V1hxQ0NGS0dWYlBWcVVlZmlKM0I2UlN1NGdnTXJ0SVphMWRSR2dxRFZQc0l2ekVzZDdVTGlMS2RwR1hTN1YxcmxmckxPQytCNjFKU1Y4eXJzUU5SRDFqS245Q2FjeFc2eXdZS0pDU2NiVE9PQ09GbTNIVytWaXRjNEt6VHRHbFRrcm55OUpPdGM0Skw2enprVnJuZU80U1NOYlZxV3M3cHJORXJYUDhnTDkwZGFwdEorTm9TSlRITVFhOHlmMEFNa3p5ZUpLKzk5WFlyY2pZaW4vSVl4c04zaHhTelNTUE1Da1pWOUYrZFZLbGRSeDNHYnpCeGttMlg0VzUwRHBicFhYY0lMTnVuSnBxMisvaHJkWTVpYnNHeHV2cXJPWlM1MG0xemtuREd1anFmRVZYWjVwYXB4WFgyZTVGZFJwODFUcXR3enhlVUdlQVdtYytyclB6Qzl0K1ZxMHpmNWpSZmR2cE9EVlJ4NG5hRmJYalpIUWRKNGM2VHQxR3AyckhTV2RuUElpK3B2bVBxYzJQcnRkZG5CZU45L2ljNXNHaWRqNTZmd29IVlJ2aEx0VkcyRWZZcWF4anZZMlFydU8yY2hrclc4Y2E3SFZXVDRKYUQ5Wnk4TnpEWmZ4RUYxdmo3d28rTzBnZkZVQktXQlJMbzFMUGZNb1Bhc3I4NERqakIvN0Vaa2xDR0oxcmd0aWN1bEIrMEZZdU80dnpadWY4TXVLNzArYlVqdEszWHEyM2dOdk4xaSsxaFpJeGRLNWZiOXJlYklWT3ZtQUNYYitSdE5aSW82MVdxYlBOYjFPZVVGUG1DWEtkSmxxblNWc25vYlVENVFtc3pna3ZxTE1INVFrMVpaNndpL0VFdFU1ZCt6R2RKV3FkNDhmL3BhdXpqbElubVJPVUo5U1VlY0krbVNmZ3VVRkd3S1N4QjVONVFubENXOFlUSmpHZU1JWHRSSkhhc2ZvQ0N5NlA2TnlwdytZRm44N21qc0JEcGI1bHVNeFJLVXZCV01kbGFuTUdXa1pReXh4SFg0SU1PbWZyc0xuSlozQUN2citDNEZKSmxmSDkxK1Q3ZGVsY0xrQ0hxZjFIeGcvQzFEMHRkeEJiRHZxVTJvRmsvQ0I4ZjE3NTM2bzk2SlJpZzhMejl5RVlSWDF3ZUMrRkJtb0hrc2JJdGlkU1pnNVhqWllSZUtVTXErZUlVZzgvRVlpZ0w3VlFDYkl0cTZiT3JwUWpEVlhxdzNOekZjVnczUjR1OHE1bFdiMzcxSG9MdUw5QVQxSzJPcTIzT29IdlUva3dwYk8vV204Qk41L2phVmxhcjY0c3JkZWprbHJ2aEJmVVMrak5sSGFvOVU3NHgzcTkxSHJIYzQreE5LYXRWOThQbGVtODd5S1huVmYrV0ZldnBoL0l1QnJheXVOSzV1bFRNTklrank4WkMxcS9QRjVrckNrdjZTS1hYY1JWTmNsalRzdUs2cmk5VTM1WExLTzJ1NWF5WEZVSnkweEV6dE9QLzNkRUZnU3RaS3oxbVlvczZGSlB1RnBQUzVBS2VwRXkwYTcxL0tqVzA1TDdrdkhLYU5kNmRpajFnRDZpRWZOTE4vV1ErUWhhNmVkamhYcmkxWHJTUVNYUWhaU3BKYmpRODBDdEo1MmJ5WmxwR1UzL29HTmltZFNUMVVQWFRSbW45UEYzd2tYMnJHWTlmWXlPQ0h2b2VuMVp2ditrSE9INzcrRjk2Z0sxUzNXWDc3ZW45WHlNYWRoRCtjVExjbHZLR1ovdzUxWGI4M3VZbDEyZ2ZLSzdYR1kyNHhNQnpqMEcxeU1sRWhrYWMxazJScmVaREIzTysydnFFY3BvYm9zMmNwbnBNdWNTZlBYMVdOUjZXb0xhVEthdjVsclBLYldlbHR6blRLYXY3bHJQTHFVZVRQT3ZyRjJ1OVpCMnNYcWM3YXBRVDRKYVR6cDNtKzJkWVlJTFBWZlVldEs1Nld6M2p4Q2Q5YUFqVXFLVXpPcWgvWDliR1JlaFROakhudFdNQy9XdEordUMrTjdUTnQ0SDNVbWRucnphNTh5MmUwcXg3ZUl5MHl2b05oRjRmOWxMNThNcmN2MGxsRTliVUMyYUw0MCtTKzZMZ2VYOTFmZmFsUGZpUHJGaitjZk5lK2w4NkNXWGFjdjZUZnRlV2src1drODZ0d1YwWkxrUFhPaS9vdVkrU0c5SmV5MUVkTnJQeXpzVGZpWVZxUHhzR3pyTDdjS2xiRFhpVlo4REc5d3EvTVlIR052d0daZTQxeE9ia1h1NzRGYnhBYnRuNDNKeW5udXZEdHJJcjZKVzR4WmNiTG12U2VKYXhCSTlySmtuQjQwd0hOYUZRb2FTaHlGZFNBQW1xVEluY2xVMEZrWmlDUk9jeDlWVlFTSWZhRW5QZmJWcHZuQU52SXkrMk9yK1dYcXVSNTRGem1jQk9lcE9CQ2J5c0ppTnZnSjFTK2l6NVM4QkNmRDRXU05INGJpZFQwU3hKNlQrcjliUGI0N3VBYTlUdUUzdDhidUFWTm4wS3Y4eTduZnVFR3pHa1NmVnc5OEFBdFpCZUlpUUFEMmt5c1pvUG9YMmJRcEhmT1BObWpNWVFwL0J1Vi9nOGo2MFBPVVYrRnJtTEsvVVRQTTZNcHRzZW5reWVBejhNZDJWdUJBOTVTVFdTbUE1UGxrVGd0V0dKRm9mOUc5YjM5b1BuUVV4Ty9Gd2c5aGlja1pFTUFVbzF2cHJiaXlvL3lMNDBjczFveURMSkIraEJET2FJb1FJMU1tSzJvTVNLN0R4WjhyaStUT0R3RmcwbTQzOUd5aExxRWQ5Mjhkb3p0UjkzYjN5ZndnMElSWkJiZTVyRXdVcjk4ZUUxZ0l5b1RLeEpEcENxSWRhajBQZHdFYnlOdzdzUTYzeFh4WllrODBQSDBBb0gxQzJpSjFmd1dwUTVEL2pmQ2oyanhmQi9qR1R1Q1VDT2tnOFJKTVdaYi94WmpiNTQzMDdabWQzYko3V3QyOGFIdS85ZUJDdmNtdU4wWndwa1BoaG1zQTJPZy93ZldHQWVqK0czU2UvazNuRVNVVDJOUXlnMkZZeFhCSWV1YzdjbTl5N25LMUxQSUVRcWhCcm9VWUQ4MEdoTEhtVlhlSnBtSlluT2VHekdVdnQ1aUFhbDFXREZjQXJQOGhZSEt2QkMrS054UW1hcjdGR1d3TUtWdHVzRkNzYXhhOXFmZ28xRm5mVXdRclJmcUM0R0VwdnlOaGZRTmREenZUVk5BeE85MDMvRzRnQndYemFxc0xPNHlNdEV6dFBYcjE2VXBkSmxzaHhuYWFzY3Zpc0tweThtdnp4ci9mdDFhTnYzL1NlZmNHbFByMTY5T21UbnA3MUxKSGM2OWV6Uno5Z2JBOC9idy82VDlyYXNXWExqbHNucFJadVNXM1pNblZMSVQrbGNPdld3dFJKVzdaTUtqdlZmV0pCajlUMDhSTjZwdllvb0ovR3A4TmIzUXNLdXFkMm4xVFk3ZG1QZFlXUmRmRllqUlphY05lbHltWUpheE1xRjFCNEQxbW91RXloMEFoY29HV0l3M2lvQzM5UzU3ZjhBT0NHY2grQ01uNHpIbWtQTGdSUDZzcDRQZ0VMU0FLSnQwSEFJUFFkaUJrRW8xRUJtR0FHRTBqNWJGeitrVnBlb3VVVFFTQitKSHNRaUVIZkRRSUIvR1kwM1l5bWcybUVudFY0M2owbHZqbWNRT2VWQUU3VGVkeUVHOGVuaVZXeDdPdEpJeVpoZk4xNktiaTczeWI5Tlk0MG1QR2RWRmlYVDhYeno0dGxyUlhqZFllMjlza2l5TEEvSUpkbTVHSWtGMG4wbE1OUXRHQldMR01BWDJyMzhKYlVnMXNTQlJwSWdBQWlZZ2d3dVNuR0FEL2F0R2tZcWlxQTd5ZWdHaUJYcXN5bnBoOCsvQnFjNlhnYjNJVjFLZTBUNER2d1YzRXY1aCt6T0pyY3d0V01wV0NrMk1OTkJNaU9YTUpNSU05K2tGendwNUgyWEh6WmNkVjAzd1JIa3Q5SDJwdVN5MzN5KzN4eXVVK2VLU1NYY1BMMUFma0VCQnJWWWxMeWFQaG9MUS9tNElycGtNNEV4RXhLbTdZZ3QzK3Zqa05EUm9oYlpyVHUrTzRxSklENytZTmViK3M0eFVmaThRbkQ2eitMeWhTMTZEbndsdklQMFdpWlI5ZWw1K1R2YVhJOHVZWm8yLzM5K0ZpN254OUJreVNYcHZoQ2NtenA3RHNVSkY4YkhPaEIwUHRJYVhMSjlhZVFmanFVb2NvVVdyK3lQZ2syell4Q0RpWmlhUEl6b3M2QTRBREpnTmxuVW1JVGtFU2lDK2xmZlIzWUY4a2Fndi9BZkpBWXg0T3kxNzNhdEFIbnowakhQak9jcysvYnovTWpabGtuTHBUQWV0UmJBaCtBKzZGRERqZkx6dmE3YVEzTldadFRmT3JPMTF1bEpiTnNSY1g0RzUyUGU3QU1HWWozRGd2V29kL2xuRUZiU3Mvb1V0WHJ6TTFxTWk5Z3RISHEzZ24wTWQ5KytqMURJQ2k3OXBBcTFaZ1hCbmswc3BSNDM5VFFGS3BtTEs3ajR1d1VhREdwd1R3VS9OQWlHU1FXNHB3UUhCU2NhQUtLSjZ5QWZ2c3R0VmxvU2czLzZsMWpSeForVUdua3hKL1BXY0ZyUDAwYVpGcGI5c201N1R0MzdEZ25wcUc3ZlIxTkIvY1FwUjQrdmd2ZWg1OXRHbXAxbElpMmNUbkxRS0FqNjlDY2VaOVJYeW1qTUkzSUZNUlh5aGpEYndFZndVWllsbTNCYlM0ZmczY3NlOU5JTXFzalFRYmpQWjJ3TG5JS3o3RllKYnNHQmQxMzlUdTJ4OGJ3c1hnZjBHMzUzdm9aeFJuSjlocEx0dGNTdjVpd21QZ1lMQmJHNktHSUEya1N3Q0NTUWN3Rldra1QrVVJEZ3drUUJmbXI3N1ErU2l3QlR3Uy8ySEhsNU9ZR0krcDdKbzlwZEJuZDM0ai9BMzZYRytRMjgwek9lL21UTDZERmNRVmFZS0Q1K0QyVGFhQ2ZFVVErTXVkc3lJbDZDQ3hHdjhGRzgrM1BZM0pJYUIySmh4YW40YmFINHRZMzRCcGphZC9XTU43MlNueEZmMExGSmtXUWlWWFpsSHd4VWpoaU05Uk9sK0lxdXE5a0dkVTAyaUxVeDJvYWkrTTFKU0tNeGNtNkxaVG0xWWxtb2RBNlJFY3lYL1RiYUtKK0c4VzhHODZHd3Z6UjQxYXZzbzVaSU1EdTNUcDE2ZHZ2OVk3ZFFPVlZrd3RYcjVvMFpYVWZ2QzMyNmR1eloxOGtFall2ZUVtOVoyeWRtRHJSTnJPMzFMamI1SzZwWFNkMWIrUkluN1IxNjZTT2hWdTJGSkxkc0NQWkYrL0pHd0tSUTMvbFg4YjlWaFhMSXozZFlGUnJnaWFOTEdoU3Q2Q0NTV0pmSGRDV1VjOWxQTmtCakdpUWNDL2crWkJFY2pncjdZWUdNbFBNTFB3ZzBJUlpMandvRmU5dU1LRjVxd25KTS9NSHZIWDBrMUhUUUpQNkxWdEtZd3U4b1hqL2JMVFpQeThnQUlMaUU1OHNxRjJNZHZicVh2U3A0RlZuNEpBNU05Q3JzSzJEN3RtN09jNmpubmpZR01uVmU4SVpMVnlCYUNsM21Iak9LTDVWSHNSVmRrR2pxMUZxRDYvTmxoRHVqeXgrbWRBUzh5TS9MbGlKTE5aNVBxbWlOY2xKaEtXdnlzRU1PWWM0YnZJa2NUdEpOT0JOSFh6OENIWndzVkV6UFFJSWo0M2hMVHhONkc3Ry96UEoyRDlKRWZ4VGFVM2lPcWx0NzgzUzF1N3RIRGVYdDE4TkpvdEJBRTNHckJhTmhDR29CL2pZY1F1Y1EzWEF1ZGFVMXFYbDk0UUZRa2N1a0t1dTBLcERJVlg5T2xWOEhDSU4ra1B0NkJRSFFaMkVYVVU3ZmFQb0FrNlNVZXdqV0NidUZFQjJ3d2hUSEJETTNmWm5Ya0tuUWNzdnZ3YmhEaTVsYm1ybTNtNW9RZnU1RFdHMTVIZDZwelFDN1c1ZkIybm94SzE0dER1cHdTdE4rTnJORzZDN29Icjl4bVNjSnBVL2tocUpkc3paUHVLaTRRejhienNRU0xXblRYd2FwOWZMZkdXOWJDaCs1cEI0Q0pkZFYvNEVMcUhQRk12UG5ITStReGU1OHN3dy9NdzljUnN1KzNINVBUaVBQdk1UZTBiZ25NOG9QckgwbVlING1YVDZ6RWJPS0QvVFVINVBydk1aaGJQZzJRTzVmbGdmRHhOLzVRSmtqdzBOSUNURkpHTVJPejd4ZHFPUFFmWlgxVHBGK2JnNlJRbFloMkNwQTVqWFEwbzBqREdUWExxVWcrS2xBMzRGSmhDQmZ2dTZGRDM2ODhLWUkwa0NRTjhWclA0OCt1aUNqUnNQaTc5MlJ6UFF4Y3VQMEpmQS84UnZ3Tmk3aStBQWx0ZWVmc1dWSCsvYWIrNk43VXV2VWZscmE3bVBzSmhpRkVlcFZDdFFQN3JFNVp5Ulpwc1hGVENTeFZaSEpTdi84NTlTNHlkSHBJOW9YVTNSbjhKS1hKYzNRYnpuNDNWckJ1c3UxRTlYTWpJWE9GM2RvaXNxRzFsUkVsbExCUE9BQ0NXZWdMZ3VBTDZxWXhmLzViTzFzS2RqdlJCU05nNjJoeTBjd1RtOWVJNFhNbkljSnFhVHJvTmIrZHQ4QUphSC9Ra2QyczJPT1VId3Q4cys1VnZDclRtc2ZETlZoMDdBd29RZXhGVW5vaEVvY1M5M21STm9SaW1zcG44YktWbkF0QUpVS2V2UEZmZEIyTlNwd3NLbm5lQmsraDZlbTREMXYxOG9iakRSLzhhN3dZYlNJYlBvOEs1VXBFUEprL0JpdTlub3liQTR0TmxwN1JHU1dmWWExZ28xc2FYMk9ETVYxRU5KSWhRQ2dBZ1ZoVTUxcTZFUWlJRU1HdGtRR0VUaXM1TWl5TGJrbjVJVVRRTGVBZzIvUEQxVjhyQnQyNGM3VGovNSs2dWRqOXEyZTFSeThrbit0dFVsVjBLclhOMVpaSHN5ZWVzSDJ5K0hSVjdhVWJRVlBMcU12bkZzMnVRQWNaYzdYZ2J4NVJzMkluVG04cmJIYVBmdzJzUFF6b2ZGeFE5Qm01RzFSNE1XajdkeG9Qd2QxQUdPa0Y3Q2UxR21xZ2ZRRHZEQzgxQXpNK3hyaVBoZUZ3dnlPMnltUXliaU5Xb2lNT0dtcGlhWVlSK2hDdmhaNUlJMThKRWtKRjJIc3l5NlpDdE9kZ29tZ2FEV21ublZrMEo5akUwQ3UyVjl0RGlpbGNVWVVqZTg3OUFlY2hEbzFORml2WS9zWHA1WmtxRndCT1hEMmFDOVlPYnY0VEZOeFBxWlBTaVVqOTFoQ3pvVWhJbHBGb1JKV0VBdUkvQ0ZESlhHSzVocThJb29vVU1INHVrZVlpUkJHZlptb2JodHR0QkRvVENqWkVUbzVOQUZvVmdXQzlXNGdaSXYwVFJQVW0xTkZWaWJyNnY1V3R0b1N5UXVOSGlJazRPQ0dTTm53bXhNSERCZ2pzNC85NWZjK0lMbXJadGw5Mnpldk5tNGVoNTFDNXExYU5GMWNKTld6Y2ZWOVdlLzlHN2N2T240ZWdiMnkvQ0dyWnFOcjh0M2JkVVJWRTZJQytuWVprenIxSkE2OVN1RHROYm9CM3F6YnVVMGRqTTVHSFJxamRmZVVtNEZmMEU0aXZXL2pwemR6eHYzbnRFdjNBLzNudEVQNUJFUjNxaFhmL3lvM21uMEpncXFOeTdoYldUSWt2cU04RXdaamVDSmxCbVRnbmRZTTE3MTVtRDQyeDEwZVJNNDdmaHJhYU9KTjBIRVJwUU14ZmRmNFRjUFJsOFBSbi9HWGg4TTZnMEdJYkY0RC9pQWcveFAvQ1BqQUt6VnZjSE5hTVkxZUEvei80enlNc2NieWttbG1oQ1FZcXAza3BnY2daOWRpSi85Z1Q0YmdmZG41N09QM1QwcmtHY0ZWUVpKd1l6aU5PWkZJcFpDYWowdmtwc3lCYXE2OGl4cWpjU0hXRUFFaUxFWVBDbEQraVlMdkk5eXNsQS92aXI2dG9aVUExMEN0U3hTbEdoenhEaHF3UXN3L00wM0hkY2NQM2J0U3ZqZjNQSnNFTVBaM0o2akdpd3BtSy9GdlA1cS9aemtNMmV0bEVZc1BmSnI4Rm9OeHF0MUxVZVN1bFdJZU5EbDlxT3FtOXRrY1ZRUkpsL01ScGRrdlBZc2dyNTJ6ZU9CQjFuV0huaFpGNUliOFI1TnlZMjY1TVlhY3NQbWNjZ0RNd0hPQTFTSS9ZYkVsazF6R1NaU1BEenRTZzhsWnhXbUNDeUovYlJqeDRHTkxXZS9HdEI0Wkx2eEV4ME8yTXBxNVMvMm5mM0pwOVZEQjRSVW16cCtkdCt5bWtKRE1xNHRjTHVQU1M5aG5hd2RQWDlKZ3g5dzhuMnB1Zk0rUDBCelAwZTlIOE8xSS9mSmN5TCtoUXZpdXFPUmhydmlWcXpOVmVOcWM0MjQ1bGpYUytWZTV6SzRQbHcyTjRnYnh1VnhZN2hKM0ZSdUJqZWJtOGN0NHQ0RlZUbWkyUER4QmJheDhaVnBIN2JIZmRpZTdMQUx1L0N4OXJrTDhHWHBISHhwdlFSZm12S1k4eXd3MnQ2aTRpbFBIZXk4cUhnNnFkUVdYbXAvRUk3WGtLL1JWcmVVcEs1NEU2dDFwZmJ5R0xyeThMWmhhMjIwTlNtMXZXSzBOVlVaRHY0eXN0UTJ2TlEydU5UV290VFcxR2diVldyTExiVU5LYlcxTExXMU45bzZxTDd0YVIySWczOEhYRnNYb3kyMTFOYkJhTXNwdGZVdHRmVXV0WFdrWlFlVTJ2cVYyakpMYldtWWxMRmtUTWZpNVZDS0w3YXhSdHNiK09ZYklLK0VlOFA0UnZnYi9FamJIS090c05RMjEyaWJXbXBiYUxUTktMVXRNZHBtbHRxV0dtMno2YmFtVWJnQ3phWkVaNll0dkMzcjFTOFpCRUNOWkNXS2ZpSTUvVWpDQ3IwcEl0QVNHRVZ5d2lhQlFLYmR4MWpNUkFLUi80RG1zMWxSL3hWZGwweTJLTTFuUG5seTlzREprM055cHJUY241MWJwMmJkNUVHOTBMUU96WnExYjkraWFYdCtiNi9CbmRNSFNmQ041SVNhS1UrTzVoMFZhMzZlKy9jd2tIUlV2QWVTYzh0NlRVcElTb3dYUzBHUUl4MEVPbnJoemR2TCtYbC9Sc05YR2pUT0tQczlqLzVuaU15bC80RnpmY2VONnpzaWE4S0VMTFFiUm5Yb0VOUEV6NmZOUzYrbGdiYXQwdEphaldqZHNXTnJMSnpQU092Vk9WV0tleW01VHRtWG9OR0p2THdUNkpnVUJrSkhiOXc0R3QzWVdGYXlNYlptZEJ6azI0K20vejE1bWIyRlAxcXpaa3c0T2xzMjZXbFo0Sk5KN0I4aTQ0aGNMOGQ1d3dXUHZsamFxYzVGY3RGNFhnZHo5dkRxZUNyQ0NIemhmUEFsc0NvNWF2Zmt4ZnJKS1UwQTB3RERRQ0k3ZE1NRDVnc0NneTJCaVR4ZW91UlBxTXdmTEd0ZTFrcndxMUt6YmUrTmk5LyttT2NQZzBheHlZMFNhNmMxT25IaVJBZmlseUZJWGNycWxkWGp2LzQ5cVhHVm1MYzZUbDQyZGFxVVdMOXBVa0pxdFpTZTNkTTNPVjRUdk9ZS2hOKzlRbkNNaGJuT3ZPRlUramRxejNTTkxzWUl2VFRQR1FoK29sM3lvcUZhdkVROTV6MDVpWHJaZWxKbVRQK2ZDT3VCbnZOUUZ0ZzZENjFBN3kwQVcxSG1mTGdGWEhOODVyQ0QrOGdFTzhLbVRBWnRpM2xMQjB5VE4wR1hWM2VJQ21SVWNrRVNKTE5lZ3FaQVM1TFJQNFZJdGgyT2JMRit1ZG1SeC9OQ3pidG9MYnE0WncrSUF0T1BaV08rWFloMUZFK2ExNjBxNWpiT3hsYllXN3owTHJoOGhSUnRCTEVuQkpBb05IOVRqS3pCczNVa2VONC9mKzZQQitmTy8yN2QvTkdIbXo3NThNTk5NQW5kUktXZ0hnZ0JyZkZmQWpxTmJnVmMrLzMzYTJqcEQ0OGVYbVh0RHk5L0F2NFdkK0FaMUZpditlazNEVkZ6YnFOTkcyR0h2TWhjM1MwbU1Ta0svRzFGYThCRmc5ZzZOcjBOcWI5OERib1B2K1JiNGgydUJ0VnpEUEV2Z0dTc1c0OTN3V0RNdXFtRFhyenBDcnBJM3pFWGRRQ3gzRXlhSTBMUnBlaklFUmxXaDNrZEZhZ1ZRaHNERUt1Uk8yZGVJOUxtQU5GcjRtaW1vN1ZHVThEN2VDV1pxVVFRNzRUckx2YUJPZ1hON055NFV4alhjd3E2bUlVOVR1MHhJQzA1dFhwdzFmcVdsRG90bTlST2ZMdDFweDRoNXRkOS9aUERrbnMxSU8rYWgxWUJpU3ZRMlJJQWdjaVVyRmI4MDFXeS83OGpmQTlQU2tkd095M2NEU0l3Qk1VVHVjRWVaT1pqeVVHWm4wSkdNeDgvdnpDL2VMK21mbWwrbVg1U0JqdHN0M2tydjVmNGVZZDV4M3Z6SSsySHpGaWdMekp2TTJOQjE4OGNabzQzOHhrbEJKQzRFSCt3bHhNMDVTSmN4RDZaWEVySjEwTkIrRk1SdnBUNEJZVUZ4UWVSOGtHNVFZWDR3NDZpb0cxRUFDOG5zbmNwdVV6RzVjaWhkd2kxbklXcTd5OE52UmI2SUpTbnY0VTc3NFpmQzM4UWp1K0dNdDl6K1NSUDNTdk10R1BKcEkrcG54eWNISlFTbEp3RWowQnA1YlFaS3cyd1Y4Kyt2WHYxeTJqVjVLMlhhaWEzU0crZE12dWxtSmRGbTVRK2VuUzYxRFN0VXhNQTIvZk5hQmpuMTdZZkFKa0FOSzdMK3ZRNlBHQWdFZWpoM0J6U3AwYmFwL2lmRi9ab1NhSGZmTDhpUHo3UFhrN01CUzc5Mjh5VGRYQlRiMkdrdmRDSXV6ak5tR2trWFd3TU04WWJjYzhXR1VsY25oRS9TcnlXMVUwK1JHTjdkMmw4VEZJVEVKT1VIRzFKb2N6YUQ4QVNLQzJiK3RZeUErelJJek05L1dMWGRxSXd2TE5oMnJMZUhRQnVkdmNSSTdwTGpWOUxmY1UwUklpTWxxS2pHci9XdkhFVEtZVzIrU284SStYak5nZHc0MGxqQTFpYi93OWFTK1NYZ0ZKYzRZN01nTndBbU9mVXRYQ2R0UEZOamFRdnBBdzNMU1JaRU9HWFVIcC94c3hWQnBqUnEyL3Yzc056K1BWcHVEVTlSbzdzSVRYcG1OYjRjL0ZMS2d1UEVuNkNqNldEbkFlVzRmYVJRdzgvdGhhSUtrT29nNVJHZzRaR1E1aUJKTFVTTXJBaXMrTytkN2szSG85TTcxenZRbTg4SHR1d1lxT3NpZ3o3Zlc4aTkrTExqdnQrNVg2a25GK3VYNkVmS2VkSHl0SE9JZVg4U0RrL3BnNzVVeVVweURtYmc2NEZQUWppNlc4aHpyc2gxMEllaE9DN1FjeTdHQmdzTWZqL1VZa3BkSElib3Vua3hyeURUdTdITVAvTEwvSWg4Qm4wOVp1dkpJK3FHUm5YN00xR2RjZkhSTVlMdjBnN2QwcjNMclZJN3c1aGsxbyt6UWNBMEEzQytyVlkzL0NsRW1iY1hHWHVOZEkzbm14OFg5d25OTG05T2hQVmNiT1pOSE9TRVp1U0dCekQ1QWMyRncyQkNxRm94a09RK2tyR3ErTG90N3UweENUdTNTdmRHejFDREkydUdkVytjOHRtelF6MVNaNlBoWFRzK21ENnZMbjJHdm84NC85NTVNamhkaVhOYjVYQ0tzVlhhbHFKT01Xb1hTbGFZaEl4UmRQMzdac0dnV0UwK2pSNzUweE16Q2VmU1BkNjNjTDkweGYzejVmeSs5c1FjNngzUE1VaDg0NW54MlM0V2puYkVINmxSQlZkek9SRm1rakJVL051enpEUGVNK21udlRkaVNKN08wZzBXTURnMGNBQXArM2JOeDNDSDJhVjVJamYzaU12Qi9tM21EMTRyTEFYL2lBdG91dHZCbm1yeW5Qc0J3VThvNjRTVUFJZDkvRlUxcU9BR1N1WmRBL0lwSE5kaDVWczNvZThTNzJ2ZVQvd0Z2UHNtWVRGcEJsSlhKM01ad0kwYXpFZ0xDQStvR2xBV2tCbWdOdTFTRVlaNjZ2aXVubnoxMHV3ZDcraEF3ZThOV1kvWElMWDR1QVpNd2RKYmJ2M2JPTjFsbUdXTHhOS1FMSVUvR0kvSkhOS29pSFFzcXhiMjVyNVl0T0xsMmJpZmtqQzhtQTZscjBNV0NKc283SHlLOUtYTHFCUU5kY0NGbEFJNGwydGpGN1VmNFludVVzdDVGOStnT09JZFNMNGJpeTRVT0FZQlg1OUtJRzZxRlNZKzJ3VVdBcHo4RTY3QWN0K3YrUDMrMUlraExGdVpGSkYvdEdkaGdCOTZIaUlNWnhaTm5la2hXU0dZSjA0TXdUcngyRWg4U0V3WThmOGtDSjhpLzB6VXFzbDJ6MzhXTVI1b2lsQ3B5N0ptV2RpTEZHS2ZyTUJqRDV4TFNkajZOUnY5NkFEb01YMFJYTW4rcUFEWmN2ZVg3NnlUSmo3M3NyMDJhR0JLN05YcllWaHFQV29vWDN5aGN4aGc0Wms0WEVwTEw4dlZCSldjYUZZdjMyaGJLdVk0WFQ5cWNPWEZCaWlEcHNtQkhtWWMyTmJFM2dvL25IeUsxUU93RmRmM3hkaDdxYlZLejdkLzk3cWpTQlAybjBVZUo3Lzh4endQTHBMbXJQZ20zVVBONXlaczVEbFBSZk1lQXc4c1pUVjZBVWpRSHJkU3k4NDZpUTcwbzBNWFl2MklEWHBiUUJ6dndCQjZKY3YwRjBRdVBUTW1hWENYUFJINlRkbjBFT2hadGtyRno0OCs4RUZPbi9KUERoSTlaS2VHdXg2MTM3U25aeExPaHUzM1l1bFB2R0t0MmQ2a2NIM2l2ZlNnOWVyeU9mMGp4L28yQTJMeXU3d3dZNCtzQzJzZzE3dUw4ek5Sb05rV2c3US9oajJnaFZoOXhDZ0Z1VS9qSnpMelBjZ2dvWkhwZ2VaY0I1RkhuajZoWG5FazM4T2VueU5iK3JUd3VnUWJ4WEhNMHJjQUFJV0h1VG9DMStGd1k0N2hMQTNtYTVBNWxNY25rL2gzRUN1b3NxbTBXSnNmcVhVb1lJb05QNTZoVVliZmhqR1V6ajhNTHhyaHhISWdyQzBNTnhyT296UEtBWHBtcHF4L1lCOGlNUnMzY1QzVElpTHZiWDVCM1FQbUM1K2UwT0F1WjVyUGxwMzZ2UW5rOWVIb3d0Z3pmdk5ocEZwZHhaNDdWb2pDaE1ubmZ2bzRmcXp6V3FEb0J4NTNJV1g2YmkvNFdiY2RZMXo2eW1IUjRHb25nVjRHQ3JiamJqM3RRZk5GTkpXRFZRV1hyWTZzcXhXdU1ZS1BSMS9DWE1kUDhJd1plNkJNRXdEci9nNTBTRjJmUzJ0TEJHRTVlZmpvdlM1dFBMN2ZHZjh4YWpvcmJTbzhwd2FVKzlWK3YvVmR1VmhVUnpidnF1NnB3RUorK2FBQmhCUlFaRW9vc0dZSzBvU3VXTFFSR1VSQVRmY2xVV0ZrU2dvS3NneWdpZ2FSVVVNN2xGZ1JFeDh4ZzAwYW1Ja2FseHY5RFBSRzNQTmpUNmoyV1I2WGkzZFRmY3dldk1sOS8wek1QT2RxYWs2ZGM3NVZYV2QraDE4ZFY2VlpkUHVFUXk4cnJ0YzAzaFp3NmJxOCtlV2Mvcld6M2MwNzkvT0w4NWFsY1ZJZmVTOFNaeWNZTUVteVVtVHhaQXRWNFNWNzRDVDBwZ04zbnd3YjFZbXhCYndiY1VjUXRxS1ord3UxT255d1pFaUtQaEFKN2dhYW8zZkllWDlCTzAweGkrTXRScTVmK3drMUQrTjlPVFdvcytvajZQOGFZME9IempVK0padUNuSS8ybzZtSC9yUFFYbytvWm9MTWhxTHp5Y2tNbkZWeWdjK2syWklFV2FyRnBwWGlnYUZDY1FST0pHamFQaVFCM3ZYNm5oaDZsZ2htZGR0M3MzZWZUYVAzUWRiMzJGUGd0YkJaS0twN2hPSWpVYjhLUnZGNnhkSTFpL1doR1daL2pZWWdFd3lJY3M0Rk8wdTRWRStpejBQVzBQUnpQZUQ3RG02UnNHK0hvNTgzZnlaaFFWdmYvRXpDM0tZU2gyWWNldXV4b3R3NFplcjE0UmZnUFhWcThBMjYrVHVYY2VPNzk1OUhKeS9JYlFDN3NaUDE0QkdlSFlOTkRRMU5UeHBiRHA1aVBack5mYys2cGRMMncxOWNwSW45VXMrcjJQSmVSMU9qVkJTTXRxWTExZHpKUlhKRkZHbWZTZjc5ejArK3NScmE4ZGE2dW1FcmE4ZkhHNElETFRjWFJIZjdOSDhlYUk5ZTZLQytVL3FyNVRyUWQ3STVXY1pJQmFIYTNCRTBSYjVpcGNTYkJndjhiQlJuUUlrbFlvVGFWYmNQZHhFbGhKY05FNnNGK2VqQS8vVGRISFNwT2tKTnZhTFgrTHpkRUlsaUZoWFVMQk8rQVFZQlpiVDc2bWFWT1RYdVdSR1Z0OVJIaTRkSi9hYlAzMStTbHBxcWc3YjRnd1VjNTRpM1hlWFJrS1VMWTJFSk5FU3pYZTJlZTZ0Y2xZOUhaMUpMbGhueDNwLzFVajY0V093VUhVT25DcytKeU9QVm1RYVJIWng2ZkZycDc5ck9uTUhyVFcyclY1ZnVlenNsYzkrL3ZLNDhBeTlieTdlZEFENHhVd0xDU3ZUbCt3NlZNT25sV1RHeGFXRWhLMHBXbDJ6czRGZmtaVXBQZjg3UmRhZ3dSYjhTN1p5cyt3L29FalZaazhKbVRwaEJidVk2L0hzR3RjamhjYWtUY2gvRWxHN1RreC9DL0ZaRlRQbEJZWTZURHNSeWtkRnFWOHVVWGh5K1N2aFNkWm5WVlhua0xNYVQ5eTRjWUpsVzQybE8zZVdzaXo5M1lISTNoTEoraUhvUDhWcXhlazZpazdpY1RvSWdTSHV2RHZRTFJFQ0ZnZ0JTMXVpaHJOSG44MGo4VEVheGNmajZEODNLVDZxMmxhRkI4SSs0V2dlRXBVMkxsYWxBMlFQUTFpbVVROWNRbHpJSy9CanUvdFprYVg4bm82OHg0OExIcnJ4WGpkeWhkUHpmbmZnN1l6emhFOXpnTHR1SVp2WldyZ3dtODFFY1hQdHNHR3RzOFdZK1o3cEFlZEc4ajR6TFZUQkpBbDZ4TW04SE1ScVBMamdEaW5KUTByWjROTlBKZG1NQTk1YTRBV240cWpYNEJaSUVrdThIT3Q4U0RhZW54cGlxYjhocy9XamRWdWxCWDQ3Rmsrd3Q3aG1aMVdsL2tBYTFQeDI5UFFQZVZuRlJTYm03REhoUjJUREp6ZFVHUTd2SzJhMVczSldidHRld08vNTVzclJhUWQ3ZGY4NDUrU3Q2eWY0NHJycWRSdlcwSGtQUXZQdWljWnZ6ZlN4c0lvbVQ5RE43YzNBY0ZiU2szTkF1S1doSDVoYktFUmtDY05XUWxlNDBOaFJTQUI3NFRlNC9TamtKOWVKWGIzRnRHL1NFc1lhT0FhS0dUY0sxekhZYU9pUERzQ25PSVFaNHg1ODBwb0JyeHYvenI0N1pjb285bHJLQ1B5TUNzV2FXLzhWL09IRnV1NTRGdFRQek5sYjN4ODc4YS92ang5N29OdXUxOWZzMEpmVWdNb3pkKytlQWJHbjc5MDdEZGJWMWxVSXV5b005ZXVvanBFT1FBWHFrMGJ5YWJMTWFnZS8rRmw1aTRxSlRIcElqaFp4VnFIK29DTHJFaGpPZFhXWTVrdmJUVWE2VFVidGVrcCtSWWlDMnUxQmxVdG5xQ1ZuSHl4bGVuSlNuMDQ0a2VMaUhxU0FBTDZwRVFxazB4NmxPUUlQWHpiWnlJQ0RzMGN0bUorclIvWjNxYTdtazJVRndsRUlKMDRCKzJjWEQ1dVpVektMWDNYbXd3K21OeFlKelR6dTYyUTBMem1vcjRGU0RTeVM5ZFVPZmJVMlBlaW1tT3lHRGFWYXZEVWgyMk54WjR3L3lsQk9sWUVsRkd6UEl5TlJKVGlLM0NSQTNqVXJWck5LM3JHMkFiT3pVK0tuenJ4VnYrMWZ5SzAyTGxxMnRuaGxkZld5UlhsTDA5YW1RZjVtZGQxNU5qNm0yTTluMVl6TmhnK3IrV2tGdVRNV3BFNUpUNW0wS0hzU1gxSzdpMkE1eG9xZmtRL2dQUDRSRmhCUWRpekkyZEI2anVyRGRWSUdFK0NxdEFaclcyaVd3SS9CUkVyZ1p6MXUzOVlaOTBJNGNvbnhPRGpEZTRIcEtZSVJzTVBaOE5hYnNBQ0dVcnRKUjNPaFIvM3hsbW9CcUh4ZUxuY0NWQWt3Qm05U3I4NWdiUS9FSGFURzI1cGtOdEVQN0ZVc2IvaHNYNVVnNTRYVHdsaE1ZZVF1S2g1S2VzY1orNlZ2d0pYR096Mzd2SmU0NjdOUHY5aDFHMm03WWxGNWNkR2k3QlV2UXdicVp3c1ovcjFaOWt5OTRXTDFadDVxenNMeTRwdzF3OStrYTg0Q05KNUc0Z2ZkbVRnTHFDbFZ5Y0t4V0JHZ0RmYXVqRWlEWjJ1UEtZMVV1Ykd1NXNza1JTNkNkUEpKSTBSWEZ6UUFOMmswTUNLeTlEVnRXSHAwOGVFK05iTWFtcjV0cUxzUFFOWHNhcTl0T1V1M0ZIR2JPM3BPOUhROVdyRjF5SWltMnByenZ6YURWMC84Wm14SmlPcFUwVlNac2JRRWN6NmptS3hGT09USnhMeW8wZ2ZzK0FkOUdZOWJxeHpMQzF5YjA3YnF3TmZMNTJ3czN2RmhLdFQ4ZlBISW5mWDVRaXFFUDQ2SG5kZWRHVit3L2FPTmZHUHJ0VWJkTCs4TEF6VWtUeTRONmI4TzZkOERyVldEbVZtMHo2UXlRRHYvRHJJaGxWV0RrSDhINFIxZFVIQ1EyU3FWOVFyQ28zSUk4cUtHcnVJUGRYT3M3MjYrREpjOE9WUmtIQ0p1SzYzOThHcFArYjgrZGZ6c3ZPLzNmL3hvUmRxazlKdTdxNitNM2FOYlVsdTdiT0VPdjRxWjh6ZHNtajlqRFR0bGZIR1hyaFdUdHhnTVc2WlVkTzFTTkw2aVpydHgyTlRseTZmT1dySUVsaVZtWlV5YWtKbUo3QzRaamJ0TXRMdXhpcnJUNW5hblFqY3JWenZLaldyZ3JPek1qYzdPek9qODhSTXBlbzJCQWxGYktRVE0vaDRxRFExOHMySmYzK3JFZ3kzZk5oanVQLzE0cUQ3Qy9iVUY3NlJ0OXRuMlhrNVY4WmphL09yd044N3QySEhuOFVtaCt1QS9QVHRPMUxxQmh2RkRJOG8vcVoyWCtUNk9DWEhvSlo3dGhUQXFUSUZSemhZeENoZThVcC9sY2txWWlwK3pGZ0I0ekNyUkE3V0xGc3V3RnJYckthMzlpUzJidDF1dmhjL0JLRU1Bem9qQnhnMHRHN2Nod0FNbll6M0hwQjJRU2NOYTQ2Zmd0YmY3UjQrTVRab0MrYzNMRjYxS21uWUZncDNqZ09ldytPRHc2REZEK1lsRkM5T2pzaWNlSVZnMXovUVVua0o5RG1UeUZWamwvRnlzYWt6V3BtcHp0V3hpWTY0V1A3RmwweHNjdE40SXJCb3ZhRzlySDZMMzlSM2hDd0FMcWdFTC9oWEFnb2VHRFk0Y3NYUEZ3bjBhbURKMXpMaVV4TVRzN0xpeDQrS2lKaytHZkxWdStVWVlOVEJKNno1eDJKenNCWFA1d2FOR0RJbDZNLzZ0OE5laWhnM2trM1FMY0R3ZGc1emFsdlZ0aDFmT0w4QXIrRWZ4U25YaExHUERodG5DdXh6WWx5NU1CbjE0TGVERzdka1RBZnNadndYbHVPZzlZSmFpdWJpQytxTEdLbWRMV0tWUWNSdEllVnNUMUpLeHlsckNLcWpHS21pT1ZWYlB4YXIzKzRKN1FuWm4zN2pCaTlaVlZPYnMxTURKVThkT1NVNGVPM3FjSzBnQ1RjbVAzRHREdG5SUmR0bWNXYnhWUkdSYzdLaWszb0ZrYmZvVS9rQjhRWTFUenBad0NsckFxUWJHM2hFWHl2V0NhcHlDL3htbmNKYVZDcWZBdGY0ekF0MER4b1JPeU91NklHcHAyWjc4NWZ0T0xJeE9kVXFOaVorVnlQWnlkb3AxZEZpUU5MVlhTS0V1bzNSUHdkWGxlNFgwUVgxdGtuVkpmeDhWeTRneEE1YWl1Vkhud0poYkNjbUJVVjFHUkoyMEI1MkJYMmcva2dNRFMvVUxaNjJlSXd5Q0ErRHBxbTlQNWVhZUJ1NnpFbWdPZHE2b000b3RPZ1cydFBOSEdWc2FrNE5TZzNLRDJNUUdoeUJ2aEMrTnVVR2xRVlZCeUEyOVlIdWdJWDhJMEVBMTBNQy9BRFR3OHR2aFVlUDI1eFVkU0JnWkVWMlRxNnNlTS8rZGVKMXUzT2gwejhtUm82Yk5HRGxzTWh6OWVwTFdhK3FRdWRuWmM0ZW1lR21UWHArV2tTSDREM24zM1NGRG82UEJnWUhEM2h3MEtES1NybkhTa1I0dWliWXpYb0UxNXJaVHowQUxXTk9BejBMUjRsbUNIS2lHSFBnQ3lKRnVFN2VEblBLRVRMODVnMWRXN2lsWXR2K2p3cjR6K3JnR2poMzg5a3pYMU5HeE01Tkd6aHc3TmJCWHlZS015bDM1RHhkdmRuS0tjN1lIM1Y0TjdKNllPVE55UkJJZFU1bnBLWW96dmRydDFad3Q3ZFhVMTZRN21rMk9JbzlRL1JpT3RkMWZXbHE3ZjFWWjdaejBpUlBucGsyY2tBYThDamR2TG54UVVGVlZBSkptejA3NlljTHMyUk93UFMrRysrRWRjZytoSjc2SFlMaU5vTWZnZ0Y5R3NuaWpqLzhMUmkvdEx5akFPOFpOY0FxOW9NQXlkZHdzT0lLdlpEakdrZW1FejJQc2c1RTNoTnRjNEc1ekR6a1R4NkZXOFhsdHJ2aVNZYWpDTHcveDIyUU83M2k0WkE3TmxqZUhvSy90dXFTOVk1Mm4vTVphK2JGOFFJdERySWVWbjFXLy9yTGpEMUNFTG5CbUtYc3FXWmNRUGpnK2ZuQjR3aHNoWGYzNjl2WHJHc0pYOHFlL0dCSWZQeVE4SmlhOGE5OCsvdDM2OVVQems4T2x3bnkwRHNXOEI2OVk0S0tYS1U2QjhuWmVoeFlVK0ZGSFhFTGNXSHdhYk9YbUI5NmJ1djNDSU9QUzhlOFdjeVVnekUwNG9ULzllU0d4Z1ZGb3JSdEQrTzdWV0dQL0ovWkcwTmJDM2loVTJodWwzN3VYWll5QlZYbkdPYkFUSHdLK1NoSEtRTm9iYkd1clAvc0d3R2RvUjB3UHVFNm9MOTY0Ym5DNzBUNXZYeVJqVFoxM2k0Z3plRTVjV3Y3NGxzalpqVnp3VUVBN3hwbVdkMkN6OFlNQkExYWtIYjUzNjFiREl3MmN0YlA0ZytwdHE0dlgrc0kxYk9kVTQyOTlCckNzaWJuMnRmRHIyVlA4bWszTmh6ODRGVCtPNkJYejRmUW1ld2cxMXRqL2YrNko2RGdZTGVqSHFQZEU2NkxLdzd6RDBxSzNmVFhvY0hyejNhZk5aNFZuNE9YZEN3LzZIbDlYWHJ0SGM2cUx6eVNmbDF2UEw0MU9FaDVmdnlyY0I3MkFCcVMyZ3I4Wk4rWk1udlhsNDN2YmE2L1F2RVBrWUFmSW5TVWw1cGhiaThXOHl3NkF0ZkliNEFudzNRTDJ3STN2dXR0bWRlangwN25XKyt3YXpYRGh2dkdvVUpTZERlYkJXTUJUUHg0a0RHY2ZjOUVrbytOdFppMzl2WjdvSjNwS3lmRWtIeDZ6WXZSMHJBdHVxUXRXM1YzQ0gwWklidEhnRU9FZGdhQmJlZnJyWk4xUkxDMmh1UDFoZVBrVnNxenRhaDFCbUZjZDY4TlVUZFlQVjgyQUgzbG1ML0k5RUlKVjdQaWNFcWJrK3I3dUhyNUFraFBOVE0zNXdEN2UyK3VWZis3dkh1bnJFL0JXV09QQkw0VzczNTIvTnkvQnA4dXJ2V01tM0szdkZ0a0ZqRFkyMkhuYXZqTjNhNlhoeHJJU1lmbTJuRVhWMVRrNVc5bXJ2VE9IdXE4NjFhR0RkbkJBLzU3bHEzSXVidE5OMUFlNkR3bjZXNEovMFBwNDkvV25iVzFhdlFCMHo0bU9TVnNUR3pjWjVpZVZsU1c1cDVTWHB4Qjk1eUdiZlIzWkxNWDZHUXFzdDMveFB0SVFqRjcrK2k2U1BEZi9BK0RPdVpaa0Z0UUlUeTllRVg2dFhwbFo5UGpFOFo5SGZyRmgwNW5UV3plZERUaFVVRnhYWDFKNGdBdkxyTzhSY0R5MytkTEZVMHVQQmZTb3l6elM4bVdydm1qZnZxTFNiUit3dzNKMmJsMnh0TElTK2VwMDB3UDJpZWlyeW4ya3VhLytGL2FSa0Z3UWRkYlNjbUx0UUIzYTcyZ09QVEQzOUJQR2RPU1NJRHk1OGZibVNQZUlGZFB6YXYwUFZ1b1BmVGpxMW9YR3hDbkE3dEpsNEMzOFcvaGRHRzBVdnZkK09jVzNFN1RLbjVSNTRlYjk3VnR2U3VkWDdPL2ttWmVMZE41bThmeXFyWTZKNmtZUWExNndYRDZrVWg5S0hUNTIvZm94bk4yeXFueDFLZnJiSUl6ZzlKOVhienVYc241dTJrWlM5K01CMXcvNXNET0tIQk1zMUJSVk1kNm82c0lyS3EyUTdIRzdEdmhzVFJYUk82aHU4NUZsTGJtaFI4dDl1SVN3THFLRDBTdDUwSTNWOTI0cU8zbnpaclArMkN0Qm1ST25aeG9ETm0vSjNkN1pjMVBobGlyUWY0TUIrUDdraGt0NUdDcEJtUEViNDExZ2FuN3czYUdSSHpJbTRka0Z3cVBHN1llNHRoSVBZZ212MUw5cEhveHpOM1ladWZHNno1Um1Tc2M1L01jOE1OK0dCM1lPL0ovSlE3eXk5T2UrSTUxM29lK1VFeDdJZlZGM2tVNE5qQzIrRG9WZmZHemwrMVFrUHd2WHUyS1h5THhtbmN4NGU2bk1QMlFaektIbVRqaEp6V1VlU1RKZ0xGT0dmQVR6eTdJYXRjeERXUVp6bGprVFRsRE9US1pKbE9HWm1Ta3VLbVpWcVk0WWtlUDk1YmJpbVIrWjBWalNEZmNKVjBmMmtqbWtxS3c4Um5ZLzh6dnpKdVBLR0R3NWx0QWVPN2JnVjU4V2ladEdpTVE1VlVnK2o5d3B5Z1lMVGMvUTV5U0hpT2hxdWFpcnJaS3VaTDVNS3ZNUFdTWVRKRW02TXBONUpNcndZT3dNVDZVRTB5YlRKTWt3TS8vbW9tSW5GZlZnT29XQXRpZnAwMHJhSjlOMDJpY0Y1eVorYUdRa2ZWcEoyc3JzU25wa0xVb1FPL3NTeWJTU1BxMms4MmZxUStlUFp5VmVRQlBxRSt4SitrUi9hNmFKWjBpdnJERjNKMDZHMExRbytpL090VjdpWXBQbVd0WUR5VDhndjdsSzFPZDVwcGNaRHllVitVR1d5UVRGVERmSzhhZVc0UmxKQm1EbXAwRENxV2ZlamttV1NXQ0ttUzZVVTg5TTVwSW9nM1EreTAvRjVpbHh2NUZ6WDh6cHlLNFIrLzA3NVhSVThCZFNtYTlsbVV6d0VlV1BkRGVYK1Y5SkJ2VzdDZTJ1TE1rMHkrM01STE5KcXNlNWM3aDZuRHRldkVvNkorZURtcXRJZHIzNG00bU1FNm5wMThhalIvM3JrT3pMNlV3aDVkRjdTV1BteTg5azM0cGxOakJSNXY0dTZEZzlpVEZMQ0pmZk9QZ0RJK25RbHN4WG50aUhIRHBmdnF5dFVzKzJaTDd5eEhFWDB2bnlNWlBSM0pCbDRzQm9jVTQ1czNhZ0xCUERWRkw3NmRMV0Rzazl4UHkxSkg3eUlPWk40aDFhRnBqNzJpSFoxOUluRVkzWWFkcjU0elBaWjJNem9wN2pzK2NrMzBkOURxRStaTmRtODdzRUhjNURwREpZYjhCRDhkM0hjdnN4NzVGK09pbmJKN2w1UkcvNW90N3lxRTc4MUhiZW03ZVZaV0tSblJNdVVYOHpHYUxiZkxHZkkyZzd2Z3BmRUhyalBFQXE0MmpGVGdYamhiT2lQbDhsUGxzZzltRVRJMFl2eWNaTUpTaE8rQlBmcDdFa3dkU04rcjZWekZWcVdvdGsraEtkMDFpU2JwSjRnR1VlVWh6YklFZDBUdHVKTlEya2RtZ3R4eVRHU2RDQldLTFBsYmltSHhqWFNIV0ZZMTR3bVFzUzgwRGNNMC9LTXN5MjZYTWswa05Yelcwa1UwakhRdGhEa1pTTGFCMWt2Z2JndkRna1V5VHF3VWE0aUxtSWNUNGE1aHhtaTJsTTlUZmhiM1lRUFlUT3FSQ0djOWFvRFA0dTg3MXdXWnhyK1hNbjNHWlg5bXVKK1VJNkFSZXh5RXdXelZXbzBZN2g4YzFnd3FleFM4Wm12ZWh2KzlyampSQ0c4OHVvREJuREFxa2Y2THVQNVJnZHc1eGpWRllueDhSUDVmaWJ6cFRTT05aSll4Wi9iZVhZR3N0VVVadHJGNk03eWpMalVjd014SEdNMkdXZHY1SXpuZVJUa1RHVmlXTUtwbVBxMFRidmVFejJaRXhsb201L2tjZGtUOFpVUnYxb0JCbFJBS3VZZDVMalJHTFVhckg5T1RSRzlXSnRwUGFKRFBHMTFSU2pkWUdVSWRoRzBZNFFpWE9scUF4Wkowd242d1Q2WFNpMWovUmFST09Tb3YxSVpCdnlHbzNNeVV1ay8yVHRwdmxSV3J1Qm1Ba2RhUVJYeEFHS0NZOWszRWhnUHFJY3ZtNmMzRDZWK1VqR2pYVG1DT1ZwZGRHWXliVEs3Y1F5bnpNaktQNm9aZmh1c2t3ODhHVUl6NzhYbHNHNU1XMjFVNm1zalN3N0huUkhlRVprcmFsc0cvLzVKb1FmaVdUOGE4UTRtRU0rSi9sSFpHd1ZvazlHMHZqaXlicEpmYUk0OTBERU9UUTMwOTJvanF6YmRFUmxqa295ek16WDdYRlA3QWhxMnRHTEJGaU81THdRVzN0ZnRJV2gxTmJzMnpDVHlweVRaSkFQZXRBKzJYSm1NbzlGR1RSdnljVHVIRmdybGQxWngzS2JIVVY3WVZkemt4am0vd0JBTFR2Q2VKeGpZR1JnWUFEaXNnODF6dkg4Tmw4WjVEa1lRT0J5N1pXMU1Qb1h6OStybkRvY1NVQXVCd01UU0JRQVowUU5FUUFBQUhpY1kyQmtZT0JJK251VmdZSFQ1eGZQdjBST0hRYWdDREpnRVFRQWhiRUZRd0FBQUhpY2pWY0xjQlhWR2Y1Mnp6bTdGNlFNb0NPRmdrQ3BLQzhGTFlKRmhRWVlBaVJvQkVkb2VFaDRCQUlZa0lReEVFeWhpTmdrSU5HRWR4SkNKSmRhS01xQVFTSnhPa0JCcXkyZHRvamoyQmRhaTZYeVVLbFdaL3Y5aDkxNHVVUEVPL1BOdDNmUDdwNy8vZi9IdVFEN2N5NkVlQXVWYmhxSzlHY1lwbk9SWjg3Z1VmMXZaRHFUa09mK0ZDVnVDZHFwbWVpc1YyS01zeHJqM05Ibzcvd0xkYW92YnRLL3dGTjhwNEhJSWFZVEk0aWR4QVlpblpoQlRIUmV3aVpuUDU5cHozdExVYTV2UnFHcXdWaC9MTEoxZ0s3NlV6U2FibGhwaHFKUmJ5RzI4bjhCeWt3Y2pXNHZuTkxaU0RlZGVIOGdHcjJQdWJhYnlFS2h2a2llamtJem5ETDhEbFAxcStocnBxQk9mNHl1ZmkvY3JUL0VZUDB1dXVsam1PcDhoTzNxRnZRalE0MUh1c3FENDQ3Q1pKMU9HZkt3bFRKTkkrZnFMcGprYmtPS3p1ZDFIaXFkRTlqbG5BNUsxWDlRSmRkK2UrckcrMFNtZlkvdnVBZjQvM3JNZHVQb3dmK2IxQm4wOFZyangrUTdpTzdFVDl4YURIY080eVZ5QzdNRWE2M3REMk9kenNRU1hZWmg1amptNjkrZ3I5T0FLbjBTMmFvUk5kNU16RlUveDFQcWVTelZrMUVvdHZkeU1FdmxJRWQ1V0t2dncwTnFHQlpUbjBYdVVPUng3eHIxSmg1MExtRUh2NS9sQkhoWWJlTDcxVmpoZFVDMTE0WFlneEoxQ1BPczNhOENmeFRhaWkrc0h4TGc5Z291MFJldkU0clg3OURPd3lNL0pFUDN3MlRyRi9vaUVkWVhoL0N5M29QMTF1NVhnWGVZTVNLK29COFM0UndMampySHNKSDhCMktucm1POGZlMkhLMUdDVlBwUHJqY2xRbnloaTdETnN1aWJIc1pmQWx2ZHVYK3p6QmcxTFpFcit0TnZ1ZFkrSXVNMVdPSlpZcXBaWnF5TFBtWWxPdkM3M1dqalE5U3psRXk5ZzNLeHY5aUE5aC9HT0x5UmZJejJpSHZyY0VydHd5N0pFZWVQUVlua2ljU3FmaGcxekpjWCtXeVY1QTE1aGJDYnpXZUZkNUg3b0wzYkZoM0ZqM2J2Sk5aNXdUbXpDZnNsenExZmFkdGs5Z3N3ejUrQktaS0RrZ2NoRjRUOHBNMUw1a2F6ekp5MWVTUDgrNURqdU1IR0MzMzJiVm55WFhKT1lzejZOOHg3eWIxa3BpM3EzTXJnaUNsSHNWNUNYUmJ4R3dkWW8yaS9LQTRrRHlRV0pZNXRMQ1hKYTUrVnVKeUhUTFVBMVdvNFZxdHBLSGIraWEzTThSZGM4SDRoYzlWZ2xic1c5Y0JYcllscTRNdGZrZWVUQjVEbnVENWVVMy9DZHRsWDh0WWcrTVJyaGJidUduUXppekhZREEzS1RRWW11TE9DUFZHdDFEazRhSjVGWHh0YjFFbGlSK1NVV2luK043ZGpSRlFuZFFIeWJWN3U1UFZGKzMrSTZDRDJNZldZS0RYU3JPSDZ2WGhjOHRyYWJUbmplaUxtU2d5NHM2ei9OOXQ3citKRnFXMDJ4N2l1dnNRb0d5Y1YxRkdlazVqTHcxMjJEc2x6TjlvY3pkU0hrV0dmRzJscmFxYnRBL3ltS2NSQ1BSeER6ZU1vOE43RFN1cjRpdDNyY2g1dmxudjZJOGJRNk9Da054cURvbHBrUHVFZVlvTlJLQkcvaU41V2R1WkFiQ3QrR0t0Qmc1ZUxnZFlXVXFNTTdqYTE3QkcwSDYvM050bndkZFlKZnM5dmlmYjYxOHpSM2VIejhsNGxlbG9ieHNNYUY5clAxZ0hwTS9MTjg5UkQ3TGNQKzgwNDlvYlpxUGVMVWUvZEVYem03Y1pCL1FIMm1sUnM4MU54VXA5bVRaTTZrMDB1d0U0MWxUNnZ3QUNKSWE4N091bnZzRmNXb2RiaVpxNHRSeTl6aXIxVS9vczlMclB0VStvOTlKTVlONzlGcnZRWXZZWnJLWGpVbTRoYWJ5NnFXSis2ZXk3ZlRTVkdZb0czbkR5QnZTNnFwL25CKzNiL2tlejFqR25iNDFoVHBjOTVmOFlQdk5QOFhuNXd6c3JCZmNPNldldDN4Qys5Q3Nyd1FmQ1ZIaG44dysrQnQ4MUY3TkJ2TW04SG9ZUHY0WXpuNGJqM0pPdEFIU3BqTzNEU240dTR2Z241NnErc0VSSm45TFhOcVZYVTZTdzZxL09Nazh0c1dxU2hNRGFGK1JqbW5OK0crMDFIcWQxM1BXdFFHOXIrZHNiUTM3Q2ErYk9kS0dJTzVSRjF3QmV0aUo0MjVzVldvWXltTmYyd2tqSlB4MTYxbkxVd0I3MnBPM1FsRHFyL29VcDhiKzFQLzRzUDdKd2hlbitJZmZwQjFKaCt3U1h0NGpwdk1UTE1TTnhwNnpTL0gydURCdk1HcW1LM1lxL0hHbXN1VU9iWHNEanFFeElqNHFld0h2VnBZc2FMK015N1FQOE5SbWVKRy9HZEdVdWVoUTNrdU9TSzF4STlkWDN3MzRnbHhwdGtGZGtHVVRiR3FJMlQ3WXh0cWR1aGJORTNiZnd5aHV3TWxkVG5vdnJXMUo4Mllwa2VqTlVSSjl0RmI4Wmpnc2krVFJ6MWc5Q25UY3k0bDlpVFBMR3htc3loakpLSEVvdVNMelptUzlGUmpVYmJ5RTVOWEk0MG1iVzhJVWp6L2tMT29DOTY0RGJXanl6Nlo2SGZnQlJ2QWU3MDMrQ011QVVWK2p5ZTF0OWw3WXV6em4yUDgxVXEreXhyVm1TenlBNWlJNW5wb3Y2UnpNM05DWmM1K1B5YjE3OEZYM3QrR0VWdTFkeDZPQWVzSng5bEhtOXNyaytIM0xYWjlhZ1hYb3VUKzIvWU82L0ZpWDM1YW15eWdneDlBeERyeWR3TW1mTUQzSmFja3lmeEhqUGQ3Y2ZyR2g1ZVRsdyt3NWhWMk9QOURDOExPT1Aya1Y1c01ZMllqOUh1REdTNmM0Z00xcHBzbm05V1lMeGJnVEsxamJuYkRRMytXK3pmY3M3aCtjZWRobm5FVExVRmxhb0M5L0Y4a3E2bWNPN2VpaTR5bjN2Rk9HRG52ZjU0d1B5ZE0vY0JaTWFPb0Y2Znd5T21IY3E5V2p6Qm1Kbm5QNFQ1M2hIT0NkV1libEt3bTNWbWlINEd6K3NwR0JyTHcxTFhENG9weDB6ZGllZWduc3lSVzNrR2FJbUJuQnRLZFJycnhXT000N05JOGE5SGl1Z1l1dzBUWWdNd1NhNzFiTnhEMlZQMTA1VDNVM1IxZzZEYU9SR1VPdTlqaFBNYzFxZ3FGS3RseEFxaUFJdDBDeXhTK2NFNjZwSEZ0Y1hPVWM3ZEc5bHpwckhHck9DWnI0emNtMmhEdk1MLzd5QXVNNlc2aFB2Wk8rTGNLMjdlSldKY1A4NzF0NGxuZVoyRk9lemhxZnB6Yk9FYy9pT3ZIY1pTejZVNmczTkZmNHhoVGhlNzkyS01PczU1Nnd2T0FHbDg5anIyK2s0OEx4YXhqblRGQXYxOTl1MFlKcWk3YU10eGxITU94cXZaV0s3bTg5MXp2SitQSWpVTEN5bjNNK29STE9OTXRVY0JUN0ErUE1DOUdzaDE2aUp6YUNEdTBZMmNiVXRwYzlIckJmWkV6bUc2TERocklYS0t6czFCN05BN3RFTUk5c0lqdE1NRzhnbmlhLzJUSWZvblF2UlAvbllpeXE3Y3B3bGkrMFJZUHdRbHhIT2hMRzFGbmdTL2JCVGZSQkQ1SWx3aG4vZ3FndmdzRVdLWHlJZFhnZldwNkJQNU5FVHNNT2I4SHc1WExWY0FBSGljZGNGdFROSUpBd0J3RDgySWpNd2pJek5FUlVSRVJFUlNRa1JUTWlKRU1pSXpNdU5JUFNORDhpRUZCTTh6M2tIa3pNZ2p6c3pJT0RKUGVmbmpYR3ZPdGVhYVk2NjU1bHhqempubkhIT3VPZWZjYzUrZWI4L3ZGeFgxUC9pbzJxajVuL2cvcllFMG9GSFFBbWd2bWhZdGpKWkgyNkk5MFhNeHNKanltTUZEMEVNMWg0RFl0RmgrN09KaHltSE9ZZEZoeitIdllEUzQ1d2p4aVBUSUVnUVBrVUw4UjZPT2lvNTZqNGJpd0hHMWNjcTRMOGNneCtxT09ZOGRRT3VoODlEZDQ2VGpEY2VCZUZBOE1iNDUzaEx2aXArUC8zRWk0UVQ1aEQ4QmtTQk9DUDFNK05rT1M0WUpZVGJZOGtuMHliS1RreWNQRXBtSjQ2ZGdwMnBPemNHVDRRMXdLM3p0Tk9HMDdQVDQ2ZTBrU0JJcnlmUnY3eG5rR2RPWlNESTNXWElXY1paMU5veW9SN1FnZEFockNqV0ZtMkpOV1VnSnArd2c0Y2dXNUFEU2pWeEg3cVhTVTFtcG9sUlZxajExT3kwbUxURU5rMFpKNDZTSjBsYlRJdW1nZEZnNk9wMmF6azZ2VDVla2E5SzNVRkdvQkJRS1JVWlZvZ1FvUXdZa0l6a0RuMEhQNEdVMFpualJNRFFhWFlobW91dlFyZWplelBKTVRtWkRwalN6TjlPZTZjNmN5VnpJWE1OSU1EMllBWXdMQTJEbU1kK3pFck1zV2NOWmsxbHpXZCt5TnJGY3JBZ3J3K3F3UTFnUEZzRE9ZWmV3RzlqOWJHZzJNcHVZWFo3TnkyN01WbWF2NGtRNEdVNkhHOEo1Y0I5d0lkd0tiZ08zbndQTlFlWVFjOHB6ZURtTk9SMDV2VG1ET1dNNU0zZ2tYb08zNDkzNEdmd0NQb3pmeVkzS2pjdEY1Rkp5R2JuY1hHRnVlMjUzcmlsM0pUZENBQkdnaENRQ2djQWc4QWdpd2dRaGtnZktnK1VoODNCNXREeE9uaWp2QXhGQkpCRExpRFZFRVZGT3RPYkQ4OGZ6UCtZdjVuL1AzOHcvSU1XVDBrZ2tFb1BFSndsSnJhUnVrbzNrSkxsSk02VEZBbmlCcHNCZTRDNllLVmdvQ0Jmc2tDRmtKSmxNWnBINVpDRzVuYXdoMjhsdThrZnlJbm1OdkhzT2NpNzVIUDZjOU54T29hQnd0aWlwU0Zsa0tYSVZmU2dLRmEwVy9hQ0FLVEFLa29LakZGS2FLZk9VbGZQeDU4dk9ONTd2UGo5OWZwT0tvTEtwVnVvWTlTTjFubnBRakM5bUZRdUxCNHRIaXNlTHA0cy9GUzhXZnkvZUxONmx4ZFBnTkNTdGtpYWpxV2dhbXFVa3JnUldrbHpDTE9HVzFKYU1sTGhMbGt0VzZXbDBMSjFJZDlCSDZRZWxnbEpwcWE1MHFOUlQrcUUwVkxwUjFsQVd1aEI3UVhWaHQ1eFRicStBVlRBcTJCWGVpcG1LT1FhTndXRFlHSkdMN0l0akY3OVd3aXU3Sy9jdkNTN05Yd3BmK3NFRU01T1lPS2FWR2Jrc3VpeTdiTG9jWVlGWU10WXFhL01LNkFya1NzZVZEVGFWeldiWHN5WHNTZlowVlZ3VnJDcTVTbExWVWJYQkVYS2NuQWtPd0Rtb2pxMkdWaWRXSTZyUjFmaHFjcld5ZXIwNndzVnh4ZHd4N3M1VnhsWEgxWEJOWmMzWGE5aHJ4R3VPYXdjOE5LK0QxODM3Y1YxNDNYbDlnZy9tcy9nRC9GWCs1bzNrRzZnYjBodk9HNjVhZW0xbGJVL3RYTzNCemNxYjlwdmJkZVE2K3kzd0xjR3QxbHM5Z2hoQm9rQW1VQWswQW9kZzlEYjBkdXZ0cGRzYnQvZnJvZlhjK29rN0NYZWtkNVliQkEzZjdtTHV5dTZ1Q211RUgzL0IvZUlYMFVVYjk4YnVUZHdER3ZHTmxzWlFFN3dKMzFUZXhHbXFhL3JjWFBncitOY3ZMWUtXM2Z2TSs0UDN2OXhmRnllTENlTHlCN1FIbmdlekQ3NjFVbHFIV3JjZmloNE9QSnlUeEVvWUVydGtTN0xYRnR1VzBJWm93N2FSMnl4dEVXbXRkUG9SL0pIa2tmS1I3dEZhZTFtN3MzMzNQenBaa2d3dEk4cG9NcWFNSzZ1VkRjdTJaUWVQSVk5ckhqc2Z1eC83TzZBZERSMGpIZTVPUktlbTA5YnA3SFIxQXAzemNyeGNMdGZJYmZLd2dxbmdLUm9VWWtXSG9sZGhWZGdWYnNXTVlsR3hyb2dvZHBVUVpiS3lYYm1rM09vQ2RjRzc4RjNsWGZ3dVY5ZG0xNEVxWG9WV1VWUWNsVkRWb3BLcWRDcUhhbEwxU2ZWTnRha0dxUlBWT0hXWm1xOXVVY3ZVUFdxSDJxLytwRjVTcjZvajNaWGR6dTYxN3EzZldMOTk3YW5zQVg1bi96N1RpKzQxUFlsNUluK3lwTUZybEpvdldwcVdvZVZxQmRwbWJidFdvN1ZyM2RvWjdZSTJyTjNWUVhWSk9yU3VVTWZVMWV1a09wM09vWnZVZmRLdDZMYjFZRDFDVDlKWDZnVjZpVjZqSDlKUDZPZjB5L3B0L1lFQllrZzI0QTEwQTlmUWFGQWFiQWFYWWNZUU1xd2I5bzBKUm95UlltUVorVWFoc2RVb041cU1UcVBYT0c4TUczZE5VQlBLUkRGeFRDS1QzR1F5T1UwVHBsblRWOU82YWM4Y1o0YWJVV2FDbVdwbW0rdk5Fbk9QZWNEc01nUG1lZk9LT1dMZXQ0QXRTUmFjcGRCU2J1RlpHaTBkRm9QRjhYKzdMQk9XYVV2SUV1bUQ5cUg3S0gzY3Z1WStTOStDRlc5bFdubFdVVCt1bjliUDZ4ZjM5L1piKzBmN0l6YWVyY0cyOVlmOEQ5dEF3b0RuS2Z3cCthbmg2ZVpnN0NCeWtESllNemcrK1BWWjBqUGlNOUd6SFR2SEhubE9mVjc3WFBaODR2bm5JY1lRZDBnd0pCNFMvN25rd1A1YjZoaDE3THhBdmVDOTZIN2hmL0haS1hWdS9jWDVhMlVZUHl3ZTlyeE1mRWw4S1hrWkhpR050STlNdjRLOGtyeWFmTFV3R2p2S0crMFluWDBkOVpyMWVzUUZjVWxkVHRmeUc4Z2J3WnVsTWZBWWZVdzM1bjBiOTFiM051U211SWZkZTMrMy83M3NBWHNhUE9GM21IZW1kei9HTWVQdTk0bnZCZSs3MzY5TndDY0VFN1AvRVA0UlRTSW03Vk14VTVWVDQxUCtxZERVcGhma2hYblIza0l2MHl2d1NyMEc3NkIzekR2dC9lSU5lM2Q4c1Q2NEQrK2orN2crb2EvZHAvRU4rVHkrRDc2UWI5MjM1NC96SS94WVA5WFA5dGY3SmY0ZS80RGY1UWY4Yy80bC80Wi9Qd0FOSkFWd0FWcUFFMmdJaUFPcWdEWGdDSXdIcGdPaFFEaXdBMFFCQ1FBS0lBTXNRQUEwQTNMQUJEZ0JOekFEZkFhV2dhMWdWREFoaUFuU2dzeGdYVkFjN0E3YWdxTkJmM0QydiswVmhsQUFBQUFBQVFBQUJCRUFsd0FXQUY4QUJRQUJBQUFBQUFBT0FBQUNBQUViQUFNQUFYaWNqWkxQVHR0QUVNWS8yd0VFQkZSb2hiaDFUejFVeFBrRHZRU0pnaEFncEloRHFEajEwQ1V4aVVYd1J2WkdFWlY2NktVOFFvOVYzNkJ2MEdmb0U3VG5IbnJydlo4M2t6UkFrV3ByN2QvTzdzNThNN01BbFBjQkhrYlBVK3dLZXlqaXJiQ1BPWHdVRHJDT2I4SUZGTDJDOEF6V3ZKZkNzN1QzaGVmby82dndQR2E5WDhLTFdQQVhoWXQ0N084SUx5SDB2d2d2NDNud1F2Z1Jab05FZUFVendYdmhWUlNEejFUbEZlWTUyM0VLYy9hbzg0MndUMDgzd2dFcStDUmM0SjZmd2pQWThGYUVaN0h1blFuUFlkZDdKenpQdkg0SUwrS0o5MXU0aUdmK212QVNYdnRONFdXODhyOExQNkxPc1o0VkxBUUQ0VldzQnpjNGhFRUNDNFUyTlArYTFLS3RqMnVraU5GQjE2MGUwV1k0NnlIaXJNWmNxdnppMENSV3RiWFZxbVg2MTJuYzZWcDFaRXluRjZsYXBjb05UWjQ2NTdBY0NvMkpSelROdWJGR05mSWorYmFJQ3dPNjF3eUxadFFaOURSaE9tejlRV2QxRWJUSkF5NTRmZHA3blVvMi8xdkpHU09seUxpY0YwYlJhOGhSY2Y2M09MWW42ZFBuV1pSbXNVbFVOYXhXS3RXdDZyYTZINnQwUDFacGt2VzBwSmhSbFd1QXBRTE5oa1M0Y3ZXNHBNM2c0azRid29uME9GTmEyVlMzb3l1ZFhpcHpJVDBJYnhkUWlvTTdYdkoyWDQwWHc1WWg3MU50NmdSWmZyVXJ4RWhzWGh4TGUxNGM3SGZUT0xPeFRoU0ZSS25OREkxNXRpM3VTN2dyWWhLS2JVMWNNcWxMcmV0dTBCNXZtT2ErMGV6Mm1RMWE3cmFoUnFFVk9vOWJVWkpGYlRWSTJsR3FiRGRTZTMzZDRrOVdOdFM0SjdXUSsvT2lXNGFxbzh4MzZONlFnZjhHRHhrZ1pTM0tyTWEwaUl5V0JvNVppZ09jNEpUZjBsaEUxOXArdlZ3ZURvZWhkc0ZEazNiS3ZaR0FyTnc0M2o4NE9UMG9PUUhUTFpaMllmcEMvUE1tUEhRNS93QnZIK2dCZUp4dDJRVllHOG5mQi9DZmhGQ3NkdTd1ZHoxaUJNNGptNWFXUW8rV3E1d0dTQ0Z0U0xoSTdkemQzZDNkM2Qzdi91ZnU3dTUzNzJibkMxbTR0OC9UZkdmSnpIeG1abmVaWkNFaDU5Ky9YdXFsLytlZlo0TDl3aVNrNUtFcThsSTFqYUVhcXFVNnFxY0dHa3ZqYUR4Tm9JbTBIQzFQSzlDS3RCS3RUS3ZRcXJRYXJVNXIwSnEwRnExTjY5QzZ0QjZ0VHh2UWhyUVJiVXliMEthMEdXMU9XOUFrMnBJYXlVZCtDbENRUXRSRVlXcW1GdHFLdHFadGFGdmFqcmFuSFNoQ1VZcFJuQ3hLMEdTYVFxMDBsYVpSRzAybmR1cWdHYlFqZGRKTW1rVmR0QlBOcGprMGwrYlJ6clFMN1VxNzBlNjBCeVhwYXJxSURxWkQ2QjQ2bFQ2alErbFlPb3JPb1N2b1loWTZrdDZnZytnaytvRitwR1BvTkRxY0hxSjM2SHM2bDY2a24ra24rb1V1cEd2b0NYcU1ycVZ1NnFIajdaVjZpbEwwT0QxSno5SFQ5QXc5UzUvVGZIcVJucWNYNkRycW8rL29CSHFGWHFLWHFaKytwSy9wQ0ZwQWFWcElBNVNoTEoxUE9kcVRCaWxQQlNwUmtSYlJZdnFDbHRBeVdrcDcwVDYwTjkxT0Y5Qit0Qy90VHdmUVYvUU4zY25LSHE1aUwxZnpHUHFiL3VFYXJ1VTZycWQvbWJpQngvSTRaaDdQRTNnaUw4Zkw4d3E4SXEvRUsvTXF2Q3F2UnIvUjc3dzZyOEZyOGxxOE5xL0Q2L0o2dkQ1dndCdnlScnd4YjhLYjhtYjBCNzNLbS9NV1BJbTM1RWIyc1o4REhPUVFOM0dZbTdtRnQ2SVA2RVBlbXJmaGJYazczcDUzNEFoSE9jWnh0ampCazNrS3Q5TDFkQU5QNVduY3h0TzVuVHQ0QnUvSW5UeVQvcVMvNkNQNm1HZHhGKy9FczNrT3orVjV2RFB2d3J2eWJydzc3OEZKN3VZZTd1VVV6K2MrN3VjMDNjVUxlQ0ZuZUlBK29VODVTNWR5amdkNVQ4NXpnWXRjNGtXOG1KZndVbDdHZS9IZXZBL3Z5L3Z4L3ZRYXZVOXYwbHYwTnIxSHI5TzdmQUFmeUFmeHdYd0lIOHFIOGVGOEJCL0pSL0hSZkF3Znk4Zng4WHdDbjhnbjhjbDhDbDNPcC9KcGZEcWZ3V2Z5V1h3Mm44UG44bmw4UGwvQUYvSkZmREZmd3BmeVpYdzVuY2RYOEpWOEZWL04xL0MxZkIxZnp6ZndqWHdUMzh5MzhLMThHOS9PZC9DZGZCZmZ6ZmZ3dlhRVzM4ZjM4d1A4SUQvRUQvTWovQ2cveG8vekUvd2tQOFZQOHpQOExEL0h6L01ML0Q5K2tWL2lsL2tWZnBWZjQ5ZjVEWDZUMytLMytSMStsOS9qOS9rRC9wQS80by81RS82VVArUFArUXYra3IvaXIva2IvcGEvNCsvNUIvNlJmK0tmK1JmK2xYL2ozL2tQL3BQLzRyLzVILzVYU0ZoRVZEeFNKVjZwbGpGU0k3VlNKL1hTSUdObG5JeVhDVEpSbHBQbFpRVlpVVmFTbFdVVldWVldrOVZsRFZsVDFwSzFaUjFaVjlhVDlXVUQyVkEya28xbEU5bFVOcFBOWlF1WkpGdEtvL2pFTHdFSlNraWFKQ3pOMGlKYnlkYXlqV3dyMjhuMnNvTkVKQ294aVlzbENaa3NVNlJWcHNvMGFaUHAwaTRkTWtOMmxFNlpLYk9rUzNhUzJUSkg1c284MlZsMmtWMWxOOWxkOXBDa2RFdVA5RXBLNWt1ZjlFdGFGc2hDeWNpQVpDVW5nN0tuNUtVZ1JTbkpJbGtzUzJTcExKTzlaRy9aUi9hVi9XUi9PVUFPbElQa1lEbEVEcFhENUhBNVFvNlVvK1JvT1VhT2xlUGtlRGxCVHBTVDVHUTVSVTZWMCtSME9VUE9sTFBrYkRsSHpwWHo1SHk1UUM2VWkrUml1VVF1bGN2a2NybENycFNyNUdxNVJxNlY2K1I2dVVGdWxKdmtacmxGYnBYYjVIYTVRKzZVdStSdXVVZnVsZnZrZm5sQUhwU0g1R0Y1UkI2VngrUnhlVUtlbEtma2FYbEducFhuNUhsNVFmNG5MOHBMOHJLOElxL0thL0s2dkNGdnlsdnl0cndqNzhwNzhyNThJQi9LUi9LeGZDS2Z5bWZ5dVh3aFg4cFg4clY4STkvS2QvSzkvQ0EveWsveXMvd2l2OHB2OHJ2OElYL0tYL0szL0NQL0tpbXJxS3BIcTlTcjFUcEdhN1JXNjdSZUczU3NqdFB4T2tFbjZuSzZ2SzZnSytwS3VyS3VvcXZxYXJxNnJxRnI2bHE2dHE2ajYrcDZ1cjV1b0J2cVJycXhicUtiNm1hNnVXNmhrM1JMYlZTZitqV2dRUTFwazRhMVdWdDBLOTFhdDlGdGRUdmRYbmZRaUVZMXBuRzFOS0dUZFlxMjZsU2RwbTA2WGR1MVEyZm9qdHFwTStsR3VrbG5hUmZkU3JmUnc3b1QzVXkzMENOMElEMUloK2xzdW9vZTFUazZsKzZsKzNRZTNhMDc2eTcwcSs2cXUrbnV1b2NtdFZ0NzZHanQxWlRPMXo3dHA5UHBURHFEdnFWTDZFUTZteTZqNCtoa09vWHUwRFRkcnd0MG9XWjBRTE9hMDBIZFUvTmEwS0tXZEpFdTFpVzZWSmZwWHJxMzdxUDc2bjY2dng2Z0IrcEJlckFlb29mcVlYcTRIcUZINmxGNnRCNmp4K3B4ZXJ5ZW9DZnFTWHF5bnFLbjZtbDZ1cDZoWitwWmVyYWVvK2ZxZVhxK1hxQVg2a1Y2c1Y2aWwrcGxlcmxlb1ZmcVZYcTFYcVBYNm5WNnZkNmdOK3BOZXJQZW9yZnFiWHE3M3FGMzZsMTZ0OTZqOStwOWVyOCtvQS9xUS9xd1BxS1A2bVA2dUQ2aFQrcFQrclErbzgvcWMvcTh2cUQvMHhmMUpYMVpYOUZYOVRWOVhkL1FOL1V0ZlZ2ZjBYZjFQWDFmUDlBUDlTUDlXRC9SVC9Vei9WeS8wQy8xSy8xYXY5RnY5VHY5WG4vUUgvVW4vVmwvMFYvMU4vMWQvOUEvOVMvOVcvL1JmejNrWVk5NDFPUHhWSG04bm1yUEdFK05wOVpUNTZuM05Iakdlc1o1eG5zbWVDWldsN0xweHNaSXZEb3lrT3pKNTdMVlNaUGVTSGMrdFNqbFRUcFJIY24xNWJLcGhkVkprM1d4bm5TK3B6UXdQNU5hVXRkVEtUdTkrUm9qeUtnMzNwTXNkOVpySW03M25DeFdXNkJTb0N4RHBaeW90WHB6eFdSUFR5cGJyRTBORjZzdERDQmwwbXVaSGxOTzFFMTJEYWR2OUhEOGpVaGYvZVNlM01CQTBuUlozK2M2cUp2aTZxRy9VdlpNNlU3bVBmMzJpN2UxbU03MHByeHBKNnBiTVljMDV0QnE1cEEyeTlXSzBhWk5TdXRVU1Mrb20rb3lGbFRLOWRQY28xbzQ0cUF2bjBwbE04bHNiN3JIMjVic0tSVlQzb3dUOVczdWVoblhnYmZOTEUzR0NVK2J2WWFlalAzaWJUZnRzNlo5dTd0OTF0MiszYlRQbXFYTkpnZHpoV0krTjlpZlVpdmJwNmxzWDNVSEpwL0Q1RHZNNUhOT05IVDBsN0o5eVh4cElKTXNGUnR5N2lOdnB4bEQzb3loMHoyR3ZIc01uV1lNZVJNelRhdUNFM1V6WGN0WUdIMnltL3pJZ0hlV2FWdzA2ekNyZkNLTDVSUFpaVTVreVp6SUxzeWxoTGwwbWJtVW5LanF5cWV6ZlZXbDhtdEQxNGg1bGR4SDFWMDQ0U1hjSDdOZFkxenNLczkxbFpkV3l0NTVab2JMbktpZFY3a0ZsZzBYcXpLNWJGK2hxcU0vbDg5VzVaelhMdWUxVkg0MXMwNDAxa2JLWXpYZEpJZUwxUkhMWkRKbDFyQ2prRWtXK2swNVZ5azd2Zmg5emNnV1pBUVpOUmtJVnhWNitoY256VkUwWmpJUnFPbkxKeGVsN05QWVhlUDA1cFNjVlM2WFBQMjUzRUtuYXFBeE1jYWVWbmNxazF0Y1ZjeGxjNFdHM25RcW55cWtDODVSYlNRejJKOTBpalhKYks2WXlxVFN5WHByc0pDMmw4RDU4UmlyaVBkYmN5alZkd3lreXlmUUhIUzVLdGQyREtUNlRLVUphYnY2Q0t2S3NUelJWREZaTlRscFg0RFZjRHp6N0IrcDdWVE42cmRMbmpKVU5TMDVPSmkwYjhTQjd0NmtUQzlKZTBubXBLc2h5NHkwZHZibnFtYW0rd2FTT2l0WnFzWW9kRVovV21QMi94bUZkSDJyYXdUalVHSG91RFk1UFBINmxIdTZxYUhwcG9lbXUzeHBaRk16R2FlOXA3czhtYjd5WktwNlU1bGlzaHA5ZVphVnAxUitzK2hNcWR4WjFVSm5TaGxuU3Vic1JHT1NMY21TdEgxN08vUFNmSC9PV3loUHlsZmxoQmJ0dWNIWFFYdGVQZlovKzdBcVYxN29ldmNhanhzMXpQcWMreXlWM0djcE4zeVd6RERpUHFRZjJlUmtzTEVSNlVQNmtRRmtFQmxDRHJVTEk1dVJMY2dJTW9xTUllTklDNWt3NllQdmcrK0Q3NFB2ZysrRDc0UHZnNCs3SzRpN0s0aTdLNGk3SytpRDc0UHZnKytEaiswczZJZnZoKytINzRmdmgrK0g3NGZ2aCsrSDc0ZnZoKytINzRmdmgrK0hINEFmZ0IrQUg0QWZnQitBSDRBZmdCK0FINEFmZ0IrQUg0QWZnQitBSDRBZmhCK0VINFFmaEIrRUg0UWZoQitFSDRRZmhCK0VINFFmaEIrRUg0UWZoQitDSDRJZmdoK0NINElmZ2grQ0g0SWZnaCtDSDRJZmdoK0NINElmZ2grQzN3Uy9DVDUydkdBVC9DYjRUZkNiNERmQmI0TGZCTDhKZmhQOEp2aE44SnZnTjhFUHd3L0REOE1Qd3cvREQ4TVB3dy9ERDhNUHd3L0REOE1Qd3cvREQ4TVB3MitHM3d5L0dYNHovR2I0emZDYjRUZkRiWWJiRExjWmJqUGNacmpOY0p2aHRzQnRnZHNDdHdWdUM5d1d1QzF3V3pEdkZ2Z3Q4RnZndDhCdmdkOEN2d1YrQy93SS9BajhDUHdJL0FqOENQd0kvQWo4Q1B3SS9BajhDUHdJL0FqOENQd0kvQ2o4S1B3by9DajhLUHdvL0NqOEtQd28vQ2o4S1B3b2ZIeU9DRWJoUitGSDRjZmd4K0RINE1mZ3grREg0TWZneCtESDRNZmd4K0RINE1mZ3grREg0TWZneCtGalh3cGlYd3JHNGNmaHgrRVA3VmR4K0hINGNmaHgrSEg0Y2ZoeCtISDRjZmdXZkF1K0JkK0NiOEczNEZ2d0xmZ1dmQXUrQmQrQ2I4RzM0RnZ3TGZnSitBbjRDZmdKK0FuNENmZ0orQW40Q2ZnSitBbjRDZmdKK0FuNENmZ0o0NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRmTXZ1K3p6UGpzOUprMCs1YWRDZTlzNTRPeGQ3R0oyZWF6L21JbmFtWVBmVFNxV1R4VU11MGk2QytDL3N6OWJpYzhjNy9iR1VJMkljUElabVFMTW9LTUltUElPQkxqTmZlN3o0ckNqOEtQd28vQ2o4S1B3by9DajhLUHdvL0NqOEtQd28vQ2o4S1B3by9DajhHUHdZL0JqOEdQd1kvQmo4R1B3WS9CajhHUHdZL0JqOEdQd1kvQmo4R1B3NC9EajhPUHc0L0RqOE9QdzQvRGo4T1B3NC9EajhPUHc0L0RqOE9QdzdmZ1cvQXQrQlo4Qzc0RjM0SnZ3YmZnVy9BdCtCWjhDNzRGMzRKdndVL0FUL2k4YzgyRnU5UUovQlI2QW5vQ2VnSjZBcnE1MjMwSjgybkszMmp1RWp0OVNEOHlnQXdpUThnbVpCalpqR3hCUnBCUms3NVFReW5ibThvWGVuTDVWRzkzcG1IUGt2MEZzdnhkUGw5STlabzYvcEIzSUoxMW5palkzMHl6dlRXcEpUMzJGeUM3dG5rL0hLekpGa3FEcVh3NmwvZGswdm1rZHpCVnNMOHdtWGNqVVk5Vnl1ZWNBeCtHNlRPL0JPeHNxa2tWaXVtQlpESFZXNVBMcGxMcHZ2NWlmMzJ4UDU5Q3VWQTNQNzFvcUZ4ZnNBZVdIWHJEOVFDazNGc2lhaGJIemdEU1daeUVaWDRsSmhMbVY2YWRjVTk3VjF1YmQ4Nmt3a0RQWUszVHFWT3NXWmJLNXlabHNxV0JNZlpnbk1MWVRETGZaMCt0VE5wZnlPdDdsdWJUbVV5NnAzd3czbjJRU2MwdjFnMzlvSmp1R2VzOEVSbitPdC9nSEpZcmxvL01tOFBmK3BlclBOb1liakN4OHJPaFZxNXF3NDhPWEQ4YjdzNzBQbHhsZ211aDh1VXZ4Q2x2eEptdU4yb2laaUp1d2pLUk1ESFp4QlFUclNhbW1waG1vczNFZEJQdEpqcE03R2lpMDhSTUU3Tk1kSm5ZeWNSc2N6S2NVKytzdkhldWVXT2U2OVNVUzg2cGNRckZ4VGwzSTZmYS9Gd3BqNUo5M1poNmhmU1NTb055MTdYT0pXU3FaZFBvcnRycHR6Ulk3WFJiR3F4QnI2WEJNYWJUY3NIcDA2N2pkR25Yd2JWamw5Q2xYY24wYUJmTWtPMkMvUlcrVU9oTzVtdUduekRWOUNZTDZXUnVTVHBwUmx3ZWxSbXhjL1dWdTNjR2F2b3ZGNnY2SmlVelJZemNxZTQ0emtyTk1GTnhIbWVVYXpVTVhZZk9oVkJubmlPYkpiQ0svYVp5K1FHZlU2cUxPRmNLeXM3b25QTDRTT1hTd3B2T3hlbVV4MGFHZGw5ekJwekhhRTV4WE9XSm1uUGNFT3RKOWRxRFNabytMQmRtdVRCckZEYldHZ0hVdGJyYXRicmF0WTV1MXpxeVhYdGx6SFVkcmo0NlhIMTBqSjVvaDJ1aUhTUDc2M0wxMGVYcW8ydjBPTHBHdHB0YnFWdVB2eDFnVVoxemhEZk00MUR6UnN6VmUyeFU3L1hsajFLK3hnaHFPbzlzVFRsZUtkZGJic2VxT09NcWZ6TkFSYmRyVlhvWVAzbjB5a3gyamRZWmc3L1JPWmpnL2xPQmFUdGxkTnZXeXFyV3Q3cUgxdXJxdE5VMWxIR3RJOGM1ZnVxb0xpZE1HNjNXdFZWV2JVTGJmOSt0eksybS9LUWYxNGlyVGZ0LzJyUzdWclREUGV5T3lyQW5qbmlJYjk3dWRQWGErWjllTzEzbmJLYnJUTThjTmNXR21TTnVuNW1WWmhObS9hZlRXYTVPdTF5cjNlVWVkbGRsMkxWZHc3ZnR4SzcvektDK3kzVXV4czhlTmJEeGMwZGY4WE5IWHZIektyTWFOMi9raWF5YlZ4bm9PSHQzSFVobTdVOFRwdDMvQWVtMDFCUUFlSndkemowS3dqQVlCdURFdnhhcGJha09Pa2hGeENWZy9CbEVIQXBxY1JSeEVvZk9DbEpCTzByRkMzZ0VqNkJrY2ZRSWVoT1BVTCszeThPYjd5ZkoweEJQSnBqaVdrYXdGdzgzODE2ZDZlS1Z1ZTVXNHpSbDkydS9YMGJLTFNlRFZna3BQeDBLTjAwRjJYWnJhZEpHbldaYVkwclhOTHExNForMzFabnFGdmxSSGNBRmZFR2p5RS9LTXlnRklBYlNvTm9DaE9BR0hpQUJyc0VqYkVUWWlMQVJLY3ZFTHZnQjE2UzVBTnpBQnlUQU0yazRCRzhiRDlsVXU0TTNzR3hxU0JBNDFFM0F4OEZmZ01SUlZnZ1B4TVFmemNGWk93QUFcIjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxuaW1wb3J0IGljb25zIGZyb20gJ3NvdXJjZS91dGlsL2ljb25zJztcclxuaW1wb3J0IHt3YXJuaW5nRnVuY30gZnJvbSAnc291cmNlL3V0aWwvdXRpbHMnO1xyXG5pbXBvcnQgY29uc3RzIGZyb20gJ3NvdXJjZS91dGlsL2NvbnN0cyc7XHJcblxyXG5pbXBvcnQgXCJzb3VyY2UvdXRpbC9jaHJvbm9cIjtcclxuaW1wb3J0IFwic291cmNlL3V0aWwvZ2VzdHVyZVwiO1xyXG5pbXBvcnQgXCJzb3VyY2UvdXRpbC9kZXZpY2VyZWFkeVwiO1xyXG5cclxuaW1wb3J0IHRoZW1lIGZyb20gJ3NvdXJjZS91dGlsL3RoZW1lJztcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICdzb3VyY2UvY29tcG9uZW50L0J1dHRvbic7XHJcbmltcG9ydCBDYXJkIGZyb20gJ3NvdXJjZS9jb21wb25lbnQvQ2FyZCc7XHJcbmltcG9ydCB7Q2VudGVyQ29udGVudCwgQWxpZ25Db250ZW50fSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NvbnRlbnRBbGlnbmVycyc7XHJcbmltcG9ydCBDaGVja2JveCBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NoZWNrYm94JztcclxuaW1wb3J0IEN1c3RvbUV2ZW50cyBmcm9tIFwic291cmNlL2NvbXBvbmVudC9DdXN0b21FdmVudHNcIjtcclxuaW1wb3J0IEdyaWQgZnJvbSAnc291cmNlL2NvbXBvbmVudC9HcmlkJztcclxuaW1wb3J0IHtJY29uLCBJY29uQnV0dG9ufSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0ljb24nO1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnc291cmNlL2NvbXBvbmVudC9JbWFnZSc7XHJcbmltcG9ydCBJbnB1dCBmcm9tICdzb3VyY2UvY29tcG9uZW50L0lucHV0JztcclxuaW1wb3J0IFBpbmJvYXJkIGZyb20gJ3NvdXJjZS9jb21wb25lbnQvUGluYm9hcmQnO1xyXG5pbXBvcnQgUHJvZ3Jlc3MgZnJvbSAnc291cmNlL2NvbXBvbmVudC9Qcm9ncmVzcyc7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSAnc291cmNlL2NvbXBvbmVudC9TbGlkZXInO1xyXG5pbXBvcnQgU3Bpbm5lciBmcm9tICdzb3VyY2UvY29tcG9uZW50L1NwaW5uZXInO1xyXG5pbXBvcnQgVG9nZ2xlIGZyb20gJ3NvdXJjZS9jb21wb25lbnQvVG9nZ2xlJztcclxuXHJcbmltcG9ydCB7Q1NTfSBmcm9tICdzb3VyY2UvdXRpbC9zdHlsZXNoZWV0JztcclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuXHJcbndpbmRvdy5Eb3JpYyA9IHtcclxuICAgIEJ1dHRvbixcclxuICAgIENhcmQsXHJcbiAgICBDZW50ZXJDb250ZW50LFxyXG4gICAgQWxpZ25Db250ZW50LFxyXG4gICAgQ2hlY2tib3gsXHJcbiAgICBDdXN0b21FdmVudHMsXHJcbiAgICBHcmlkLFxyXG4gICAgSWNvbixcclxuICAgIEljb25CdXR0b24sXHJcbiAgICBJbWFnZSxcclxuICAgIElucHV0LFxyXG4gICAgUGluYm9hcmQsXHJcbiAgICBQcm9ncmVzcyxcclxuICAgIFNsaWRlcixcclxuICAgIFNwaW5uZXIsXHJcbiAgICBUb2dnbGVcclxufTtcclxud2luZG93LlJlYWN0ID0gUmVhY3Q7XHJcbndpbmRvdy5Eb3JpY1V0aWwgPSB7XHJcbiAgICBDU1MsXHJcbiAgICB3YXJuaW5nRnVuY1xyXG59O1xyXG5cclxuTWF0aC5yYW5kID0gKGEsIGIgPSBudWxsKSA9PiB7XHJcbiAgICBpZiAoYiA9PT0gbnVsbCkge1xyXG4gICAgICAgIGIgPSBhO1xyXG4gICAgICAgIGEgPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChiIC0gYSArIDEpKSArIGE7XHJcbn07XHJcblxyXG53aW5kb3cuY2Jsb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xyXG53aW5kb3cuY2JlcnIgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxuaW1wb3J0IHtjcmVhdGVTdHlsZVNoZWV0LCBnZW5DU1N9IGZyb20gJ3NvdXJjZS91dGlsL3N0eWxlc2hlZXQnO1xyXG5cclxuaW1wb3J0IFJvYm90b0ZvbnQgZnJvbSAnc291cmNlL2RhdGEtdXJpL3JvYm90by1saWdodC53b2ZmLnNvdXJjZSc7XHJcbmltcG9ydCBJb25pY0ZvbnQgZnJvbSAnc291cmNlL2RhdGEtdXJpL2lvbmljb25zLndvZmYuc291cmNlJztcclxuXHJcbmNvbnN0IGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKTtcclxuY29uc3Qgcm9ib3RvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5jb25zdCBhcHBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuY29uc3QgZm9udHMgPSBuZXcgU2V0KCk7XHJcblxyXG5jb25zdCBjb21wb25lbnRTdHlsZVNoZWV0ID0gY3JlYXRlU3R5bGVTaGVldCgpO1xyXG5sZXQgaW5pdENhbGxlZCA9IGZhbHNlO1xyXG5cclxucm9ib3RvLnNldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiLCBcImRvcmljLWNvcmUtc3R5bGVcIik7XHJcbmhlYWQuYXBwZW5kQ2hpbGQocm9ib3RvKTtcclxuXHJcbmFwcFN0eWxlLnNldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiLCBcImRvcmljLWFwcC1zdHlsZVwiKTtcclxuaGVhZC5hcHBlbmRDaGlsZChhcHBTdHlsZSk7XHJcblxyXG53aW5kb3cuQXBwID0ge1xyXG4gICAgYXN5bmMgcmVuZGVyKGNvbnRlbnQpIHtcclxuICAgICAgICBjb25zdCB3cmFwcGVyID0gKFxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7cG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogMCwgbGVmdDogMCwgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIG92ZXJmbG93OiAnaGlkZGVuJ319Pntjb250ZW50fTwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKGluaXRDYWxsZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRldmljZVJlYWR5O1xyXG4gICAgICAgICAgICBjb21wb25lbnRTdHlsZVNoZWV0Ll9faW5pdChyb2JvdG8pO1xyXG4gICAgICAgICAgICBpbml0Q2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhY3RET00ucmVuZGVyKHdyYXBwZXIsIGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgIEFwcC5zdHlsZVNoZWV0Ll9faW5pdChhcHBTdHlsZSk7XHJcbiAgICAgICAgQXBwLnN0eWxlU2hlZXQgPSBjcmVhdGVTdHlsZVNoZWV0KCk7XHJcbiAgICB9LFxyXG4gICAgYWRkRm9udChuYW1lLCBkZWYpIHtcclxuICAgICAgICBpZiAoZm9udHMuaGFzKG5hbWUpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHJcbiAgICAgICAgZm9udHMuYWRkKG5hbWUpO1xyXG4gICAgICAgIGVsZW0uZGF0YXNldC5mb250TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgZWxlbS5pbm5lckhUTUwgPSBnZW5DU1Moe1wiQGZvbnQtZmFjZVwiOiBkZWZ9KTtcclxuXHJcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgIH0sXHJcbiAgICBzdHlsZVNoZWV0OiBjcmVhdGVTdHlsZVNoZWV0KClcclxufTtcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiKlwiOiB7XHJcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcclxuICAgIH0sXHJcbiAgICBcImh0bWwsIGJvZHlcIjoge1xyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBtYXJnaW46IDBcclxuICAgIH0sXHJcbiAgICBib2R5OiB7XHJcbiAgICAgICAgZm9udEZhbWlseTogXCJSb2JvdG9cIixcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjVmNWY1J1xyXG4gICAgfVxyXG59KTtcclxuQXBwLmFkZEZvbnQoJ3JvYm90bycsIHtcclxuICAgIGZvbnRGYW1pbHk6IGBcIlJvYm90b1wiYCxcclxuICAgIHNyYzogYHVybChcIiR7Um9ib3RvRm9udH1cIikgZm9ybWF0KFwid29mZlwiKWAsXHJcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxyXG4gICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiXHJcbn0pO1xyXG5BcHAuYWRkRm9udCgnaW9uaWMnLCB7XHJcbiAgICBmb250RmFtaWx5OiBgXCJJb25pY1wiYCxcclxuICAgIHNyYzogYHVybChcIiR7SW9uaWNGb250fVwiKSBmb3JtYXQoXCJ3b2ZmXCIpYCxcclxuICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXHJcbiAgICBmb250U3R5bGU6IFwibm9ybWFsXCJcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnRTdHlsZVNoZWV0O1xyXG4iLCJpbXBvcnQgcmVnZXggZnJvbSAneHJlZ2V4cCc7XHJcblxyXG5jb25zdCBjaHJvbm9TcGVjaWFsID0ge1xyXG4gICAgJ3llc3RlcmRheScoZGF0ZSkge1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDEpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgICcxIHdlZWsgYWdvJyhkYXRlKSB7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gNyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGNocm9ub1VuaXRSZWdleCA9IHJlZ2V4KFwiKD88b2Zmc2V0PihcXFxcK3xcXFxcLSlcXFxcZCspICg/PHVuaXQ+XFxcXHcrKVwiKTtcclxuY29uc3QgdW5pdEZ1bmN0aW9uID0ge1xyXG4gICAgbWlsbGlzZWNvbmQoZGF0ZSwgbWlsbGlzZWNvbmRzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG1pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgc2Vjb25kKGRhdGUsIHNlY29uZHMpIHtcclxuICAgICAgICBkYXRlLnNldFNlY29uZHMoZGF0ZS5nZXRTZWNvbmRzKCkgKyBzZWNvbmRzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBtaW51dGUoZGF0ZSwgbWludXRlcykge1xyXG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIG1pbnV0ZXMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIGhvdXIoZGF0ZSwgaG91cnMpIHtcclxuICAgICAgICBkYXRlLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSArIGhvdXJzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBkYXkoZGF0ZSwgZGF5cykge1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIGRheXMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIHdlZWsoZGF0ZSwgd2Vla3MpIHtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyB3ZWVrcyAqIDcpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIG1vbnRoKGRhdGUsIG1vbnRocykge1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gZGF0ZS5nZXRNb250aCgpICsgbW9udGhzO1xyXG4gICAgICAgIGRhdGUuc2V0TW9udGgoZXhwZWN0ZWQpO1xyXG4gICAgICAgIGlmIChkYXRlLmdldE1vbnRoKCkgIT09IGV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZSgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgeWVhcihkYXRlLCB5ZWFycykge1xyXG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgeWVhcnMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIGRlY2FkZShkYXRlLCBkZWNhZGVzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBkZWNhZGVzICogMTApO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzdGFydE9mID0ge1xyXG4gICAgc2Vjb25kKGRhdGUpIHtcclxuICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcclxuICAgIH0sXHJcbiAgICBtaW51dGUoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2Yuc2Vjb25kKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcygwKTtcclxuICAgIH0sXHJcbiAgICBob3VyKGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLm1pbnV0ZShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoMCk7XHJcbiAgICB9LFxyXG4gICAgZGF5KGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLmhvdXIoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRIb3VycygwKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrKGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLmRheShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpKTtcclxuICAgIH0sXHJcbiAgICBtb250aChkYXRlKSB7XHJcbiAgICAgICAgc3RhcnRPZi5kYXkoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKDEpO1xyXG4gICAgfSxcclxuICAgIHllYXIoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2YubW9udGgoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNb250aCgwKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZW5kT2YgPSB7XHJcbiAgICBzZWNvbmQoZGF0ZSkge1xyXG4gICAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDk5OSk7XHJcbiAgICB9LFxyXG4gICAgbWludXRlKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5zZWNvbmQoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKDU5KTtcclxuICAgIH0sXHJcbiAgICBob3VyKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5taW51dGUoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKDU5KTtcclxuICAgIH0sXHJcbiAgICBkYXkoZGF0ZSkge1xyXG4gICAgICAgIGVuZE9mLmhvdXIoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRIb3VycygyMyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayhkYXRlKSB7XHJcbiAgICAgICAgZW5kT2YuZGF5KGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArICg2IC0gZGF0ZS5nZXREYXkoKSkpO1xyXG4gICAgfSxcclxuICAgIG1vbnRoKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5kYXkoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyAxKTtcclxuICAgICAgICBkYXRlLnNldERhdGUoMCk7XHJcbiAgICB9LFxyXG4gICAgeWVhcihkYXRlKSB7XHJcbiAgICAgICAgZW5kT2YubW9udGgoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNb250aCgxMSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHVuaXRDb252ZXJzaW9uID0ge1xyXG4gICAgJ21pbGxpc2Vjb25kJzogJ21pbGxpc2Vjb25kJyxcclxuICAgICdtaWxsaXNlY29uZHMnOiAnbWlsbGlzZWNvbmQnLFxyXG4gICAgJ21zJzogJ21pbGxpc2Vjb25kJyxcclxuXHJcbiAgICAnc2Vjb25kJzogJ3NlY29uZCcsXHJcbiAgICAnc2Vjb25kcyc6ICdzZWNvbmQnLFxyXG4gICAgJ3MnOiAnc2Vjb25kJyxcclxuXHJcbiAgICAnbWludXRlJzogJ21pbnV0ZScsXHJcbiAgICAnbWludXRlcyc6ICdtaW51dGUnLFxyXG4gICAgJ21pbic6ICdtaW51dGUnLFxyXG5cclxuICAgICdob3VyJzogJ2hvdXInLFxyXG4gICAgJ2hvdXJzJzogJ2hvdXInLFxyXG4gICAgJ2hyJzogJ2hvdXInLFxyXG5cclxuICAgICdkYXknOiAnZGF5JyxcclxuICAgICdkYXlzJzogJ2RheScsXHJcbiAgICAnbmknOiAnZGF5JyxcclxuICAgICdoaSc6ICdkYXknLFxyXG4gICAgJ+aXpSc6ICdkYXknLFxyXG5cclxuICAgICd3ZWVrJzogJ3dlZWsnLFxyXG4gICAgJ3dlZWtzJzogJ3dlZWsnLFxyXG4gICAgJ3NodXUnOiAnd2VlaycsXHJcbiAgICAn44GX44KF44GGJzogJ3dlZWsnLFxyXG4gICAgJ+mAsSc6ICd3ZWVrJyxcclxuXHJcbiAgICAnbW9udGgnOiAnbW9udGgnLFxyXG4gICAgJ21vbnRocyc6ICdtb250aCcsXHJcblxyXG4gICAgJ3llYXInOiAneWVhcicsXHJcbiAgICAneWVhcnMnOiAneWVhcicsXHJcblxyXG4gICAgJ2RlY2FkZSc6ICdkZWNhZGUnLFxyXG4gICAgJ2RlY2FkZXMnOiAnZGVjYWRlJ1xyXG59O1xyXG5jb25zdCBjaHJvbm9JbmZvID0ge1xyXG4gICAgZGF5czogW1xyXG4gICAgICAgICdTdW5kYXknLFxyXG4gICAgICAgICdNb25kYXknLFxyXG4gICAgICAgICdUdWVzZGF5JyxcclxuICAgICAgICAnV2VkbmVzZGF5JyxcclxuICAgICAgICAnVGh1cnNkYXknLFxyXG4gICAgICAgICdGcmlkYXknLFxyXG4gICAgICAgICdTYXR1cmRheSdcclxuICAgIF0sXHJcbiAgICBtb250aHM6IFtcclxuICAgICAgICAnSmFudWFyeScsXHJcbiAgICAgICAgJ0ZlYnJ1YXJ5JyxcclxuICAgICAgICAnTWFyY2gnLFxyXG4gICAgICAgICdBcHJpbCcsXHJcbiAgICAgICAgJ01heScsXHJcbiAgICAgICAgJ0p1bmUnLFxyXG4gICAgICAgICdKdWx5JyxcclxuICAgICAgICAnQXVndXN0JyxcclxuICAgICAgICAnU2VwdGVtYmVyJyxcclxuICAgICAgICAnT2N0b2JlcicsXHJcbiAgICAgICAgJ05vdmVtYmVyJyxcclxuICAgICAgICAnRGVjZW1iZXInXHJcbiAgICBdXHJcbn07XHJcbmNvbnN0IGNocm9ub0Zvcm1hdCA9IHtcclxuICAgIG1zOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldE1pbGxpc2Vjb25kcygpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMDAke2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCl9YC5zbGljZSgtMylcclxuICAgIH0sXHJcbiAgICBzZWNvbmQ6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0U2Vjb25kcygpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMCR7ZGF0ZS5nZXRTZWNvbmRzKCl9YC5zbGljZSgtMilcclxuICAgIH0sXHJcbiAgICBtaW51dGU6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMCR7ZGF0ZS5nZXRNaW51dGVzKCl9YC5zbGljZSgtMilcclxuICAgIH0sXHJcbiAgICBob3VyOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgcGFkZGVkOiBkYXRlID0+IGAwJHtkYXRlLmdldEhvdXJzKCl9YC5zbGljZSgtMiksXHJcbiAgICAgICAgXCIxMlwiOiBkYXRlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaG91ciA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xyXG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIjEycGFkZGVkXCI6IGRhdGUgPT4gYDAke2Nocm9ub0Zvcm1hdC5ob3VyWycxMiddKGRhdGUpfWAuc2xpY2UoLTIpXHJcbiAgICB9LFxyXG4gICAgd2Vla2RheToge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXREYXkoKSxcclxuICAgICAgICBzaG9ydDogZGF0ZSA9PiBjaHJvbm9JbmZvLmRheXNbZGF0ZS5nZXREYXkoKV0uc2xpY2UoMCwgMyksXHJcbiAgICAgICAgZnVsbDogZGF0ZSA9PiBjaHJvbm9JbmZvLmRheXNbZGF0ZS5nZXREYXkoKV1cclxuICAgIH0sXHJcbiAgICBkYXRlOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldERhdGUoKSxcclxuICAgICAgICBwYWRkZWQ6IGRhdGUgPT4gYDAke2RhdGUuZ2V0RGF0ZSgpfWAuc2xpY2UoLTIpXHJcbiAgICB9LFxyXG4gICAgbW9udGg6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0TW9udGgoKSArIDEsXHJcbiAgICAgICAgc2hvcnQ6IGRhdGUgPT4gY2hyb25vSW5mby5tb250aHNbZGF0ZS5nZXREYXRlKCldLnNsaWNlKDAsIDMpLFxyXG4gICAgICAgIGZ1bGw6IGRhdGUgPT4gY2hyb25vSW5mby5tb250aHNbZGF0ZS5nZXREYXRlKCldXHJcbiAgICB9LFxyXG4gICAgeWVhcjoge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwLFxyXG4gICAgICAgIGZ1bGw6IGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpXHJcbiAgICB9LFxyXG4gICAgdG9kOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiAoZGF0ZS5nZXRIb3VycygpIDwgMTIgPT09IHRydWUpID8gXCJBTVwiIDogXCJQTVwiXHJcbiAgICB9XHJcbn07XHJcbmNocm9ub0Zvcm1hdC5kYXkgPSBjaHJvbm9Gb3JtYXQuZGF0ZTtcclxuY29uc3QgY2hyb25vQ2hlY2tVbml0ID0gdW5pdCA9PiB7XHJcbiAgICBpZiAodW5pdENvbnZlcnNpb24uaGFzT3duUHJvcGVydHkodW5pdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgdW5pdDogJHt1bml0fWApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyogLUF4ZWxEb2MtXHJcbm1vZHVsZSBnbG9iYWwge1xyXG4gICAgQGZ1bmN0aW9uIGNocm9ubyB7XHJcbiAgICAgICAgQGRlc2MgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB7Y2hyb25vfS5cclxuICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgIEBhcmcgZGF0ZVRpbWUgW0RhdGVdXHJcbiAgICAgICAgICAgICAgICBUaGlzIGlzIHNvbWUgbG9uZyBkZXNjcmlwdGlvbiBvZiB0aGUgdGhpbmdcclxuICAgICAgICAgICAgICAgIHt5ZWFyLCBtb250aH0gZGVzdHJ1Y3R1cmluZz9cclxuICAgICAgICAgICAgICAgIFt0aXRsZV15ZWFyW3RpdGxlXVxyXG4gICAgICAgIH1cclxuICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG5cclxuICAgICAgICBAZnVuY3Rpb24gZGlmZiB7XHJcbiAgICAgICAgICAgIEBkZXNjIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGN1bGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgdG8gYWRkIHRvIHRoZSBmaXJzdCBhcmd1bWVudCBpbiBvcmRlciB0byBnZXQgdGhlIHNlY29uZCBhcmd1bWVudC5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBzdGFydERhdGUgW2Nocm9ub10gVGhlIGRhdGUgdG8gc3RhcnQgZnJvbS5cclxuICAgICAgICAgICAgICAgIEBhcmcgdGFyZ2V0RGF0ZSBbY2hyb25vXSBUaGUgZGF0ZSB0byBnZXQgdG8uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBvYmplY3RcclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIG5vdyB7XHJcbiAgICAgICAgICAgIEBkZXNjIFJldHVybnMgdGhlIGN1cnJlbnQgZGF0ZSBhcyBhIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEBhcmdzIHt9XHJcbiAgICAgICAgICAgIEByZXR1cm4gY2hyb25vXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBmdW5jdGlvbiBwYXJzZSB7XHJcbiAgICAgICAgICAgIEBkZXNjIFBhcnNlcyBhIGRhdGUgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBjaHJvbm8gb2JqZWN0IHJlcHJlc2VudGVkIGJ5IGl0LlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGRhdGVTdHJpbmcgW3N0cmluZ10gVGhlIHN0cmluZyB0byBwYXJzZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gcGFyc2VNUyB7XHJcbiAgICAgICAgICAgIEBkZXNjIFBhcnNlcyBhIGRhdGUgc3RyaW5nIGdlbmVyYXRlZCBieSBDIyBjb2RlIGFuZCByZXR1cm5zIHRoZSBjaHJvbm8gb2JqZWN0IHJlcHJlc2VudGVkIGJ5IGl0LlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGRhdGVTdHJpbmcgW3N0cmluZ10gVGhlIHN0cmluZyB0byBwYXJzZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gdHJpZ2dlciB7XHJcbiAgICAgICAgICAgIEBkZXNjIEZpcmVzIGEgZnVuY3Rpb24gYWZ0ZXIgYSBzcGVjaWZpZWQgdGltZS5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBkZWxheSBbbnVtYmVyXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxyXG4gICAgICAgICAgICAgICAgQGFyZyBmdW5jIFtmdW5jdGlvbl0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9UcmlnZ2VyXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9iamVjdCBjaHJvbm8ge1xyXG4gICAgICAgIEBwcm9wIGRhdGVPYmplY3Qge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgRGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIERhdGVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEBwcm9wIHVuaXhUaW1lc3RhbXAge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSB1bml4IHRpbWVzdGFtcCBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAcHJvcCBtaWxsaXNlY29uZHMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBtaWxsaXNlY29uZHMgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCBzZWNvbmRzIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgc2Vjb25kcyBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIG1pbnV0ZXMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBtaW51dGVzIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3AgaG91cnMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBob3VycyBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIHdlZWtkYXkge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSB3ZWVrZGF5IG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3AgZGF0ZSB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIGRhdGUgb2YgdGhlIGNocm9ubyBvYmplY3QuIFRoaXMgbnVtYmVyIGlzIGFkanVzdGVkIHRvIHRoZSByYW5nZSAoMC0zMCkgdW5saWtlIHRoZSBub3JtYWwgRGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCBtb250aHMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBtb250aHMgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCB5ZWFyIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgeWVhciBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAZnVuY3Rpb24gc2hpZnQge1xyXG4gICAgICAgICAgICBAZGVzYyBTaGlmdHMgdGhlIGRhdGUgZm9yd2FyZCBvciBiYWNrd2FyZCBpbiB0aW1lLlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIG9mZnNldCBbTnVtYmVyXSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc2hpZnQgdGhlIGRhdGUuXHJcbiAgICAgICAgICAgICAgICBAYXJnIHVuaXQgW1N0cmluZ10gVGhlIHVuaXRzIHRvIHNoaWZ0IGJ5LiBWYWxpZCB2YWx1ZXMgYXJlOiAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInLCAnZGVjYWRlJy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGR1cmF0aW9uIFtvYmplY3RdIEFuIG9iamVjdCB0aGF0IHdpbGwgc2hpZnQgdGhlIGRhdGUuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9cclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIHN0YXJ0T2Yge1xyXG4gICAgICAgICAgICBAZGVzYyBNb3ZlcyB0aGUgZGF0ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNwZWNpZmllZCB1bml0LlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIHVuaXQgW3N0cmluZ10gVGhlIHVuaXQgdG8gbW92ZSB0byB0aGUgc3RhcnQgb2YuIFZhbGlkIHZhbHVlcyBhcmU6ICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcicuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9cclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIGZvcm1hdCB7XHJcbiAgICAgICAgICAgIEBkZXNjIEZvcm1hdHMgdGhlIGNocm9ubyBvYmplY3QgdXNpbmcgdGhlIHNwZWNpZmllZCBzdHJpbmcuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgZm9ybWF0IFtzdHJpbmddIFRoZSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZm9ybWF0IHRoZSBkYXRlIHNob3VsZCBiZSBwdXQgaW50by5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIHN0cmluZ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvYmplY3QgY2hyb25vVHJpZ2dlciB7XHJcbiAgICAgICAgQHByb3Agc3RhdHVzIHtcclxuICAgICAgICAgICAgQGRlc2MgVGhlIHN0YXR1cyBvZiB0aGUgdHJpZ2dlci5cclxuICAgICAgICAgICAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAZnVuY3Rpb24gY2FuY2VsIHtcclxuICAgICAgICAgICAgQGRlc2MgQ2FuY2VscyB0aGUgdHJpZ2dlciBpZiBpdCBoYXNuJ3QgZmlyZWQgeWV0LlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4qL1xyXG5jb25zdCBjaHJvbm8gPSAoYXJnID0gbnVsbCkgPT4ge1xyXG4gICAgY29uc3QgaW50ZXJuYWxEYXRlID0gKCgpID0+IHtcclxuICAgICAgICBpZiAoYXJnID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKERhdGUucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYXJnKSA9PT0gdHJ1ZSB8fCAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShhcmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFyZy5fX2Nocm9ubyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJnLmRhdGVPYmplY3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYXJnID0gYXJnLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChjaHJvbm9TcGVjaWFsLmhhc093blByb3BlcnR5KGFyZykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaHJvbm9TcGVjaWFsW2FyZ10obmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhhcmcsIGNocm9ub1VuaXRSZWdleCk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge29mZnNldCwgdW5pdH0gPSBtYXRjaDtcclxuXHJcbiAgICAgICAgICAgICAgICBjaHJvbm9DaGVja1VuaXQodW5pdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuaXRGdW5jdGlvblt1bml0Q29udmVyc2lvblt1bml0XV0obmV3IERhdGUoKSwgcGFyc2VJbnQob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShhcmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qge3llYXIgPSAxOTcwLCBtb250aCA9IDAsIGRhdGUgPSAwLCBob3VycyA9IDAsIG1pbnV0ZXMgPSAwLCBzZWNvbmRzID0gMCwgbWlsbGlzZWNvbmRzID0gMH0gPSBhcmc7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlICsgMSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX19jaHJvbm86IHRydWUsXHJcbiAgICAgICAgZ2V0IGRhdGVPYmplY3QoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShpbnRlcm5hbERhdGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHVuaXhUaW1lc3RhbXAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0VGltZSgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldCBtaWxsaXNlY29uZHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2Vjb25kcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRTZWNvbmRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgbWludXRlcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgaG91cnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCB3ZWVrZGF5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldERheSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGRhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0RGF0ZSgpIC0gMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBtb250aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRNb250aCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHllYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQocHJvcHMpIHtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgeWVhciA9IGludGVybmFsRGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICAgICAgbW9udGggPSBpbnRlcm5hbERhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgICAgIGRhdGUgPSBpbnRlcm5hbERhdGUuZ2V0RGF0ZSgpIC0gMSxcclxuICAgICAgICAgICAgICAgIGhvdXJzID0gaW50ZXJuYWxEYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gaW50ZXJuYWxEYXRlLmdldE1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBpbnRlcm5hbERhdGUuZ2V0U2Vjb25kcygpLFxyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gaW50ZXJuYWxEYXRlLmdldE1pbGxpc2Vjb25kcygpXHJcbiAgICAgICAgICAgIH0gPSBwcm9wcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjaHJvbm8obmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUgKyAxLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaGlmdChvZmZzZXQsIHVuaXQpIHtcclxuICAgICAgICAgICAgbGV0IG5ld0RhdGU7XHJcbiAgICAgICAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZShpbnRlcm5hbERhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAob2Zmc2V0Lmhhc093blByb3BlcnR5KCdfX2Nocm9ub19kdXJhdGlvbicpICYmIG9mZnNldC5fX2Nocm9ub19kdXJhdGlvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIG9mZnNldCA9IG9mZnNldC5hc09iamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3VuaXQsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb25vQ2hlY2tVbml0KHVuaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGUgPSB1bml0RnVuY3Rpb25bdW5pdENvbnZlcnNpb25bdW5pdF1dKG5ld0RhdGUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hyb25vKG5ld0RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKG9mZnNldCwgY2hyb25vVW5pdFJlZ2V4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKHtvZmZzZXQsIHVuaXR9ID0gbWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9ub0NoZWNrVW5pdCh1bml0KTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUludChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaHJvbm8odW5pdEZ1bmN0aW9uW3VuaXRDb252ZXJzaW9uW3VuaXRdXShuZXdEYXRlLCBvZmZzZXQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhcnRPZih1bml0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkRGF0ZSA9IG5ldyBEYXRlKGludGVybmFsRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBzdGFydE9mW3VuaXRdKGFkanVzdGVkRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2hyb25vKGFkanVzdGVkRGF0ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmRPZih1bml0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkRGF0ZSA9IG5ldyBEYXRlKGludGVybmFsRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBlbmRPZlt1bml0XShhZGp1c3RlZERhdGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNocm9ubyhhZGp1c3RlZERhdGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZm9ybWF0KGZvcm1hdFN0cmluZyA9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdFN0cmluZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0U3RyaW5nID09PSAndXRjJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRTdHJpbmcgPT09ICdsb2NhbGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRTdHJpbmcucmVwbGFjZShcclxuICAgICAgICAgICAgICAgIC9cXHsoXFx3KykoXFwvKFxcdyspKT9cXH0vZyxcclxuICAgICAgICAgICAgICAgIChmdWxsLCBwcm9wLCBza2lwLCB0eXBlID0gJ2Jhc2UnKSA9PiBjaHJvbm9Gb3JtYXRbcHJvcF1bdHlwZV0oaW50ZXJuYWxEYXRlKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUudG9TdHJpbmcoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGludGVybmFsRGF0ZS50b0pTT04oKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwie21vbnRofS17ZGF5fS17eWVhci9mdWxsfSB7aG91ci9wYWRkZWR9OnttaW51dGUvcGFkZGVkfTp7c2Vjb25kL3BhZGRlZH1cIi5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgL1xceyhcXHcrKShcXC8oXFx3KykpP1xcfS9nLFxyXG4gICAgICAgICAgICAgICAgKGZ1bGwsIHByb3AsIHNraXAsIHR5cGUgPSAnYmFzZScpID0+IGNocm9ub0Zvcm1hdFtwcm9wXVt0eXBlXShpbnRlcm5hbERhdGUpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuY2hyb25vLmRpZmYgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xyXG4gICAgY29uc3QgaW50ZXJuYWxEYXRlID0gbmV3IERhdGUoc2Vjb25kLnVuaXhUaW1lc3RhbXAgLSBmaXJzdC51bml4VGltZXN0YW1wKTtcclxuICAgIGNvbnNvbGUubG9nKHNlY29uZC51bml4VGltZXN0YW1wIC0gZmlyc3QudW5peFRpbWVzdGFtcCk7XHJcbiAgICBjb25zb2xlLmxvZyhpbnRlcm5hbERhdGUpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBpbnRlcm5hbERhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXHJcbiAgICAgICAgc2Vjb25kczogaW50ZXJuYWxEYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICBtaW51dGVzOiBpbnRlcm5hbERhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgIGhvdXJzOiBpbnRlcm5hbERhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICBkYXlzOiBpbnRlcm5hbERhdGUuZ2V0RGF0ZSgpIC0gMSxcclxuICAgICAgICBtb250aHM6IGludGVybmFsRGF0ZS5nZXRNb250aCgpLFxyXG4gICAgICAgIHllYXJzOiBpbnRlcm5hbERhdGUuZ2V0RnVsbFllYXIoKSAtIDE5NzBcclxuICAgIH07XHJcbn07XHJcbmNocm9uby5ub3cgPSAoKSA9PiBjaHJvbm8oRGF0ZS5ub3coKSk7XHJcbmNocm9uby5wYXJzZSA9IHN0cmluZyA9PiBjaHJvbm8oRGF0ZS5wYXJzZShzdHJpbmcpKTtcclxuY2hyb25vLnBhcnNlTVMgPSBzdHJpbmcgPT4gY2hyb25vKERhdGUucGFyc2Uoc3RyaW5nLnJlcGxhY2UoXCJUXCIsIFwiIFwiKSkpO1xyXG5jaHJvbm8udHJpZ2dlciA9IChkZWxheSwgZnVuYywgLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgc3RhdHVzID0gJ2ZpcmVkJztcclxuICAgICAgICAgICAgZnVuYyguLi5hcmdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGF5XHJcbiAgICApO1xyXG4gICAgbGV0IHN0YXR1cztcclxuXHJcbiAgICBzdGF0dXMgPSAnd2FpdGluZyc7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxsZWQnO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHN0YXR1cygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5jaHJvbm8ud2FpdCA9IHdhaXQgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUobnVsbCksIHdhaXQpKTtcclxuXHJcbndpbmRvdy5jaHJvbm8gPSBjaHJvbm87XHJcbi8vIGV4cG9ydCBkZWZhdWx0IGNocm9ubztcclxuIiwiZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdGhlbWU6IHtcclxuICAgICAgICBibHVpc2g6ICcjNDI4NWY0JyxcclxuICAgICAgICBncmF5Qkc6IFwiI2QwZDBkMFwiXHJcbiAgICB9LFxyXG4gICAgY3NzOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZFRyYW5zaXRpb246IFwiYmFja2dyb3VuZC1jb2xvciAyNTBtcyBsaW5lYXJcIlxyXG4gICAgfVxyXG59O1xyXG4iLCJpbXBvcnQgRW52IGZyb20gJ3NvdXJjZS91dGlsL2Vudic7XHJcblxyXG4vKipcclxuICAgIEB0eXBlIFByb21pc2VcclxuICAgIEBuYW1lIGRldmljZVJlYWR5XHJcbiAgICBAZGVzYyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgZGV2aWNlcmVhZHkgZXZlbnQgaGFzIGZpcmVkIGluIGNvZG92YS5cclxuICAgICAgICBVc2VmdWwgZm9yIHBsdWdpbnMgdGhhdCBhcmUgd3JpdHRlbiBhbmQgaW5jbHVkZWQgb3V0c2lkZSBvZiBDb3JpbnRoaWFuLlxyXG4qL1xyXG5pZiAod2luZG93LmRldmljZVJlYWR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHdpbmRvdy5kZXZpY2VSZWFkeSA9IG5ldyBQcm9taXNlKFxyXG4gICAgICAgIHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoRW52LmFwcCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZXJlYWR5XCIsICgpID0+IHJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBAdHlwZSBPYmplY3RcclxuICAgIEBuYW1lIEVudmlyb25tZW50XHJcbiAgICBAZGVzYyBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbW9iaWxlXHJcbiAgICAgICAgVHJ1ZSBpZiB0aGUgY3VycmVudCBwYWdlIGlzIG9uIGEgbW9iaWxlIHBsYXRmb3JtIChtb2JpbGUgYnJvd3NlciwgY29yZG92YSwgZXRjLikuXHJcbiAgICBAcHJvcGVydHkge0Jvb2xlYW59IGFwcFxyXG4gICAgICAgIFRydWUgaWYgdGhlIGN1cnJlbnQgcGFnZSBpcyBpbnNpZGUgb2YgY29yZG92YS5cclxuKi9cclxuXHJcbmNvbnN0IGV2ZW50U3VwcG9ydCA9ICgoKSA9PiB7XHJcbiAgICBsZXQgcGFzc2l2ZSA9IGZhbHNlO1xyXG4gICAgbGV0IG9uY2UgPSBmYWxzZTtcclxuICAgIGNvbnN0IGV2dENoZWNrZXIgPSB7XHJcbiAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XHJcbiAgICAgICAgICAgIHBhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBvbmNlKCkge1xyXG4gICAgICAgICAgICBvbmNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbnVsbCwgZXZ0Q2hlY2tlcik7XHJcbiAgICByZXR1cm4ge3Bhc3NpdmUsIG9uY2V9O1xyXG59KSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBtb2JpbGU6IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTW9iaWxlXCIpICE9PSAtMSxcclxuICAgIGFwcDogdHlwZW9mIGNvcmRvdmEgIT09ICd1bmRlZmluZWQnLFxyXG4gICAgZXZlbnRzOiBldmVudFN1cHBvcnRcclxufSk7XHJcbiIsImltcG9ydCBFbnYgZnJvbSBcInNvdXJjZS91dGlsL2VudlwiO1xyXG5cclxuY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIG9wdHMgPSBmYWxzZSkge1xyXG4gICAgaWYgKEVudi5ldmVudHMucGFzc2l2ZSA9PT0gZmFsc2UgJiYgdHlwZW9mIG9wdHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMuY2FwdHVyZSB8fCBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChFbnYuZXZlbnRzLnBhc3NpdmUgPT09IHRydWUgJiYgdHlwZW9mIG9wdHMgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIG9wdHMgPSB7Y2FwdHVyZTogb3B0c307XHJcbiAgICB9XHJcbiAgICB0aGlzOjphZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRzKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKGBhZGRpbmc6ICR7dHlwZX0sIHN1cHBvcnQ6IHBhc3NpdmUoJHtFbnYuZXZlbnRzLnBhc3NpdmV9KS5vbmNlKCR7RW52LmV2ZW50cy5vbmNlfSlgKTtcclxufTtcclxuXHJcbmNvbnN0IGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcclxuY29uc3Qgc2NoZWR1bGUgPSAodGltZSwgZnVuYykgPT4gc2V0VGltZW91dChmdW5jLCB0aW1lKTtcclxuXHJcbmNvbnN0IGZpbmRQcmVzc1RhcmdldCA9IG5vZGUgPT4ge1xyXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1uby1wcmVzc1wiKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vZGUgfHwgZG9jdW1lbnQuYm9keTtcclxufTtcclxuY29uc3QgdG91Y2hEYXRhID0gKHtwYWdlWDp4LCBwYWdlWTp5LCBpZGVudGlmaWVyOmlkLCB0YXJnZXR9LCB7bW91c2VUcmlnZ2VyZWQgPSBmYWxzZX0sIHRhcmdldE92ZXJyaWRlID0gbnVsbCkgPT4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBwb3NpdGlvbjogT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgeCwgeVxyXG4gICAgfSksXHJcbiAgICB0aW1lOiBEYXRlLm5vdygpLFxyXG4gICAgdGFyZ2V0OiB0YXJnZXRPdmVycmlkZSB8fCB0YXJnZXQsXHJcbiAgICBwcmVzc1RhcmdldDogZmluZFByZXNzVGFyZ2V0KHRhcmdldE92ZXJyaWRlIHx8IHRhcmdldCksXHJcbiAgICBpZCxcclxuICAgIG1vdXNlVHJpZ2dlcmVkXHJcbn0pO1xyXG5cclxuY29uc3QgcG9sYXJWZWN0b3IgPSAoe3Bvc2l0aW9uOiB7eDp4MSwgeTp5MX19LCB7cG9zaXRpb246IHt4OngyLCB5OnkyfX0pID0+IHtcclxuICAgIGxldCBhbmdsZTtcclxuICAgIGxldCBtYWduaXR1ZGU7XHJcblxyXG4gICAgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xyXG4gICAgYW5nbGUgKj0gMTgwIC8gTWF0aC5QSTtcclxuICAgIGFuZ2xlID0gKGFuZ2xlICsgNDUwKSAlIDM2MDtcclxuXHJcbiAgICBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoXHJcbiAgICAgICAgKHgyIC0geDEpICoqIDIgK1xyXG4gICAgICAgICh5MiAtIHkxKSAqKiAyXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYW5nbGUsXHJcbiAgICAgICAgbWFnbml0dWRlXHJcbiAgICB9O1xyXG59O1xyXG5cclxuY29uc3QgYW5nbGVEaWYgPSAoZmlyc3RBbmdsZSwgc2Vjb25kQW5nbGUpID0+IHtcclxuICAgIGNvbnN0IGFic0RpZiA9IE1hdGguYWJzKGZpcnN0QW5nbGUgLSBzZWNvbmRBbmdsZSkgJSAzNjA7XHJcbiAgICBpZiAoYWJzRGlmID4gMTgwKSB7XHJcbiAgICAgICAgcmV0dXJuIDM2MCAtIGFic0RpZjtcclxuICAgIH1cclxuICAgIHJldHVybiBhYnNEaWY7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVFdmVudCA9IChldmVudFR5cGUsIGRldGFpbCA9IG51bGwsIGV2ZW50UHJvcHMgPSB7fSkgPT4ge1xyXG4gICAgbGV0IGV2ZW50O1xyXG5cclxuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcclxuICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudFR5cGUsIHRydWUsIHRydWUsIGRldGFpbCk7XHJcblxyXG4gICAgZm9yKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoZXZlbnRQcm9wcykpIHtcclxuICAgICAgICBldmVudFtrZXldID0gZXZlbnRQcm9wc1trZXldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudDtcclxufTtcclxuXHJcbmNvbnN0IHJlZ2lzdGVyID0gKHR5cGUsIGNyZWF0ZUNhbGxiYWNrcykgPT4ge1xyXG4gICAgbGV0IHtzdGFydCA9ICgpID0+IHt9LCBtb3ZlID0gKCkgPT4ge30sIGVuZCA9ICgpID0+IHt9fSA9IGNyZWF0ZUNhbGxiYWNrcyh7cG9sYXJWZWN0b3IsIGFuZ2xlRGlmfSk7XHJcblxyXG4gICAgcmVnaXN0ZXJlZEhhbmRsZXJzLnB1c2godHlwZSk7XHJcbiAgICByZWdpc3RlcmVkQ2FsbGJhY2tzW3R5cGVdID0ge3N0YXJ0LCBtb3ZlLCBlbmR9O1xyXG4gICAgdG91Y2hWYXJzW3R5cGVdID0ge307XHJcbn07XHJcblxyXG5jb25zdCBlZGl0YWJsZVRhZ05hbWVzID0gW1wiaW5wdXRcIiwgXCJ0ZXh0YXJlYVwiLCBcInNlbGVjdFwiXTtcclxuXHJcbmxldCBlbmFibGVkO1xyXG5sZXQgdG91Y2hEYXRhU3RhcnQ7XHJcbmxldCB0b3VjaERhdGFMYXN0O1xyXG5sZXQgdG91Y2hWYXJzO1xyXG5sZXQgcmVnaXN0ZXJlZEhhbmRsZXJzO1xyXG5sZXQgcmVnaXN0ZXJlZENhbGxiYWNrcztcclxuXHJcbmVuYWJsZWQgPSB0cnVlO1xyXG50b3VjaERhdGFTdGFydCA9IHt9O1xyXG50b3VjaERhdGFMYXN0ID0ge307XHJcbnRvdWNoVmFycyA9IHt9O1xyXG5yZWdpc3RlcmVkSGFuZGxlcnMgPSBbXTtcclxucmVnaXN0ZXJlZENhbGxiYWNrcyA9IHt9O1xyXG5cclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBcInRvdWNoc3RhcnRcIixcclxuICAgIGV2dCA9PiB7XHJcbiAgICAgICAgbGV0IHtjaGFuZ2VkVG91Y2hlc30gPSBldnQ7XHJcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOjpmb3JFYWNoKHRvdWNoID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRvdWNoRGF0YSh0b3VjaCwgZXZ0KTtcclxuXHJcbiAgICAgICAgICAgIHRvdWNoRGF0YVN0YXJ0W2RhdGEuaWRdID0gZGF0YTtcclxuICAgICAgICAgICAgdG91Y2hEYXRhTGFzdFtkYXRhLmlkXSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgICBkYXRhLnByZXNzVGFyZ2V0LnNldEF0dHJpYnV0ZShcInByZXNzZWRcIiwgXCJcIik7XHJcblxyXG4gICAgICAgICAgICByZWdpc3RlcmVkSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyTmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcmVnaXN0ZXJlZENhbGxiYWNrc1toYW5kbGVyTmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgdG91Y2hWYXJzW2hhbmRsZXJOYW1lXVtkYXRhLmlkXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5zdGFydCh7dG91Y2g6IGRhdGEsIHZhcnM6IHRvdWNoVmFyc1toYW5kbGVyTmFtZV1bZGF0YS5pZF19KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZmFsc2VcclxuKTtcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBcInRvdWNobW92ZVwiLFxyXG4gICAgZXZ0ID0+IHtcclxuICAgICAgICBsZXQge2NoYW5nZWRUb3VjaGVzfSA9IGV2dDtcclxuICAgICAgICBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hhbmdlZFRvdWNoZXM6OmZvckVhY2godG91Y2ggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdG91Y2hEYXRhKHRvdWNoLCBldnQpO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydFRvdWNoID0gdG91Y2hEYXRhU3RhcnRbZGF0YS5pZF07XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQb3NpdGlvbiA9IHRvdWNoRGF0YUxhc3RbZGF0YS5pZF07XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJhbGxWZWN0b3IgPSBwb2xhclZlY3RvcihkYXRhLCBzdGFydFRvdWNoKTtcclxuICAgICAgICAgICAgY29uc3QgZGlmVmVjdG9yID0gcG9sYXJWZWN0b3IoZGF0YSwgbGFzdFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXJOYW1lID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSByZWdpc3RlcmVkQ2FsbGJhY2tzW2hhbmRsZXJOYW1lXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhcnMgPSB0b3VjaFZhcnNbaGFuZGxlck5hbWVdW2RhdGEuaWRdO1xyXG5cclxuICAgICAgICAgICAgICAgIGhhbmRsZXIubW92ZSh7dG91Y2g6IGRhdGEsIHZhcnMsIG92ZXJhbGxWZWN0b3IsIGRpZlZlY3Rvcn0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBmYWxzZVxyXG4pO1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgIFwidG91Y2hlbmRcIixcclxuICAgIGV2dCA9PiB7XHJcbiAgICAgICAgbGV0IHtjaGFuZ2VkVG91Y2hlc30gPSBldnQ7XHJcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOjpmb3JFYWNoKHRvdWNoID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRvdWNoRGF0YSh0b3VjaCwgZXZ0KTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRUb3VjaCA9IHRvdWNoRGF0YVN0YXJ0W2RhdGEuaWRdO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRUYWdOYW1lID0gZGF0YS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmFsbFZlY3RvciA9IHBvbGFyVmVjdG9yKGRhdGEsIHN0YXJ0VG91Y2gpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNvbWV0aGluZ0VkaXRhYmxlO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudE5vZGU7XHJcblxyXG4gICAgICAgICAgICBkYXRhLnByZXNzVGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInByZXNzZWRcIik7XHJcblxyXG4gICAgICAgICAgICBzb21ldGhpbmdFZGl0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGRhdGEudGFyZ2V0O1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmdldEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnROb2RlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbWV0aGluZ0VkaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IGRvY3VtZW50IHx8IGN1cnJlbnROb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIChlZGl0YWJsZVRhZ05hbWVzLmluZGV4T2YodGFyZ2V0VGFnTmFtZSkgPT09IC0xICYmIHNvbWV0aGluZ0VkaXRhYmxlID09PSBmYWxzZSAmJiBldnQuY2FuY2VsYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoZXZ0LmNhbmNlbGFibGUgPT09IHRydWUgJiYgZWRpdGFibGVUYWdOYW1lcy5pbmRleE9mKHRhcmdldFRhZ05hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXJOYW1lID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSByZWdpc3RlcmVkQ2FsbGJhY2tzW2hhbmRsZXJOYW1lXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhcnMgPSB0b3VjaFZhcnNbaGFuZGxlck5hbWVdW2RhdGEuaWRdO1xyXG5cclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuZW5kKHt0b3VjaDogZGF0YSwgdmFycywgc3RhcnRUb3VjaCwgb3ZlcmFsbFZlY3Rvcn0pO1xyXG4gICAgICAgICAgICAgICAgdG91Y2hWYXJzW2hhbmRsZXJOYW1lXVt0b3VjaC5pZF0gPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRvdWNoRGF0YVN0YXJ0W3RvdWNoLmlkXSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRvdWNoRGF0YUxhc3RbdG91Y2guaWRdID0gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBmYWxzZVxyXG4pO1xyXG5cclxuKCgpID0+IHtcclxuICAgIGlmIChFbnYubW9iaWxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29weVByb3BMaXN0ID0gWydwYWdlWCcsICdwYWdlWScsICdzY3JlZW5YJywgJ3NjcmVlblknLCAnYWx0S2V5JywgJ2N0cmxLZXknLCAnc2hpZnRLZXknLCAnbWV0YUtleScsICdjbGllbnRYJywgJ2NsaWVudFknLCAnbGF5ZXJYJywgJ2xheWVyWScsICd4JywgJ3knXTtcclxuICAgIGNvbnN0IGNyZWF0ZVRvdWNoID0gKGV2dCwgdGFyZ2V0KSA9PiBjb3B5UHJvcExpc3QucmVkdWNlKFxyXG4gICAgICAgIChzeW50aFRvdWNoLCBwcm9wZXJ0eU5hbWUpID0+IHtcclxuICAgICAgICAgICAgc3ludGhUb3VjaFtwcm9wZXJ0eU5hbWVdID0gZXZ0W3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgIHJldHVybiBzeW50aFRvdWNoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge2lkZW50aWZpZXI6IC0xLCB0YXJnZXQsIHNvdXJjZUVsZW1lbnQ6IHRhcmdldH1cclxuICAgICk7XHJcbiAgICBjb25zdCBjcmVhdGVUb3VjaExpc3QgPSAoZXZ0LCB0YXJnZXQpID0+ICh7XHJcbiAgICAgICAgY2hhbmdlZFRvdWNoZXM6IHtcclxuICAgICAgICAgICAgMDogY3JlYXRlVG91Y2goZXZ0LCB0YXJnZXQpLFxyXG4gICAgICAgICAgICBsZW5ndGg6IDFcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGxldCBjdXJyZW50RWxlbWVudDtcclxuICAgIGxldCBtb3VzZUlzRG93bjtcclxuXHJcbiAgICBjdXJyZW50RWxlbWVudCA9IG51bGw7XHJcbiAgICBtb3VzZUlzRG93biA9IGZhbHNlO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgIFwibW91c2Vkb3duXCIsXHJcbiAgICAgICAgZXZ0ID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2dC5idXR0b24gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUV2ZW50KFxyXG4gICAgICAgICAgICAgICAgXCJ0b3VjaHN0YXJ0XCIsXHJcbiAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZVRvdWNoTGlzdChldnQsIGV2dC50YXJnZXQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlVHJpZ2dlcmVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBtb3VzZUlzRG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gZXZ0LnRhcmdldDtcclxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgIFwibW91c2Vtb3ZlXCIsXHJcbiAgICAgICAgZXZ0ID0+IHtcclxuICAgICAgICAgICAgaWYgKG1vdXNlSXNEb3duID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlRXZlbnQoXHJcbiAgICAgICAgICAgICAgICBcInRvdWNobW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVUb3VjaExpc3QoZXZ0LCBjdXJyZW50RWxlbWVudCksXHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2VUcmlnZ2VyZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChldnQudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2lucHV0JyB8fCBldnQudGFyZ2V0LnR5cGUgIT09ICdyYW5nZScpIHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBcIm1vdXNldXBcIixcclxuICAgICAgICBldnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZ0LmJ1dHRvbiAhPT0gMCB8fCBtb3VzZUlzRG93biA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUV2ZW50KFxyXG4gICAgICAgICAgICAgICAgXCJ0b3VjaGVuZFwiLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVUb3VjaExpc3QoZXZ0LCBjdXJyZW50RWxlbWVudCksXHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2VUcmlnZ2VyZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIG1vdXNlSXNEb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufSkoKTtcclxuXHJcbnJlZ2lzdGVyKFxyXG4gICAgXCJ0YXBcIixcclxuICAgICgpID0+ICh7XHJcbiAgICAgICAgc3RhcnQgKHt2YXJzfSkge1xyXG4gICAgICAgICAgICB2YXJzLnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdmUgKHt2YXJzLCBvdmVyYWxsVmVjdG9yfSkge1xyXG4gICAgICAgICAgICBpZiAob3ZlcmFsbFZlY3Rvci5tYWduaXR1ZGUgPiAyMCkge1xyXG4gICAgICAgICAgICAgICAgdmFycy52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmQgKHt2YXJzLCBzdGFydFRvdWNoLCB0b3VjaCwgb3ZlcmFsbFZlY3Rvcn0pIHtcclxuICAgICAgICAgICAgaWYgKG92ZXJhbGxWZWN0b3IubWFnbml0dWRlID4gMjApIHtcclxuICAgICAgICAgICAgICAgIHZhcnMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFycy52YWxpZCA9PT0gdHJ1ZSAmJiAodG91Y2gudGltZSAtIHN0YXJ0VG91Y2gudGltZSkgPCA1MDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydFRvdWNoLnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBudWxsICYmIHRvdWNoLm1vdXNlVHJpZ2dlcmVkID09PSBmYWxzZSAmJiAoJ2JsdXInIGluIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUb3VjaC50YXJnZXQuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzdGFydFRvdWNoLnRhcmdldC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUV2ZW50KFwidGFwXCIsIG51bGwsIHt0b3VjaH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuKTtcclxuXHJcbnJlZ2lzdGVyKFxyXG4gICAgXCJob2xkXCIsXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3JlYXRlQ2FsbGJhY2tGb3JUb3VjaCA9IHRvdWNoID0+XHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXRzW3RvdWNoLmlkXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0b3VjaC50YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFdmVudChcImhvbGRcIiwgbnVsbCwge3Bvc2l0aW9uOiB0b3VjaC5wb3NpdGlvbn0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGxldCB0aW1lb3V0cztcclxuXHJcbiAgICAgICAgdGltZW91dHMgPSB7fTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydCAoe3RvdWNofSkge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dHNbdG91Y2guaWRdID0gc2NoZWR1bGUoMTAwMCwgY3JlYXRlQ2FsbGJhY2tGb3JUb3VjaCh0b3VjaCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb3ZlICh7dG91Y2gsIG92ZXJhbGxWZWN0b3J9KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmFsbFZlY3Rvci5tYWduaXR1ZGUgPiAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0c1t0b3VjaC5pZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRzW3RvdWNoLmlkXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVuZCAoe3RvdWNofSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRzW3RvdWNoLmlkXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0c1t0b3VjaC5pZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRzW3RvdWNoLmlkXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4pO1xyXG5cclxud2luZG93Lmdlc3R1cmUgPSB7cmVnaXN0ZXJ9O1xyXG4iLCJjb25zdCBjID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuXHJcbmNvbnN0IGljb25zID0ge1xyXG5cImlvbi1pb25pY1wiOiBjKDYxNzcxKSxcclxuXCJpb24tYXJyb3ctdXAtYVwiOiBjKDYxNzA4KSxcclxuXCJpb24tYXJyb3ctcmlnaHQtYVwiOiBjKDYxNzA1KSxcclxuXCJpb24tYXJyb3ctZG93bi1hXCI6IGMoNjE2OTkpLFxyXG5cImlvbi1hcnJvdy1sZWZ0LWFcIjogYyg2MTcwMiksXHJcblwiaW9uLWFycm93LXVwLWJcIjogYyg2MTcwOSksXHJcblwiaW9uLWFycm93LXJpZ2h0LWJcIjogYyg2MTcwNiksXHJcblwiaW9uLWFycm93LWRvd24tYlwiOiBjKDYxNzAwKSxcclxuXCJpb24tYXJyb3ctbGVmdC1iXCI6IGMoNjE3MDMpLFxyXG5cImlvbi1hcnJvdy11cC1jXCI6IGMoNjE3MTApLFxyXG5cImlvbi1hcnJvdy1yaWdodC1jXCI6IGMoNjE3MDcpLFxyXG5cImlvbi1hcnJvdy1kb3duLWNcIjogYyg2MTcwMSksXHJcblwiaW9uLWFycm93LWxlZnQtY1wiOiBjKDYxNzA0KSxcclxuXCJpb24tYXJyb3ctcmV0dXJuLXJpZ2h0XCI6IGMoNjIwNTQpLFxyXG5cImlvbi1hcnJvdy1yZXR1cm4tbGVmdFwiOiBjKDYyMDUzKSxcclxuXCJpb24tYXJyb3ctc3dhcFwiOiBjKDYyMDU2KSxcclxuXCJpb24tYXJyb3ctc2hyaW5rXCI6IGMoNjIwNTUpLFxyXG5cImlvbi1hcnJvdy1leHBhbmRcIjogYyg2MjA0NiksXHJcblwiaW9uLWFycm93LW1vdmVcIjogYyg2MjA1MSksXHJcblwiaW9uLWFycm93LXJlc2l6ZVwiOiBjKDYyMDUyKSxcclxuXCJpb24tY2hldnJvbi11cFwiOiBjKDYxNzM0KSxcclxuXCJpb24tY2hldnJvbi1yaWdodFwiOiBjKDYxNzMzKSxcclxuXCJpb24tY2hldnJvbi1kb3duXCI6IGMoNjE3MzEpLFxyXG5cImlvbi1jaGV2cm9uLWxlZnRcIjogYyg2MTczMiksXHJcblwiaW9uLW5hdmljb24tcm91bmRcIjogYyg2MTk2NSksXHJcblwiaW9uLW5hdmljb25cIjogYyg2MTk2NiksXHJcblwiaW9uLWRyYWdcIjogYyg2MTc0NCksXHJcblwiaW9uLWxvZy1pblwiOiBjKDYyMTEwKSxcclxuXCJpb24tbG9nLW91dFwiOiBjKDYyMTExKSxcclxuXCJpb24tY2hlY2ttYXJrLXJvdW5kXCI6IGMoNjE3MjkpLFxyXG5cImlvbi1jaGVja21hcmtcIjogYyg2MTczMCksXHJcblwiaW9uLWNoZWNrbWFyay1jaXJjbGVkXCI6IGMoNjE3MjgpLFxyXG5cImlvbi1jbG9zZS1yb3VuZFwiOiBjKDYxNzM3KSxcclxuXCJpb24tY2xvc2VcIjogYyg2MTczOCksXHJcblwiaW9uLWNsb3NlLWNpcmNsZWRcIjogYyg2MTczNiksXHJcblwiaW9uLXBsdXMtcm91bmRcIjogYyg2MTk3NSksXHJcblwiaW9uLXBsdXNcIjogYyg2MTk3NiksXHJcblwiaW9uLXBsdXMtY2lyY2xlZFwiOiBjKDYxOTc0KSxcclxuXCJpb24tbWludXMtcm91bmRcIjogYyg2MTk2MCksXHJcblwiaW9uLW1pbnVzXCI6IGMoNjE5NjEpLFxyXG5cImlvbi1taW51cy1jaXJjbGVkXCI6IGMoNjE5NTkpLFxyXG5cImlvbi1pbmZvcm1hdGlvblwiOiBjKDYxNzcwKSxcclxuXCJpb24taW5mb3JtYXRpb24tY2lyY2xlZFwiOiBjKDYxNzY5KSxcclxuXCJpb24taGVscFwiOiBjKDYxNzYzKSxcclxuXCJpb24taGVscC1jaXJjbGVkXCI6IGMoNjE3NjIpLFxyXG5cImlvbi1iYWNrc3BhY2Utb3V0bGluZVwiOiBjKDYyMzk4KSxcclxuXCJpb24tYmFja3NwYWNlXCI6IGMoNjIzOTkpLFxyXG5cImlvbi1oZWxwLWJ1b3lcIjogYyg2MjA3NiksXHJcblwiaW9uLWFzdGVyaXNrXCI6IGMoNjIyMjgpLFxyXG5cImlvbi1hbGVydFwiOiBjKDYxNjk3KSxcclxuXCJpb24tYWxlcnQtY2lyY2xlZFwiOiBjKDYxNjk2KSxcclxuXCJpb24tcmVmcmVzaFwiOiBjKDYxOTgwKSxcclxuXCJpb24tbG9vcFwiOiBjKDYxOTUzKSxcclxuXCJpb24tc2h1ZmZsZVwiOiBjKDYxOTg1KSxcclxuXCJpb24taG9tZVwiOiBjKDYxNzY0KSxcclxuXCJpb24tc2VhcmNoXCI6IGMoNjE5ODMpLFxyXG5cImlvbi1mbGFnXCI6IGMoNjIwNzMpLFxyXG5cImlvbi1zdGFyXCI6IGMoNjIwMzApLFxyXG5cImlvbi1oZWFydFwiOiBjKDYxNzYxKSxcclxuXCJpb24taGVhcnQtYnJva2VuXCI6IGMoNjIyMzcpLFxyXG5cImlvbi1nZWFyLWFcIjogYyg2MTc1NyksXHJcblwiaW9uLWdlYXItYlwiOiBjKDYxNzU4KSxcclxuXCJpb24tdG9nZ2xlLWZpbGxlZFwiOiBjKDYyMjkyKSxcclxuXCJpb24tdG9nZ2xlXCI6IGMoNjIyOTMpLFxyXG5cImlvbi1zZXR0aW5nc1wiOiBjKDYyMTI1KSxcclxuXCJpb24td3JlbmNoXCI6IGMoNjIxMzgpLFxyXG5cImlvbi1oYW1tZXJcIjogYyg2MjA3NSksXHJcblwiaW9uLWVkaXRcIjogYyg2MjE0MyksXHJcblwiaW9uLXRyYXNoLWFcIjogYyg2MjAzNCksXHJcblwiaW9uLXRyYXNoLWJcIjogYyg2MjAzNSksXHJcblwiaW9uLWRvY3VtZW50XCI6IGMoNjE3NDMpLFxyXG5cImlvbi1kb2N1bWVudC10ZXh0XCI6IGMoNjE3NDIpLFxyXG5cImlvbi1jbGlwYm9hcmRcIjogYyg2MTczNSksXHJcblwiaW9uLXNjaXNzb3JzXCI6IGMoNjIyODMpLFxyXG5cImlvbi1mdW5uZWxcIjogYyg2MjIzNSksXHJcblwiaW9uLWJvb2ttYXJrXCI6IGMoNjIwNTkpLFxyXG5cImlvbi1lbWFpbFwiOiBjKDYxNzQ2KSxcclxuXCJpb24tZW1haWwtdW5yZWFkXCI6IGMoNjI0MDMpLFxyXG5cImlvbi1mb2xkZXJcIjogYyg2MTc1MyksXHJcblwiaW9uLWZpbGluZ1wiOiBjKDYxNzQ4KSxcclxuXCJpb24tYXJjaGl2ZVwiOiBjKDYxNjk4KSxcclxuXCJpb24tcmVwbHlcIjogYyg2MTk4MiksXHJcblwiaW9uLXJlcGx5LWFsbFwiOiBjKDYxOTgxKSxcclxuXCJpb24tZm9yd2FyZFwiOiBjKDYxNzU0KSxcclxuXCJpb24tc2hhcmVcIjogYyg2MTk4NCksXHJcblwiaW9uLXBhcGVyLWFpcnBsYW5lXCI6IGMoNjIxNDcpLFxyXG5cImlvbi1saW5rXCI6IGMoNjE5NTApLFxyXG5cImlvbi1wYXBlcmNsaXBcIjogYyg2MTk2NyksXHJcblwiaW9uLWNvbXBvc2VcIjogYyg2MTc0MCksXHJcblwiaW9uLWJyaWVmY2FzZVwiOiBjKDYyMDYwKSxcclxuXCJpb24tbWVka2l0XCI6IGMoNjIxMTQpLFxyXG5cImlvbi1hdFwiOiBjKDYxNzExKSxcclxuXCJpb24tcG91bmRcIjogYyg2MTk3NyksXHJcblwiaW9uLXF1b3RlXCI6IGMoNjIyNzkpLFxyXG5cImlvbi1jbG91ZFwiOiBjKDYxNzM5KSxcclxuXCJpb24tdXBsb2FkXCI6IGMoNjIwMzcpLFxyXG5cImlvbi1tb3JlXCI6IGMoNjE5NjMpLFxyXG5cImlvbi1ncmlkXCI6IGMoNjE3NTkpLFxyXG5cImlvbi1jYWxlbmRhclwiOiBjKDYxNzE5KSxcclxuXCJpb24tY2xvY2tcIjogYyg2MjA2MiksXHJcblwiaW9uLWNvbXBhc3NcIjogYyg2MjA2NyksXHJcblwiaW9uLXBpbnBvaW50XCI6IGMoNjIxMTkpLFxyXG5cImlvbi1waW5cIjogYyg2MjExOCksXHJcblwiaW9uLW5hdmlnYXRlXCI6IGMoNjIxMTUpLFxyXG5cImlvbi1sb2NhdGlvblwiOiBjKDYxOTUxKSxcclxuXCJpb24tbWFwXCI6IGMoNjE5NTUpLFxyXG5cImlvbi1sb2NrLWNvbWJpbmF0aW9uXCI6IGMoNjI2NzYpLFxyXG5cImlvbi1sb2NrZWRcIjogYyg2MTk1MiksXHJcblwiaW9uLXVubG9ja2VkXCI6IGMoNjIwMzYpLFxyXG5cImlvbi1rZXlcIjogYyg2MjEwMiksXHJcblwiaW9uLWFycm93LWdyYXBoLXVwLXJpZ2h0XCI6IGMoNjIwNTApLFxyXG5cImlvbi1hcnJvdy1ncmFwaC1kb3duLXJpZ2h0XCI6IGMoNjIwNDgpLFxyXG5cImlvbi1hcnJvdy1ncmFwaC11cC1sZWZ0XCI6IGMoNjIwNDkpLFxyXG5cImlvbi1hcnJvdy1ncmFwaC1kb3duLWxlZnRcIjogYyg2MjA0NyksXHJcblwiaW9uLXN0YXRzLWJhcnNcIjogYyg2MjEzMyksXHJcblwiaW9uLWNvbm5lY3Rpb24tYmFyc1wiOiBjKDYyMDY4KSxcclxuXCJpb24tcGllLWdyYXBoXCI6IGMoNjIxMTcpLFxyXG5cImlvbi1jaGF0YnViYmxlXCI6IGMoNjE3MjYpLFxyXG5cImlvbi1jaGF0YnViYmxlLXdvcmtpbmdcIjogYyg2MTcyNSksXHJcblwiaW9uLWNoYXRidWJibGVzXCI6IGMoNjE3MjcpLFxyXG5cImlvbi1jaGF0Ym94XCI6IGMoNjE3MjMpLFxyXG5cImlvbi1jaGF0Ym94LXdvcmtpbmdcIjogYyg2MTcyMiksXHJcblwiaW9uLWNoYXRib3hlc1wiOiBjKDYxNzI0KSxcclxuXCJpb24tcGVyc29uXCI6IGMoNjE5NzEpLFxyXG5cImlvbi1wZXJzb24tYWRkXCI6IGMoNjE5NjkpLFxyXG5cImlvbi1wZXJzb24tc3RhbGtlclwiOiBjKDYxOTcwKSxcclxuXCJpb24td29tYW5cIjogYyg2MjA0NSksXHJcblwiaW9uLW1hblwiOiBjKDYxOTU0KSxcclxuXCJpb24tZmVtYWxlXCI6IGMoNjIwNzIpLFxyXG5cImlvbi1tYWxlXCI6IGMoNjIxMTMpLFxyXG5cImlvbi10cmFuc2dlbmRlclwiOiBjKDYyNzA5KSxcclxuXCJpb24tZm9ya1wiOiBjKDYyMDc0KSxcclxuXCJpb24ta25pZmVcIjogYyg2MjEwMyksXHJcblwiaW9uLXNwb29uXCI6IGMoNjIxMzIpLFxyXG5cImlvbi1zb3VwLWNhbi1vdXRsaW5lXCI6IGMoNjI3MDcpLFxyXG5cImlvbi1zb3VwLWNhblwiOiBjKDYyNzA4KSxcclxuXCJpb24tYmVlclwiOiBjKDYyMDU4KSxcclxuXCJpb24td2luZWdsYXNzXCI6IGMoNjIxMzcpLFxyXG5cImlvbi1jb2ZmZWVcIjogYyg2MjA2NiksXHJcblwiaW9uLWljZWNyZWFtXCI6IGMoNjIwNzcpLFxyXG5cImlvbi1waXp6YVwiOiBjKDYyMTIwKSxcclxuXCJpb24tcG93ZXJcIjogYyg2MjEyMSksXHJcblwiaW9uLW1vdXNlXCI6IGMoNjIyNzIpLFxyXG5cImlvbi1iYXR0ZXJ5LWZ1bGxcIjogYyg2MTcxNSksXHJcblwiaW9uLWJhdHRlcnktaGFsZlwiOiBjKDYxNzE2KSxcclxuXCJpb24tYmF0dGVyeS1sb3dcIjogYyg2MTcxNyksXHJcblwiaW9uLWJhdHRlcnktZW1wdHlcIjogYyg2MTcxNCksXHJcblwiaW9uLWJhdHRlcnktY2hhcmdpbmdcIjogYyg2MTcxMyksXHJcblwiaW9uLXdpZmlcIjogYyg2MjA0NCksXHJcblwiaW9uLWJsdWV0b290aFwiOiBjKDYxNzE4KSxcclxuXCJpb24tY2FsY3VsYXRvclwiOiBjKDYyMDYxKSxcclxuXCJpb24tY2FtZXJhXCI6IGMoNjE3MjApLFxyXG5cImlvbi1leWVcIjogYyg2MTc0NyksXHJcblwiaW9uLWV5ZS1kaXNhYmxlZFwiOiBjKDYyMjE0KSxcclxuXCJpb24tZmxhc2hcIjogYyg2MTc1MSksXHJcblwiaW9uLWZsYXNoLW9mZlwiOiBjKDYxNzUwKSxcclxuXCJpb24tcXItc2Nhbm5lclwiOiBjKDYyMjc4KSxcclxuXCJpb24taW1hZ2VcIjogYyg2MTc2NyksXHJcblwiaW9uLWltYWdlc1wiOiBjKDYxNzY4KSxcclxuXCJpb24td2FuZFwiOiBjKDYyMjk2KSxcclxuXCJpb24tY29udHJhc3RcIjogYyg2MjA2OSksXHJcblwiaW9uLWFwZXJ0dXJlXCI6IGMoNjIyMjcpLFxyXG5cImlvbi1jcm9wXCI6IGMoNjI0MDEpLFxyXG5cImlvbi1lYXNlbFwiOiBjKDYyNDAyKSxcclxuXCJpb24tcGFpbnRicnVzaFwiOiBjKDYyNjc3KSxcclxuXCJpb24tcGFpbnRidWNrZXRcIjogYyg2MjY3OCksXHJcblwiaW9uLW1vbml0b3JcIjogYyg2MTk2MiksXHJcblwiaW9uLWxhcHRvcFwiOiBjKDYxOTQ4KSxcclxuXCJpb24taXBhZFwiOiBjKDYxOTQ1KSxcclxuXCJpb24taXBob25lXCI6IGMoNjE5NDYpLFxyXG5cImlvbi1pcG9kXCI6IGMoNjE5NDcpLFxyXG5cImlvbi1wcmludGVyXCI6IGMoNjE5NzgpLFxyXG5cImlvbi11c2JcIjogYyg2MjEzNiksXHJcblwiaW9uLW91dGxldFwiOiBjKDYyMjc0KSxcclxuXCJpb24tYnVnXCI6IGMoNjIxNDIpLFxyXG5cImlvbi1jb2RlXCI6IGMoNjIwNjUpLFxyXG5cImlvbi1jb2RlLXdvcmtpbmdcIjogYyg2MjA2NCksXHJcblwiaW9uLWNvZGUtZG93bmxvYWRcIjogYyg2MjA2MyksXHJcblwiaW9uLWZvcmstcmVwb1wiOiBjKDYyMTQ0KSxcclxuXCJpb24tbmV0d29ya1wiOiBjKDYyMjczKSxcclxuXCJpb24tcHVsbC1yZXF1ZXN0XCI6IGMoNjIyNzcpLFxyXG5cImlvbi1tZXJnZVwiOiBjKDYyMjcxKSxcclxuXCJpb24teGJveFwiOiBjKDYyMjIwKSxcclxuXCJpb24tcGxheXN0YXRpb25cIjogYyg2MjIxOCksXHJcblwiaW9uLXN0ZWFtXCI6IGMoNjIyMTkpLFxyXG5cImlvbi1jbG9zZWQtY2FwdGlvbmluZ1wiOiBjKDYyMjMxKSxcclxuXCJpb24tdmlkZW9jYW1lcmFcIjogYyg2MjAzOCksXHJcblwiaW9uLWZpbG0tbWFya2VyXCI6IGMoNjE3NDkpLFxyXG5cImlvbi1kaXNjXCI6IGMoNjE3NDEpLFxyXG5cImlvbi1oZWFkcGhvbmVcIjogYyg2MTc2MCksXHJcblwiaW9uLW11c2ljLW5vdGVcIjogYyg2MTk2NCksXHJcblwiaW9uLXJhZGlvLXdhdmVzXCI6IGMoNjIxMjQpLFxyXG5cImlvbi1zcGVha2VycGhvbmVcIjogYyg2MjEzMCksXHJcblwiaW9uLW1pYy1hXCI6IGMoNjE5NTYpLFxyXG5cImlvbi1taWMtYlwiOiBjKDYxOTU3KSxcclxuXCJpb24tbWljLWNcIjogYyg2MTk1OCksXHJcblwiaW9uLXZvbHVtZS1oaWdoXCI6IGMoNjIwMzkpLFxyXG5cImlvbi12b2x1bWUtbWVkaXVtXCI6IGMoNjIwNDEpLFxyXG5cImlvbi12b2x1bWUtbG93XCI6IGMoNjIwNDApLFxyXG5cImlvbi12b2x1bWUtbXV0ZVwiOiBjKDYyMDQyKSxcclxuXCJpb24tbGV2ZWxzXCI6IGMoNjIxMDQpLFxyXG5cImlvbi1wbGF5XCI6IGMoNjE5NzMpLFxyXG5cImlvbi1wYXVzZVwiOiBjKDYxOTY4KSxcclxuXCJpb24tc3RvcFwiOiBjKDYyMDMxKSxcclxuXCJpb24tcmVjb3JkXCI6IGMoNjE5NzkpLFxyXG5cImlvbi1za2lwLWZvcndhcmRcIjogYyg2MTk4NyksXHJcblwiaW9uLXNraXAtYmFja3dhcmRcIjogYyg2MTk4NiksXHJcblwiaW9uLWVqZWN0XCI6IGMoNjE3NDUpLFxyXG5cImlvbi1iYWdcIjogYyg2MTcxMiksXHJcblwiaW9uLWNhcmRcIjogYyg2MTcyMSksXHJcblwiaW9uLWNhc2hcIjogYyg2MjIzMCksXHJcblwiaW9uLXByaWNldGFnXCI6IGMoNjIxMjIpLFxyXG5cImlvbi1wcmljZXRhZ3NcIjogYyg2MjEyMyksXHJcblwiaW9uLXRodW1ic3VwXCI6IGMoNjIwMzMpLFxyXG5cImlvbi10aHVtYnNkb3duXCI6IGMoNjIwMzIpLFxyXG5cImlvbi1oYXBweS1vdXRsaW5lXCI6IGMoNjI0MDYpLFxyXG5cImlvbi1oYXBweVwiOiBjKDYyMjM2KSxcclxuXCJpb24tc2FkLW91dGxpbmVcIjogYyg2MjY3OSksXHJcblwiaW9uLXNhZFwiOiBjKDYyMjgyKSxcclxuXCJpb24tYm93dGllXCI6IGMoNjI0MDApLFxyXG5cImlvbi10c2hpcnQtb3V0bGluZVwiOiBjKDYyNzEwKSxcclxuXCJpb24tdHNoaXJ0XCI6IGMoNjI3MTEpLFxyXG5cImlvbi10cm9waHlcIjogYyg2MjI5NCksXHJcblwiaW9uLXBvZGl1bVwiOiBjKDYyMjc2KSxcclxuXCJpb24tcmliYm9uLWFcIjogYyg2MjI4MCksXHJcblwiaW9uLXJpYmJvbi1iXCI6IGMoNjIyODEpLFxyXG5cImlvbi11bml2ZXJzaXR5XCI6IGMoNjIyOTUpLFxyXG5cImlvbi1tYWduZXRcIjogYyg2MjExMiksXHJcblwiaW9uLWJlYWtlclwiOiBjKDYyMDU3KSxcclxuXCJpb24tZXJsZW5tZXllci1mbGFza1wiOiBjKDYyNDA1KSxcclxuXCJpb24tZWdnXCI6IGMoNjIwNzEpLFxyXG5cImlvbi1lYXJ0aFwiOiBjKDYyMDcwKSxcclxuXCJpb24tcGxhbmV0XCI6IGMoNjIyNzUpLFxyXG5cImlvbi1saWdodGJ1bGJcIjogYyg2MjEwNSksXHJcblwiaW9uLWN1YmVcIjogYyg2MjIzMiksXHJcblwiaW9uLWxlYWZcIjogYyg2MTk0OSksXHJcblwiaW9uLXdhdGVyZHJvcFwiOiBjKDYyMDQzKSxcclxuXCJpb24tZmxhbWVcIjogYyg2MjIzNCksXHJcblwiaW9uLWZpcmViYWxsXCI6IGMoNjIyMzMpLFxyXG5cImlvbi1ib25maXJlXCI6IGMoNjIyMjkpLFxyXG5cImlvbi11bWJyZWxsYVwiOiBjKDYyMTM1KSxcclxuXCJpb24tbnVjbGVhclwiOiBjKDYyMTE2KSxcclxuXCJpb24tbm8tc21va2luZ1wiOiBjKDYyMTQ2KSxcclxuXCJpb24tdGhlcm1vbWV0ZXJcIjogYyg2MjEzNCksXHJcblwiaW9uLXNwZWVkb21ldGVyXCI6IGMoNjIxMzEpLFxyXG5cImlvbi1tb2RlbC1zXCI6IGMoNjIxNDUpLFxyXG5cImlvbi1wbGFuZVwiOiBjKDYxOTcyKSxcclxuXCJpb24tamV0XCI6IGMoNjIxMDEpLFxyXG5cImlvbi1sb2FkLWFcIjogYyg2MjEwNiksXHJcblwiaW9uLWxvYWQtYlwiOiBjKDYyMTA3KSxcclxuXCJpb24tbG9hZC1jXCI6IGMoNjIxMDgpLFxyXG5cImlvbi1sb2FkLWRcIjogYyg2MjEwOSksXHJcblwiaW9uLWlvcy1pb25pYy1vdXRsaW5lXCI6IGMoNjI1NDIpLFxyXG5cImlvbi1pb3MtYXJyb3ctYmFja1wiOiBjKDYyNDE1KSxcclxuXCJpb24taW9zLWFycm93LWZvcndhcmRcIjogYyg2MjQxNyksXHJcblwiaW9uLWlvcy1hcnJvdy11cFwiOiBjKDYyNDI0KSxcclxuXCJpb24taW9zLWFycm93LXJpZ2h0XCI6IGMoNjI0MTkpLFxyXG5cImlvbi1pb3MtYXJyb3ctZG93blwiOiBjKDYyNDE2KSxcclxuXCJpb24taW9zLWFycm93LWxlZnRcIjogYyg2MjQxOCksXHJcblwiaW9uLWlvcy1hcnJvdy10aGluLXVwXCI6IGMoNjI0MjMpLFxyXG5cImlvbi1pb3MtYXJyb3ctdGhpbi1yaWdodFwiOiBjKDYyNDIyKSxcclxuXCJpb24taW9zLWFycm93LXRoaW4tZG93blwiOiBjKDYyNDIwKSxcclxuXCJpb24taW9zLWFycm93LXRoaW4tbGVmdFwiOiBjKDYyNDIxKSxcclxuXCJpb24taW9zLWNpcmNsZS1maWxsZWRcIjogYyg2MjQ2NCksXHJcblwiaW9uLWlvcy1jaXJjbGUtb3V0bGluZVwiOiBjKDYyNDY1KSxcclxuXCJpb24taW9zLWNoZWNrbWFyay1lbXB0eVwiOiBjKDYyNDYxKSxcclxuXCJpb24taW9zLWNoZWNrbWFyay1vdXRsaW5lXCI6IGMoNjI0NjIpLFxyXG5cImlvbi1pb3MtY2hlY2ttYXJrXCI6IGMoNjI0NjMpLFxyXG5cImlvbi1pb3MtcGx1cy1lbXB0eVwiOiBjKDYyNjAxKSxcclxuXCJpb24taW9zLXBsdXMtb3V0bGluZVwiOiBjKDYyNjAyKSxcclxuXCJpb24taW9zLXBsdXNcIjogYyg2MjYwMyksXHJcblwiaW9uLWlvcy1jbG9zZS1lbXB0eVwiOiBjKDYyNDY4KSxcclxuXCJpb24taW9zLWNsb3NlLW91dGxpbmVcIjogYyg2MjQ2OSksXHJcblwiaW9uLWlvcy1jbG9zZVwiOiBjKDYyNDcwKSxcclxuXCJpb24taW9zLW1pbnVzLWVtcHR5XCI6IGMoNjI1NjIpLFxyXG5cImlvbi1pb3MtbWludXMtb3V0bGluZVwiOiBjKDYyNTYzKSxcclxuXCJpb24taW9zLW1pbnVzXCI6IGMoNjI1NjQpLFxyXG5cImlvbi1pb3MtaW5mb3JtYXRpb24tZW1wdHlcIjogYyg2MjUzOSksXHJcblwiaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lXCI6IGMoNjI1NDApLFxyXG5cImlvbi1pb3MtaW5mb3JtYXRpb25cIjogYyg2MjU0MSksXHJcblwiaW9uLWlvcy1oZWxwLWVtcHR5XCI6IGMoNjI1MzIpLFxyXG5cImlvbi1pb3MtaGVscC1vdXRsaW5lXCI6IGMoNjI1MzMpLFxyXG5cImlvbi1pb3MtaGVscFwiOiBjKDYyNTM0KSxcclxuXCJpb24taW9zLXNlYXJjaFwiOiBjKDYyNjI5KSxcclxuXCJpb24taW9zLXNlYXJjaC1zdHJvbmdcIjogYyg2MjYyOCksXHJcblwiaW9uLWlvcy1zdGFyXCI6IGMoNjI2NDMpLFxyXG5cImlvbi1pb3Mtc3Rhci1oYWxmXCI6IGMoNjI2NDEpLFxyXG5cImlvbi1pb3Mtc3Rhci1vdXRsaW5lXCI6IGMoNjI2NDIpLFxyXG5cImlvbi1pb3MtaGVhcnRcIjogYyg2MjUzMSksXHJcblwiaW9uLWlvcy1oZWFydC1vdXRsaW5lXCI6IGMoNjI1MzApLFxyXG5cImlvbi1pb3MtbW9yZVwiOiBjKDYyNTcwKSxcclxuXCJpb24taW9zLW1vcmUtb3V0bGluZVwiOiBjKDYyNTY5KSxcclxuXCJpb24taW9zLWhvbWVcIjogYyg2MjUzNiksXHJcblwiaW9uLWlvcy1ob21lLW91dGxpbmVcIjogYyg2MjUzNSksXHJcblwiaW9uLWlvcy1jbG91ZFwiOiBjKDYyNDc2KSxcclxuXCJpb24taW9zLWNsb3VkLW91dGxpbmVcIjogYyg2MjQ3MyksXHJcblwiaW9uLWlvcy1jbG91ZC11cGxvYWRcIjogYyg2MjQ3NSksXHJcblwiaW9uLWlvcy1jbG91ZC11cGxvYWQtb3V0bGluZVwiOiBjKDYyNDc0KSxcclxuXCJpb24taW9zLWNsb3VkLWRvd25sb2FkXCI6IGMoNjI0NzIpLFxyXG5cImlvbi1pb3MtY2xvdWQtZG93bmxvYWQtb3V0bGluZVwiOiBjKDYyNDcxKSxcclxuXCJpb24taW9zLXVwbG9hZFwiOiBjKDYyNjY3KSxcclxuXCJpb24taW9zLXVwbG9hZC1vdXRsaW5lXCI6IGMoNjI2NjYpLFxyXG5cImlvbi1pb3MtZG93bmxvYWRcIjogYyg2MjQ5NiksXHJcblwiaW9uLWlvcy1kb3dubG9hZC1vdXRsaW5lXCI6IGMoNjI0OTUpLFxyXG5cImlvbi1pb3MtcmVmcmVzaFwiOiBjKDYyNjIwKSxcclxuXCJpb24taW9zLXJlZnJlc2gtb3V0bGluZVwiOiBjKDYyNjE5KSxcclxuXCJpb24taW9zLXJlZnJlc2gtZW1wdHlcIjogYyg2MjYxOCksXHJcblwiaW9uLWlvcy1yZWxvYWRcIjogYyg2MjYyMSksXHJcblwiaW9uLWlvcy1sb29wLXN0cm9uZ1wiOiBjKDYyNTUzKSxcclxuXCJpb24taW9zLWxvb3BcIjogYyg2MjU1NCksXHJcblwiaW9uLWlvcy1ib29rbWFya3NcIjogYyg2MjQ0MiksXHJcblwiaW9uLWlvcy1ib29rbWFya3Mtb3V0bGluZVwiOiBjKDYyNDQxKSxcclxuXCJpb24taW9zLWJvb2tcIjogYyg2MjQ0MCksXHJcblwiaW9uLWlvcy1ib29rLW91dGxpbmVcIjogYyg2MjQzOSksXHJcblwiaW9uLWlvcy1mbGFnXCI6IGMoNjI1MDkpLFxyXG5cImlvbi1pb3MtZmxhZy1vdXRsaW5lXCI6IGMoNjI1MDgpLFxyXG5cImlvbi1pb3MtZ2xhc3Nlc1wiOiBjKDYyNTI3KSxcclxuXCJpb24taW9zLWdsYXNzZXMtb3V0bGluZVwiOiBjKDYyNTI2KSxcclxuXCJpb24taW9zLWJyb3dzZXJzXCI6IGMoNjI0NDgpLFxyXG5cImlvbi1pb3MtYnJvd3NlcnMtb3V0bGluZVwiOiBjKDYyNDQ3KSxcclxuXCJpb24taW9zLWF0XCI6IGMoNjI0MjYpLFxyXG5cImlvbi1pb3MtYXQtb3V0bGluZVwiOiBjKDYyNDI1KSxcclxuXCJpb24taW9zLXByaWNldGFnXCI6IGMoNjI2MDUpLFxyXG5cImlvbi1pb3MtcHJpY2V0YWctb3V0bGluZVwiOiBjKDYyNjA0KSxcclxuXCJpb24taW9zLXByaWNldGFnc1wiOiBjKDYyNjA3KSxcclxuXCJpb24taW9zLXByaWNldGFncy1vdXRsaW5lXCI6IGMoNjI2MDYpLFxyXG5cImlvbi1pb3MtY2FydFwiOiBjKDYyNDU2KSxcclxuXCJpb24taW9zLWNhcnQtb3V0bGluZVwiOiBjKDYyNDU1KSxcclxuXCJpb24taW9zLWNoYXRib3hlc1wiOiBjKDYyNDU4KSxcclxuXCJpb24taW9zLWNoYXRib3hlcy1vdXRsaW5lXCI6IGMoNjI0NTcpLFxyXG5cImlvbi1pb3MtY2hhdGJ1YmJsZVwiOiBjKDYyNDYwKSxcclxuXCJpb24taW9zLWNoYXRidWJibGUtb3V0bGluZVwiOiBjKDYyNDU5KSxcclxuXCJpb24taW9zLWNvZ1wiOiBjKDYyNDgyKSxcclxuXCJpb24taW9zLWNvZy1vdXRsaW5lXCI6IGMoNjI0ODEpLFxyXG5cImlvbi1pb3MtZ2VhclwiOiBjKDYyNTI1KSxcclxuXCJpb24taW9zLWdlYXItb3V0bGluZVwiOiBjKDYyNTI0KSxcclxuXCJpb24taW9zLXNldHRpbmdzXCI6IGMoNjI2MzEpLFxyXG5cImlvbi1pb3Mtc2V0dGluZ3Mtc3Ryb25nXCI6IGMoNjI2MzApLFxyXG5cImlvbi1pb3MtdG9nZ2xlXCI6IGMoNjI2NTkpLFxyXG5cImlvbi1pb3MtdG9nZ2xlLW91dGxpbmVcIjogYyg2MjY1OCksXHJcblwiaW9uLWlvcy1hbmFseXRpY3NcIjogYyg2MjQxNCksXHJcblwiaW9uLWlvcy1hbmFseXRpY3Mtb3V0bGluZVwiOiBjKDYyNDEzKSxcclxuXCJpb24taW9zLXBpZVwiOiBjKDYyNTk2KSxcclxuXCJpb24taW9zLXBpZS1vdXRsaW5lXCI6IGMoNjI1OTUpLFxyXG5cImlvbi1pb3MtcHVsc2VcIjogYyg2MjYxMSksXHJcblwiaW9uLWlvcy1wdWxzZS1zdHJvbmdcIjogYyg2MjYxMCksXHJcblwiaW9uLWlvcy1maWxpbmdcIjogYyg2MjUwNSksXHJcblwiaW9uLWlvcy1maWxpbmctb3V0bGluZVwiOiBjKDYyNTA0KSxcclxuXCJpb24taW9zLWJveFwiOiBjKDYyNDQ0KSxcclxuXCJpb24taW9zLWJveC1vdXRsaW5lXCI6IGMoNjI0NDMpLFxyXG5cImlvbi1pb3MtY29tcG9zZVwiOiBjKDYyNDg4KSxcclxuXCJpb24taW9zLWNvbXBvc2Utb3V0bGluZVwiOiBjKDYyNDg3KSxcclxuXCJpb24taW9zLXRyYXNoXCI6IGMoNjI2NjEpLFxyXG5cImlvbi1pb3MtdHJhc2gtb3V0bGluZVwiOiBjKDYyNjYwKSxcclxuXCJpb24taW9zLWNvcHlcIjogYyg2MjQ5MiksXHJcblwiaW9uLWlvcy1jb3B5LW91dGxpbmVcIjogYyg2MjQ5MSksXHJcblwiaW9uLWlvcy1lbWFpbFwiOiBjKDYyNDk5KSxcclxuXCJpb24taW9zLWVtYWlsLW91dGxpbmVcIjogYyg2MjQ5OCksXHJcblwiaW9uLWlvcy11bmRvXCI6IGMoNjI2NjMpLFxyXG5cImlvbi1pb3MtdW5kby1vdXRsaW5lXCI6IGMoNjI2NjIpLFxyXG5cImlvbi1pb3MtcmVkb1wiOiBjKDYyNjE3KSxcclxuXCJpb24taW9zLXJlZG8tb3V0bGluZVwiOiBjKDYyNjE2KSxcclxuXCJpb24taW9zLXBhcGVycGxhbmVcIjogYyg2MjU4MCksXHJcblwiaW9uLWlvcy1wYXBlcnBsYW5lLW91dGxpbmVcIjogYyg2MjU3OSksXHJcblwiaW9uLWlvcy1mb2xkZXJcIjogYyg2MjUxNyksXHJcblwiaW9uLWlvcy1mb2xkZXItb3V0bGluZVwiOiBjKDYyNTE2KSxcclxuXCJpb24taW9zLXBhcGVyXCI6IGMoNjI1NzgpLFxyXG5cImlvbi1pb3MtcGFwZXItb3V0bGluZVwiOiBjKDYyNTc3KSxcclxuXCJpb24taW9zLWxpc3RcIjogYyg2MjU0OCksXHJcblwiaW9uLWlvcy1saXN0LW91dGxpbmVcIjogYyg2MjU0NyksXHJcblwiaW9uLWlvcy13b3JsZFwiOiBjKDYyNjc1KSxcclxuXCJpb24taW9zLXdvcmxkLW91dGxpbmVcIjogYyg2MjY3NCksXHJcblwiaW9uLWlvcy1hbGFybVwiOiBjKDYyNDA4KSxcclxuXCJpb24taW9zLWFsYXJtLW91dGxpbmVcIjogYyg2MjQwNyksXHJcblwiaW9uLWlvcy1zcGVlZG9tZXRlclwiOiBjKDYyNjQwKSxcclxuXCJpb24taW9zLXNwZWVkb21ldGVyLW91dGxpbmVcIjogYyg2MjYzOSksXHJcblwiaW9uLWlvcy1zdG9wd2F0Y2hcIjogYyg2MjY0NSksXHJcblwiaW9uLWlvcy1zdG9wd2F0Y2gtb3V0bGluZVwiOiBjKDYyNjQ0KSxcclxuXCJpb24taW9zLXRpbWVyXCI6IGMoNjI2NTcpLFxyXG5cImlvbi1pb3MtdGltZXItb3V0bGluZVwiOiBjKDYyNjU2KSxcclxuXCJpb24taW9zLWNsb2NrXCI6IGMoNjI0NjcpLFxyXG5cImlvbi1pb3MtY2xvY2stb3V0bGluZVwiOiBjKDYyNDY2KSxcclxuXCJpb24taW9zLXRpbWVcIjogYyg2MjY1NSksXHJcblwiaW9uLWlvcy10aW1lLW91dGxpbmVcIjogYyg2MjY1NCksXHJcblwiaW9uLWlvcy1jYWxlbmRhclwiOiBjKDYyNDUyKSxcclxuXCJpb24taW9zLWNhbGVuZGFyLW91dGxpbmVcIjogYyg2MjQ1MSksXHJcblwiaW9uLWlvcy1waG90b3NcIjogYyg2MjU5NCksXHJcblwiaW9uLWlvcy1waG90b3Mtb3V0bGluZVwiOiBjKDYyNTkzKSxcclxuXCJpb24taW9zLWFsYnVtc1wiOiBjKDYyNDEwKSxcclxuXCJpb24taW9zLWFsYnVtcy1vdXRsaW5lXCI6IGMoNjI0MDkpLFxyXG5cImlvbi1pb3MtY2FtZXJhXCI6IGMoNjI0NTQpLFxyXG5cImlvbi1pb3MtY2FtZXJhLW91dGxpbmVcIjogYyg2MjQ1MyksXHJcblwiaW9uLWlvcy1yZXZlcnNlLWNhbWVyYVwiOiBjKDYyNjIzKSxcclxuXCJpb24taW9zLXJldmVyc2UtY2FtZXJhLW91dGxpbmVcIjogYyg2MjYyMiksXHJcblwiaW9uLWlvcy1leWVcIjogYyg2MjUwMSksXHJcblwiaW9uLWlvcy1leWUtb3V0bGluZVwiOiBjKDYyNTAwKSxcclxuXCJpb24taW9zLWJvbHRcIjogYyg2MjQzOCksXHJcblwiaW9uLWlvcy1ib2x0LW91dGxpbmVcIjogYyg2MjQzNyksXHJcblwiaW9uLWlvcy1jb2xvci13YW5kXCI6IGMoNjI0ODYpLFxyXG5cImlvbi1pb3MtY29sb3Itd2FuZC1vdXRsaW5lXCI6IGMoNjI0ODUpLFxyXG5cImlvbi1pb3MtY29sb3ItZmlsdGVyXCI6IGMoNjI0ODQpLFxyXG5cImlvbi1pb3MtY29sb3ItZmlsdGVyLW91dGxpbmVcIjogYyg2MjQ4MyksXHJcblwiaW9uLWlvcy1ncmlkLXZpZXdcIjogYyg2MjUyOSksXHJcblwiaW9uLWlvcy1ncmlkLXZpZXctb3V0bGluZVwiOiBjKDYyNTI4KSxcclxuXCJpb24taW9zLWNyb3Atc3Ryb25nXCI6IGMoNjI0OTMpLFxyXG5cImlvbi1pb3MtY3JvcFwiOiBjKDYyNDk0KSxcclxuXCJpb24taW9zLWJhcmNvZGVcIjogYyg2MjQyOCksXHJcblwiaW9uLWlvcy1iYXJjb2RlLW91dGxpbmVcIjogYyg2MjQyNyksXHJcblwiaW9uLWlvcy1icmllZmNhc2VcIjogYyg2MjQ0NiksXHJcblwiaW9uLWlvcy1icmllZmNhc2Utb3V0bGluZVwiOiBjKDYyNDQ1KSxcclxuXCJpb24taW9zLW1lZGtpdFwiOiBjKDYyNTU4KSxcclxuXCJpb24taW9zLW1lZGtpdC1vdXRsaW5lXCI6IGMoNjI1NTcpLFxyXG5cImlvbi1pb3MtbWVkaWNhbFwiOiBjKDYyNTU2KSxcclxuXCJpb24taW9zLW1lZGljYWwtb3V0bGluZVwiOiBjKDYyNTU1KSxcclxuXCJpb24taW9zLWluZmluaXRlXCI6IGMoNjI1MzgpLFxyXG5cImlvbi1pb3MtaW5maW5pdGUtb3V0bGluZVwiOiBjKDYyNTM3KSxcclxuXCJpb24taW9zLWNhbGN1bGF0b3JcIjogYyg2MjQ1MCksXHJcblwiaW9uLWlvcy1jYWxjdWxhdG9yLW91dGxpbmVcIjogYyg2MjQ0OSksXHJcblwiaW9uLWlvcy1rZXlwYWRcIjogYyg2MjU0NCksXHJcblwiaW9uLWlvcy1rZXlwYWQtb3V0bGluZVwiOiBjKDYyNTQzKSxcclxuXCJpb24taW9zLXRlbGVwaG9uZVwiOiBjKDYyNjQ5KSxcclxuXCJpb24taW9zLXRlbGVwaG9uZS1vdXRsaW5lXCI6IGMoNjI2NDgpLFxyXG5cImlvbi1pb3MtZHJhZ1wiOiBjKDYyNDk3KSxcclxuXCJpb24taW9zLWxvY2F0aW9uXCI6IGMoNjI1NTApLFxyXG5cImlvbi1pb3MtbG9jYXRpb24tb3V0bGluZVwiOiBjKDYyNTQ5KSxcclxuXCJpb24taW9zLW5hdmlnYXRlXCI6IGMoNjI1NzQpLFxyXG5cImlvbi1pb3MtbmF2aWdhdGUtb3V0bGluZVwiOiBjKDYyNTczKSxcclxuXCJpb24taW9zLWxvY2tlZFwiOiBjKDYyNTUyKSxcclxuXCJpb24taW9zLWxvY2tlZC1vdXRsaW5lXCI6IGMoNjI1NTEpLFxyXG5cImlvbi1pb3MtdW5sb2NrZWRcIjogYyg2MjY2NSksXHJcblwiaW9uLWlvcy11bmxvY2tlZC1vdXRsaW5lXCI6IGMoNjI2NjQpLFxyXG5cImlvbi1pb3MtbW9uaXRvclwiOiBjKDYyNTY2KSxcclxuXCJpb24taW9zLW1vbml0b3Itb3V0bGluZVwiOiBjKDYyNTY1KSxcclxuXCJpb24taW9zLXByaW50ZXJcIjogYyg2MjYwOSksXHJcblwiaW9uLWlvcy1wcmludGVyLW91dGxpbmVcIjogYyg2MjYwOCksXHJcblwiaW9uLWlvcy1nYW1lLWNvbnRyb2xsZXItYVwiOiBjKDYyNTIxKSxcclxuXCJpb24taW9zLWdhbWUtY29udHJvbGxlci1hLW91dGxpbmVcIjogYyg2MjUyMCksXHJcblwiaW9uLWlvcy1nYW1lLWNvbnRyb2xsZXItYlwiOiBjKDYyNTIzKSxcclxuXCJpb24taW9zLWdhbWUtY29udHJvbGxlci1iLW91dGxpbmVcIjogYyg2MjUyMiksXHJcblwiaW9uLWlvcy1hbWVyaWNhbmZvb3RiYWxsXCI6IGMoNjI0MTIpLFxyXG5cImlvbi1pb3MtYW1lcmljYW5mb290YmFsbC1vdXRsaW5lXCI6IGMoNjI0MTEpLFxyXG5cImlvbi1pb3MtYmFzZWJhbGxcIjogYyg2MjQzMCksXHJcblwiaW9uLWlvcy1iYXNlYmFsbC1vdXRsaW5lXCI6IGMoNjI0MjkpLFxyXG5cImlvbi1pb3MtYmFza2V0YmFsbFwiOiBjKDYyNDMyKSxcclxuXCJpb24taW9zLWJhc2tldGJhbGwtb3V0bGluZVwiOiBjKDYyNDMxKSxcclxuXCJpb24taW9zLXRlbm5pc2JhbGxcIjogYyg2MjY1MSksXHJcblwiaW9uLWlvcy10ZW5uaXNiYWxsLW91dGxpbmVcIjogYyg2MjY1MCksXHJcblwiaW9uLWlvcy1mb290YmFsbFwiOiBjKDYyNTE5KSxcclxuXCJpb24taW9zLWZvb3RiYWxsLW91dGxpbmVcIjogYyg2MjUxOCksXHJcblwiaW9uLWlvcy1ib2R5XCI6IGMoNjI0MzYpLFxyXG5cImlvbi1pb3MtYm9keS1vdXRsaW5lXCI6IGMoNjI0MzUpLFxyXG5cImlvbi1pb3MtcGVyc29uXCI6IGMoNjI1OTApLFxyXG5cImlvbi1pb3MtcGVyc29uLW91dGxpbmVcIjogYyg2MjU4OSksXHJcblwiaW9uLWlvcy1wZXJzb25hZGRcIjogYyg2MjU5MiksXHJcblwiaW9uLWlvcy1wZXJzb25hZGQtb3V0bGluZVwiOiBjKDYyNTkxKSxcclxuXCJpb24taW9zLXBlb3BsZVwiOiBjKDYyNTg4KSxcclxuXCJpb24taW9zLXBlb3BsZS1vdXRsaW5lXCI6IGMoNjI1ODcpLFxyXG5cImlvbi1pb3MtbXVzaWNhbC1ub3Rlc1wiOiBjKDYyNTcyKSxcclxuXCJpb24taW9zLW11c2ljYWwtbm90ZVwiOiBjKDYyNTcxKSxcclxuXCJpb24taW9zLWJlbGxcIjogYyg2MjQzNCksXHJcblwiaW9uLWlvcy1iZWxsLW91dGxpbmVcIjogYyg2MjQzMyksXHJcblwiaW9uLWlvcy1taWNcIjogYyg2MjU2MSksXHJcblwiaW9uLWlvcy1taWMtb3V0bGluZVwiOiBjKDYyNTYwKSxcclxuXCJpb24taW9zLW1pYy1vZmZcIjogYyg2MjU1OSksXHJcblwiaW9uLWlvcy12b2x1bWUtaGlnaFwiOiBjKDYyNjcwKSxcclxuXCJpb24taW9zLXZvbHVtZS1sb3dcIjogYyg2MjY3MSksXHJcblwiaW9uLWlvcy1wbGF5XCI6IGMoNjI2MDApLFxyXG5cImlvbi1pb3MtcGxheS1vdXRsaW5lXCI6IGMoNjI1OTkpLFxyXG5cImlvbi1pb3MtcGF1c2VcIjogYyg2MjU4NCksXHJcblwiaW9uLWlvcy1wYXVzZS1vdXRsaW5lXCI6IGMoNjI1ODMpLFxyXG5cImlvbi1pb3MtcmVjb3JkaW5nXCI6IGMoNjI2MTUpLFxyXG5cImlvbi1pb3MtcmVjb3JkaW5nLW91dGxpbmVcIjogYyg2MjYxNCksXHJcblwiaW9uLWlvcy1mYXN0Zm9yd2FyZFwiOiBjKDYyNTAzKSxcclxuXCJpb24taW9zLWZhc3Rmb3J3YXJkLW91dGxpbmVcIjogYyg2MjUwMiksXHJcblwiaW9uLWlvcy1yZXdpbmRcIjogYyg2MjYyNSksXHJcblwiaW9uLWlvcy1yZXdpbmQtb3V0bGluZVwiOiBjKDYyNjI0KSxcclxuXCJpb24taW9zLXNraXBiYWNrd2FyZFwiOiBjKDYyNjM1KSxcclxuXCJpb24taW9zLXNraXBiYWNrd2FyZC1vdXRsaW5lXCI6IGMoNjI2MzQpLFxyXG5cImlvbi1pb3Mtc2tpcGZvcndhcmRcIjogYyg2MjYzNyksXHJcblwiaW9uLWlvcy1za2lwZm9yd2FyZC1vdXRsaW5lXCI6IGMoNjI2MzYpLFxyXG5cImlvbi1pb3Mtc2h1ZmZsZS1zdHJvbmdcIjogYyg2MjYzMiksXHJcblwiaW9uLWlvcy1zaHVmZmxlXCI6IGMoNjI2MzMpLFxyXG5cImlvbi1pb3MtdmlkZW9jYW1cIjogYyg2MjY2OSksXHJcblwiaW9uLWlvcy12aWRlb2NhbS1vdXRsaW5lXCI6IGMoNjI2NjgpLFxyXG5cImlvbi1pb3MtZmlsbVwiOiBjKDYyNTA3KSxcclxuXCJpb24taW9zLWZpbG0tb3V0bGluZVwiOiBjKDYyNTA2KSxcclxuXCJpb24taW9zLWZsYXNrXCI6IGMoNjI1MTMpLFxyXG5cImlvbi1pb3MtZmxhc2stb3V0bGluZVwiOiBjKDYyNTEyKSxcclxuXCJpb24taW9zLWxpZ2h0YnVsYlwiOiBjKDYyNTQ2KSxcclxuXCJpb24taW9zLWxpZ2h0YnVsYi1vdXRsaW5lXCI6IGMoNjI1NDUpLFxyXG5cImlvbi1pb3Mtd2luZWdsYXNzXCI6IGMoNjI2NzMpLFxyXG5cImlvbi1pb3Mtd2luZWdsYXNzLW91dGxpbmVcIjogYyg2MjY3MiksXHJcblwiaW9uLWlvcy1waW50XCI6IGMoNjI1OTgpLFxyXG5cImlvbi1pb3MtcGludC1vdXRsaW5lXCI6IGMoNjI1OTcpLFxyXG5cImlvbi1pb3MtbnV0cml0aW9uXCI6IGMoNjI1NzYpLFxyXG5cImlvbi1pb3MtbnV0cml0aW9uLW91dGxpbmVcIjogYyg2MjU3NSksXHJcblwiaW9uLWlvcy1mbG93ZXJcIjogYyg2MjUxNSksXHJcblwiaW9uLWlvcy1mbG93ZXItb3V0bGluZVwiOiBjKDYyNTE0KSxcclxuXCJpb24taW9zLXJvc2VcIjogYyg2MjYyNyksXHJcblwiaW9uLWlvcy1yb3NlLW91dGxpbmVcIjogYyg2MjYyNiksXHJcblwiaW9uLWlvcy1wYXdcIjogYyg2MjU4NiksXHJcblwiaW9uLWlvcy1wYXctb3V0bGluZVwiOiBjKDYyNTg1KSxcclxuXCJpb24taW9zLWZsYW1lXCI6IGMoNjI1MTEpLFxyXG5cImlvbi1pb3MtZmxhbWUtb3V0bGluZVwiOiBjKDYyNTEwKSxcclxuXCJpb24taW9zLXN1bm55XCI6IGMoNjI2NDcpLFxyXG5cImlvbi1pb3Mtc3Vubnktb3V0bGluZVwiOiBjKDYyNjQ2KSxcclxuXCJpb24taW9zLXBhcnRseXN1bm55XCI6IGMoNjI1ODIpLFxyXG5cImlvbi1pb3MtcGFydGx5c3Vubnktb3V0bGluZVwiOiBjKDYyNTgxKSxcclxuXCJpb24taW9zLWNsb3VkeVwiOiBjKDYyNDgwKSxcclxuXCJpb24taW9zLWNsb3VkeS1vdXRsaW5lXCI6IGMoNjI0NzkpLFxyXG5cImlvbi1pb3MtcmFpbnlcIjogYyg2MjYxMyksXHJcblwiaW9uLWlvcy1yYWlueS1vdXRsaW5lXCI6IGMoNjI2MTIpLFxyXG5cImlvbi1pb3MtdGh1bmRlcnN0b3JtXCI6IGMoNjI2NTMpLFxyXG5cImlvbi1pb3MtdGh1bmRlcnN0b3JtLW91dGxpbmVcIjogYyg2MjY1MiksXHJcblwiaW9uLWlvcy1zbm93eVwiOiBjKDYyNjM4KSxcclxuXCJpb24taW9zLW1vb25cIjogYyg2MjU2OCksXHJcblwiaW9uLWlvcy1tb29uLW91dGxpbmVcIjogYyg2MjU2NyksXHJcblwiaW9uLWlvcy1jbG91ZHktbmlnaHRcIjogYyg2MjQ3OCksXHJcblwiaW9uLWlvcy1jbG91ZHktbmlnaHQtb3V0bGluZVwiOiBjKDYyNDc3KSxcclxuXCJpb24tYW5kcm9pZC1hcnJvdy11cFwiOiBjKDYyMzEwKSxcclxuXCJpb24tYW5kcm9pZC1hcnJvdy1mb3J3YXJkXCI6IGMoNjIyMjMpLFxyXG5cImlvbi1hbmRyb2lkLWFycm93LWRvd25cIjogYyg2MjMwMSksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctYmFja1wiOiBjKDYyMTU0KSxcclxuXCJpb24tYW5kcm9pZC1hcnJvdy1kcm9wdXBcIjogYyg2MjMwOSksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcHVwLWNpcmNsZVwiOiBjKDYyMzA4KSxcclxuXCJpb24tYW5kcm9pZC1hcnJvdy1kcm9wcmlnaHRcIjogYyg2MjMwNyksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcHJpZ2h0LWNpcmNsZVwiOiBjKDYyMzA2KSxcclxuXCJpb24tYW5kcm9pZC1hcnJvdy1kcm9wZG93blwiOiBjKDYyMzAzKSxcclxuXCJpb24tYW5kcm9pZC1hcnJvdy1kcm9wZG93bi1jaXJjbGVcIjogYyg2MjMwMiksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcGxlZnRcIjogYyg2MjMwNSksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcGxlZnQtY2lyY2xlXCI6IGMoNjIzMDQpLFxyXG5cImlvbi1hbmRyb2lkLWFkZFwiOiBjKDYyMTUxKSxcclxuXCJpb24tYW5kcm9pZC1hZGQtY2lyY2xlXCI6IGMoNjIyOTcpLFxyXG5cImlvbi1hbmRyb2lkLXJlbW92ZVwiOiBjKDYyMTk2KSxcclxuXCJpb24tYW5kcm9pZC1yZW1vdmUtY2lyY2xlXCI6IGMoNjIzNzcpLFxyXG5cImlvbi1hbmRyb2lkLWNsb3NlXCI6IGMoNjIxNjcpLFxyXG5cImlvbi1hbmRyb2lkLWNhbmNlbFwiOiBjKDYyMzE4KSxcclxuXCJpb24tYW5kcm9pZC1yYWRpby1idXR0b24tb2ZmXCI6IGMoNjIzNzQpLFxyXG5cImlvbi1hbmRyb2lkLXJhZGlvLWJ1dHRvbi1vblwiOiBjKDYyMzc1KSxcclxuXCJpb24tYW5kcm9pZC1jaGVja21hcmstY2lyY2xlXCI6IGMoNjIzMjUpLFxyXG5cImlvbi1hbmRyb2lkLWNoZWNrYm94LW91dGxpbmUtYmxhbmtcIjogYyg2MjMyMiksXHJcblwiaW9uLWFuZHJvaWQtY2hlY2tib3gtb3V0bGluZVwiOiBjKDYyMzIzKSxcclxuXCJpb24tYW5kcm9pZC1jaGVja2JveC1ibGFua1wiOiBjKDYyMzIxKSxcclxuXCJpb24tYW5kcm9pZC1jaGVja2JveFwiOiBjKDYyMzI0KSxcclxuXCJpb24tYW5kcm9pZC1kb25lXCI6IGMoNjIzMzkpLFxyXG5cImlvbi1hbmRyb2lkLWRvbmUtYWxsXCI6IGMoNjIzMzgpLFxyXG5cImlvbi1hbmRyb2lkLW1lbnVcIjogYyg2MjM1NiksXHJcblwiaW9uLWFuZHJvaWQtbW9yZS1ob3Jpem9udGFsXCI6IGMoNjIzNTgpLFxyXG5cImlvbi1hbmRyb2lkLW1vcmUtdmVydGljYWxcIjogYyg2MjM1OSksXHJcblwiaW9uLWFuZHJvaWQtcmVmcmVzaFwiOiBjKDYyMzc2KSxcclxuXCJpb24tYW5kcm9pZC1zeW5jXCI6IGMoNjIzODUpLFxyXG5cImlvbi1hbmRyb2lkLXdpZmlcIjogYyg2MjIxMyksXHJcblwiaW9uLWFuZHJvaWQtY2FsbFwiOiBjKDYyMTYyKSxcclxuXCJpb24tYW5kcm9pZC1hcHBzXCI6IGMoNjIzMDApLFxyXG5cImlvbi1hbmRyb2lkLXNldHRpbmdzXCI6IGMoNjIxOTkpLFxyXG5cImlvbi1hbmRyb2lkLW9wdGlvbnNcIjogYyg2MjM2NSksXHJcblwiaW9uLWFuZHJvaWQtZnVubmVsXCI6IGMoNjIzNDcpLFxyXG5cImlvbi1hbmRyb2lkLXNlYXJjaFwiOiBjKDYyMTk3KSxcclxuXCJpb24tYW5kcm9pZC1ob21lXCI6IGMoNjIzNTEpLFxyXG5cImlvbi1hbmRyb2lkLWNsb3VkLW91dGxpbmVcIjogYyg2MjMyOSksXHJcblwiaW9uLWFuZHJvaWQtY2xvdWRcIjogYyg2MjMzMCksXHJcblwiaW9uLWFuZHJvaWQtZG93bmxvYWRcIjogYyg2MjE3MyksXHJcblwiaW9uLWFuZHJvaWQtdXBsb2FkXCI6IGMoNjIzOTApLFxyXG5cImlvbi1hbmRyb2lkLWNsb3VkLWRvbmVcIjogYyg2MjMyOCksXHJcblwiaW9uLWFuZHJvaWQtY2xvdWQtY2lyY2xlXCI6IGMoNjIzMjcpLFxyXG5cImlvbi1hbmRyb2lkLWZhdm9yaXRlLW91dGxpbmVcIjogYyg2MjM0MyksXHJcblwiaW9uLWFuZHJvaWQtZmF2b3JpdGVcIjogYyg2MjM0NCksXHJcblwiaW9uLWFuZHJvaWQtc3Rhci1vdXRsaW5lXCI6IGMoNjIzODIpLFxyXG5cImlvbi1hbmRyb2lkLXN0YXItaGFsZlwiOiBjKDYyMzgxKSxcclxuXCJpb24tYW5kcm9pZC1zdGFyXCI6IGMoNjIyMDQpLFxyXG5cImlvbi1hbmRyb2lkLWNhbGVuZGFyXCI6IGMoNjIxNjEpLFxyXG5cImlvbi1hbmRyb2lkLWFsYXJtLWNsb2NrXCI6IGMoNjIyOTgpLFxyXG5cImlvbi1hbmRyb2lkLXRpbWVcIjogYyg2MjM4NyksXHJcblwiaW9uLWFuZHJvaWQtc3RvcHdhdGNoXCI6IGMoNjIyMDUpLFxyXG5cImlvbi1hbmRyb2lkLXdhdGNoXCI6IGMoNjIzOTcpLFxyXG5cImlvbi1hbmRyb2lkLWxvY2F0ZVwiOiBjKDYyMTg1KSxcclxuXCJpb24tYW5kcm9pZC1uYXZpZ2F0ZVwiOiBjKDYyMzYwKSxcclxuXCJpb24tYW5kcm9pZC1waW5cIjogYyg2MjM3MSksXHJcblwiaW9uLWFuZHJvaWQtY29tcGFzc1wiOiBjKDYyMzMyKSxcclxuXCJpb24tYW5kcm9pZC1tYXBcIjogYyg2MjM1NSksXHJcblwiaW9uLWFuZHJvaWQtd2Fsa1wiOiBjKDYyMzk1KSxcclxuXCJpb24tYW5kcm9pZC1iaWN5Y2xlXCI6IGMoNjIzMTMpLFxyXG5cImlvbi1hbmRyb2lkLWNhclwiOiBjKDYyMzE5KSxcclxuXCJpb24tYW5kcm9pZC1idXNcIjogYyg2MjMxNyksXHJcblwiaW9uLWFuZHJvaWQtc3Vid2F5XCI6IGMoNjIzODMpLFxyXG5cImlvbi1hbmRyb2lkLXRyYWluXCI6IGMoNjIzODgpLFxyXG5cImlvbi1hbmRyb2lkLWJvYXRcIjogYyg2MjMxNCksXHJcblwiaW9uLWFuZHJvaWQtcGxhbmVcIjogYyg2MjM3MiksXHJcblwiaW9uLWFuZHJvaWQtcmVzdGF1cmFudFwiOiBjKDYyMzc4KSxcclxuXCJpb24tYW5kcm9pZC1iYXJcIjogYyg2MjMxMiksXHJcblwiaW9uLWFuZHJvaWQtY2FydFwiOiBjKDYyMzIwKSxcclxuXCJpb24tYW5kcm9pZC1jYW1lcmFcIjogYyg2MjE2MyksXHJcblwiaW9uLWFuZHJvaWQtaW1hZ2VcIjogYyg2MjE4MCksXHJcblwiaW9uLWFuZHJvaWQtZmlsbVwiOiBjKDYyMzQ1KSxcclxuXCJpb24tYW5kcm9pZC1jb2xvci1wYWxldHRlXCI6IGMoNjIzMzEpLFxyXG5cImlvbi1hbmRyb2lkLWNyZWF0ZVwiOiBjKDYyMzM0KSxcclxuXCJpb24tYW5kcm9pZC1tYWlsXCI6IGMoNjIxODcpLFxyXG5cImlvbi1hbmRyb2lkLWRyYWZ0c1wiOiBjKDYyMzQwKSxcclxuXCJpb24tYW5kcm9pZC1zZW5kXCI6IGMoNjIxOTgpLFxyXG5cImlvbi1hbmRyb2lkLWFyY2hpdmVcIjogYyg2MjE1MyksXHJcblwiaW9uLWFuZHJvaWQtZGVsZXRlXCI6IGMoNjIzMzUpLFxyXG5cImlvbi1hbmRyb2lkLWF0dGFjaFwiOiBjKDYyMzExKSxcclxuXCJpb24tYW5kcm9pZC1zaGFyZVwiOiBjKDYyMjAwKSxcclxuXCJpb24tYW5kcm9pZC1zaGFyZS1hbHRcIjogYyg2MjM4MCksXHJcblwiaW9uLWFuZHJvaWQtYm9va21hcmtcIjogYyg2MjMxNSksXHJcblwiaW9uLWFuZHJvaWQtZG9jdW1lbnRcIjogYyg2MjMzNyksXHJcblwiaW9uLWFuZHJvaWQtY2xpcGJvYXJkXCI6IGMoNjIzMjYpLFxyXG5cImlvbi1hbmRyb2lkLWxpc3RcIjogYyg2MjM1MyksXHJcblwiaW9uLWFuZHJvaWQtZm9sZGVyLW9wZW5cIjogYyg2MjM0NiksXHJcblwiaW9uLWFuZHJvaWQtZm9sZGVyXCI6IGMoNjIxNzYpLFxyXG5cImlvbi1hbmRyb2lkLXByaW50XCI6IGMoNjIzNzMpLFxyXG5cImlvbi1hbmRyb2lkLW9wZW5cIjogYyg2MjM2NCksXHJcblwiaW9uLWFuZHJvaWQtZXhpdFwiOiBjKDYyMzQxKSxcclxuXCJpb24tYW5kcm9pZC1jb250cmFjdFwiOiBjKDYyMzMzKSxcclxuXCJpb24tYW5kcm9pZC1leHBhbmRcIjogYyg2MjM0MiksXHJcblwiaW9uLWFuZHJvaWQtZ2xvYmVcIjogYyg2MjM0OCksXHJcblwiaW9uLWFuZHJvaWQtY2hhdFwiOiBjKDYyMTY0KSxcclxuXCJpb24tYW5kcm9pZC10ZXh0c21zXCI6IGMoNjIzODYpLFxyXG5cImlvbi1hbmRyb2lkLWhhbmdvdXRcIjogYyg2MjM0OSksXHJcblwiaW9uLWFuZHJvaWQtaGFwcHlcIjogYyg2MjM1MCksXHJcblwiaW9uLWFuZHJvaWQtc2FkXCI6IGMoNjIzNzkpLFxyXG5cImlvbi1hbmRyb2lkLXBlcnNvblwiOiBjKDYyMzY4KSxcclxuXCJpb24tYW5kcm9pZC1wZW9wbGVcIjogYyg2MjM2NiksXHJcblwiaW9uLWFuZHJvaWQtcGVyc29uLWFkZFwiOiBjKDYyMzY3KSxcclxuXCJpb24tYW5kcm9pZC1jb250YWN0XCI6IGMoNjIxNjgpLFxyXG5cImlvbi1hbmRyb2lkLWNvbnRhY3RzXCI6IGMoNjIxNjkpLFxyXG5cImlvbi1hbmRyb2lkLXBsYXlzdG9yZVwiOiBjKDYyMTkyKSxcclxuXCJpb24tYW5kcm9pZC1sb2NrXCI6IGMoNjIzNTQpLFxyXG5cImlvbi1hbmRyb2lkLXVubG9ja1wiOiBjKDYyMzg5KSxcclxuXCJpb24tYW5kcm9pZC1taWNyb3Bob25lXCI6IGMoNjIxODgpLFxyXG5cImlvbi1hbmRyb2lkLW1pY3JvcGhvbmUtb2ZmXCI6IGMoNjIzNTcpLFxyXG5cImlvbi1hbmRyb2lkLW5vdGlmaWNhdGlvbnMtbm9uZVwiOiBjKDYyMzYxKSxcclxuXCJpb24tYW5kcm9pZC1ub3RpZmljYXRpb25zXCI6IGMoNjIzNjMpLFxyXG5cImlvbi1hbmRyb2lkLW5vdGlmaWNhdGlvbnMtb2ZmXCI6IGMoNjIzNjIpLFxyXG5cImlvbi1hbmRyb2lkLXZvbHVtZS1tdXRlXCI6IGMoNjIzOTIpLFxyXG5cImlvbi1hbmRyb2lkLXZvbHVtZS1kb3duXCI6IGMoNjIzOTEpLFxyXG5cImlvbi1hbmRyb2lkLXZvbHVtZS11cFwiOiBjKDYyMzk0KSxcclxuXCJpb24tYW5kcm9pZC12b2x1bWUtb2ZmXCI6IGMoNjIzOTMpLFxyXG5cImlvbi1hbmRyb2lkLWhhbmRcIjogYyg2MjE3OSksXHJcblwiaW9uLWFuZHJvaWQtZGVza3RvcFwiOiBjKDYyMzM2KSxcclxuXCJpb24tYW5kcm9pZC1sYXB0b3BcIjogYyg2MjM1MiksXHJcblwiaW9uLWFuZHJvaWQtcGhvbmUtcG9ydHJhaXRcIjogYyg2MjM3MCksXHJcblwiaW9uLWFuZHJvaWQtcGhvbmUtbGFuZHNjYXBlXCI6IGMoNjIzNjkpLFxyXG5cImlvbi1hbmRyb2lkLWJ1bGJcIjogYyg2MjMxNiksXHJcblwiaW9uLWFuZHJvaWQtc3VubnlcIjogYyg2MjM4NCksXHJcblwiaW9uLWFuZHJvaWQtYWxlcnRcIjogYyg2MjI5OSksXHJcblwiaW9uLWFuZHJvaWQtd2FybmluZ1wiOiBjKDYyMzk2KSxcclxuXCJpb24tc29jaWFsLXR3aXR0ZXJcIjogYyg2MjAxOSksXHJcblwiaW9uLXNvY2lhbC10d2l0dGVyLW91dGxpbmVcIjogYyg2MjAxOCksXHJcblwiaW9uLXNvY2lhbC1mYWNlYm9va1wiOiBjKDYyMDAxKSxcclxuXCJpb24tc29jaWFsLWZhY2Vib29rLW91dGxpbmVcIjogYyg2MjAwMCksXHJcblwiaW9uLXNvY2lhbC1nb29nbGVwbHVzXCI6IGMoNjIwMDUpLFxyXG5cImlvbi1zb2NpYWwtZ29vZ2xlcGx1cy1vdXRsaW5lXCI6IGMoNjIwMDQpLFxyXG5cImlvbi1zb2NpYWwtZ29vZ2xlXCI6IGMoNjIyODcpLFxyXG5cImlvbi1zb2NpYWwtZ29vZ2xlLW91dGxpbmVcIjogYyg2MjI4NiksXHJcblwiaW9uLXNvY2lhbC1kcmliYmJsZVwiOiBjKDYxOTk3KSxcclxuXCJpb24tc29jaWFsLWRyaWJiYmxlLW91dGxpbmVcIjogYyg2MTk5NiksXHJcblwiaW9uLXNvY2lhbC1vY3RvY2F0XCI6IGMoNjI2OTYpLFxyXG5cImlvbi1zb2NpYWwtZ2l0aHViXCI6IGMoNjIwMDMpLFxyXG5cImlvbi1zb2NpYWwtZ2l0aHViLW91dGxpbmVcIjogYyg2MjAwMiksXHJcblwiaW9uLXNvY2lhbC1pbnN0YWdyYW1cIjogYyg2MjI4OSksXHJcblwiaW9uLXNvY2lhbC1pbnN0YWdyYW0tb3V0bGluZVwiOiBjKDYyMjg4KSxcclxuXCJpb24tc29jaWFsLXdoYXRzYXBwXCI6IGMoNjI3MDQpLFxyXG5cImlvbi1zb2NpYWwtd2hhdHNhcHAtb3V0bGluZVwiOiBjKDYyNzAzKSxcclxuXCJpb24tc29jaWFsLXNuYXBjaGF0XCI6IGMoNjI3MDApLFxyXG5cImlvbi1zb2NpYWwtc25hcGNoYXQtb3V0bGluZVwiOiBjKDYyNjk5KSxcclxuXCJpb24tc29jaWFsLWZvdXJzcXVhcmVcIjogYyg2MjI4NSksXHJcblwiaW9uLXNvY2lhbC1mb3Vyc3F1YXJlLW91dGxpbmVcIjogYyg2MjI4NCksXHJcblwiaW9uLXNvY2lhbC1waW50ZXJlc3RcIjogYyg2MjEyOSksXHJcblwiaW9uLXNvY2lhbC1waW50ZXJlc3Qtb3V0bGluZVwiOiBjKDYyMTI4KSxcclxuXCJpb24tc29jaWFsLXJzc1wiOiBjKDYyMDEzKSxcclxuXCJpb24tc29jaWFsLXJzcy1vdXRsaW5lXCI6IGMoNjIwMTIpLFxyXG5cImlvbi1zb2NpYWwtdHVtYmxyXCI6IGMoNjIwMTcpLFxyXG5cImlvbi1zb2NpYWwtdHVtYmxyLW91dGxpbmVcIjogYyg2MjAxNiksXHJcblwiaW9uLXNvY2lhbC13b3JkcHJlc3NcIjogYyg2MjAyNSksXHJcblwiaW9uLXNvY2lhbC13b3JkcHJlc3Mtb3V0bGluZVwiOiBjKDYyMDI0KSxcclxuXCJpb24tc29jaWFsLXJlZGRpdFwiOiBjKDYyMDExKSxcclxuXCJpb24tc29jaWFsLXJlZGRpdC1vdXRsaW5lXCI6IGMoNjIwMTApLFxyXG5cImlvbi1zb2NpYWwtaGFja2VybmV3c1wiOiBjKDYyMDA3KSxcclxuXCJpb24tc29jaWFsLWhhY2tlcm5ld3Mtb3V0bGluZVwiOiBjKDYyMDA2KSxcclxuXCJpb24tc29jaWFsLWRlc2lnbmVybmV3c1wiOiBjKDYxOTk1KSxcclxuXCJpb24tc29jaWFsLWRlc2lnbmVybmV3cy1vdXRsaW5lXCI6IGMoNjE5OTQpLFxyXG5cImlvbi1zb2NpYWwteWFob29cIjogYyg2MjAyNyksXHJcblwiaW9uLXNvY2lhbC15YWhvby1vdXRsaW5lXCI6IGMoNjIwMjYpLFxyXG5cImlvbi1zb2NpYWwtYnVmZmVyXCI6IGMoNjE5OTMpLFxyXG5cImlvbi1zb2NpYWwtYnVmZmVyLW91dGxpbmVcIjogYyg2MTk5MiksXHJcblwiaW9uLXNvY2lhbC1za3lwZVwiOiBjKDYyMDE1KSxcclxuXCJpb24tc29jaWFsLXNreXBlLW91dGxpbmVcIjogYyg2MjAxNCksXHJcblwiaW9uLXNvY2lhbC1saW5rZWRpblwiOiBjKDYyMDA5KSxcclxuXCJpb24tc29jaWFsLWxpbmtlZGluLW91dGxpbmVcIjogYyg2MjAwOCksXHJcblwiaW9uLXNvY2lhbC12aW1lb1wiOiBjKDYyMDIxKSxcclxuXCJpb24tc29jaWFsLXZpbWVvLW91dGxpbmVcIjogYyg2MjAyMCksXHJcblwiaW9uLXNvY2lhbC10d2l0Y2hcIjogYyg2MjcwMiksXHJcblwiaW9uLXNvY2lhbC10d2l0Y2gtb3V0bGluZVwiOiBjKDYyNzAxKSxcclxuXCJpb24tc29jaWFsLXlvdXR1YmVcIjogYyg2MjAyOSksXHJcblwiaW9uLXNvY2lhbC15b3V0dWJlLW91dGxpbmVcIjogYyg2MjAyOCksXHJcblwiaW9uLXNvY2lhbC1kcm9wYm94XCI6IGMoNjE5OTkpLFxyXG5cImlvbi1zb2NpYWwtZHJvcGJveC1vdXRsaW5lXCI6IGMoNjE5OTgpLFxyXG5cImlvbi1zb2NpYWwtYXBwbGVcIjogYyg2MTk5MSksXHJcblwiaW9uLXNvY2lhbC1hcHBsZS1vdXRsaW5lXCI6IGMoNjE5OTApLFxyXG5cImlvbi1zb2NpYWwtYW5kcm9pZFwiOiBjKDYxOTg5KSxcclxuXCJpb24tc29jaWFsLWFuZHJvaWQtb3V0bGluZVwiOiBjKDYxOTg4KSxcclxuXCJpb24tc29jaWFsLXdpbmRvd3NcIjogYyg2MjAyMyksXHJcblwiaW9uLXNvY2lhbC13aW5kb3dzLW91dGxpbmVcIjogYyg2MjAyMiksXHJcblwiaW9uLXNvY2lhbC1odG1sNVwiOiBjKDYyNjkxKSxcclxuXCJpb24tc29jaWFsLWh0bWw1LW91dGxpbmVcIjogYyg2MjY5MCksXHJcblwiaW9uLXNvY2lhbC1jc3MzXCI6IGMoNjI2ODcpLFxyXG5cImlvbi1zb2NpYWwtY3NzMy1vdXRsaW5lXCI6IGMoNjI2ODYpLFxyXG5cImlvbi1zb2NpYWwtamF2YXNjcmlwdFwiOiBjKDYyNjkzKSxcclxuXCJpb24tc29jaWFsLWphdmFzY3JpcHQtb3V0bGluZVwiOiBjKDYyNjkyKSxcclxuXCJpb24tc29jaWFsLWFuZ3VsYXJcIjogYyg2MjY4MSksXHJcblwiaW9uLXNvY2lhbC1hbmd1bGFyLW91dGxpbmVcIjogYyg2MjY4MCksXHJcblwiaW9uLXNvY2lhbC1ub2RlanNcIjogYyg2MjY5NSksXHJcblwiaW9uLXNvY2lhbC1zYXNzXCI6IGMoNjI2OTgpLFxyXG5cImlvbi1zb2NpYWwtcHl0aG9uXCI6IGMoNjI2OTcpLFxyXG5cImlvbi1zb2NpYWwtY2hyb21lXCI6IGMoNjI2ODMpLFxyXG5cImlvbi1zb2NpYWwtY2hyb21lLW91dGxpbmVcIjogYyg2MjY4MiksXHJcblwiaW9uLXNvY2lhbC1jb2RlcGVuXCI6IGMoNjI2ODUpLFxyXG5cImlvbi1zb2NpYWwtY29kZXBlbi1vdXRsaW5lXCI6IGMoNjI2ODQpLFxyXG5cImlvbi1zb2NpYWwtbWFya2Rvd25cIjogYyg2MjY5NCksXHJcblwiaW9uLXNvY2lhbC10dXhcIjogYyg2MjE0OSksXHJcblwiaW9uLXNvY2lhbC1mcmVlYnNkLWRldmlsXCI6IGMoNjIxNDgpLFxyXG5cImlvbi1zb2NpYWwtdXNkXCI6IGMoNjIyOTEpLFxyXG5cImlvbi1zb2NpYWwtdXNkLW91dGxpbmVcIjogYyg2MjI5MCksXHJcblwiaW9uLXNvY2lhbC1iaXRjb2luXCI6IGMoNjIxMjcpLFxyXG5cImlvbi1zb2NpYWwtYml0Y29pbi1vdXRsaW5lXCI6IGMoNjIxMjYpLFxyXG5cImlvbi1zb2NpYWwteWVuXCI6IGMoNjI3MDYpLFxyXG5cImlvbi1zb2NpYWwteWVuLW91dGxpbmVcIjogYyg2MjcwNSksXHJcblwiaW9uLXNvY2lhbC1ldXJvXCI6IGMoNjI2ODkpLFxyXG5cImlvbi1zb2NpYWwtZXVyby1vdXRsaW5lXCI6IGMoNjI2ODgpXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBpY29ucztcclxuIiwiY29uc3QgY3NzTm9NZWFzdXJlbWVudCA9IG5ldyBTZXQoW1xyXG4gICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxyXG4gICAgXCJib3hGbGV4XCIsXHJcbiAgICBcImJveEZsZXhHcm91cFwiLFxyXG4gICAgXCJib3hPcmRpbmFsR3JvdXBcIixcclxuICAgIFwiY29sdW1uQ291bnRcIixcclxuICAgIFwiZmlsbE9wYWNpdHlcIixcclxuICAgIFwiZmxleFwiLFxyXG4gICAgXCJmbGV4R3Jvd1wiLFxyXG4gICAgXCJmbGV4UG9zaXRpdmVcIixcclxuICAgIFwiZmxleFNocmlua1wiLFxyXG4gICAgXCJmbGV4TmVnYXRpdmVcIixcclxuICAgIFwiZmxleE9yZGVyXCIsXHJcbiAgICBcImZvbnRXZWlnaHRcIixcclxuICAgIFwibGluZUNsYW1wXCIsXHJcbiAgICBcImxpbmVIZWlnaHRcIixcclxuICAgIFwib3BhY2l0eVwiLFxyXG4gICAgXCJvcmRlclwiLFxyXG4gICAgXCJvcnBoYW5zXCIsXHJcbiAgICBcInN0b3BPcGFjaXR5XCIsXHJcbiAgICBcInN0cm9rZURhc2hvZmZzZXRcIixcclxuICAgIFwic3Ryb2tlT3BhY2l0eVwiLFxyXG4gICAgXCJzdHJva2VXaWR0aFwiLFxyXG4gICAgXCJ0YWJTaXplXCIsXHJcbiAgICBcIndpZG93c1wiLFxyXG4gICAgXCJ6SW5kZXhcIixcclxuICAgIFwiem9vbVwiXHJcbl0pO1xyXG5jb25zdCBjc3NQcmVmaXhOYW1lcyA9IG5ldyBTZXQoW1xyXG4gICAgJ3RyYW5zZm9ybScsXHJcbiAgICAndHJhbnNmb3JtT3JpZ2luJyxcclxuICAgICdib3hTaGFkb3cnLFxyXG4gICAgJ3RyYW5zaXRpb24nLFxyXG4gICAgJ2FuaW1hdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uRGVsYXknLFxyXG4gICAgJ2FuaW1hdGlvbkRpcmVjdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uRHVyYXRpb24nLFxyXG4gICAgJ2FuaW1hdGlvbkZpbGxNb2RlJyxcclxuICAgICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsXHJcbiAgICAnYW5pbWF0aW9uTmFtZScsXHJcbiAgICAnYW5pbWF0aW9uUGxheVN0YXRlJyxcclxuICAgICdhbmltYXRpb25UaW1pbmdGdW5jdGlvbicsXHJcbiAgICAndXNlclNlbGVjdCcsXHJcbiAgICAnanVzdGlmeUNvbnRlbnQnLFxyXG4gICAgJ2FsaWduSXRlbXMnLFxyXG4gICAgJ2ZsZXhXcmFwJyxcclxuXSk7XHJcbmNvbnN0IGNzc1ByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJywgJy1vLScsICcnXTtcclxuXHJcbmNvbnN0IGdldENTU1ZhbHVlID0gKHByb3AsIHZhbHVlKSA9PiB7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKHZhbHVlID0+IGdldENTU1ZhbHVlKHByb3AsIHZhbHVlKVswXSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBjc3NOb01lYXN1cmVtZW50Lmhhcyhwcm9wKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICB2YWx1ZSArPSBcInB4XCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3ZhbHVlXTtcclxufTtcclxuXHJcbmNvbnN0IGdlbkNTUyA9IChkZWZzLCB0YWJzID0gMCkgPT4ge1xyXG4gICAgY29uc3Qgc3BhY2UgPSAnXFx0Jy5yZXBlYXQodGFicyk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGVmcykucmVkdWNlKFxyXG4gICAgICAgIChjc3MsIFtzZWxlY3RvciwgY3NzUHJvcHNdKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBPYmplY3QuZW50cmllcyhjc3NQcm9wcykucmVkdWNlKFxyXG4gICAgICAgICAgICAgICAgKGNvbnRlbnRBcnJheSwgW3Byb3BOYW1lLCBwcm9wVmFsdWVdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSA9PT0gZmFsc2UgJiYgdHlwZW9mIHByb3BWYWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBbZ2VuQ1NTKHtbcHJvcE5hbWVdOiBwcm9wVmFsdWV9LCB0YWJzICsgMSldO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0Q1NTVmFsdWUocHJvcE5hbWUsIHByb3BWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzc1Byb3BOYW1lID0gcHJvcE5hbWUucmVwbGFjZSgvW0EtWl0vZywgbGV0dGVyID0+ICctJyArIGxldHRlci50b0xvd2VyQ2FzZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NQcmVmaXhOYW1lcy5oYXMocHJvcE5hbWUpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGNzc1ByZWZpeGVzLm1hcChwcmVmaXggPT4gYCR7c3BhY2V9XFx0JHtwcmVmaXh9JHtjc3NQcm9wTmFtZX06ICR7dmFsdWVbMF19O2ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSB2YWx1ZS5tYXAodmFsdWUgPT4gYCR7c3BhY2V9XFx0JHtjc3NQcm9wTmFtZX06ICR7dmFsdWV9O2ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb250ZW50QXJyYXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmxpbmVzXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBbXVxyXG4gICAgICAgICAgICApLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3Iuc2xpY2UoMCwgMTApID09PSBcIkBrZXlmcmFtZXNcIikge1xyXG4gICAgICAgICAgICAgICAgY3NzLnB1c2goYCR7c3BhY2V9QC13ZWJraXQta2V5ZnJhbWVzICR7c2VsZWN0b3Iuc2xpY2UoMTEpfSB7XFxuJHtjb250ZW50fVxcbiR7c3BhY2V9fWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNzcy5wdXNoKGAke3NwYWNlfSR7c2VsZWN0b3J9IHtcXG4ke2NvbnRlbnR9XFxuJHtzcGFjZX19YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjc3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBbXVxyXG4gICAgKS5qb2luKCdcXG4nKTtcclxufTtcclxuY29uc3QgY3JlYXRlU3R5bGVTaGVldCA9ICgpID0+IHtcclxuICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRTdHlsZXMoZGVmcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgZGVmXSBvZiBPYmplY3QuZW50cmllcyhkZWZzKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVzW3NlbGVjdG9yXSA9IGRlZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX19pbml0KHN0eWxlVGFnKSB7XHJcbiAgICAgICAgICAgIHN0eWxlVGFnLmlubmVySFRNTCA9IGdlbkNTUyhzdHlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5jb25zdCBDU1MgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIHJnYmE6IChyLCBnLCBiLCBhKSA9PiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2F9KWAsXHJcbiAgICByZ2I6IChyLCBnLCBiKSA9PiBDU1MucmdiYShyLCBnLCBiLCAxKVxyXG59KTtcclxuXHJcbmV4cG9ydCB7Y3JlYXRlU3R5bGVTaGVldCwgZ2VuQ1NTLCBDU1N9O1xyXG4iLCJjb25zdCB0aGVtZSA9IHtcclxuICAgIGdlbmVyYWw6IHtcclxuICAgICAgICBib3hTaGFkb3c6ICcwIDJweCAycHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDNweCAxcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMiknXHJcbiAgICB9LFxyXG4gICAgYnV0dG9uOiB7XHJcbiAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHRoZW1lO1xyXG4iLCJjb25zdCB3YXJuaW5nRnVuYyA9IGVycm9yTWVzc2FnZSA9PlxyXG4gICAgKCkgPT4gY29uc29sZS53YXJuKGVycm9yTWVzc2FnZSk7XHJcblxyXG53aW5kb3cucmFuZ2UgPSB7XHJcbiAgICBhcnJheShzdGFydCwgZW5kID0gbnVsbCwgZiA9IG51bGwpIHtcclxuICAgICAgICBjb25zdCBhcnIgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKGYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGYgPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZiA9IGkgPT4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICAgICAgYXJyLnB1c2goZihzdGFydCkpO1xyXG4gICAgICAgICAgICBzdGFydCArPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH0sXHJcbiAgICAqZ2VuKHN0YXJ0LCBlbmQgPSBudWxsLCBmID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChmID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBmID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGYgPSBpID0+IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydDtcclxuICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGYoc3RhcnQpO1xyXG4gICAgICAgICAgICBzdGFydCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICB3YXJuaW5nRnVuY1xyXG59O1xyXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb21cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hcFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZW50cmllc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC92YWx1ZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBjYWxsTmV4dCA9IHN0ZXAuYmluZChudWxsLCBcIm5leHRcIik7XG4gICAgICB2YXIgY2FsbFRocm93ID0gc3RlcC5iaW5kKG51bGwsIFwidGhyb3dcIik7XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGNhbGxOZXh0LCBjYWxsVGhyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxOZXh0KCk7XG4gICAgfSk7XG4gIH07XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRhc3NpZ24gPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9PYmplY3QkYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPyBfT2JqZWN0JHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2Zyb20yLmRlZmF1bHQpKGFycik7XG4gIH1cbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfU3ltYm9sID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2xcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9TeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IG1vZHVsZS5leHBvcnRzLCBfX2VzTW9kdWxlOiB0cnVlIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9TeW1ib2wgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbFwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfUHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKVtcImRlZmF1bHRcIl07XG5cbiEoZnVuY3Rpb24gKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIF9TeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IF9TeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBfT2JqZWN0JGNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICBpZiAoX09iamVjdCRzZXRQcm90b3R5cGVPZikge1xuICAgICAgX09iamVjdCRzZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCkge1xuICAgICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkpO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fCBtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4vLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4vLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3Rcbi8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG50eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHVuZGVmaW5lZCk7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuQXJyYXkuZnJvbTsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlJyk7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5NYXA7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5hc3NpZ247IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJC5jcmVhdGUoUCwgRCk7XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJC5zZXREZXNjKGl0LCBrZXksIGRlc2MpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5lbnRyaWVzOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3QuZnJlZXplOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmtleXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC52YWx1ZXM7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5Qcm9taXNlOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuU2V0OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLlN5bWJvbDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi8kLndrcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSAoTyA9IE9iamVjdChpdCkpW1RBR10pID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGhpZGUgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBzdHJpY3ROZXcgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZGVmaW5lZCAgICAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKVxuICAsIGZvck9mICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lICA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSUQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCdpZCcpXG4gICwgJGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgc2V0U3BlY2llcyAgID0gcmVxdWlyZSgnLi8kLnNldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBTSVpFICAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSdcbiAgLCBpZCAgICAgICAgICAgPSAwO1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoISRoYXMoaXQsIElEKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG9iamVjdCBpZFxuICAgIGhpZGUoaXQsIElELCArK2lkKTtcbiAgLy8gcmV0dXJuIG9iamVjdCBpZCB3aXRoIHByZWZpeFxuICB9IHJldHVybiAnTycgKyBpdFtJRF07XG59O1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIHN0cmljdE5ldyh0aGF0LCBDLCBOQU1FKTtcbiAgICAgIHRoYXQuX2kgPSAkLmNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBmb3JPZiAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgY2xhc3NvZiA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvck9mKHRoaXMsIGZhbHNlLCBhcnIucHVzaCwgYXJyKTtcbiAgICByZXR1cm4gYXJyO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHN0cmljdE5ldyAgICAgID0gcmVxdWlyZSgnLi8kLnN0cmljdC1uZXcnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGlmKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgc3RyaWN0TmV3KHRhcmdldCwgQywgTkFNRSk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgICQuZWFjaC5jYWxsKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcycuc3BsaXQoJywnKSxmdW5jdGlvbihLRVkpe1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKWhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzEuMi42J307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24ocGFyYW0pe1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgaWYoSVNfUFJPVE8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQpe1xuICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gIH1cbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBnZXROYW1lcyAgPSByZXF1aXJlKCcuLyQnKS5nZXROYW1lc1xuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldE5hbWVzKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIGlmKHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nKXJldHVybiBnZXRXaW5kb3dOYW1lcyhpdCk7XG4gIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvICAgICAgID0gcmVxdWlyZSgnLi8kJykuZ2V0UHJvdG9cbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsIG1ldGhvZHMsIGtleTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkbmF0aXZlKXtcbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90bygkZGVmYXVsdC5jYWxsKG5ldyBCYXNlKSk7XG4gICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgIC8vIEZGIGZpeFxuICAgIGlmKCFMSUJSQVJZICYmIGhhcyhwcm90bywgRkZfSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gICAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gICAgfVxuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKVxuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyBzYWZlID0gdHJ1ZTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwidmFyICRPYmplY3QgPSBPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXG4gIGdldFByb3RvOiAgICRPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gIGlzRW51bTogICAgIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgc2V0RGVzYzogICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgc2V0RGVzY3M6ICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXG4gIGdldE5hbWVzOiAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgZ2V0U3ltYm9sczogJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcbn07IiwidmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vJC50YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi8kLmNvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxudmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmVudCwgZG9tYWluLCBmbjtcbiAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpe1xuICAgIHByb2Nlc3MuZG9tYWluID0gbnVsbDtcbiAgICBwYXJlbnQuZXhpdCgpO1xuICB9XG4gIHdoaWxlKGhlYWQpe1xuICAgIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuICAgIGZuICAgICA9IGhlYWQuZm47XG4gICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgIGZuKCk7IC8vIDwtIGN1cnJlbnRseSB3ZSB1c2UgaXQgb25seSBmb3IgUHJvbWlzZSAtIHRyeSAvIGNhdGNoIG5vdCByZXF1aXJlZFxuICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xufTtcblxuLy8gTm9kZS5qc1xuaWYoaXNOb2RlKXtcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbi8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxufSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgdmFyIHRvZ2dsZSA9IDFcbiAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gLXRvZ2dsZTtcbiAgfTtcbi8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG59IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZmx1c2gpO1xuICB9O1xuLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbi8vIC0gc2V0SW1tZWRpYXRlXG4vLyAtIE1lc3NhZ2VDaGFubmVsXG4vLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4vLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuLy8gLSBzZXRUaW1lb3V0XG59IGVsc2Uge1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc2FwKGZuKXtcbiAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWQsIGRvbWFpbjogaXNOb2RlICYmIHByb2Nlc3MuZG9tYWlufTtcbiAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICBpZighaGVhZCl7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5KCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59OyIsIi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0Jyk7XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgYSA9IE9iamVjdC5hc3NpZ25cbiAgICAsIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gYSh7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cyhhKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCAkJCAgICA9IGFyZ3VtZW50c1xuICAgICwgJCRsZW4gPSAkJC5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0S2V5cyAgICA9ICQuZ2V0S2V5c1xuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9sc1xuICAgICwgaXNFbnVtICAgICA9ICQuaXNFbnVtO1xuICB3aGlsZSgkJGxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdCgkJFtpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9XG4gIHJldHVybiBUO1xufSA6IE9iamVjdC5hc3NpZ247IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgaXNFbnVtICAgID0gJC5pc0VudW07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzRW50cmllcyl7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdChpdClcbiAgICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSl7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuaGlkZScpOyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgZ2V0RGVzYyAgPSByZXF1aXJlKCcuLyQnKS5nZXREZXNjXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuLyQuY3R4JykoRnVuY3Rpb24uY2FsbCwgZ2V0RGVzYyhPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCAkICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsIFNQRUNJRVMgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBjb3JlW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pJC5zZXREZXNjKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vJCcpLnNldERlc2NcbiAgLCBoYXMgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgVHlwZUVycm9yKG5hbWUgKyBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vJC50by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmh0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdG5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0bmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuLyQuaW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07IiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgc3RvcmUgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIFN5bWJvbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKS5TeW1ib2w7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBTeW1ib2wgJiYgU3ltYm9sW25hbWVdIHx8IChTeW1ib2wgfHwgdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59OyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuLyQuY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBPW0lURVJBVE9SXSAhPT0gdW5kZWZpbmVkXG4gICAgfHwgJ0BAaXRlcmF0b3InIGluIE9cbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsICQkICAgICAgPSBhcmd1bWVudHNcbiAgICAgICwgJCRsZW4gICA9ICQkLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gJCRsZW4gPiAxID8gJCRbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgJCRsZW4gPiAyID8gJCRbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLyQuYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vJC5vYmplY3QtYXNzaWduJyl9KTsiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vJC5vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKGl0KSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vJC5vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oJGdldFByb3RvdHlwZU9mKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCRrZXlzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXR9KTsiLCIiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgTElCUkFSWSAgICA9IHJlcXVpcmUoJy4vJC5saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgY3R4ICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGNsYXNzb2YgICAgPSByZXF1aXJlKCcuLyQuY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJylcbiAgLCBzdHJpY3ROZXcgID0gcmVxdWlyZSgnLi8kLnN0cmljdC1uZXcnKVxuICAsIGZvck9mICAgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBzZXRQcm90byAgID0gcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldFxuICAsIHNhbWUgICAgICAgPSByZXF1aXJlKCcuLyQuc2FtZS12YWx1ZScpXG4gICwgU1BFQ0lFUyAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi8kLnNwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIGFzYXAgICAgICAgPSByZXF1aXJlKCcuLyQubWljcm90YXNrJylcbiAgLCBQUk9NSVNFICAgID0gJ1Byb21pc2UnXG4gICwgcHJvY2VzcyAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgUCAgICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIFdyYXBwZXI7XG5cbnZhciB0ZXN0UmVzb2x2ZSA9IGZ1bmN0aW9uKHN1Yil7XG4gIHZhciB0ZXN0ID0gbmV3IFAoZnVuY3Rpb24oKXt9KTtcbiAgaWYoc3ViKXRlc3QuY29uc3RydWN0b3IgPSBPYmplY3Q7XG4gIHJldHVybiBQLnJlc29sdmUodGVzdCkgPT09IHRlc3Q7XG59O1xuXG52YXIgVVNFX05BVElWRSA9IGZ1bmN0aW9uKCl7XG4gIHZhciB3b3JrcyA9IGZhbHNlO1xuICBmdW5jdGlvbiBQMih4KXtcbiAgICB2YXIgc2VsZiA9IG5ldyBQKHgpO1xuICAgIHNldFByb3RvKHNlbGYsIFAyLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdHJ5IHtcbiAgICB3b3JrcyA9IFAgJiYgUC5yZXNvbHZlICYmIHRlc3RSZXNvbHZlKCk7XG4gICAgc2V0UHJvdG8oUDIsIFApO1xuICAgIFAyLnByb3RvdHlwZSA9ICQuY3JlYXRlKFAucHJvdG90eXBlLCB7Y29uc3RydWN0b3I6IHt2YWx1ZTogUDJ9fSk7XG4gICAgLy8gYWN0dWFsIEZpcmVmb3ggaGFzIGJyb2tlbiBzdWJjbGFzcyBzdXBwb3J0LCB0ZXN0IHRoYXRcbiAgICBpZighKFAyLnJlc29sdmUoNSkudGhlbihmdW5jdGlvbigpe30pIGluc3RhbmNlb2YgUDIpKXtcbiAgICAgIHdvcmtzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFjdHVhbCBWOCBidWcsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTYyXG4gICAgaWYod29ya3MgJiYgcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJykpe1xuICAgICAgdmFyIHRoZW5hYmxlVGhlbkdvdHRlbiA9IGZhbHNlO1xuICAgICAgUC5yZXNvbHZlKCQuc2V0RGVzYyh7fSwgJ3RoZW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgdGhlbmFibGVUaGVuR290dGVuID0gdHJ1ZTsgfVxuICAgICAgfSkpO1xuICAgICAgd29ya3MgPSB0aGVuYWJsZVRoZW5Hb3R0ZW47XG4gICAgfVxuICB9IGNhdGNoKGUpeyB3b3JrcyA9IGZhbHNlOyB9XG4gIHJldHVybiB3b3Jrcztcbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGEsIGIpe1xuICAvLyBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIGlmKExJQlJBUlkgJiYgYSA9PT0gUCAmJiBiID09PSBXcmFwcGVyKXJldHVybiB0cnVlO1xuICByZXR1cm4gc2FtZShhLCBiKTtcbn07XG52YXIgZ2V0Q29uc3RydWN0b3IgPSBmdW5jdGlvbihDKXtcbiAgdmFyIFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXTtcbiAgcmV0dXJuIFMgIT0gdW5kZWZpbmVkID8gUyA6IEM7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSksXG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpXG59O1xudmFyIHBlcmZvcm0gPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICBleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24ocmVjb3JkLCBpc1JlamVjdCl7XG4gIGlmKHJlY29yZC5uKXJldHVybjtcbiAgcmVjb3JkLm4gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSByZWNvcmQuYztcbiAgYXNhcChmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHJlY29yZC52XG4gICAgICAsIG9rICAgID0gcmVjb3JkLnMgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spcmVjb3JkLmggPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIgPT09IHRydWUgPyB2YWx1ZSA6IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSl7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBjaGFpbi5sZW5ndGggPSAwO1xuICAgIHJlY29yZC5uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3Qpc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgdmFyIHByb21pc2UgPSByZWNvcmQucFxuICAgICAgICAsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgICBpZihpc1VuaGFuZGxlZChwcm9taXNlKSl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKXtcbiAgICAgICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlfSk7XG4gICAgICAgIH0gZWxzZSBpZigoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gcmVjb3JkLmEgPSB1bmRlZmluZWQ7XG4gICAgfSwgMSk7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB2YXIgcmVjb3JkID0gcHJvbWlzZS5fZFxuICAgICwgY2hhaW4gID0gcmVjb3JkLmEgfHwgcmVjb3JkLmNcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICBpZihyZWNvcmQuaClyZXR1cm4gZmFsc2U7XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciByZWNvcmQgPSB0aGlzO1xuICBpZihyZWNvcmQuZClyZXR1cm47XG4gIHJlY29yZC5kID0gdHJ1ZTtcbiAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcbiAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgcmVjb3JkLnMgPSAyO1xuICByZWNvcmQuYSA9IHJlY29yZC5jLnNsaWNlKCk7XG4gIG5vdGlmeShyZWNvcmQsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHJlY29yZC5wID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgYXNhcChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtyOiByZWNvcmQsIGQ6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmQudiA9IHZhbHVlO1xuICAgICAgcmVjb3JkLnMgPSAxO1xuICAgICAgbm90aWZ5KHJlY29yZCwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICAkcmVqZWN0LmNhbGwoe3I6IHJlY29yZCwgZDogZmFsc2V9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYoIVVTRV9OQVRJVkUpe1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICB2YXIgcmVjb3JkID0gdGhpcy5fZCA9IHtcbiAgICAgIHA6IHN0cmljdE5ldyh0aGlzLCBQLCBQUk9NSVNFKSwgICAgICAgICAvLyA8LSBwcm9taXNlXG4gICAgICBjOiBbXSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgICBhOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICAgIHM6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgICAgZDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICAgIHY6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgaDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGhhbmRsZWQgcmVqZWN0aW9uXG4gICAgICBuOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCByZWNvcmQsIDEpLCBjdHgoJHJlamVjdCwgcmVjb3JkLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHJlY29yZCwgZXJyKTtcbiAgICB9XG4gIH07XG4gIHJlcXVpcmUoJy4vJC5yZWRlZmluZS1hbGwnKShQLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFApKVxuICAgICAgICAsIHByb21pc2UgID0gcmVhY3Rpb24ucHJvbWlzZVxuICAgICAgICAsIHJlY29yZCAgID0gdGhpcy5fZDtcbiAgICAgIHJlYWN0aW9uLm9rICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWNvcmQuYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHJlY29yZC5hKXJlY29yZC5hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYocmVjb3JkLnMpbm90aWZ5KHJlY29yZCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiBQfSk7XG5yZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKShQLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vJC5zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vJC5jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgdGVzdFJlc29sdmUodHJ1ZSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgUCAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuLyQuaXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXtcbiAgUC5hbGwoaXRlcilbJ2NhdGNoJ10oZnVuY3Rpb24oKXt9KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gZ2V0Q29uc3RydWN0b3IodGhpcylcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdFxuICAgICAgLCB2YWx1ZXMgICAgID0gW107XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgdmFsdWVzLnB1c2gsIHZhbHVlcyk7XG4gICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aFxuICAgICAgICAsIHJlc3VsdHMgICA9IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICBpZihyZW1haW5pbmcpJC5lYWNoLmNhbGwodmFsdWVzLCBmdW5jdGlvbihwcm9taXNlLCBpbmRleCl7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIGVsc2UgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IGdldENvbnN0cnVjdG9yKHRoaXMpXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5yZXF1aXJlKCcuLyQuY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vJC5zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyICQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLndrcycpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuLyQua2V5b2YnKVxuICAsICRuYW1lcyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdldC1uYW1lcycpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuLyQuZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vJC5wcm9wZXJ0eS1kZXNjJylcbiAgLCBnZXREZXNjICAgICAgICA9ICQuZ2V0RGVzY1xuICAsIHNldERlc2MgICAgICAgID0gJC5zZXREZXNjXG4gICwgX2NyZWF0ZSAgICAgICAgPSAkLmNyZWF0ZVxuICAsIGdldE5hbWVzICAgICAgID0gJG5hbWVzLmdldFxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIHNldHRlciAgICAgICAgID0gZmFsc2VcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgaXNFbnVtICAgICAgICAgPSAkLmlzRW51bVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCB1c2VOYXRpdmUgICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoc2V0RGVzYyh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gc2V0RGVzYyh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnZXREZXNjKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIHNldERlc2MoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pc2V0RGVzYyhPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IHNldERlc2M7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbC5wcm90b3R5cGUpO1xuICBzeW0uX2sgPSB0YWc7XG4gIERFU0NSSVBUT1JTICYmIHNldHRlciAmJiBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlzZXREZXNjKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBzZXREZXNjKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkpO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldXG4gICAgPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgdmFyIEQgPSBnZXREZXNjKGl0ID0gdG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOKXJlc3VsdC5wdXNoKGtleSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyICRzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgLCBpICAgID0gMVxuICAgICwgJCQgICA9IGFyZ3VtZW50c1xuICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgd2hpbGUoJCQubGVuZ3RoID4gaSlhcmdzLnB1c2goJCRbaSsrXSk7XG4gIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgfTtcbiAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG59O1xudmFyIGJ1Z2d5SlNPTiA9ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighdXNlTmF0aXZlKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKGlzU3ltYm9sKHRoaXMpKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgcmV0dXJuIHdyYXAodWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKSk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2wucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xuICB9O1xuXG4gICQuY3JlYXRlICAgICA9ICRjcmVhdGU7XG4gICQuaXNFbnVtICAgICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgJC5nZXREZXNjICAgID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJC5zZXREZXNjICAgID0gJGRlZmluZVByb3BlcnR5O1xuICAkLnNldERlc2NzICAgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgJC5nZXROYW1lcyAgID0gJG5hbWVzLmdldCA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAkLmdldFN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuLyQubGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgc3ltYm9sU3RhdGljcyA9IHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufTtcbi8vIDE5LjQuMi4yIFN5bWJvbC5oYXNJbnN0YW5jZVxuLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxuLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXG4vLyAxOS40LjIuNiBTeW1ib2wubWF0Y2hcbi8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXG4vLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXG4vLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcbi8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcbi8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcbi8vIDE5LjQuMi4xMyBTeW1ib2wudG9TdHJpbmdUYWdcbi8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcbiQuZWFjaC5jYWxsKChcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCwnICtcbiAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHN5bSA9IHdrcyhpdCk7XG4gIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xufSk7XG5cbnNldHRlciA9IHRydWU7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3ltYm9sJywgc3ltYm9sU3RhdGljcyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXVzZU5hdGl2ZSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIXVzZU5hdGl2ZSB8fCBidWdneUpTT04pLCAnSlNPTicsIHtzdHJpbmdpZnk6ICRzdHJpbmdpZnl9KTtcblxuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHA6Ly9nb28uZ2wvWGtCcmpEXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vJC5vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpe1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pOyIsIi8vIGh0dHA6Ly9nb28uZ2wvWGtCcmpEXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsICR2YWx1ZXMgPSByZXF1aXJlKCcuLyQub2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpe1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbkl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEl0ZXJhdG9ycy5BcnJheTsiXX0=
